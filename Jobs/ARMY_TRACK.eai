#IFDEF GLOBAL
    integer array army_owner
    location array army_loc
    location array army_dir
    location array army_future
    real array army_strength
    group array army_group
    integer array army_count
    integer army_num = 0
    real army_radius = 1200
    real army_future_mult = 3
    group in_army_group = CreateGroup()
    integer main_army = -1

#ELSE
// Army Tracker

function CopyArmy takes integer from, integer to returns nothing
  set army_owner[to] = army_owner[from]
  set army_loc[to] = army_loc[from]
  set army_dir[to] = army_dir[from]
  set army_future[to] = army_future[from]
  set army_strength[to] = army_strength[from]
  set army_group[to] = army_group[from]
  set army_count[to] = army_count[from]
endfunction

function TrackArmy takes integer num returns boolean
  local group g = CreateGroup()
  local unit u = null
  //local location l = null
  local real x = 0
  local real y = 0
  set army_strength[num] = 0
  set army_count[num] = 0

  call GroupEnumUnitsInRangeOfLoc(g, army_loc[num], army_radius, null)
  // set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, false)
  // set g = SelectUnittype(g, UNIT_TYPE_PEON, false)
  // set g = SelectByPlayer(g, Player(army_owner[num]), true)
  // if Player(army_owner[num]) == ai_player then
  //   set g = SelectByUnitStandard(g, true)  // check other player Standard will let FirstOfGroup is null
  // else
  //   set g = SelectByInvisible(g, ai_player, false)  // Fix using invisible units to exploit amai to force defend its town
  // endif
  // set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and GetOwningPlayer(u) == Player(army_owner[num]) and not (IsUnitType(u, UNIT_TYPE_STRUCTURE) or IsUnitType(u, UNIT_TYPE_PEON) or IsUnitInGroup(u, in_army_group)) then
      if (Player(army_owner[num]) != ai_player and IsUnitInvisible(u, ai_player)) or (Player(army_owner[num]) == ai_player and not IsStandardUnit(u)) then
        // Fix using invisible units to exploit amai to force defend its town
        // check other player Standard will let FirstOfGroup is null
      else
        if u == major_hero then
          set main_army = num
        endif
        call GroupAddUnit(army_group[num], u)
        call GroupAddUnit(in_army_group, u)
        set x = x + GetUnitX(u)  // Prevent loc exceeding map range
        set y = y + GetUnitY(u)
        //set l = GetSumLoc_dd(l, GetUnitLoc(u))
        set army_count[num] = army_count[num] + 1
        set army_strength[num] = army_strength[num] + GetUnitStrength(u)
      endif
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null

  call RemoveLocation(army_dir[num])
  call RemoveLocation(army_future[num])
  if army_strength[num] == 0 then
    call DestroyGroup(army_group[num])
    set army_group[num] = null
    call RemoveLocation(army_loc[num])
    set army_loc[num] = null
    set army_dir[num] = null
    set army_future[num] = null
    //call RemoveLocation(l)
    //set l = null
    return false
  endif
  set x = x / Max(army_count[num], 1)
  set y = y / Max(army_count[num], 1)
  //set l = GetDivisionLoc_d(l, Max(army_count[num], 1))
  set army_dir[num] = GetSubtractionLoc_dd(Location(x, y), army_loc[num])
  call CreateDebugTagLoc("Tracked Army: " + Int2Str(num) + " Strength:" + Int2Str(R2I(army_strength[num])), 10, x, y, 3.00, 1.50)
  set army_loc[num] = Location(x, y)
  set army_future[num] = GetSumLoc_kd(army_loc[num], GetMultipleLoc(army_dir[num], army_future_mult))

 // if army_strength[num] != 0 then
   // call PingMinimap(GetLocationX(l), GetLocationY(l), 4)
 // endif
  //set l = null
  return true
endfunction

function TrackExistingArmies takes nothing returns nothing
  local integer i = 0
  local integer first_free = 0
  loop
    exitwhen i >= army_num
    call GroupClear(army_group[i])
    if TrackArmy(i) then
      if i != first_free then
        call CopyArmy(i, first_free)
      endif
      set first_free = first_free + 1
    endif
    set i = i + 1
  endloop
  set army_num = first_free
endfunction

function SeedNewArmyAtLoc takes location l, integer p returns nothing
  set army_owner[army_num] = p
  if army_loc[army_num] != null then
    call RemoveLocation(army_loc[army_num])
  endif
  if army_dir[army_num] != null then
    call RemoveLocation(army_dir[army_num])
  endif
  if army_future[army_num] != null then
    call RemoveLocation(army_future[army_num])
  endif
  if army_group[army_num] != null then
    call DestroyGroup(army_group[army_num])
  endif
  set army_loc[army_num] = l
  set army_dir[army_num] = Location(0,0)
  set army_future[army_num] = Location(0,0)
  set army_group[army_num] = CreateGroup()
  if TrackArmy(army_num) then
    set army_num = army_num + 1
  endif
endfunction

function SeedNewArmiesForPlayer takes integer p returns nothing
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsOfPlayer(g, Player(p), null)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, false)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, false)
  set g = SelectByAlive(g, true)
  if Player(p) == ai_player then
    set g = SelectByUnitStandard(g, true)   // Hopefully fix issues of heroes doing other things not making false armies
  endif
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if not IsUnitInGroup(u, in_army_group) then
      if IsUnitType(u, UNIT_TYPE_HERO) or major_hero == u or GetRandomInt(0, 30) == 1 then
      //if UnitAlive(u) and not IsUnitInGroup(u, in_army_group) and (IsUnitType(u, UNIT_TYPE_HERO) or major_hero == u or (GetRandomInt(0, 30) == 1 and not (IsUnitType(u, UNIT_TYPE_STRUCTURE) or IsUnitType(u, UNIT_TYPE_PEON)))) then
        call SeedNewArmyAtLoc(Location(GetUnitX(u), GetUnitY(u)), p)
      endif
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
endfunction

function SeedNewArmies takes nothing returns nothing
  local integer p = 0
  loop
    exitwhen p >= GetBJMaxPlayers()
    if GetPlayerSlotState(Player(p)) == PLAYER_SLOT_STATE_PLAYING and not IsPlayerObserver(Player(p)) then
      call SeedNewArmiesForPlayer(p)
    endif
    set p = p + 1
  endloop
endfunction

function UpdateSpecificTownThreat takes integer num returns nothing
  local integer i = 0
  local real dist = 0
  local real threat = 0
  local real max_threat = 0
  local location loc = null

  set town_threat[num] = 0
  loop
    if i == main_army then
      set i = i + 1
    endif
    exitwhen i >= army_num
    set dist = RMax(DistanceBetweenPoints(army_future[i], town_loc[num]), full_threat_distance)
    if dist <= no_threat_distance then
      set loc = GetSubtractionLoc(town_loc[num], army_loc[i])
      if DistanceBetweenPoints(army_loc[i], town_loc[num]) < GetLengthOfLoc(army_dir[i]) and RAbs(GetAngleBetweenLocs(army_dir[i], loc)) <= 0.4 then
        set dist = full_threat_distance
      endif
      call RemoveLocation(loc)
      set threat = distance_threat_mult * army_strength[i] / Pow(dist, distance_threat_exponent)
      if IsPlayerAlly(Player(town_owner[num]), Player(army_owner[i])) then
        set town_threat[num] = town_threat[num] - threat
      else
        set town_threat[num] = town_threat[num] + threat
        if threat > max_threat then
          set max_threat = threat
          set town_threat_army[num] = i
        endif
      endif
    endif
    set i = i + 1
  endloop
  set loc = null
  if IsPlayerAlly(Player(town_owner[num]), ai_player) then
    if (most_threatened_town == -1 or town_threat[most_threatened_town] < town_threat[num]) and town_count[num] > 0 then
      set most_threatened_town = num
    endif
   // call DisplayToAll("Town threatened "+Int2Str(num)+" Threat: "+Int2Str(R2I(town_threat[num])))
   // call PingMinimapEx(GetLocationX(town_loc[num]), GetLocationY(town_loc[num]), 4, 255, 0, 0, true)
  elseif IsPlayerEnemy(Player(town_owner[num]), ai_player) and town_count[num] > 0 then
    if most_threatened_enemy_town == -1 or town_threat[most_threatened_enemy_town] < town_threat[num] then
      set most_threatened_enemy_town = num
    endif
  endif
endfunction

function UpdateTownThreat takes nothing returns nothing
  local integer i = 0
  local real accepted_threat_level = LinearInterpolation(atl_time_start, atl_time_end, atl_time_start_val, atl_time_end_val, TimerGetElapsed(tq_timer)) * LinearInterpolation(atl_enemy_start, atl_enemy_end, atl_enemy_start_mult, atl_enemy_end_mult, c_enemy_total)
  set town_threatened = false
  //call Trace("ARMY_TRACK: Town threat update")
  set most_threatened_town = -1
  set most_threatened_enemy_town = -1
  loop
    exitwhen i >= town_num
    call UpdateSpecificTownThreat(i)
    set i = i + 1
  endloop
  if most_threatened_town == -1 then
    set most_threatened_town = 0
  endif
  if most_threatened_enemy_town == -1 then
    set most_threatened_enemy_town = 0
  endif
  if town_threat[most_threatened_town] > accepted_threat_level and town_threat[most_threatened_town] > (I2R(c_ally_total + 1) / c_enemy_total) * town_threat[most_threatened_enemy_town] then
    set town_threatened = true
  endif
  if town_threatened and town_num != 0 then
    call SetCaptainHome(DEFENSE_CAPTAIN, GetLocationX(town_loc[most_threatened_town]), GetLocationY(town_loc[most_threatened_town]))
  endif
endfunction

function ArmyTrackJob takes nothing returns nothing
  //local unit alliance = null
  call DisplayToAllJobDebug("ARMY_TRACK JOB START")
  call GroupClear(in_army_group)
  call TrackExistingArmies()
  call SeedNewArmies()
  //set alliance = GetAllianceTarget()
  //if alliance != null then
    //call CreateDebugTag("Alliance Target", 10, alliance, 3.00, 1.50)
  //endif
  call UpdateTownThreat()
  call TQAddJob(16, ARMY_TRACK, 0)  //4
endfunction
#ENDIF