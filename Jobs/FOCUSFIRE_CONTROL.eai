#IFDEF GLOBAL
  group windwalk_group = CreateGroup()
  group focus_fire_group = CreateGroup()
  group micro_ranged_group = CreateGroup()
  group micro_enemymelee_group = CreateGroup()
  location last_major_hero_loc = Location(0,0)
  location enemy_melee_loc = Location(0,0)
  unit focus_fire_unit = null
  unit deny_unit = null
  real bj_PI = 3.14159
  real bj_RADTODEG = 180.0/bj_PI
#ELSE
//============================================================================
// Focus Fire Job
//============================================================================

function AngleBetweenPoints takes location locA, location locB returns real
  return bj_RADTODEG * Atan2(GetLocationY(locB) - GetLocationY(locA), GetLocationX(locB) - GetLocationX(locA))
endfunction

function IsUnitFacingUnit takes unit u, unit target returns boolean
  local location unitloc = GetUnitLoc(u)
  local location targetloc = GetUnitLoc(target)
  local real angle = AngleBetweenPoints(unitloc, targetloc)
  local real unitfacing = GetUnitFacing(u)
  local boolean isFacing = false
  if (unitfacing - 25 >= angle or unitfacing + 25 <= angle) then //or (IsUnitType(u, UNIT_TYPE_MELEE_ATTACKER) and DistanceBetweenUnits(u, target) > 128) then
    set isFacing = true
  endif
  call RemoveLocation(unitloc)
  call RemoveLocation(targetloc)
  set unitloc = null
  set targetloc = null
  return isFacing
endfunction

function GroupMicroSystem takes group g, group meleeg, group temp_focus returns nothing
  local unit u = null
  local location unitloc = null
  local location l = null
  local unit melee = null
  local group copy = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) then
      set unitloc = GetUnitLoc(u)
      set copy = CopyGroup(meleeg,copy)
      set melee = GetNearestOfGroup(melee, copy, unitloc)
      if melee != null and DistanceBetweenUnits(u, melee) < 150 and UnitAlive(melee) and IsUnitFacingUnit(melee, u) and GetUnitMoveSpeed(melee) <= GetUnitMoveSpeed(u) and (not IsUnitType(u, UNIT_TYPE_FLYING) or (IsUnitType(u, UNIT_TYPE_FLYING) and IsUnitType(melee, UNIT_TYPE_ATTACKS_FLYING))) and (GetOwningPlayer(u) != ai_player or not IsUnitInGroup(u, focus_fire_group)) then // 220 is the smallest ranged unit in warcraft 3.
        set l = GetSubtractionLoc_kd(unitloc, GetUnitLoc(melee))
        set l = GetProjectedLoc_dd(unitloc, l, 400)
        call RemoveGuardPosition(u)
        call CreateDebugTagLoc("FF: MICRO LOC", 10, GetLocationX(l), GetLocationY(l), 3.00, 1.50)
        call IssuePointOrderLoc(u, "move", l)
        call TQAddUnitJob(1, RESET_HEALTH, 50, u)
        call RemoveLocation(l)
        if GetOwningPlayer(u) == ai_player then
          call GroupRemoveUnit(temp_focus, u)
        endif
      else
        call RemoveLocation(unitloc)
      endif
      call DestroyGroup(copy)
    endif
    call GroupRemoveUnit(g, u)
  endloop
  set copy = null
  set melee = null
  set unitloc = null
  set l = null
endfunction

function GroupOrderFocusWindInstant takes group g returns nothing
  local unit u = null
  local group cg = null
  set cg = CopyGroup(g,cg)
  loop
    set u = FirstOfGroup(cg)
    exitwhen u == null
    if (GetUnitAbilityLevel(u, 'AOwk') > 0 or GetUnitAbilityLevel(u, 'ANwk') > 0) and not UnitInvis(u) then
      //if not IsUnitInGroup(u, windwalk_group) then
      call GroupAddUnit(windwalk_group, u)
      //endif
      call CreateDebugTag("FF: windwalk", 10, u, 1.00, 0.80)
      call IssueImmediateOrder(u, "windwalk")
      call TQAddUnitJob(8, RESET_WINDWALKER, 0, u)
      call GroupRemoveUnit(g, u)  // move to windwalk_group
    endif
    call GroupRemoveUnit(cg, u)
  endloop
  call DestroyGroup(cg)
  set cg = null
endfunction

function GroupOrderDeny_d takes group g, unit target returns nothing
  local unit u = null
  local boolean b = false
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null or GetUnitState(target, UNIT_STATE_LIFE) <= 0 or b == true
    if IsUnitType(u, UNIT_TYPE_HERO) then
      if GetUnitAbilityLevel(u, 'AUdr') > 0 then  //Intentionally check one by one, prioritizing the restoration of magic
        set b = IssueTargetOrder(u, "darkritual", target)
      elseif GetUnitAbilityLevel(u, 'AUdp') > 0 or GetUnitAbilityLevel(u, 'AIdp') > 0 then
        set b = IssueTargetOrder(u, "deathpact", target)
      elseif GetUnitAbilityLevel(u, 'AIg2') > 0 or GetUnitAbilityLevel(u, 'AIdg') > 0 then
        set b = IssueTargetOrderById(u, 852674, target)
      endif
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set u = null
endfunction

function GroupOrderAttack_d takes group g, unit target returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null or GetUnitState(target, UNIT_STATE_LIFE) <= 0
    if UnitInvis(u) then
      call RemoveGuardPosition(u)
      call IssueTargetOrder(u, "attack", target)
      call GroupAddUnit(focus_fire_group, u)
      //call RecycleGuardPosition(u)  // use RESET_WINDWALKER job
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set u = null
endfunction

function FocusGroupRemoveUnit takes group g returns nothing
  local integer i = 0
  local unit u = null
  local group ug = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null or i >= 12  //group order just can control 12 unit
    //if not IsUnitInGroup(u, focus_fire_group) then
    call CreateDebugTag("FF", 10, u, 1.00, 0.80)
    call GroupAddUnit(ug, u)
    set i = i + 1
    //endif
    //call RemoveGuardPosition(u)
    //call TQAddUnitJob(1.5, RESET_GUARD_POSITION_ONLY, 80, u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = ug
  set u = null
  set ug = null
endfunction

// Already facing the unit so no need to focus fire in this case
function FilterFocusFireGroupIfFacing takes group g, unit target returns nothing
	local unit u = null
	local group ug = null
	set ug = CopyGroup(g,ug)
	loop
		set u = FirstOfGroup(ug)
		exitwhen u == null
		if IsUnitFacingUnit(u, target) then
			call GroupRemoveUnit(focus_fire_group,u)
		endif
		call GroupRemoveUnit(ug,u)
	endloop
	call DestroyGroup(ug)
	set ug = null
endfunction

function FocusFire takes unit u returns nothing
  local group t = null
  local group temp_focus = null
  if GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
    return  //Insurance
  endif
  set t = CreateGroup()
  set temp_focus = CreateGroup()
  call GroupEnumUnitsInRange(t, GetUnitX(u), GetUnitY(u), focus_fire_ranged_dist, null)
  set t = SelectUnittype(t, UNIT_TYPE_RANGED_ATTACKER, true)
  set temp_focus = GroupAddGroup(temp_focus, t)
  call GroupClear(t)
  // call DestroyGroup(t)
  // set t = CreateGroup()
  call GroupEnumUnitsInRange(t, GetUnitX(u), GetUnitY(u), focus_fire_melee_dist, null)
  set t = SelectUnittype(t, UNIT_TYPE_MELEE_ATTACKER, true)
  set temp_focus = GroupAddGroup(temp_focus, t)
  call GroupClear(t)
  // call DestroyGroup(t)
  // set t = CreateGroup()
  call GroupEnumUnitsInRange(t, GetUnitX(u), GetUnitY(u), normal_battle_radius, null)
  if u == deny_unit then
    set t = SelectByInvisible(t, Player(PLAYER_NEUTRAL_AGGRESSIVE), true)
  else
    set t = SelectByInvisible(t, GetOwningPlayer(u), true)
  endif
  set temp_focus = GroupAddGroup(temp_focus, t)
  call GroupRemoveUnit(temp_focus,deny_unit)  // cannot control deny_unit
  set temp_focus = SelectByPlayer(temp_focus, ai_player, true)
  if IsUnitType(u, UNIT_TYPE_FLYING) == true then
    set temp_focus = SelectUnittype(temp_focus, UNIT_TYPE_ATTACKS_FLYING, true)
  endif
  set temp_focus = SelectUnittype(temp_focus, UNIT_TYPE_PEON, false)
  set temp_focus = SelectUnittype(temp_focus, UNIT_TYPE_STRUCTURE, false)
  set temp_focus = SelectByHidden(temp_focus, false)
  set temp_focus = SelectByAlive(temp_focus, true)
  call BlzGroupRemoveGroupFast(focus_fire_group, temp_focus)  // Remove units that have already focus fired this iteration (intentionally wrong way round)
  //set temp_focus = SelectByOrderOr2(focus_fire_group,OrderId("move"),OrderId("attack"),OrderId("stop"), true)
  set temp_focus = SelectByOrder(temp_focus, OrderId("blizzard"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("flamestrike"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("massteleport"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("earthquake"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("voodoo"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("deathanddecay"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("starfall"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("tranquility"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("clusterrockets"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("tornado"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("volcano"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("healingspray"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("stampede"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("rainoffire"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("magicleash"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("cloudoffog"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("unstableconcoction"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("grabtree"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("possession"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("ambush"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("devour"), false)
  set temp_focus = SelectByOrder(temp_focus, 852487, false)
  set temp_focus = SelectByUnitStandard(temp_focus, true)  //Reduce usage IsUnitInGroup
  if u != deny_unit and GetUnitState(u, UNIT_STATE_LIFE) > 0 then  //Insurance
    if FirstOfGroup(micro_enemymelee_group) != null then
      call BlzGroupRemoveGroupFast(focus_fire_group, micro_ranged_group)
      call GroupMicroSystem(micro_ranged_group, micro_enemymelee_group, temp_focus)  // Move ranged units away from melee units, if moved here they will not focus fire
    endif
  endif
  call DestroyGroup(t)
  if BlzGroupGetSize(temp_focus) > 0 and GetUnitState(u, UNIT_STATE_LIFE) > 0 then  //final Insurance
    if focus_fire_unit == null or focus_fire_unit != u then
      if not IsUnitType(u,UNIT_TYPE_STRUCTURE) and not IsUnitOwnedByPlayer(u, Player(PLAYER_NEUTRAL_AGGRESSIVE)) then  // Dont windwalk for non-critical enemies
        call GroupOrderFocusWindInstant(temp_focus)
      endif
      set focus_fire_unit = u
    endif
    call CreateDebugTag("FF: here:" + Int2Str(BlzGroupGetSize(temp_focus)), 10, u, 1.00, 0.80)
    if u == deny_unit and own_race == R_UNDEAD then
      call GroupOrderDeny_d(CopyGroup(temp_focus,t), u)
    endif
    if GetUnitState(u, UNIT_STATE_LIFE) > 0 then
      call FocusGroupRemoveUnit(temp_focus)
      call GroupTargetOrder(temp_focus, "attack", u)
    endif
    if GetUnitState(u, UNIT_STATE_LIFE) > 0 then
      call GroupOrderAttack_d(CopyGroup(windwalk_group,t), u)  // Forces Windwalking invisible units to attack directly as normal group order is ignored
    endif
    if u != deny_unit then
      set focus_fire_group = GroupAddGroup(focus_fire_group, temp_focus)  // Finally add units to group to say they have focus fired
    endif
  endif
  call DestroyGroup(temp_focus)
  set temp_focus = null
  set t = null
endfunction

function FocusEnemyUnitsNearGroup takes group g returns nothing
  local unit u = null
  local real hero_min_health = 100000
  local unit hero_min_health_unit = null
  local real min_health = 100000
  local unit min_health_unit = null
  local real building_min_health = 100000
  local unit building_min_health_unit = null
  local real disabled_min_health = 100000
  local unit disabled_min_health_unit = null
  local unit special_unit = null
  local real range_strength = 0
  local integer enemy_count = 0
  local real unit_life = 0
  local real x = 0
  local real y = 0
  local integer id = 0
  local boolean cansleep = false
  local player p = null
  call GroupClear(micro_ranged_group)
  call GroupClear(micro_enemymelee_group)
  if deny_unit != null then
    call GroupRemoveUnit(g,deny_unit)  // cannot control deny_unit
  endif
  if town_threatened then
    set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_AGGRESSIVE), false)
  endif
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set unit_life = GetUnitState(u, UNIT_STATE_LIFE)
    if unit_life > 0 and not IsUnitHidden(u) then
      set p = GetOwningPlayer(u)
      if IsPlayerEnemy(p, ai_player) and not (UnitInvis(u) and not IsUnitDetected(u, ai_player)) and IsUnitVisible(u, ai_player) then
        if IsUnitType(u, UNIT_TYPE_MELEE_ATTACKER) then
          set x = x + GetUnitX(u)  // Prevent loc exceeding map range
          set y = y + GetUnitY(u)
          //set enemy_melee_loc = GetSumLoc_dd(enemy_melee_loc, GetUnitLoc(u))
          set enemy_count = enemy_count + 1
          call GroupAddUnit(micro_enemymelee_group, u)
        endif
        set id = GetUnitTypeId(u)
        if IsUnitType(u, UNIT_TYPE_HERO) then
          if unit_life < hero_min_health then
            set hero_min_health = unit_life
            set hero_min_health_unit = u
          endif
        elseif id == 'hpxe' or id == 'espv' or id == 'ngsp' then
          set special_unit = u
        else
          set cansleep = UnitIsSleeping(u)
          if unit_life < min_health and not cansleep and (unit_life < GetUnitState(u, UNIT_STATE_MAX_LIFE) or IsUnitType(u, UNIT_TYPE_MELEE_ATTACKER) or IsUnitType(u, UNIT_TYPE_RANGED_ATTACKER) or IsUnitType(u, UNIT_TYPE_TOWNHALL)) then
            set min_health = unit_life
            set min_health_unit = u
          endif
          if unit_life < disabled_min_health and GetUnitMoveSpeed(u) == 0 and not IsUnitType(u, UNIT_TYPE_STRUCTURE) and not cansleep then
            set disabled_min_health = unit_life
            set disabled_min_health_unit = u
          endif
          if unit_life < building_min_health and IsUnitType(u, UNIT_TYPE_STRUCTURE) then
            set building_min_health = unit_life
            set building_min_health_unit = u
          endif
        endif
      elseif p != Player(PLAYER_NEUTRAL_PASSIVE) and IsPlayerAlly(p, ai_player) and not UnitInvis(u) then
        if IsUnitType(u, UNIT_TYPE_RANGED_ATTACKER) and not IsUnitType(u, UNIT_TYPE_SUMMONED) and not IsUnitType(u, UNIT_TYPE_STRUCTURE) and not IsUnitType(u, UNIT_TYPE_PEON) then
          set range_strength = range_strength + GetUnitStrength(u)
          if unit_life < GetUnitState(u, UNIT_STATE_MAX_LIFE)*0.70 then
            call GroupAddUnit(micro_ranged_group, u) // Only add to micro orders if damaged
          endif
        endif
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  if enemy_count != 0 then
    set x = x / I2R(enemy_count)
    set y = y / I2R(enemy_count)
    call MoveLocation(enemy_melee_loc, x, y)
    //set enemy_melee_loc = GetDivisionLoc_d(enemy_melee_loc, I2R(enemy_count))
  endif
  if hero_min_health_unit != null and (hero_min_health < focus_fire_limit * range_strength or disabled_min_health_unit == hero_min_health_unit) then
    call SetTargetHeroes(true)
    call FocusFire(hero_min_health_unit)
  else
    call SetTargetHeroes(false)
    if special_unit != null then
      call FocusFire(special_unit)
    elseif disabled_min_health_unit != null then
      if min_health_unit != null then
        if min_health * 3 < disabled_min_health then
          call FocusFire(min_health_unit)
        else
          call FocusFire(disabled_min_health_unit)
        endif
      else
        call FocusFire(disabled_min_health_unit)
      endif
    elseif min_health_unit != null then
      call FocusFire(min_health_unit)
    elseif building_min_health_unit != null then
      call FocusFire(building_min_health_unit)
    endif
  endif
  set p = null
  set u = null
  set hero_min_health_unit = null
  set min_health_unit = null
  set building_min_health_unit = null
  set disabled_min_health_unit = null
  set special_unit = null
endfunction

//============================================================================
function FocusFireJob takes nothing returns nothing
  local group g = CreateGroup()
  local integer i = 0

  call DisplayToAllJobDebug("FOCUSFIRE_CONTROL JOB START")

  //if retreat_controlled and (attack_running or town_threatened) then

  if not CaptainRetreating() and (attack_running or town_threatened) then
    if major_hero == null or not UnitAlive(major_hero) or IsUnitInGroup(major_hero, unit_healing) then
      set major_hero = GetMajorHeroReplacement_k(major_hero,last_major_hero_loc)
    endif
    if major_hero != null then
      call RemoveLocation(last_major_hero_loc)
      set last_major_hero_loc = GetUnitLoc(major_hero)
      call GroupEnumUnitsInRange(g,GetUnitX(major_hero),GetUnitY(major_hero),battle_radius,null)
      call FocusEnemyUnitsNearGroup(g)
    endif
    if main_army >= 0 and army_loc[main_army] != null then
      call GroupEnumUnitsInRange(g, GetLocationX(army_loc[main_army]), GetLocationY(army_loc[main_army]), battle_radius, null)
      call FocusEnemyUnitsNearGroup(g)
    endif
    loop
      exitwhen i >= army_num
      if Player(army_owner[i]) == ai_player and main_army != i and army_loc[i] != null then
        call GroupEnumUnitsInRange(g, GetLocationX(army_loc[i]), GetLocationY(army_loc[i]), battle_radius, null)
        call FocusEnemyUnitsNearGroup(g)
      endif
      set i = i + 1
    endloop
    if deny_unit != null and UnitAlive(deny_unit) and GetUnitState(deny_unit, UNIT_STATE_LIFE) < 24 and (GetUnitState(deny_unit, UNIT_STATE_LIFE)/GetUnitState(deny_unit, UNIT_STATE_MAX_LIFE)) < 0.10 then
      call FocusFire(deny_unit)
      set deny_unit = null
    endif
    call SetTargetHeroes(difficulty != EASY)
    call GroupClear(focus_fire_group)
  //else
    //call GroupRecycleGuardPositionInstant(CopyGroup(windwalk_group,g))
    //loop
    //	set u = FirstOfGroup(windwalk_group)
    //	exitwhen u == null
    //	call GroupRemoveUnit(windwalk_group, u)
    //	if not IsUnitInGroup(u, unit_healing) and not IsUnitInGroup(u, unit_harassing) then
    //		call RecycleGuardPosition(u)
    //	endif
    //endloop
  endif
  call DestroyGroup(g)
  set g = null
  call TQAddJob(2 * sleep_multiplier, FOCUSFIRE_CONTROL, 0)
endfunction

#ENDIF