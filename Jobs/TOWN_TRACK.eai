#IFDEF GLOBAL
    boolean town_threatened = false
    integer array town_owner
    location array town_loc
    real array town_value
    real array town_threat
    group array town_group
    integer array town_count
    integer array town_threat_army
    boolean array town_can_tp
    integer most_threatened_town = -1
    integer most_threatened_enemy_town = -1
    integer town_num = 0
    real town_radius = 2500
    group in_town_group = CreateGroup()
#ELSE
function CopyTown takes integer from, integer to returns nothing
  set town_owner[to] = town_owner[from]
  set town_loc[to] = town_loc[from]
  set town_value[to] = town_value[from]
  set town_threat[to] = town_threat[from]
  set town_group[to] = town_group[from]
  set town_count[to] = town_count[from]
endfunction

//===========================================================================
//function LivingPlayerUnitsOfTypeIdFilter takes nothing returns boolean
//    local unit filterUnit = GetFilterUnit()
//    return IsUnitAliveBJ(filterUnit) and GetUnitTypeId(filterUnit) == bj_livingPlayerUnitsTypeId
//endfunction

//===========================================================================
//function CountLivingPlayerUnitsOfTypeId takes integer unitId, player whichPlayer returns integer
//    local group g
//    local integer matchedCount

//    set g = CreateGroup()
//    set bj_livingPlayerUnitsTypeId = unitId
//    call GroupEnumUnitsOfPlayer(g, whichPlayer, filterLivingPlayerUnitsOfTypeId)
//    set matchedCount = CountUnitsInGroup(g)
//    call DestroyGroup(g)

//    return matchedCount
//endfunction

//    set filterLivingPlayerUnitsOfTypeId = Filter(function LivingPlayerUnitsOfTypeIdFilter)
//	    boolexpr           filterLivingPlayerUnitsOfTypeId   = null
//		integer            bj_livingPlayerUnitsTypeId  = 0

function TrackTown takes integer num returns boolean
  local group g = CreateGroup()
  local unit u = null
  //local location l = null
  local real x = 0
  local real y = 0

  set town_value[num] = 0
  set town_count[num] = 0
  set town_can_tp[num] = false
  call GroupEnumUnitsInRangeOfLoc(g, town_loc[num], town_radius, null)
  set g = SelectByPlayer(g, Player(town_owner[num]), true)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  set g = SelectByAlive2(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if not IsUnitInGroup(u, in_town_group) then
      call GroupAddUnit(town_group[num], u)
      call GroupAddUnit(in_town_group, u)
      set x = x + GetUnitX(u)  // Prevent loc exceeding map range
      set y = y + GetUnitY(u)
      //set l = GetSumLoc_dd(l,GetUnitLoc(u))
      set town_count[num] = town_count[num] + 1
      set town_value[num] = town_value[num] + 1
      if IsUnitType(u, UNIT_TYPE_TOWNHALL) then //and UnitAlive(u) then
        set town_can_tp[num] = true
      endif
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  call RemoveLocation(town_loc[num])
  if town_count[num] == 0 then
    call DestroyGroup(town_group[num])
    set town_group[num] = null
    set town_loc[num] = null
    //call RemoveLocation(l)
    //set l = null
    return false
  endif
  //    call PingMinimapEx(GetLocationX(l), GetLocationY(l), 9, 0, 0, 255, false)
  set x = x / Max(town_count[num], 1)
  set y = y / Max(town_count[num], 1)
  set town_loc[num] = Location(x, y)
  //set town_loc[num] = GetDivisionLoc_d(l, Max(town_count[num], 1))
  //set l = null
  return true
endfunction

function TrackExistingTowns takes nothing returns nothing
  local integer i = 0
  local integer first_free = 0
  loop
    exitwhen i >= town_num
    call GroupClear(town_group[i])
    if TrackTown(i) then
      if i != first_free then
        call CopyTown(i, first_free)
      endif
      set first_free = first_free + 1
    endif
    set i = i + 1
  endloop
  set town_num = first_free
endfunction

function SeedNewTownAtLoc takes location l, integer p returns nothing
  if town_loc[town_num] != null then
    call RemoveLocation(town_loc[town_num])
  endif
  if town_group[town_num] != null then
    call DestroyGroup(town_group[town_num])
  endif
  set town_owner[town_num] = p
  set town_loc[town_num] = l
  set town_threat[town_num] = 0
  set town_group[town_num] = CreateGroup()
  if TrackTown(town_num) then
    set town_num = town_num + 1
  endif
endfunction

function SeedNewTownsForPlayer takes integer p returns nothing
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsOfPlayer(g, Player(p), null)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  set g = SelectByAlive(g,true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if not IsUnitInGroup(u, in_town_group) then  //IsUnitType(u, UNIT_TYPE_STRUCTURE) and UnitAlive(u) and
      call SeedNewTownAtLoc(GetUnitLoc(u), p)
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
endfunction

function SeedNewTowns takes nothing returns nothing
  local integer p = 0
  loop
    exitwhen p >= GetBJMaxPlayers()
    if GetPlayerSlotState(Player(p)) == PLAYER_SLOT_STATE_PLAYING and not IsPlayerObserver(Player(p)) then
      call SeedNewTownsForPlayer(p)
    endif
    set p = p + 1
  endloop
endfunction

function TownTrackJob takes nothing returns nothing
  call DisplayToAllJobDebug("TOWN_TRACK Job Start")
  call GroupClear(in_town_group)
  call TrackExistingTowns()
  call SeedNewTowns()
  call TQAddJob(9, TOWN_TRACK, 0)
endfunction
#ENDIF