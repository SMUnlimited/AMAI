
native DebugS               takes string str                            returns nothing
native DebugFI              takes string str, integer val               returns nothing
native DebugUnitID          takes string str, integer val               returns nothing
native DisplayText          takes integer p, string str                 returns nothing
native DisplayTextI         takes integer p, string str, integer val    returns nothing
native DisplayTextII        takes integer p, string str, integer v1, integer v2 returns nothing
native DisplayTextIII       takes integer p, string str, integer v1, integer v2, integer v3 returns nothing
native DoAiScriptDebug      takes nothing                               returns boolean

native GetAiPlayer          takes nothing                               returns integer
native GetHeroId            takes nothing                               returns integer
native GetHeroLevelAI       takes nothing                               returns integer

native GetUnitCount         takes integer unitid                        returns integer
native GetPlayerUnitTypeCount takes player p, integer unitid            returns integer
native GetUnitCountDone     takes integer unitid                        returns integer
native GetTownUnitCount     takes integer id, integer tn, boolean dn    returns integer
native GetUnitGoldCost      takes integer unitid                        returns integer
native GetUnitWoodCost      takes integer unitid                        returns integer
native GetUnitBuildTime     takes integer unitid                        returns integer

native GetMinesOwned        takes nothing                               returns integer
native GetGoldOwned         takes nothing                               returns integer
native TownWithMine         takes nothing                               returns integer
native TownHasMine          takes integer townid                        returns boolean
native TownHasHall          takes integer townid                        returns boolean

native GetUpgradeLevel      takes integer id                            returns integer
native GetUpgradeGoldCost   takes integer id                            returns integer
native GetUpgradeWoodCost   takes integer id                            returns integer
native GetNextExpansion     takes nothing                               returns integer
native GetMegaTarget        takes nothing                               returns unit
native GetBuilding          takes player p                              returns unit
native GetEnemyPower        takes nothing                               returns integer
native SetAllianceTarget    takes unit id                               returns nothing
native GetAllianceTarget    takes nothing                               returns unit

native SetProduce           takes integer qty, integer id, integer town returns boolean
native Unsummon             takes unit unitid                           returns nothing
native SetExpansion         takes unit peon, integer id                 returns boolean
native SetUpgrade           takes integer id                            returns boolean
native SetHeroLevels        takes code func                             returns nothing
native SetNewHeroes         takes boolean state                         returns nothing
native PurchaseZeppelin     takes nothing                               returns nothing

native MergeUnits           takes integer qty, integer a, integer b, integer make returns boolean
native ConvertUnits         takes integer qty, integer id               returns boolean

native SetCampaignAI        takes nothing                               returns nothing
native SetMeleeAI           takes nothing                               returns nothing
native SetTargetHeroes      takes boolean state                         returns nothing
native SetPeonsRepair       takes boolean state                         returns nothing
native SetRandomPaths       takes boolean state                         returns nothing
native SetDefendPlayer      takes boolean state                         returns nothing
native SetHeroesFlee        takes boolean state                         returns nothing
native SetHeroesBuyItems    takes boolean state                         returns nothing
native SetWatchMegaTargets  takes boolean state                         returns nothing
native SetIgnoreInjured     takes boolean state                         returns nothing
native SetHeroesTakeItems   takes boolean state                         returns nothing
native SetUnitsFlee         takes boolean state                         returns nothing
native SetGroupsFlee        takes boolean state                         returns nothing
native SetSlowChopping      takes boolean state                         returns nothing
native SetCaptainChanges    takes boolean allow                         returns nothing
native SetSmartArtillery    takes boolean state                         returns nothing
native SetReplacementCount  takes integer qty                           returns nothing
native GroupTimedLife       takes boolean allow                         returns nothing
native RemoveInjuries       takes nothing                               returns nothing
native RemoveSiege          takes nothing                               returns nothing

native InitAssault          takes nothing                               returns nothing
native AddAssault           takes integer qty, integer id               returns boolean
native AddDefenders         takes integer qty, integer id               returns boolean

native GetCreepCamp         takes integer min, integer max, boolean flyers_ok returns unit

native StartGetEnemyBase    takes nothing                               returns nothing
native WaitGetEnemyBase     takes nothing                               returns boolean
native GetEnemyBase         takes nothing                               returns unit
native GetExpansionFoe      takes nothing                               returns unit
native GetEnemyExpansion    takes nothing                               returns unit
native GetExpansionX        takes nothing                               returns integer
native GetExpansionY        takes nothing                               returns integer
native SetStagePoint        takes real x, real y                        returns nothing
native AttackMoveKill       takes unit target                           returns nothing
native AttackMoveXY         takes integer x, integer y                  returns nothing
native LoadZepWave          takes integer x, integer y                  returns nothing
native SuicidePlayer        takes player id, boolean check_full         returns boolean
native SuicidePlayerUnits   takes player id, boolean check_full         returns boolean
native CaptainInCombat      takes boolean attack_captain                returns boolean
native IsTowered            takes unit target                           returns boolean

native ClearHarvestAI       takes nothing                               returns nothing
native HarvestGold          takes integer town, integer peons           returns nothing
native HarvestWood          takes integer town, integer peons           returns nothing
native GetExpansionPeon     takes nothing                               returns unit

native StopGathering        takes nothing                               returns nothing
native AddGuardPost         takes integer id, real x, real y            returns nothing
native FillGuardPosts       takes nothing                               returns nothing
native ReturnGuardPosts     takes nothing                               returns nothing
native CreateCaptains       takes nothing                               returns nothing
native SetCaptainHome       takes integer which, real x, real y         returns nothing
native ResetCaptainLocs     takes nothing                               returns nothing
native ShiftTownSpot        takes real x, real y                        returns nothing
native TeleportCaptain      takes real x, real y                        returns nothing
native ClearCaptainTargets  takes nothing                               returns nothing
native CaptainAttack        takes real x, real y                        returns nothing
native CaptainVsUnits       takes player id                             returns nothing
native CaptainVsPlayer      takes player id                             returns nothing
native CaptainGoHome        takes nothing                               returns nothing
native CaptainIsHome        takes nothing                               returns boolean
native CaptainIsFull        takes nothing                               returns boolean
native CaptainIsEmpty       takes nothing                               returns boolean
native CaptainGroupSize     takes nothing                               returns integer
native CaptainReadiness     takes nothing                               returns integer
native CaptainRetreating    takes nothing                               returns boolean
native CaptainReadinessHP   takes nothing                               returns integer
native CaptainReadinessMa   takes nothing                               returns integer
native CaptainAtGoal        takes nothing                               returns boolean
native CreepsOnMap          takes nothing                               returns boolean
native SuicideUnit          takes integer count, integer unitid         returns nothing
native SuicideUnitEx        takes integer ct, integer uid, integer pid  returns nothing
native StartThread          takes code func                             returns nothing
native Sleep                takes real seconds                          returns nothing
native UnitAlive            takes unit id                               returns boolean
native UnitInvis            takes unit id                               returns boolean
native IgnoredUnits         takes integer unitid                        returns integer
native TownThreatened       takes nothing                               returns boolean
native DisablePathing       takes nothing                               returns nothing
native SetAmphibious        takes nothing                               returns nothing

native CommandsWaiting      takes nothing                               returns integer
native GetLastCommand       takes nothing                               returns integer
native GetLastData          takes nothing                               returns integer
native PopLastCommand       takes nothing                               returns nothing
native MeleeDifficulty      takes nothing                               returns integer

globals

   //============================================================================
   // Standard Constants and Variables
   //============================================================================

    constant integer M1                 =    60
    constant integer M2                 =  2*60
    constant integer M3                 =  3*60
    constant integer M4                 =  4*60
    constant integer M5                 =  5*60
    constant integer M6                 =  6*60
    constant integer M7                 =  7*60
    constant integer M8                 =  8*60
    constant integer M9                 =  9*60
    constant integer M10                = 10*60
    constant integer M11                = 11*60
    constant integer M12                = 12*60
    constant integer M13                = 13*60
    constant integer M14                = 14*60
    constant integer M15                = 15*60

    constant integer EASY               = 1
    constant integer NORMAL             = 2
    constant integer HARD               = 3
    constant integer INSANE             = 4 // not used

    constant integer MELEE_NEWBIE       = 1
    constant integer MELEE_NORMAL       = 2
    constant integer MELEE_INSANE       = 3

    constant integer ATTACK_CAPTAIN     = 1
    constant integer DEFENSE_CAPTAIN    = 2
    constant integer BOTH_CAPTAINS      = 3

    constant integer BUILD_UNIT         = 1
    constant integer BUILD_UPGRADE      = 2
    constant integer BUILD_EXPAND       = 3

    constant integer UPKEEP_TIER1       = 50
    constant integer UPKEEP_TIER2       = 80

    //--------------------------------------------------------------------

    player  ai_player

    integer sleep_seconds
    integer total_gold              = 0
    integer total_wood              = 0
    integer gold_buffer             = 0 // usually for potion money
    integer difficulty              = NORMAL
    integer exp_seen                = 0
    integer racial_farm             = 'hhou'
    integer hero_id                 = 'Hamg'
    integer hero_id2                = 'Hmkg'
    integer hero_id3                = 'Hpal'
    integer array skill
    integer array skills1
    integer array skills2
    integer array skills3
    integer max_hero_level          = 0

    integer array harass_qty
    integer array harass_max
    integer array harass_units
    integer harass_length           = 0

    integer array defense_qty
    integer array defense_units
    integer defense_length          = 0

    integer array build_qty
    integer array build_type
    integer array build_item
    integer array build_town
    integer build_length            = 0

    integer campaign_gold_peons     = 5
    integer campaign_wood_peons     = 3
    integer campaign_basics_speed   = 5

    integer min_creeps              = -1
    integer max_creeps              = -1

    boolean harvest_town1           = true
    boolean harvest_town2           = true
    boolean harvest_town3           = true
    boolean do_campaign_farms       = true
    boolean two_heroes              = false
    boolean allow_air_creeps        = false
    boolean take_exp                = false
    boolean allow_signal_abort      = false
    boolean ready_for_zeppelin      = true
    boolean get_zeppelin            = false

    boolean build_campaign_attackers = true

    boolean do_debug_cheats         = false
    boolean trace_on                = true
    boolean zep_next_wave           = false
    boolean form_group_timeouts     = true


    // =============================================================
    // AMAI constants
    // =============================================================



    constant integer o0                 = 0
    string array unitNames

  integer ARCHMAGE = 1  // Cannot be constants for VS AI support
  constant integer oARCHMAGE = 'Hamg'
  integer PALADIN = 2  // Cannot be constants for VS AI support
  constant integer oPALADIN = 'Hpal'
  integer MTN_KING = 3  // Cannot be constants for VS AI support
  constant integer oMTN_KING = 'Hmkg'
  integer BLADE_MASTER = 4  // Cannot be constants for VS AI support
  constant integer oBLADE_MASTER = 'Obla'
  integer FAR_SEER = 5  // Cannot be constants for VS AI support
  constant integer oFAR_SEER = 'Ofar'
  integer TAUREN_CHIEF = 6  // Cannot be constants for VS AI support
  constant integer oTAUREN_CHIEF = 'Otch'
  integer DEATH_KNIGHT = 7  // Cannot be constants for VS AI support
  constant integer oDEATH_KNIGHT = 'Udea'
  integer DREAD_LORD = 8  // Cannot be constants for VS AI support
  constant integer oDREAD_LORD = 'Udre'
  integer LICH = 9  // Cannot be constants for VS AI support
  constant integer oLICH = 'Ulic'
  integer DEMON_HUNTER = 10  // Cannot be constants for VS AI support
  constant integer oDEMON_HUNTER = 'Edem'
  integer KEEPER = 11  // Cannot be constants for VS AI support
  constant integer oKEEPER = 'Ekee'
  integer MOON_PRIESTESS = 12  // Cannot be constants for VS AI support
  constant integer oMOON_PRIESTESS = 'Emoo'
  integer COPTER = 13  // Cannot be constants for VS AI support
  constant integer oCOPTER = 'hgyr'
  integer ELEMENTAL = 14  // Cannot be constants for VS AI support
  constant integer oELEMENTAL = 'hwat'
  integer FOOTMAN = 15  // Cannot be constants for VS AI support
  constant integer oFOOTMAN = 'hfoo'
  integer GRYPHON = 16  // Cannot be constants for VS AI support
  constant integer oGRYPHON = 'hgry'
  integer KNIGHT = 17  // Cannot be constants for VS AI support
  constant integer oKNIGHT = 'hkni'
  integer MORTAR = 18  // Cannot be constants for VS AI support
  constant integer oMORTAR = 'hmtm'
  integer PEASANT = 19  // Cannot be constants for VS AI support
  constant integer oPEASANT = 'hpea'
  integer PRIEST = 20  // Cannot be constants for VS AI support
  constant integer oPRIEST = 'hmpr'
  integer RIFLEMAN = 21  // Cannot be constants for VS AI support
  constant integer oRIFLEMAN = 'hrif'
  integer SORCERESS = 22  // Cannot be constants for VS AI support
  constant integer oSORCERESS = 'hsor'
  integer STEAM_TANK = 23  // Cannot be constants for VS AI support
  constant integer oSTEAM_TANK = 'hmtt'
  integer MILITIA = 24  // Cannot be constants for VS AI support
  constant integer oMILITIA = 'hmil'
  integer AVIARY = 25  // Cannot be constants for VS AI support
  constant integer oAVIARY = 'hgra'
  integer BARRACKS = 26  // Cannot be constants for VS AI support
  constant integer oBARRACKS = 'hbar'
  integer BLACKSMITH = 27  // Cannot be constants for VS AI support
  constant integer oBLACKSMITH = 'hbla'
  integer CANNON_TOWER = 28  // Cannot be constants for VS AI support
  constant integer oCANNON_TOWER = 'hctw'
  integer CASTLE = 29  // Cannot be constants for VS AI support
  constant integer oCASTLE = 'hcas'
  integer GUARD_TOWER = 30  // Cannot be constants for VS AI support
  constant integer oGUARD_TOWER = 'hgtw'
  integer HOUSE = 31  // Cannot be constants for VS AI support
  constant integer oHOUSE = 'hhou'
  integer HUMAN_ALTAR = 32  // Cannot be constants for VS AI support
  constant integer oHUMAN_ALTAR = 'halt'
  integer KEEP = 33  // Cannot be constants for VS AI support
  constant integer oKEEP = 'hkee'
  integer LUMBER_MILL = 34  // Cannot be constants for VS AI support
  constant integer oLUMBER_MILL = 'hlum'
  integer SANCTUM = 35  // Cannot be constants for VS AI support
  constant integer oSANCTUM = 'hars'
  integer TOWN_HALL = 36  // Cannot be constants for VS AI support
  constant integer oTOWN_HALL = 'htow'
  integer WATCH_TOWER = 37  // Cannot be constants for VS AI support
  constant integer oWATCH_TOWER = 'hwtw'
  integer WORKSHOP = 38  // Cannot be constants for VS AI support
  constant integer oWORKSHOP = 'harm'
  integer UPG_SIGHT = 39  // Cannot be constants for VS AI support
  constant integer oUPG_SIGHT = 'Rhss'
  integer UPG_DEFEND = 40  // Cannot be constants for VS AI support
  constant integer oUPG_DEFEND = 'Rhde'
  integer UPG_HAMMERS = 41  // Cannot be constants for VS AI support
  constant integer oUPG_HAMMERS = 'Rhhb'
  integer UPG_BREEDING = 42  // Cannot be constants for VS AI support
  constant integer oUPG_BREEDING = 'Rhan'
  integer UPG_GUN_RANGE = 43  // Cannot be constants for VS AI support
  constant integer oUPG_GUN_RANGE = 'Rhri'
  integer UPG_SENTINEL = 44  // Cannot be constants for VS AI support
  constant integer oUPG_SENTINEL = 'Rhse'
  integer UPG_BOMBS = 45  // Cannot be constants for VS AI support
  constant integer oUPG_BOMBS = 'Rhgb'
  integer CATAPULT = 46  // Cannot be constants for VS AI support
  constant integer oCATAPULT = 'ocat'
  integer WITCH_DOCTOR = 47  // Cannot be constants for VS AI support
  constant integer oWITCH_DOCTOR = 'odoc'
  integer GRUNT = 48  // Cannot be constants for VS AI support
  constant integer oGRUNT = 'ogru'
  integer HEAD_HUNTER = 49  // Cannot be constants for VS AI support
  constant integer oHEAD_HUNTER = 'ohun'
  integer KODO_BEAST = 50  // Cannot be constants for VS AI support
  constant integer oKODO_BEAST = 'okod'
  integer PEON = 51  // Cannot be constants for VS AI support
  constant integer oPEON = 'opeo'
  integer RAIDER = 52  // Cannot be constants for VS AI support
  constant integer oRAIDER = 'orai'
  integer SHAMAN = 53  // Cannot be constants for VS AI support
  constant integer oSHAMAN = 'oshm'
  integer TAUREN = 54  // Cannot be constants for VS AI support
  constant integer oTAUREN = 'otau'
  integer WYVERN = 55  // Cannot be constants for VS AI support
  constant integer oWYVERN = 'owyv'
  integer ORC_ALTAR = 56  // Cannot be constants for VS AI support
  constant integer oORC_ALTAR = 'oalt'
  integer ORC_BARRACKS = 57  // Cannot be constants for VS AI support
  constant integer oORC_BARRACKS = 'obar'
  integer BESTIARY = 58  // Cannot be constants for VS AI support
  constant integer oBESTIARY = 'obea'
  integer FORGE = 59  // Cannot be constants for VS AI support
  constant integer oFORGE = 'ofor'
  integer FORTRESS = 60  // Cannot be constants for VS AI support
  constant integer oFORTRESS = 'ofrt'
  integer GREAT_HALL = 61  // Cannot be constants for VS AI support
  constant integer oGREAT_HALL = 'ogre'
  integer LODGE = 62  // Cannot be constants for VS AI support
  constant integer oLODGE = 'osld'
  integer STRONGHOLD = 63  // Cannot be constants for VS AI support
  constant integer oSTRONGHOLD = 'ostr'
  integer BURROW = 64  // Cannot be constants for VS AI support
  constant integer oBURROW = 'otrb'
  integer TOTEM = 65  // Cannot be constants for VS AI support
  constant integer oTOTEM = 'otto'
  integer ORC_WATCH_TOWER = 66  // Cannot be constants for VS AI support
  constant integer oORC_WATCH_TOWER = 'owtw'
  integer UPG_ORC_WAR_DRUMS = 67  // Cannot be constants for VS AI support
  constant integer oUPG_ORC_WAR_DRUMS = 'Rwdm'
  integer UPG_ORC_PILLAGE = 68  // Cannot be constants for VS AI support
  constant integer oUPG_ORC_PILLAGE = 'Ropg'
  integer UPG_ORC_BERSERK = 69  // Cannot be constants for VS AI support
  constant integer oUPG_ORC_BERSERK = 'Robs'
  integer UPG_ORC_PULVERIZE = 70  // Cannot be constants for VS AI support
  constant integer oUPG_ORC_PULVERIZE = 'Rows'
  integer UPG_ORC_ENSNARE = 71  // Cannot be constants for VS AI support
  constant integer oUPG_ORC_ENSNARE = 'Roen'
  integer UPG_ORC_VENOM = 72  // Cannot be constants for VS AI support
  constant integer oUPG_ORC_VENOM = 'Rovs'
  integer UPG_ORC_REGEN = 73  // Cannot be constants for VS AI support
  constant integer oUPG_ORC_REGEN = 'Rotr'
  integer ABOMINATION = 74  // Cannot be constants for VS AI support
  constant integer oABOMINATION = 'uabo'
  integer ACOLYTE = 75  // Cannot be constants for VS AI support
  constant integer oACOLYTE = 'uaco'
  integer BANSHEE = 76  // Cannot be constants for VS AI support
  constant integer oBANSHEE = 'uban'
  integer CRYPT_FIEND = 77  // Cannot be constants for VS AI support
  constant integer oCRYPT_FIEND = 'ucry'
  integer FROST_WYRM = 78  // Cannot be constants for VS AI support
  constant integer oFROST_WYRM = 'ufro'
  integer GARGOYLE = 79  // Cannot be constants for VS AI support
  constant integer oGARGOYLE = 'ugar'
  integer GARGOYLE_MORPH = 80  // Cannot be constants for VS AI support
  constant integer oGARGOYLE_MORPH = 'ugrm'
  integer GHOUL = 81  // Cannot be constants for VS AI support
  constant integer oGHOUL = 'ugho'
  integer MEAT_WAGON = 82  // Cannot be constants for VS AI support
  constant integer oMEAT_WAGON = 'umtw'
  integer NECRO = 83  // Cannot be constants for VS AI support
  constant integer oNECRO = 'unec'
  integer SKEL_WARRIOR = 84  // Cannot be constants for VS AI support
  constant integer oSKEL_WARRIOR = 'uske'
  integer SHADE = 85  // Cannot be constants for VS AI support
  constant integer oSHADE = 'ushd'
  integer UNDEAD_MINE = 86  // Cannot be constants for VS AI support
  constant integer oUNDEAD_MINE = 'ugol'
  integer UNDEAD_ALTAR = 87  // Cannot be constants for VS AI support
  constant integer oUNDEAD_ALTAR = 'uaod'
  integer BONEYARD = 88  // Cannot be constants for VS AI support
  constant integer oBONEYARD = 'ubon'
  integer NECROPOLIS_1 = 89  // Cannot be constants for VS AI support
  constant integer oNECROPOLIS_1 = 'unpl'
  integer NECROPOLIS_2 = 90  // Cannot be constants for VS AI support
  constant integer oNECROPOLIS_2 = 'unp1'
  integer NECROPOLIS_3 = 91  // Cannot be constants for VS AI support
  constant integer oNECROPOLIS_3 = 'unp2'
  integer SAC_PIT = 92  // Cannot be constants for VS AI support
  constant integer oSAC_PIT = 'usap'
  integer CRYPT = 93  // Cannot be constants for VS AI support
  constant integer oCRYPT = 'usep'
  integer SLAUGHTERHOUSE = 94  // Cannot be constants for VS AI support
  constant integer oSLAUGHTERHOUSE = 'uslh'
  integer DAMNED_TEMPLE = 95  // Cannot be constants for VS AI support
  constant integer oDAMNED_TEMPLE = 'utod'
  integer ZIGGURAT_1 = 96  // Cannot be constants for VS AI support
  constant integer oZIGGURAT_1 = 'uzig'
  integer ZIGGURAT_2 = 97  // Cannot be constants for VS AI support
  constant integer oZIGGURAT_2 = 'uzg1'
  integer GRAVEYARD = 98  // Cannot be constants for VS AI support
  constant integer oGRAVEYARD = 'ugrv'
  integer UPG_CANNIBALIZE = 99  // Cannot be constants for VS AI support
  constant integer oUPG_CANNIBALIZE = 'Ruac'
  integer UPG_GHOUL_FRENZY = 100  // Cannot be constants for VS AI support
  constant integer oUPG_GHOUL_FRENZY = 'Rugf'
  integer UPG_FIEND_WEB = 101  // Cannot be constants for VS AI support
  constant integer oUPG_FIEND_WEB = 'Ruwb'
  integer UPG_STONE_FORM = 102  // Cannot be constants for VS AI support
  constant integer oUPG_STONE_FORM = 'Rusf'
  integer UPG_WYRM_BREATH = 103  // Cannot be constants for VS AI support
  constant integer oUPG_WYRM_BREATH = 'Rufb'
  integer UPG_SKEL_LIFE = 104  // Cannot be constants for VS AI support
  constant integer oUPG_SKEL_LIFE = 'Rusl'
  integer UPG_PLAGUE = 105  // Cannot be constants for VS AI support
  constant integer oUPG_PLAGUE = 'Rupc'
  integer WISP = 106  // Cannot be constants for VS AI support
  constant integer oWISP = 'ewsp'
  integer ARCHER = 107  // Cannot be constants for VS AI support
  constant integer oARCHER = 'earc'
  integer DRUID_TALON = 108  // Cannot be constants for VS AI support
  constant integer oDRUID_TALON = 'edot'
  integer DRUID_TALON_M = 109  // Cannot be constants for VS AI support
  constant integer oDRUID_TALON_M = 'edtm'
  integer BALLISTA = 110  // Cannot be constants for VS AI support
  constant integer oBALLISTA = 'ebal'
  integer DRUID_CLAW = 111  // Cannot be constants for VS AI support
  constant integer oDRUID_CLAW = 'edoc'
  integer DRUID_CLAW_M = 112  // Cannot be constants for VS AI support
  constant integer oDRUID_CLAW_M = 'edcm'
  integer DRYAD = 113  // Cannot be constants for VS AI support
  constant integer oDRYAD = 'edry'
  integer HIPPO = 114  // Cannot be constants for VS AI support
  constant integer oHIPPO = 'ehip'
  integer HIPPO_RIDER = 115  // Cannot be constants for VS AI support
  constant integer oHIPPO_RIDER = 'ehpr'
  integer HUNTRESS = 116  // Cannot be constants for VS AI support
  constant integer oHUNTRESS = 'esen'
  integer CHIMAERA = 117  // Cannot be constants for VS AI support
  constant integer oCHIMAERA = 'echm'
  integer ANCIENT_LORE = 118  // Cannot be constants for VS AI support
  constant integer oANCIENT_LORE = 'eaoe'
  integer ANCIENT_WAR = 119  // Cannot be constants for VS AI support
  constant integer oANCIENT_WAR = 'eaom'
  integer ANCIENT_WIND = 120  // Cannot be constants for VS AI support
  constant integer oANCIENT_WIND = 'eaow'
  integer TREE_AGES = 121  // Cannot be constants for VS AI support
  constant integer oTREE_AGES = 'etoa'
  integer TREE_ETERNITY = 122  // Cannot be constants for VS AI support
  constant integer oTREE_ETERNITY = 'etoe'
  integer TREE_LIFE = 123  // Cannot be constants for VS AI support
  constant integer oTREE_LIFE = 'etol'
  integer ANCIENT_PROTECT = 124  // Cannot be constants for VS AI support
  constant integer oANCIENT_PROTECT = 'etrp'
  integer ELF_ALTAR = 125  // Cannot be constants for VS AI support
  constant integer oELF_ALTAR = 'eate'
  integer CHIMAERA_ROOST = 126  // Cannot be constants for VS AI support
  constant integer oCHIMAERA_ROOST = 'edos'
  integer HUNTERS_HALL = 127  // Cannot be constants for VS AI support
  constant integer oHUNTERS_HALL = 'edob'
  integer MOON_WELL = 128  // Cannot be constants for VS AI support
  constant integer oMOON_WELL = 'emow'
  integer ELF_MINE = 129  // Cannot be constants for VS AI support
  constant integer oELF_MINE = 'egol'
  integer UPG_ULTRAVISION = 130  // Cannot be constants for VS AI support
  constant integer oUPG_ULTRAVISION = 'Reuv'
  integer UPG_BLESSING = 131  // Cannot be constants for VS AI support
  constant integer oUPG_BLESSING = 'Renb'
  integer UPG_SCOUT = 132  // Cannot be constants for VS AI support
  constant integer oUPG_SCOUT = 'Resc'
  integer UPG_GLAIVE = 133  // Cannot be constants for VS AI support
  constant integer oUPG_GLAIVE = 'Remg'
  integer UPG_BOWS = 134  // Cannot be constants for VS AI support
  constant integer oUPG_BOWS = 'Reib'
  integer UPG_MARKSMAN = 135  // Cannot be constants for VS AI support
  constant integer oUPG_MARKSMAN = 'Remk'
  integer UPG_ABOLISH = 136  // Cannot be constants for VS AI support
  constant integer oUPG_ABOLISH = 'Resi'
  integer UPG_CHIM_ACID = 137  // Cannot be constants for VS AI support
  constant integer oUPG_CHIM_ACID = 'Recb'
  integer UPG_HIPPO_TAME = 138  // Cannot be constants for VS AI support
  constant integer oUPG_HIPPO_TAME = 'Reht'
  integer UPG_BOLT = 139  // Cannot be constants for VS AI support
  constant integer oUPG_BOLT = 'Repb'
  integer UPG_MARK_CLAW = 140  // Cannot be constants for VS AI support
  constant integer oUPG_MARK_CLAW = 'Reeb'
  integer UPG_MARK_TALON = 141  // Cannot be constants for VS AI support
  constant integer oUPG_MARK_TALON = 'Reec'
  integer UPG_MELEE = 142  // Cannot be constants for VS AI support
  constant integer oUPG_MELEE = 'Rhme'
  integer UPG_RANGED = 143  // Cannot be constants for VS AI support
  constant integer oUPG_RANGED = 'Rhra'
  integer UPG_ARMOR = 144  // Cannot be constants for VS AI support
  constant integer oUPG_ARMOR = 'Rhar'
  integer UPG_LEATHER = 145  // Cannot be constants for VS AI support
  constant integer oUPG_LEATHER = 'Rhla'
  integer UPG_MASONRY = 146  // Cannot be constants for VS AI support
  constant integer oUPG_MASONRY = 'Rhac'
  integer UPG_WOOD = 147  // Cannot be constants for VS AI support
  constant integer oUPG_WOOD = 'Rhlh'
  integer UPG_PRAYING = 148  // Cannot be constants for VS AI support
  constant integer oUPG_PRAYING = 'Rhpt'
  integer UPG_SORCERY = 149  // Cannot be constants for VS AI support
  constant integer oUPG_SORCERY = 'Rhst'
  integer UPG_ORC_MELEE = 150  // Cannot be constants for VS AI support
  constant integer oUPG_ORC_MELEE = 'Rome'
  integer UPG_ORC_RANGED = 151  // Cannot be constants for VS AI support
  constant integer oUPG_ORC_RANGED = 'Rora'
  integer UPG_ORC_ARMOR = 152  // Cannot be constants for VS AI support
  constant integer oUPG_ORC_ARMOR = 'Roar'
  integer UPG_ORC_SPIKES = 153  // Cannot be constants for VS AI support
  constant integer oUPG_ORC_SPIKES = 'Rosp'
  integer UPG_ORC_DOCS = 154  // Cannot be constants for VS AI support
  constant integer oUPG_ORC_DOCS = 'Rowd'
  integer UPG_ORC_SHAMAN = 155  // Cannot be constants for VS AI support
  constant integer oUPG_ORC_SHAMAN = 'Rost'
  integer UPG_UNHOLY_STR = 156  // Cannot be constants for VS AI support
  constant integer oUPG_UNHOLY_STR = 'Rume'
  integer UPG_CR_ATTACK = 157  // Cannot be constants for VS AI support
  constant integer oUPG_CR_ATTACK = 'Rura'
  integer UPG_UNHOLY_ARMOR = 158  // Cannot be constants for VS AI support
  constant integer oUPG_UNHOLY_ARMOR = 'Ruar'
  integer UPG_CR_ARMOR = 159  // Cannot be constants for VS AI support
  constant integer oUPG_CR_ARMOR = 'Rucr'
  integer UPG_NECROS = 160  // Cannot be constants for VS AI support
  constant integer oUPG_NECROS = 'Rune'
  integer UPG_BANSHEE = 161  // Cannot be constants for VS AI support
  constant integer oUPG_BANSHEE = 'Ruba'
  integer UPG_STR_MOON = 162  // Cannot be constants for VS AI support
  constant integer oUPG_STR_MOON = 'Resm'
  integer UPG_STR_WILD = 163  // Cannot be constants for VS AI support
  constant integer oUPG_STR_WILD = 'Resw'
  integer UPG_MOON_ARMOR = 164  // Cannot be constants for VS AI support
  constant integer oUPG_MOON_ARMOR = 'Rema'
  integer UPG_HIDES = 165  // Cannot be constants for VS AI support
  constant integer oUPG_HIDES = 'Rerh'
  integer UPG_DRUID_TALON = 166  // Cannot be constants for VS AI support
  constant integer oUPG_DRUID_TALON = 'Redt'
  integer UPG_DRUID_CLAW = 167  // Cannot be constants for VS AI support
  constant integer oUPG_DRUID_CLAW = 'Redc'
  integer HEALING_POTION = 168  // Cannot be constants for VS AI support
  constant integer oHEALING_POTION = 'phea'
  integer MANA_POTION = 169  // Cannot be constants for VS AI support
  constant integer oMANA_POTION = 'pman'
  integer CIRCLET_OF_NOBILITY = 170  // Cannot be constants for VS AI support
  constant integer oCIRCLET_OF_NOBILITY = 'cnob'
  integer PERIAPT_OF_VITALITY = 171  // Cannot be constants for VS AI support
  constant integer oPERIAPT_OF_VITALITY = 'prvt'
  integer BOOTS_OF_SPEED = 172  // Cannot be constants for VS AI support
  constant integer oBOOTS_OF_SPEED = 'bspd'
  integer M_SCROLL_OF_HEALING = 173  // Cannot be constants for VS AI support
  constant integer oM_SCROLL_OF_HEALING = 'shea'
  integer SCROLL_OF_PROTECTION = 174  // Cannot be constants for VS AI support
  constant integer oSCROLL_OF_PROTECTION = 'spro'
  integer TOWN_PORTAL = 175  // Cannot be constants for VS AI support
  constant integer oTOWN_PORTAL = 'stwp'
  integer POTION_OF_INVISIBILITY = 176  // Cannot be constants for VS AI support
  constant integer oPOTION_OF_INVISIBILITY = 'pinv'
  integer POTION_OF_LESSER_INVULNERBILITY = 177  // Cannot be constants for VS AI support
  constant integer oPOTION_OF_LESSER_INVULNERBILITY = 'pnvl'
  integer SATYR_SHADOWDANCER = 178  // Cannot be constants for VS AI support
  constant integer oSATYR_SHADOWDANCER = 'nsts'
  integer FURBOLG_SHAMAN = 179  // Cannot be constants for VS AI support
  constant integer oFURBOLG_SHAMAN = 'nfrs'
  integer THUNDER_LIZARD = 180  // Cannot be constants for VS AI support
  constant integer oTHUNDER_LIZARD = 'nthl'
  integer CENTAUR_OUTRUNNER = 181  // Cannot be constants for VS AI support
  constant integer oCENTAUR_OUTRUNNER = 'ncen'
  integer HARPY_ROGUE = 182  // Cannot be constants for VS AI support
  constant integer oHARPY_ROGUE = 'nhrr'
  integer RAZORMANE_MEDICINE_MAN = 183  // Cannot be constants for VS AI support
  constant integer oRAZORMANE_MEDICINE_MAN = 'nrzm'
  integer HARPY_WINDWITCH = 184  // Cannot be constants for VS AI support
  constant integer oHARPY_WINDWITCH = 'nhrw'
  integer FEL_BEAST = 185  // Cannot be constants for VS AI support
  constant integer oFEL_BEAST = 'npfl'
  integer DRAENEI_DISCIPLE = 186  // Cannot be constants for VS AI support
  constant integer oDRAENEI_DISCIPLE = 'ndrm'
  integer VOIDWALKER = 187  // Cannot be constants for VS AI support
  constant integer oVOIDWALKER = 'nvdw'
  integer DRAENEI_DARKSLAYER = 188  // Cannot be constants for VS AI support
  constant integer oDRAENEI_DARKSLAYER = 'ndrd'
  integer ROGUE = 189  // Cannot be constants for VS AI support
  constant integer oROGUE = 'nrog'
  integer ASSASSIN = 190  // Cannot be constants for VS AI support
  constant integer oASSASSIN = 'nass'
  integer KOBOLD_GEOMANCER = 191  // Cannot be constants for VS AI support
  constant integer oKOBOLD_GEOMANCER = 'nkog'
  integer FOREST_TROLL_HIGH_PRIEST = 192  // Cannot be constants for VS AI support
  constant integer oFOREST_TROLL_HIGH_PRIEST = 'nfsh'
  integer BURNING_ARCHER = 193  // Cannot be constants for VS AI support
  constant integer oBURNING_ARCHER = 'nskf'
  integer WILDKIN = 194  // Cannot be constants for VS AI support
  constant integer oWILDKIN = 'nowb'
  integer MURLOC_FLESHEATER = 195  // Cannot be constants for VS AI support
  constant integer oMURLOC_FLESHEATER = 'nmfs'
  integer SLUDGE_FLINGER = 196  // Cannot be constants for VS AI support
  constant integer oSLUDGE_FLINGER = 'nslf'
  integer SATYR_SOULSTEALER = 197  // Cannot be constants for VS AI support
  constant integer oSATYR_SOULSTEALER = 'nstl'
  integer BARBED_ARACHNATHID = 198  // Cannot be constants for VS AI support
  constant integer oBARBED_ARACHNATHID = 'nanm'
  integer BLUE_DRAGONSPAWN_MEDDLER = 199  // Cannot be constants for VS AI support
  constant integer oBLUE_DRAGONSPAWN_MEDDLER = 'nbdm'
  integer MAGNATAUR_WARRIOR = 200  // Cannot be constants for VS AI support
  constant integer oMAGNATAUR_WARRIOR = 'nmgw'
  integer POLAR_FURBOLG_SHAMAN = 201  // Cannot be constants for VS AI support
  constant integer oPOLAR_FURBOLG_SHAMAN = 'nfps'
  integer GNOLL_BRUTE = 202  // Cannot be constants for VS AI support
  constant integer oGNOLL_BRUTE = 'ngnb'
  integer GNOLL_WARDEN = 203  // Cannot be constants for VS AI support
  constant integer oGNOLL_WARDEN = 'ngnw'
  integer OGRE_MAGI = 204  // Cannot be constants for VS AI support
  constant integer oOGRE_MAGI = 'nomg'
  integer MUD_GOLEM = 205  // Cannot be constants for VS AI support
  constant integer oMUD_GOLEM = 'ngrk'
  integer FOREST_TROLL_BERSERKER = 206  // Cannot be constants for VS AI support
  constant integer oFOREST_TROLL_BERSERKER = 'nftb'
  integer FOREST_TROLL_SHADOW_PRIEST = 207  // Cannot be constants for VS AI support
  constant integer oFOREST_TROLL_SHADOW_PRIEST = 'nfsp'
  integer OGRE_MAULER = 208  // Cannot be constants for VS AI support
  constant integer oOGRE_MAULER = 'nogm'
  integer GNOLL_OVERSEER = 209  // Cannot be constants for VS AI support
  constant integer oGNOLL_OVERSEER = 'ngnv'
  integer ICE_TROLL_BERSERKER = 210  // Cannot be constants for VS AI support
  constant integer oICE_TROLL_BERSERKER = 'nits'
  integer ICE_TROLL_TRAPPER = 211  // Cannot be constants for VS AI support
  constant integer oICE_TROLL_TRAPPER = 'nitt'
  integer NERUBIAN_WARRIOR = 212  // Cannot be constants for VS AI support
  constant integer oNERUBIAN_WARRIOR = 'nnwa'
  integer FROST_REVENANT = 213  // Cannot be constants for VS AI support
  constant integer oFROST_REVENANT = 'nrvs'
  integer NERUBIAN_WEBSPINNER = 214  // Cannot be constants for VS AI support
  constant integer oNERUBIAN_WEBSPINNER = 'nnwl'
  integer MURGUL_SNARECASTER = 215  // Cannot be constants for VS AI support
  constant integer oMURGUL_SNARECASTER = 'nmsn'
  integer MAKRURA_SNAPPER = 216  // Cannot be constants for VS AI support
  constant integer oMAKRURA_SNAPPER = 'nlsn'
  integer MAKRURA_DEEPSEER = 217  // Cannot be constants for VS AI support
  constant integer oMAKRURA_DEEPSEER = 'nlds'
  integer GIANT_SEA_TURTLE = 218  // Cannot be constants for VS AI support
  constant integer oGIANT_SEA_TURTLE = 'ntrt'
  integer KOBOLD = 219  // Cannot be constants for VS AI support
  constant integer oKOBOLD = 'nkob'
  integer MURLOC_HUNTSMAN = 220  // Cannot be constants for VS AI support
  constant integer oMURLOC_HUNTSMAN = 'nmrr'
  integer BLACK_DRAGON_1 = 221  // Cannot be constants for VS AI support
  constant integer oBLACK_DRAGON_1 = 'nbdr'
  integer BLACK_DRAGON_2 = 222  // Cannot be constants for VS AI support
  constant integer oBLACK_DRAGON_2 = 'nbdk'
  integer BLACK_DRAGON_3 = 223  // Cannot be constants for VS AI support
  constant integer oBLACK_DRAGON_3 = 'nbwm'
  integer BLUE_DRAGON_1 = 224  // Cannot be constants for VS AI support
  constant integer oBLUE_DRAGON_1 = 'nadw'
  integer BLUE_DRAGON_2 = 225  // Cannot be constants for VS AI support
  constant integer oBLUE_DRAGON_2 = 'nadk'
  integer BLUE_DRAGON_3 = 226  // Cannot be constants for VS AI support
  constant integer oBLUE_DRAGON_3 = 'nadr'
  integer BRONZE_DRAGON_1 = 227  // Cannot be constants for VS AI support
  constant integer oBRONZE_DRAGON_1 = 'nbzw'
  integer BRONZE_DRAGON_2 = 228  // Cannot be constants for VS AI support
  constant integer oBRONZE_DRAGON_2 = 'nbzk'
  integer BRONZE_DRAGON_3 = 229  // Cannot be constants for VS AI support
  constant integer oBRONZE_DRAGON_3 = 'nbzd'
  integer GREEN_DRAGON_1 = 230  // Cannot be constants for VS AI support
  constant integer oGREEN_DRAGON_1 = 'ngrw'
  integer GREEN_DRAGON_2 = 231  // Cannot be constants for VS AI support
  constant integer oGREEN_DRAGON_2 = 'ngdk'
  integer GREEN_DRAGON_3 = 232  // Cannot be constants for VS AI support
  constant integer oGREEN_DRAGON_3 = 'ngrd'
  integer NETHER_DRAGON_1 = 233  // Cannot be constants for VS AI support
  constant integer oNETHER_DRAGON_1 = 'nnht'
  integer NETHER_DRAGON_2 = 234  // Cannot be constants for VS AI support
  constant integer oNETHER_DRAGON_2 = 'nndk'
  integer NETHER_DRAGON_3 = 235  // Cannot be constants for VS AI support
  constant integer oNETHER_DRAGON_3 = 'nndr'
  integer RED_DRAGON_1 = 236  // Cannot be constants for VS AI support
  constant integer oRED_DRAGON_1 = 'nrdk'
  integer RED_DRAGON_2 = 237  // Cannot be constants for VS AI support
  constant integer oRED_DRAGON_2 = 'nrdr'
  integer RED_DRAGON_3 = 238  // Cannot be constants for VS AI support
  constant integer oRED_DRAGON_3 = 'nrwm'
  integer ZEPPELIN = 239  // Cannot be constants for VS AI support
  constant integer oZEPPELIN = 'nzep'
  integer SAPPER = 240  // Cannot be constants for VS AI support
  constant integer oSAPPER = 'ngsp'
  integer SHREDDER = 241  // Cannot be constants for VS AI support
  constant integer oSHREDDER = 'ngir'
  integer GOLD_MINE = 242  // Cannot be constants for VS AI support
  constant integer oGOLD_MINE = 'ngol'
  integer JAINA = 243  // Cannot be constants for VS AI support
  constant integer oJAINA = 'Hjai'
  integer MURADIN = 244  // Cannot be constants for VS AI support
  constant integer oMURADIN = 'Hmbr'
  integer CHURCH = 245  // Cannot be constants for VS AI support
  constant integer oCHURCH = 'htws'
  integer MAGE_TOWER = 246  // Cannot be constants for VS AI support
  constant integer oMAGE_TOWER = 'htws'
  integer GROM = 247  // Cannot be constants for VS AI support
  constant integer oGROM = 'Ogrh'
  integer THRALL = 248  // Cannot be constants for VS AI support
  constant integer oTHRALL = 'Othr'
  integer PIG_FARM = 249  // Cannot be constants for VS AI support
  constant integer oPIG_FARM = 'npgf'
  integer CHAOS_GRUNT = 250  // Cannot be constants for VS AI support
  constant integer oCHAOS_GRUNT = 'nchg'
  integer CHAOS_WARLOCK = 251  // Cannot be constants for VS AI support
  constant integer oCHAOS_WARLOCK = 'nchw'
  integer CHAOS_RAIDER = 252  // Cannot be constants for VS AI support
  constant integer oCHAOS_RAIDER = 'nchr'
  integer CHAOS_PEON = 253  // Cannot be constants for VS AI support
  constant integer oCHAOS_PEON = 'ncpn'
  integer CHAOS_KODO = 254  // Cannot be constants for VS AI support
  constant integer oCHAOS_KODO = 'nckb'
  integer CHAOS_GROM = 255  // Cannot be constants for VS AI support
  constant integer oCHAOS_GROM = 'Opgh'
  integer CHAOS_BLADEMASTER = 256  // Cannot be constants for VS AI support
  constant integer oCHAOS_BLADEMASTER = 'Nbbc'
  integer CHAOS_BURROW = 257  // Cannot be constants for VS AI support
  constant integer oCHAOS_BURROW = 'ocbw'
  integer MALGANIS = 258  // Cannot be constants for VS AI support
  constant integer oMALGANIS = 'Umal'
  integer TICHONDRIUS  = 259  // Cannot be constants for VS AI support
  constant integer oTICHONDRIUS  = 'Utic'
  integer PIT_LORD = 260  // Cannot be constants for VS AI support
  constant integer oPIT_LORD = 'Npld'
  integer SYLVANUS = 261  // Cannot be constants for VS AI support
  constant integer oSYLVANUS = 'Hvwd'
  integer CENARIUS = 262  // Cannot be constants for VS AI support
  constant integer oCENARIUS = 'Ecen'
  integer ILLIDAN = 263  // Cannot be constants for VS AI support
  constant integer oILLIDAN = 'Eevi'
  integer ILLIDAN_DEMON = 264  // Cannot be constants for VS AI support
  constant integer oILLIDAN_DEMON = 'Eevm'
  integer MAIEV = 265  // Cannot be constants for VS AI support
  constant integer oMAIEV = 'Ewrd'
  integer HIGH_ARCHER  = 266  // Cannot be constants for VS AI support
  constant integer oHIGH_ARCHER  = 'nhea'
  integer HIGH_FOOTMAN = 267  // Cannot be constants for VS AI support
  constant integer oHIGH_FOOTMAN = 'hcth'
  integer HIGH_FOOTMEN = 268  // Cannot be constants for VS AI support
  constant integer oHIGH_FOOTMEN = 'hcth'
  integer HIGH_SWORDMAN = 269  // Cannot be constants for VS AI support
  constant integer oHIGH_SWORDMAN = 'hhes'
  integer DRAGON_HAWK = 270  // Cannot be constants for VS AI support
  constant integer oDRAGON_HAWK = 'nws1'
  integer CORRUPT_TREANT = 271  // Cannot be constants for VS AI support
  constant integer oCORRUPT_TREANT = 'nenc'
  integer POISON_TREANT = 272  // Cannot be constants for VS AI support
  constant integer oPOISON_TREANT = 'nenp'
  integer PLAGUE_TREANT = 273  // Cannot be constants for VS AI support
  constant integer oPLAGUE_TREANT = 'nepl'
  integer SHANDRIS = 274  // Cannot be constants for VS AI support
  constant integer oSHANDRIS = 'eshd'
  integer ELF_FARM = 275  // Cannot be constants for VS AI support
  constant integer oELF_FARM = 'nefm'
  integer ELF_GUARD_TOWER = 276  // Cannot be constants for VS AI support
  constant integer oELF_GUARD_TOWER = 'negt'
  integer HIGH_SKY = 277  // Cannot be constants for VS AI support
  constant integer oHIGH_SKY = 'negm'
  integer HIGH_EARTH = 278  // Cannot be constants for VS AI support
  constant integer oHIGH_EARTH = 'negf'
  integer HIGH_TOWER = 279  // Cannot be constants for VS AI support
  constant integer oHIGH_TOWER = 'negt'
  integer ELF_HIGH_BARRACKS = 280  // Cannot be constants for VS AI support
  constant integer oELF_HIGH_BARRACKS = 'nheb'
  integer CORRUPT_LIFE = 281  // Cannot be constants for VS AI support
  constant integer oCORRUPT_LIFE = 'nctl'
  integer CORRUPT_WELL = 282  // Cannot be constants for VS AI support
  constant integer oCORRUPT_WELL = 'ncmw'
  integer CORRUPT_PROTECTOR = 283  // Cannot be constants for VS AI support
  constant integer oCORRUPT_PROTECTOR = 'ncap'
  integer CORRUPT_WAR = 284  // Cannot be constants for VS AI support
  constant integer oCORRUPT_WAR = 'ncaw'
  integer UPG_ORC_CHAOS = 285  // Cannot be constants for VS AI support
  constant integer oUPG_ORC_CHAOS = 'Roch'
  constant integer OBJECT_NUM = 285
  integer FOOTMEN = FOOTMAN
  integer oFOOTMEN = oFOOTMAN
  integer RIFLEMEN = RIFLEMAN
  integer oRIFLEMEN = oRIFLEMAN
  integer TANK = STEAM_TANK
  integer oTANK = oSTEAM_TANK
  integer GYRO = COPTER
  integer oGYRO = oCOPTER
  integer PIT_FIEND = CRYPT_FIEND
  integer oPIT_FIEND = oCRYPT_FIEND
  integer ORC_DRAGON = RED_DRAGON_3
  integer oORC_DRAGON = oRED_DRAGON_3
  integer ZEPPLIN = ZEPPELIN
  integer oZEPPLIN = oZEPPELIN
  integer MOON_CHICK = MOON_PRIESTESS
  integer oMOON_CHICK = oMOON_PRIESTESS
  integer MOON_BABE = MOON_PRIESTESS
  integer oMOON_BABE = oMOON_PRIESTESS
  integer MOON_HONEY = MOON_PRIESTESS
  integer oMOON_HONEY = oMOON_PRIESTESS

  constant integer AVATAR = 'AHav'
  constant integer BASH = 'AHbh'
  constant integer THUNDER_BOLT = 'AHtb'
  constant integer THUNDER_CLAP = 'AHtc'
  constant integer DEVOTION_AURA = 'AHad'
  constant integer DIVINE_SHIELD = 'AHds'
  constant integer HOLY_BOLT = 'AHhb'
  constant integer RESURRECTION = 'AHre'
  constant integer BLIZZARD = 'AHbz'
  constant integer BRILLIANCE_AURA = 'AHab'
  constant integer MASS_TELEPORT = 'AHmt'
  constant integer WATER_ELEMENTAL = 'AHwe'
  constant integer CRITICAL_STRIKE = 'AOcr'
  constant integer MIRROR_IMAGE = 'AOmi'
  constant integer BLADE_STORM = 'AOww'
  constant integer WIND_WALK = 'AOwk'
  constant integer CHAIN_LIGHTNING = 'AOcl'
  constant integer EARTHQUAKE = 'AOeq'
  constant integer FAR_SIGHT = 'AOfs'
  constant integer SPIRIT_WOLF = 'AOsf'
  constant integer ENDURANCE_AURA = 'AOae'
  constant integer ENDURANE_AURA = 'AOae'
  constant integer REINCARNATION = 'AOre'
  constant integer SHOCKWAVE = 'AOsh'
  constant integer WAR_STOMP = 'AOws'
  constant integer SLEEP = 'AUsl'
  constant integer VAMP_AURA = 'AUav'
  constant integer CARRION_SWARM = 'AUcs'
  constant integer INFERNO = 'AUin'
  constant integer DARK_RITUAL = 'AUdr'
  constant integer DEATH_DECAY = 'AUdd'
  constant integer FROST_ARMOR = 'AUfu'
  constant integer FROST_NOVA = 'AUfn'
  constant integer ANIM_DEAD = 'AUan'
  constant integer DEATH_COIL = 'AUdc'
  constant integer DEATH_PACT = 'AUdp'
  constant integer UNHOLY_AURA = 'AUau'
  constant integer FORCE_NATURE = 'AEfn'
  constant integer ENT_ROOTS = 'AEer'
  constant integer THORNS_AURA = 'AEah'
  constant integer TRANQUILITY = 'AEtq'
  constant integer EVASION = 'AEev'
  constant integer IMMOLATION = 'AEim'
  constant integer MANA_BURN = 'AEmb'
  constant integer METAMORPHOSIS = 'AEme'
  constant integer SEARING_ARROWS = 'AHfa'
  constant integer SCOUT = 'AEst'
  constant integer STARFALL = 'AEsf'
  constant integer TRUESHOT = 'AEar'


    constant integer BUILD_ITEM         = 4
    
    constant integer BLOC_STD = 1
    constant integer BLOC_FRONT = 2
    constant integer BLOC_MINE = 3

    constant integer NOT_ENOUGH_RES = 1
    constant integer CANNOT_BUILD = 2
    constant integer BUILT_ALL = 3
    constant integer BUILT_SOME = 4

    constant integer SR_RANDOM = 0
    constant integer SR_ELF = 1
    constant integer SR_HUMAN = 2
    constant integer SR_ORC = 3
    constant integer SR_UNDEAD = 4

    constant integer R_RANDOM = 0
    constant integer R_ELF = 1
    constant integer R_HUMAN = 2
    constant integer R_ORC = 3
    constant integer R_UNDEAD = 4
    constant integer R_NEUTRAL = 5
    constant integer RACE_NUMBER = 4

    constant integer HERO_LEVEL_NUMBER = 10


    constant integer BUY_NEUTRAL = 0
    constant integer BUY_NEUTRAL_HERO = 1
    constant integer UPDATE_STRENGTH = 2
    constant integer DETECT_DEFEAT = 3
    constant integer DETECT_DOUBLE_EXP = 4
    constant integer HARVEST_CHECK = 5
    constant integer MICRO_UNITS = 6
    constant integer MILITIA_CHECK = 7
    constant integer TOWER_RUSH = 8
    constant integer FOCUSFIRE_CONTROL = 9
    constant integer FAST_BUILD = 10
    constant integer MILITIA_EXPAND = 11
    constant integer BUILD_EXPANSION = 12
    constant integer RALLY_POINT = 13
    constant integer ANCIENT_EXPANSION = 14
    constant integer HARASS = 15
    constant integer RETREAT_CONTROL = 16
    constant integer MICRO_HERO = 17
    constant integer ARMY_TRACK = 18
    constant integer CHAT_QUEUE = 19
    constant integer TOWER_RUSH_CHECK = 20
    constant integer ANCIENT_EXPANSION_CHECK = 21
    constant integer ITEM_EXPANSION_CHECK = 22
    constant integer REPAIR_CONTROL = 23
    constant integer RESET_HEALTH = 24
    constant integer ZEPPELIN_MOVE = 25
    constant integer TELEPORT = 26
    constant integer TOWN_TRACK = 27
    constant integer CHAT_VARS = 28
    constant integer REVEAL_ENEMY = 29
    constant integer TIMED_CHAT = 30
    constant integer CLEANUP_BLOCKS = 31
    constant integer NEUTRAL_GUARDED = 32
    constant integer RESET_WINDWALKER = 33
    constant integer SELL_ZIGGURATS = 34
    constant integer EXCHANGE = 35
    constant integer ZEPPELIN_FOLLOW = 36
    constant integer RESET_GUARD_POSITION = 37
    constant integer ITEM_REPEAT_CHECK = 38
    constant integer RESET_GUARD_POSITION_ONLY = 39
    constant integer BUY_ITEM = 40
    constant integer HEALTH_FOUNTAIN = 41
    constant integer MANA_FOUNTAIN = 42
    constant integer NEUTRAL_ENEMY_CHECK = 43
    constant integer MOON_WELL_CONTROL = 44
    constant integer SEND_HOME = 45
    constant integer ITEM_EXPANSION = 46
    
    constant integer STRATEGY_TYPE_MELEE = 0
    constant integer STRATEGY_TYPE_RANGED = 1
    constant integer STRATEGY_TYPE_AIR = 2
    constant integer STRATEGY_TYPE_CASTER = 3
    
    constant integer NEUTRAL_TAVERN = 0
    constant integer NEUTRAL_OBSERVATORY = 1
    constant integer NEUTRAL_MERC_CAMP = 2
    constant integer NEUTRAL_DRAGON_ROOST = 3
    constant integer NEUTRAL_HEALING_FOUNTAIN = 4
    constant integer NEUTRAL_MERCHANT = 5
    constant integer NEUTRAL_MANA_FOUNTAIN = 6
    constant integer NEUTRAL_SHIPYARD = 7
    constant integer NEUTRAL_MARKETPLACE = 8
    constant integer NEUTRAL_POWER_FOUNTAIN = 9
    constant integer NEUTRAL_HEAL_WARD = 10
    constant integer NEUTRAL_COUNT = 11
    
    constant integer UPKEEP_UNDECIDED = 0
    constant integer UPKEEP_NOT_ALLOWED = 1
    constant integer UPKEEP_ALLOWED = 2

    constant integer UPKEEP_LOW = 0
    constant integer UPKEEP_HIGH = 1
    constant integer UPKEEP_NUM = 2
    
    constant integer HEALER_TYPE_NO_TARGET = 0
    constant integer HEALER_TYPE_SUDDEN = 1
    constant integer HEALER_TYPE_CONTINUOUS = 2
    constant integer HEALER_TYPE_WARD = 3
    constant integer HEALER_TYPE_HERO = 4

    constant integer UPGRADED = 9999
    
    constant integer BT_UNIT = 0
    constant integer BT_BUILDING = 1
    constant integer BT_HERO = 2
    constant integer BT_UPGRADE = 3
    constant integer BT_ML_UPGRADE = 4
    constant integer BT_RACIAL_ITEM = 5
    constant integer BT_NEUTRAL_HERO = 6
    constant integer BT_MERC = 7
    constant integer BT_GOBLIN_MERC = 8
    constant integer BT_DRAGON = 9
    constant integer BT_MERCHANT_ITEM = 10
    
    constant integer COMPARE_TRUE = 0
    constant integer COMPARE_EQ = 1
    constant integer COMPARE_UNEQ = 2
    constant integer COMPARE_GREATER = 3
    constant integer COMPARE_GREATER_EQ = 4
    constant integer COMPARE_LESS = 5
    constant integer COMPARE_LESS_EQ = 6
	
	constant integer HEALINGITEM_MASS = 0
	constant integer HEALINGITEM_SINGLE = 1
	constant integer MERCHANTITEM_MASS = 2	
	constant integer GLOBALHEALING = 3
	constant integer HEALINGITEM_HERO = 4
	constant integer MANAITEM_HERO = 5
	constant integer ITEMTYPE_SUDDEN = 0
	constant integer ITEMTYPE_CONTINUOUS = 1
	
	constant integer HERO_SKILL_MAJOR = 0
	constant integer HERO_SKILL_MINOR = 1
	constant integer HERO_SKILL_RARE = 2

    real sleep_multiplier = 1  // increases performance by checking stuff not so often
    integer slm_start = 4  // how many computer players is needed tor the sleep multiplier to start increasing
    integer slm_end = 10 // how many computer players is needed tor the sleep multiplier to stop increasing
    real slm_start_mult = 1 // how much is the sleep multiplied when its below the slm_start codition
    real slm_end_mult = 2  // how much is the sleep multiplied when its above the slm_end codition
    real hero_radius = 200  // scanning this small area around hero to detect if the hero gets surrounded by enemy or is in danger of becoming that so it should move
    boolean use_linear_upkeep_saving = false  // should the computers save the upkeep threshold gold over the time above or save it all at once when it get's to the upkeep border?
    integer repair_threshold = 6  // computers only repair buildings if they have more than this many workers
    integer repair_threshold_threatened = 8 // computers only repair buildings when the town is under attack if they got more than this many workers
    real max_follow_dist = 1000  // Max Distance behind the army a zeppelin follows
    integer neutral_hero_time = 25  // when is neutral heroes available in seconds /5
    real buy_timeout_large = 120  // time in seconds the hero goes to a shop before it gives up if it haven't reached it
    real buy_timeout_small = 15  // time in seconds a hero tries to buy items at shop before giving up      
    real buy_distance = 350  // how close to a shop does a unit have to be for buying?
    integer build_array_reset_time = 100  // every this * 5 seconds, the build array is reset    
    integer rp_strat_normal = 250  // normalizing strategy priorities added from strengths with this value
    integer strategy_tier_bonus = 35  // the priority bonus added to a strategy if the computer is in the same tier as specified for the strategy
    integer attacking_strategy = 4       // strategy when attacking enemy players
    real focus_fire_limit = 35	// if a enemy heros hp fall below the computers combined strength of ranged attackers in a battle * this, they will focus fire on the hero
    real focus_fire_ranged_dist = 600 // Distance from ranged units enemy units can be targeted with focus fire
    real focus_fire_melee_dist = 50 // Distance from melee units enemy units can be targeted with focus fire
    real flee_health_percentage = 0.25  // Units flee from battle if the health goes below his % value(0.25 = 25%)
    real flee_minimum_health = 100  // Units flee from battle if the health goes below this    
    real statue_distance = 300  // how near the units a statue used by undead should be in the fights
    real teleport_radius = 800  // units will stay within this radius from a hero that is using town portal  
    integer gold_exchange_level = 650  // computers give extra gold above this value to other computers on the same team in need of gold
    integer wood_exchange_level = 350  // computers give extra lumber above this value to other computers on the same team in need of lumber
    integer max_towns = 5  // how many towns is a computer allowed to have?   
    boolean add_tag = true // Add the [AMAI] tag in front of name
    boolean add_skill = true // Add the current skill after the name    
    integer fav_hero_add = 20  // priority added to heroes to be picked if they are favorites of the used profile       
    integer max_harass_groups = 10  // how many different harass groups you can use    
    integer attacking_aggression = -12  // the base agression value for all computers, higher value and they will play more agressive. Recomended -5 to 5   
    real expansion_radius = 650  // the radius araound a mine computers check for creeps before expanding there
    real harass_radius_attack_ranged = 800  // how far away from ranged enemy units harassing units attack a inferior enemy unit
    real harass_radius_attack_melee = 400  // how far away from melee enemy units harassing units attack a inferior enemy unit
    real harass_radius_flee_ranged = 1200  // how far away from ranged enemy units harassing units turn and flee
    real harass_radius_flee_melee = 800  // how far away from melee enemy units harassing units turn and flee  
    boolean chatting	= true  // set to false to turn off computer taunts and chatting (Can still talk in observer mode)
    real full_threat_distance = 600  // a enemy army within this distance is counted as a full threat
    real no_threat_distance = 3000  // a enemy army outside this distance is counted as no threat
    real distance_threat_exponent = 0.8  // how fast the threat increases as the enemy army gets from the no_threat_distance to the full_threat_distance
    real distance_threat_mult = 540  // how much the threat vlaue goes up on a town when a enemy army aproaches, higher value means higher threat to town
    real atl_time_start = 300  // accepted threat level increase starts at this time
    real atl_time_end = 900    // and ends at that time
    real atl_time_start_val = 10  // it starts with this value
    real atl_time_end_val = 20  // and ends with that value
    real atl_enemy_start = 1 // accepted threat level multiplier increases at that enemy number
    real atl_enemy_end = 4   // until that enemy number
    real atl_enemy_start_mult = 1  // the multiplier starts for accepted threat level starts with this
    real atl_enemy_end_mult = 1.5    // and ends with this    
    real teleport_low_threat = 40  // Army uses TP to get home and defend if a threat is greater than this
    real teleport_high_threat = 80  // Army uses TP to get home and defend if a threat is greater than this
    real teleport_low_threat_distance = 6000  // Army won't use TP home if they are closer to base than this and a low threat level appears
    real teleport_high_threat_distance = 3000  // Army won't use TP home if they are closer to base than this and a high threat level appears
    real teleport_army_min_strength = 20  // how big the army need to be for use of TP to threatened town
    real teleport_min_threat = 70  // minimum threat level TP use is allowed on  
    integer shredder_peon_count = 12  // how many peons does a goblin shredder replace in lumber harvesting
    integer minimum_peon_wood = 2000 // computers don't build any workers for lumber harvesting if they have more lumber than this
    integer maximum_peon_wood = 200  // computers build all needed workers for lumber harvesting if they have lumber lower than this  
                 

   boolean ver_neutral_heroes_available = true  // does the version have neutral heroes ?
   integer ver_neutral_hero_number = 0  // how many neutral heroes ?
   boolean ver_only_heroes_buy = false  // can only heroes buy stuff ?
   integer ver_food_limit = 100  // what is the food limit ?
   integer ver_strat_change_enemy_strength_min = 25  // don't allow strategy change unless the maximum strength of all enemy players in the game is above this.
   integer ver_hero_base_value = 4  // what is the base strength of a hero (the level number is added to get the actual strength) ?
   integer ver_hero_ultimate_level = 6  // at what level do the heroes get their ultimates ?
   integer ver_hero_ultimate_value = 4  // how much extra strength does the ultimate give to the hero ?
   real ver_creeps_attack_buildings_dist = 1000  // how far away do creeps attack buildings ?
   boolean ver_mercs_night_buy = false // can mercs be bought at night without waking up creeps ?
   real ver_tower_check_radius = 2000  // check for towers in this radius around a target
   real ver_harass_tower_check_radius = 1400  // check for towers in this radius during harassing
   integer ver_optimal_gold = 5  // The optimal number of peons that should be harvesting gold
   real ver_flee_multiple1 = 1  // Multiplier to players strength at lowest aggression to measure if amai is allowed to flee
   real ver_flee_multiple2 = 2  // Multiplier to players strength at highest aggression to measure if amai allowed to flee
   real ver_flee_multiple3 = 3  // Multipler to players strength at highest aggression to measure if amai will flee
   real ver_low_aggression = -15  // Aggression below this uses the lowest strength flee multiplier
   real ver_high_aggression = 45  // Agression above this uses the highest strength flee multiplier

   

   
    integer hero1_revive_prio = 200  // priority for reviving hero1
    integer hero2_revive_prio = 120  // priority for reviving hero2
    integer hero3_revive_prio = 80  // priority for reviving hero1
    integer prio_n_inc = 2  // priority increase for building needed buildings
    integer prio_t_inc = 1  // priority increase in time
    integer prio_q_inc = 2  // priority increase in quantity
    integer farm_food2 = 1 // builds another farm at the same time when this near food used to food produced
    integer farm_prio = 400 // priority for farm building
    integer peon_prio = 280 // priority for peon building
	integer ghoul_prio = 250  // priority for ghoul building
    integer expa_prio = 200 // priority for expansion building
    integer expa_emergency_prio = 300  // priority for rebuilding an expansion
    integer expa_rebuild_prio = 200 // priority for rebuilding an expansion
    integer peon_1_mine_number = 15 // maximum number of peons to build when 1 mine is owned (redundent if race uses ghouls)
    integer peon_2_mines_number = 20 // maximum number of peons to build when 2 mines are owned (redundent if race uses ghouls)
    integer peon_mines_number = 24  // maximum number of peons to build when more mines are owned (redundent if race uses ghouls)
    integer min_peon_number_single_mine = 6 // minimum number of peons when 1 mine is owned
    integer min_peon_number_multi_mine = 11 // minimum number of peons when more than 1 mine is owned
    integer strat_food_persistence = 2  // * current food use added to priority for current strategy (prevents computers from changing styrategy when having large army)
    integer relevant_strat_change_number = 3   // number of strategies with highest RPs that can be chosen when changing strategy
    integer kb_add1 = 8  // priority added to all strategies having a building the computer already got as a key building
    integer kb_add2 = 9  // priority added to all strategies having a building the computer already started to build as key building
    integer kb_add3 = 7  // priority added to all strategies having both building the computer already got as key buildings
    integer kb_add4 = 10 // value for 2 of a key buildings
    integer ku_add1 = 4  // priority added to all strategies having a upgrade the computer already got as key upgrade in first level
    integer ku_add2 = 7  // priority added to all strategies having a upgrade the computer already got as key upgrade in second level
    integer ku_add3 = 8  // priority added to all strategies having a upgrade the computer already got as key upgrade in third level
    integer fav_unit_add = 20  // priority added to strategies havign the current profiles favorite unit as key units.
    integer debug_strategy = -1  // this race is locked to this strategy number for testing.(-1 is unlocked) 
    boolean race_use_fountain = true  // does the race use healing fountains ?
    boolean race_manual_loading = true  // does the race need manual loading of wisps in goldmines ?
    integer race_manual_loading_wisp = 0 //
    integer race_manual_loading_mine = 0 //
    boolean race_towerrush_available = false  // does the race have a towerrush ?
    integer race_towerrush_requirement = 0  // what is the building required to build towers ?
    integer race_tower_id = 0  // what is the id of the races towers?
    integer race_tower_upgrade = 0  //what is the id of the tower upgrade ?
    integer race_towerrush_probability = 33 // how high (in percent) is the probability of doing a tower rush?
	integer race_towerrush_hero_rush_level = 2   // the bonus strength value hero must have to be able to do the tower rush
    boolean race_militia_expansion_available = false  // does the race have a militia expansion ?
    integer race_hero_number = 4  // how many racial heroes ?
    integer race_simple_melee = 0  // a basic melee unit, only necessary when basic_melee is used
    integer race_advanced_melee = 0  // an advanced melee unit to replace the basic one, only necessary when basic_melee is used
    boolean race_has_ghouls = false  // has the race a ghoul-like wood harvester/fighter unit ?
    boolean race_ghouls_attack = true  // do those ghouls go with the army on attacks ?
	integer race_min_ghouls = 2  // smallest number of ghouls to build at all times
	integer race_max_ghouls = 5  // maximum number of ghouls to build in low lumber situations
    boolean race_has_power_build = false  // can multiple racial workers work on the same building ?
    boolean race_no_wood_harvest = false  // has the race no wood harvesters ?
    boolean race_ignore_injured = false  // should the race leave injured units at home ?
    boolean race_uses_mine_expansion = false  // does the race expand with a mine building like undead ?
    boolean race_uses_shredder = true  // does the race use the goblin shredder ?
    boolean race_militia_available = false  // does the race have militia ?
    real race_militia_max_distance = 1000  // how far away from the town hall are the militia allowed ?
    integer race_militia_id = 'hmil'  // what is the militia unit type id?
    integer race_militia_ability = 'Amil'  // what is the militia ability id ?
    integer race_militia_hall_ability = 'Amic'  // what is the militia ability of the hall ?
    string race_militia_unitstring = "militia"  // what is the unitstring/name of the militia ?
    string race_militiaworker_unitstring = "peasant"  // what is the string of the unit that can be turned to militia ?
    boolean race_ancient_expansion_available = false  // can the race expand with an uprooted building that also helps fighting the creeps ?
    integer race_ancient_expansion_probability = 33  // how high (in percent) is the probability of doing an ancient expansion when possible ?
    integer race_ancient_expansion_strength = 15  // up to how much expansion strength is an ancient expansion allowed ?
    integer race_ancient_expansion_help_id = 'earc'  // the unit id of the unit that should help in ancient expansion
    integer race_ancient_expansion_hero_rush_level = 2  // the bonus strength value hero must have to be able to do the ancient expansion
    integer race_item_expansion_item_id = 0  // what is expand item name(from StandardUnits.txt) ?
    boolean race_item_expansion_available = false  // can expand with item building ?
    integer race_item_expansion_probability = 5 // how high (in percent) is the probability of doing a item expansion?
    integer race_item_sale_level = 0  // buy expand item need hall level ?
    boolean race_sell_ziggurats = false  // does the race sell ziggurats that are at no more needed expansions ?
    real race_ziggurat_keep_distance = 1500  // keep ziggurat if this near another building except a ziggurat is
    boolean race_build_farms_front = false  // should the race build farms towards the front (as soon as the front is computed) ?
    integer race_farms_front_limit = 4  // limit the number of farms at the front to this number
    integer race_farms_at_mine = 0  // the first that many farms will be built at the mine
    real race_max_expa_mine_distance = 850  // the maximum distance between the mine and the expansion building
    integer min_peon_number_double_mine = 11  // minimum number of peons when 2 mines are owned
    boolean race_has_moonwells = false  // Racial farms have healing properties
    integer groundid = 'ewsp'  // Used to create path units, must be different from race peon



    boolean destroy_buildings_on_defeat = true  // Should the buildings of the AI be destroyed on defeat or given to neutral player ?
    integer attack_reform_length = 20  // reform the attack group (getting new units) every that time on an attack (in seconds / 2)
    real front_base_distance = 1100  // the distance of the front locations from the start location
    boolean ver_heroes = true  // Does this version have heroes?
    boolean fixedcomputername = false  // Enable to force computers to have there fixed name instead of a profile name
    integer green_creep_camp_strength_bonus = 0  // Bonus strength added to minor creep camps
    integer orange_creep_camp_strength_bonus = 5  // Bonus strength added to mediocre creep camps
    integer red_creep_camp_strength_bonus = 10  // Bonus strength added to major creep camps
	boolean disable_surrender = false  // Set to true to stop amai from giving up early when it detects its going to lose
	real strategy_change_threshold = 1.2  // New strategy priority must be larger than this (default 1.20) multiple to the current strategy prority
    boolean debugging = false  // Can turn on for debugging mode to display debug type messages
    integer major_hero_skill_value = 60  // Priority to choose the first line of hero skills
    integer minor_hero_skill_value = 30  // Priority to choose the second line of hero skills
    integer rare_hero_skill_value = 10  // Priority to choose the third line of hero skills

	boolean IsAMAI = false
    boolean leadally = false
	
	boolean campaign_ai = false

    string language = "English"
    
    string ai_id = ""
    
    string message_add = ""
    
    real command_wait = 3
    
    real time_of_day = 0
    
    boolean water_map = false
    
    string array digit_map
    
    integer array player_race
    integer array player_race_pref
    string array race_name
    
    boolean game_is_ffa = false
    boolean game_is_1on1 = false


    integer total_food              = 0
    integer wood_buffer             = 0
    real    gold_income             = 0
    integer income_per_mine         = 3000
    real    gold_unit_percentage    = 0.9
    boolean take_all_ghouls_along = false


    integer racial_peon	= 0
    integer array racial_hall
    integer array racial_goldmine
    integer minearray = 0
    integer array racial_zigg
    integer ziggarray = 0
    integer racial_expansion = 0
    integer racial_altar = 0
    integer racial_shop = 0
    integer racial_militia = 0
    integer racial_militiahero = 0
    integer racial_ghoul = 0
    integer racial_lumber = 0
    integer racial_rushcreep = 0
    unit rushcreep_target = null
    integer neutral_shredder = 0
    integer neutral_zeppelin = 0
    integer tp_item = 0
    integer tiernum = 3
    integer mapSize = 0

    integer array hero
    integer array hero_skills // The skill line chosen for the hero, major, minor or rare
    integer array skills
    integer array tempskills
    integer array allskills
    integer first_choosable_hero = 0
    boolean array hero_built
    integer array hero_revive_prio
    unit array hero_unit
    integer array all_heroes
    integer array all_heroes_copy
    integer array hero_rp
    integer hero_number = 0
    integer chosen = 0
    
    real array action_points
    integer action_numbers = 0
    
    real enemy_density = 0
    location enemy_density_loc = Location(0,0)
    real ally_density = 0
    location ally_density_loc = Location(0,0)
    
    real nearest_enemy_range = 10000000
    player nearest_enemy = null
    player nearest_human_enemy = null
    
    integer array upkeep_allowed
    integer array last_upkeep_allowed
    integer array upkeep_border
    integer array upkeep_resistance
    integer array upkeep_save_time
    integer array upkeep_time
    integer array upkeep_mines_needed

    integer array attack_qty
    integer array attack_max
    integer array attack_units
    integer attack_length           = 0

	//==============================================================
    // (AMAI)  Build Variables
    //==============================================================
    integer array build_prio
    integer array build_loc

    integer array t_build_qty
    integer array t_build_type
    integer array t_build_item
    integer array t_build_town
    integer array t_build_prio
    integer array t_build_loc
    integer t_build_length            = 0

    integer array bl_req_qty
    integer array bl_req_type
    integer array bl_allow_qty
    integer array bl_allow_type
    integer array bl_expire_time
    boolean array bl_only_done
    integer bl_length = 0
    integer blocked_gold = 0
    integer blocked_wood = 0
    integer blocked_food = 0
    
    integer array rbl_req_gold
    integer array rbl_req_wood
    integer array rbl_req_food   // Food required before building unit
    integer array rbl_allow_qty
    integer array rbl_allow_type
    integer array rbl_expire_time
    integer rbl_length = 0

    boolean build_lock = true

	//==============================================================
    // (AMAI)  Standard Unit Variables
    //==============================================================
    integer array old_id
    integer array needed1  // needed building and factory if unit
    integer array needed2  // needed building 2
    integer array needed3  // needed for upgrade level 3
    integer array build_free // free buildings
    integer array gold_sum
    integer array build_time_sum
    integer array build_num
    real array income_percentage
    integer array prio_sum
    integer array tc_add1  // building that has to be added for TownCount
    integer array tc_add2  // building that has to be added for TownCount
    integer array available_time
    integer array regenerate_time
    integer array attacking_max_num
    integer array upgrade_time
    integer array gold_price
    integer array wood_price
    integer array hero_rush_bonus
    integer array buy_type
    
    integer array building
    integer building_length = 0

    integer array campaign_defenders

    integer array creep_strength
    integer creep_strength_length = 0

    unit follow_zeppelin = null
    boolean zeppelin_following = false

    boolean array neutral_available
    unit array nearest_neutral
    group array neutral_guards
    boolean array neutral_guarded
    integer array neutral_enemy
    boolean array neutral_ordered
    unit array neutral_sent
    boolean array neutral_night_buy
    integer array neutral_id
    real array buy_time_large
    real array buy_time_small
    integer array neutral_wanted
    boolean no_sleep = false
    integer array dragons
    integer array merc_unit
    integer merc_number = 0
    integer dragon_number = 0
    integer merc_healer = 0
    integer merc_caster = 0
    integer merc_melee = 0
    integer merc_range = 0
    integer merc_stopper = 0
    integer merc_rush = 0

    integer minimum_attack_strength = 11

    integer max_farms = 0

    integer exp_time_count = 0
    integer exp_first_time = 30
    integer exp_second_time = 180
    real expansion_taken_radius = 1000  // the radius around a mine where enemy or allied buildings are considered as possessing that mine (it is considered taken then)

    integer creep_camp_radius = 550
    integer camp_scan_depth = 3
    integer camp_last_checked = 40

    integer air_strength = 0
    integer array p_str_cache
    integer array p_str_cache_timeout
    integer p_str_cache_valid_time = 2

    boolean ai_no_creep = false
    boolean town_threat_break = true
    //boolean captain_flee = true

    integer strategy = 0
    integer chosen_strategy = 0
    integer last_strategy = 100
    string array strategy_name
    string array strategy_default_name
    string array strategy_default_report
    integer array key_building1
    integer array key_building2
    integer array key_upgrade1
    integer array key_upgrade2
    integer array key_unit
    integer array rp_strat
    integer array rp_strat_sort
    boolean array beginning_strat
    integer array strat_minimum_time
    integer rp_strat_length = 0
    integer rp_strat_sort_length = 0
    integer small_map_tier1_bonus = 20
    real k_add_start_mult = 3
    real k_add_end_mult = 1
    real k_add_start_time = 120
    real k_add_end_time = 1200
    boolean array strategy_type_used
    integer array strategy_type
    integer strategy_type_used_penalty = 30
    integer array strategy_tier
    integer array strategy_first_exp_time
    integer array strategy_second_exp_time
    integer array strategy_first_hero
    integer array strategy_first_hero_bonus
    integer array strategy_second_hero
    integer array strategy_second_hero_bonus
    integer array strategy_third_hero
    integer array strategy_third_hero_bonus
    integer array strategy_race_aggression

    boolean attacking_expansion = false
    boolean recalculate_heros = false // Tavern heros cannot be trained so get a normal hero

    integer tier = 0
    integer own_strength = 0
    integer uncertainty = 10
    integer tower_factor = 10
    integer array race_aggression
    integer array b_race_aggression
    integer added_aggression = 0  // aggression added when upkeep becomes higher
    boolean h_siege = false
    unit alli_target = null
    integer expansion_target_bonus = 7
    integer comp_chosen_target_bonus = 5
    real comp_chosen_target_rate = 0.5

    boolean balancing = false
    texttag debugstrattag = CreateTextTag()
    texttag debugcountertag = CreateTextTag()
    
    group healer_group = CreateGroup()
    boolean ward_cast = false

    group urgent_healing_group = CreateGroup()
    group medium_healing_group = CreateGroup()
    group small_healing_group = CreateGroup()
    integer urgent_healing_count = 0
    integer medium_healing_count = 0
    integer small_healing_count = 0
    boolean fountain_available = false

    unit item_unit = null

    integer array healer_id
    integer array healer_spell
    integer array healer_type
    integer array healer_mana_cost
    integer array healer_upg_id
    integer array healer_upg_level
    integer healer_length = 0

    integer array c_enemy  // number of enemy players of certain races or random
    integer c_enemy_total	= 0
    integer array c_ally  // number of allied players of certain races
    integer c_ally_total = 0
    integer c_enemy_user_total = 0  //number of enemy human player
    integer c_ally_user_total = 0  //number of ally human player
    integer c_ai_total = 0
    boolean enemy_revealed = false
    integer strat_prev = 0  // strategy chosen by the ai before this one
    integer hero_prev = 0  // hero chosen by the ai before this one
    integer picked_hero = 0
    boolean first_ai = true
    integer next_ai = 0
    boolean no_ai_ally = false
    boolean no_ally_ctrl = true

    boolean player_defeated	= false

    real enemy_air = 0
    real ally_air = 0
    real enemy_casters = 0
    real ally_casters = 0
    real enemy_towers = 0
    real ally_towers = 0
    real enemy_piercing = 0
    real ally_piercing = 0
    real enemy_normal = 0
    real ally_normal = 0
    real enemy_siege = 0
    real ally_siege = 0
    real enemy_magic = 0
    real ally_magic = 0
    real enemy_unarmored = 0
    real ally_unarmored = 0
    real enemy_lightarmor = 0
    real ally_lightarmor = 0
    real enemy_mediumarmor = 0
    real ally_mediumarmor = 0
    real enemy_heavyarmor = 0
    real ally_heavyarmor = 0


    boolean array town_built
    location array own_town_loc
    real array own_town_dist
    unit array own_town_mine
    integer first_town_mine = 0
    location array exist_town
    integer exist_town_num = 0

    integer attacking_ghouls = 0
    integer harvesting_ghouls = 0

    integer ai_time = 0

    integer tq_length = 0
    real array tq_time
    integer array tq_jid
    integer array tq_par
    unit array tq_unit_par
    group array tq_group_par
    boolean tq_lock = true
    timer tq_timer = CreateTimer()

    boolean attack_running = false
    boolean no_attack_allowed = false

    integer order_cancel = 851976
    integer order_attack = 851983

    sound chatSound = CreateSound( "Sound\\Interface\\InGameChatWhat1.wav", false, false, false, 10, 10, "" )
    sound importantSound = CreateSound( "Sound\\Interface\\CreepAggroWhat1.wav", false, false, false, 10, 10, "" )

    boolean array chat_target_obs
    boolean array chat_target_ally
    boolean array chat_target_enemy
    boolean array chat_important
    string array chat_list
    string array chat_list_race
    integer array chat_list_eq
    integer chat_list_length = 0
    string chat_race = ""
    integer chat_eq = 0
    string array chat_queue
    boolean array chat_queue_importance
    player array chat_queue_player
    string chat_strategy = null
    integer chat_queue_size = -1
    constant integer C_STRATEGY = 0

    string array chat_AGG
    integer chat_AGG_length = 0
    constant integer C_AGG = 1
    string array chat_Ally
    integer chat_Ally_length = 0
    constant integer C_Ally = 2
    string array chat_Attack
    integer chat_Attack_length = 0
    constant integer C_Attack = 3
    string array chat_Creep
    integer chat_Creep_length = 0
    constant integer C_Creep = 4
    string array chat_Done
    integer chat_Done_length = 0
    constant integer C_Done = 5
    string array chat_EGG
    integer chat_EGG_length = 0
    constant integer C_EGG = 6
    string array chat_Expansion
    integer chat_Expansion_length = 0
    constant integer C_Expansion = 7
    string array chat_Goldproblem
    integer chat_Goldproblem_length = 0
    constant integer C_Goldproblem = 8
    string array chat_Greet
    integer chat_Greet_length = 0
    constant integer C_Greet = 9
    string array chat_Mega
    integer chat_Mega_length = 0
    constant integer C_Mega = 10
    string array chat_Megatarget
    integer chat_Megatarget_length = 0
    constant integer C_Megatarget = 11
    string array chat_Taunt
    integer chat_Taunt_length = 0
    constant integer C_Taunt = 12
    string array chat_Thanks
    integer chat_Thanks_length = 0
    constant integer C_Thanks = 13

    string chat_no_unit_selected = ""
    string chat_confirm_attack_unit = ""
    string chat_towerrush = ""
    string chat_no_orc = ""
    string invalid_strategy_number = ""
    string chat_dynamic_counter = "and countering "
    string militia_expansion_chat = ""

    //gamecache translation_map = InitGameCache("AMAI_TM.w3v")
    hashtable translation_map = InitHashtable()
    string array translation
    integer translation_length = 0

    //gamecache additional_info = InitGameCache("AMAI_AI.w3v") // Used for harrass data
    //gamecache com = InitGameCache("AMAI_Com.w3v")
	hashtable additional_info = InitHashtable()
	constant integer START_STRENGTH = 0
	constant integer AVOID_TOWERS = 1
	constant integer STRENGTH_LIMIT = 2
	constant integer STATE_ATTACKING = 3
	constant integer FLEE_PERCENT = 4
	constant integer FLEE_NUMBER = 5
	constant integer INVISIBLE_COUNT = 6
	constant integer LOCX = 7
	constant integer LOCY = 8
	constant integer STATE_RETREAT = 9
	constant integer WINDWALK_COUNT = 10
	hashtable com = InitHashtable()
	constant integer PROFILE_USED = 0
	constant integer TEAM_STATEGY_INUSE = 1
	constant integer IS_AMAI = 2
	constant integer RACE = 3
	constant integer RACE_PREF = 4
	constant integer USE_SPECIAL_RACES = 5
  constant integer PROFILE_SELECTION = 6
  constant integer CHAT_LOCK = 7

  gamecache amaiCache = InitGameCache("AMAI_AI.w3v")

	//gamecache settings = InitGameCache("AMAI_Set.w3v")

    string array char_table
    string array char_bug_table
    integer char_table_length = 0
    hashtable language_table = InitHashtable()
    constant integer CHAR_TABLE = 0
    constant integer CHAT_VARS_TABLE = 1
    string array chat_vars
    integer chat_vars_length = 1
    //gamecache chat_vars_map = InitGameCache("AMAI_CVM.w3v")
	//hashtable chat_vars_map = InitHashtable()

  boolean i_locked_chat = false

    integer area_uncertainty = 10
    integer force_number = 0
    player array own_force
    player array ally_force
    player array enemy_force
    integer gold_problem_level = 0
    boolean ask_for_gold = false
    boolean desperation_assault = false
    integer SaveYourselfMode = -1
    player sharedRacePlayer = null
    boolean humanPlayerAllys = false
    unit double_expansion_target = null

  unit secondmine = null
    unit major_hero = null
    real battle_radius = 1500
    real normal_battle_radius = 1500  // units within that radius are considered belonging to the current battle
    real creep_battle_radius = 750  // same as with normal_battle_radius, but for battles against creeps
    boolean retreat_controlled = false
    location home_location = null
    real enemy_strength_sum = 0
    real ally_strength_sum = 0
    boolean isfleeing = false
    integer added_target_aggression = 0  // The current bonus aggression added to current attack specified in the profiles
    integer added_racial_aggression = 0  // The current bonus added to current attack based on which race amai is attacking

    location enemy_loc = Location(0,0)
    location last_enemy_loc = Location(0,0)
    location ally_loc = Location(0,0)
    location last_ally_loc = Location(0,0)
    unit shop_sent = null
    boolean shop_ordered = false
    real shop_buy_time_small = -1
    real shop_buy_time_large = -1
    integer shop_wanted = 0
    unit shop_unit = null
    real shop_distance_limit = 100000
    real raceshop_distance_limit = 100000
    real merchant_distance_limit = 5000
	boolean retreat_home = false
	boolean ismoving = false
	real buyX
	real buyY
	
	group going_home_group = CreateGroup()
	group buying_group = CreateGroup()
	
  constant integer ACTION_DO_NOTHING = 0
  constant integer ACTION_GO_HOME = 1
  constant integer ACTION_FOUNTAIN = 2
  constant integer ACTION_TP = 3
  constant integer ACTION_ZEPPELIN_HOME = 4
  constant integer ACTION_ZEPPELIN_FOUNTAIN = 5
  constant integer ACTION_HEALER = 6
  constant integer ACTION_MANA_FOUNTAIN = 7
  constant integer ACTION_MOONWELLS = 8

  location array hero_loc
  location array hero_dir
  real array hero_hp
  real array hero_hp_loss
  real array hero_enemy_density
  location array hero_enemy_loc
  real array hero_ally_density
  location array hero_ally_loc


    group unit_healing = CreateGroup()
    group unit_rescueing = CreateGroup()
    group unit_harassing = CreateGroup()
    group unit_zepplin_move = CreateGroup()
    group unit_buying_item = CreateGroup()
    group unit_buying_merc = CreateGroup()
    group unit_buying_tavern = CreateGroup()

    constant integer ZTARGET_HOME = 0
    constant integer ZTARGET_FOUNTAIN = 1
    constant integer ZTARGET_MOONWELLS = 2
    boolean zepdropping = false	// Currently ordering unit to exit zepplin
    boolean teleporting = false
    location teleportloc = Location(0,0)
    constant integer HARASS_TARGET_PEONS = 0
    constant integer HARASS_TARGET_EXPANSION = 1
    constant integer HARASS_TARGET_LOCATION = 2
    constant integer HARASS_TARGET_MAIN_HALL = 3
    integer array harass_time
    integer array harass_size
    integer distraction_group = 0
    integer array army_owner
    location array army_loc
    location array army_dir
    location array army_future
    real array army_strength
    group array army_group
    integer array army_count
    integer army_num = 0
    real army_radius = 1200
    real army_future_mult = 3
    group in_army_group = CreateGroup()
    integer main_army = -1
      
    boolean town_threatened = false
    integer array town_owner
    location array town_loc
    real array town_value
    real array town_threat
    group array town_group
    integer array town_count
    integer array town_threat_army
    boolean array town_can_tp
    integer most_threatened_town = -1
    integer most_threatened_enemy_town = -1
    integer town_num = 0
    real town_radius = 2500
    group in_town_group = CreateGroup()
    boolean militia_allowed = false
    boolean militia_check_enabled = true
    unit militia_hall = null
    boolean use_militia_only_on_bigger_threats = false

    boolean towerrush = false
    unit array builder
    location tower_target_loc = null
    real first_tower_point_x = 0
    real first_tower_point_y = 0
    real enemy_point_x = 0
    real enemy_point_y = 0
    integer towers_built = 0
    player rushedplayer = null
	location toweringplayerloc = null
    integer ancient_exp_state = 0
    integer ancient_exp_count = 0
    location ancient_exp_loc = null
    unit ancient_exp_wisp = null
    unit ancient_exp_unit = null
    group ancient_exp_group = CreateGroup()
    boolean ancient_attack_running = false
    boolean ancient_exp_nobuild = false

   boolean ancient_expanding = false
   integer OrderIdCancel = 851976
  group windwalk_group = CreateGroup()
  group focus_fire_group = CreateGroup()
  group micro_ranged_group = CreateGroup()
  group micro_enemymelee_group = CreateGroup()
  location last_major_hero_loc = Location(0,0)
  location enemy_melee_loc = Location(0,0)
  unit focus_fire_unit = null
  real bj_PI = 3.14159
  real bj_RADTODEG = 180.0/bj_PI
	unit nearest_moon_well = null

    boolean town_hall_built = false
    real last_expansion_x = 0
    real last_expansion_y = 0
    real next_expansion_x = 0
    real next_expansion_y = 0
    boolean expansion_changed = false
	

boolean militia_expanding = false
boolean militia = true
integer militia_time_count = 0
integer militia_time_out = 100  // value * 3 seconds
integer militia_state = 0
unit militia_builder = null
unit militia_fastb1 = null
unit militia_fastb2 = null
unit militia_fastb3 = null
unit militia_expansion = null
location militia_loc = null

  integer item_exp_state = 0
  unit itemhero = null
  boolean item_attack_running = false
  boolean expitem_buy = false
  location item_exp_guard_loc = null
  boolean item_expanding = false



    boolean creeping_only = false

    boolean break_attack 	= false
    boolean go_home		= false
    boolean attack_player	= false
    boolean attack_point	= false
    boolean attack_unit		= false
    boolean no_attack		= false
    boolean no_creep_attack	= false
    boolean no_player_attack	= false
    boolean strat_change_allowed = true
    integer attack_target_p	= 0
    integer attack_target_x	= 0
    integer attack_target_y	= 0
    integer bn_airair = 0
    integer bn_airground = 0
    integer bn_groundair = 0
    integer bn_groundground = 0
    integer bn_farm = 0
    integer bn_guard = 0
    unit 	target_unit = null
    integer array target_queue_x
    integer array target_queue_y
    unit    array target_queue_u
    integer queue_length	= 0
    integer queue_pointer	= 0
    boolean queue_running	= false
    boolean queue_attack_p	= false
    boolean queue_attack_u	= false
    integer queue_t_x		= 0
    integer queue_t_y		= 0
    unit	queue_t_u = null


    integer profile_length      = 0
    integer profile            = 0
    integer debug_profile = -1

    string ai_name = "Computer"
    integer own_race = 0
    real taunt_rate = 1.00 // how man % of the time computers taunt, set by profiles. Recommended values 0.50 to 1.50
    integer taunt_start_time = 60  // the time for the computers to start taunting (in seconds * 5)
    integer farm_food = 8 // build farm when this near food used to food produced
    integer strat_persistence = 1000  // extra priority to the current strategy to make computer not change strategy too fast  

	// Profile settings
    string array profilename
    integer array fav_hero
    integer array fav_unit
    integer array p_race  // Desired race for the profile to be picked (default random)
    integer array p_aggression  // aggression modify to total attacking_aggression. reccomended -10 to 10
    integer array p_uncertainty  // adds or subtracts this value to the enemies strength every so often. reccomended 5 to 15
    integer array p_minimum_attack_strength  // How much strength required before amai can start attacking. reccomended 3 to 6
    integer array p_farm_food  // How much food to have left before building a new farm
    integer array p_exp_first_time  // Make amai build expansion earlier or later by this number of seconds. reccomended -10 to 10
    integer array p_exp_second_time
    integer array p_strat_persistence  // How persistance amai is to keep its current strategy. reccomended 1.05 to 2.00
    integer array p_expansion_target_bonus  // aggression bonus for expansion targets
    integer array p_comp_chosen_target_bonus  // aggression bonus for targets chosen by the hard coded AI
    integer array p_surrender  // How likly amai will give up, 0 being never give up and 4 being give up really easily
    integer array p_rare // Ensures the profile is rarely picked
    real array p_gold_unit_percentage  // The higher this is the more unit production buildings are constructed. reccomended 0.9 to 1
    real array p_taunt_rate // Will display a taunt every 5th second for this percent of the time. Reccomended 1 to 2
    real array p_comp_chosen_target_rate  // how often the computer considers an attack target chosen by the hard coded AI


    real path_top = GetCameraBoundMaxY()+GetCameraMargin(CAMERA_MARGIN_TOP)
    real path_bottom = GetCameraBoundMinY()-GetCameraMargin(CAMERA_MARGIN_BOTTOM)
    real path_left = GetCameraBoundMinX()-GetCameraMargin(CAMERA_MARGIN_LEFT)
    real path_right = GetCameraBoundMaxX()+GetCameraMargin(CAMERA_MARGIN_RIGHT)
    //rect playable_rect = Rect(path_left, path_bottom, path_right, path_top)

    unit array expansion_list
    location array expansion_ancient
    real array expansion_dist
    group array expansion_creeps
    integer expansion_list_length = 0
    
    unit array water_expansion_list
    integer water_expansion_list_length = 0
    group water_expansion = CreateGroup()
    group array water_expansion_creeps
    group far_expansion = CreateGroup()

    boolean active_expansion = false

    unit expansion_peon = null
    unit build_zeppelin = null
    location exp_loc_cache = Location(0,0)
    integer exp_loc_cache_timeout = 0

    integer exp_number = 0
    integer array exp_rp
    unit array exp_unit
    real array exp_dist
    location array exp_ancient
    group array exp_creeps

    group current_expansion_creeps = null
    unit current_expansion = null
    boolean first_expansion_chosen = false
    unit not_taken_expansion = null
    boolean pathing_done = false

    integer confirm_count = 0
    integer array ai_force
    integer ai_force_length = 0
    boolean pathing_receive_finished = false

    integer home_field = 0

    location mine_loc = null
    location array front_loc   // the locations along the frontier of the main base (on the way to the enemies and a certain distance from the base)
    integer front_loc_num = 0  // the number of front locations
    boolean front_locs_computed = false  // are the front points computed ?

    integer udg_unique_counter = 0
    gamecache udg_debug_cache = null
    string udg_current_category = null
    timer udg_debug_timer = CreateTimer()
    boolean job_debug = false  // Job system reports will be displayed (used for finding thread crashes)
    integer debug_player = 0

    integer chosen_counter = -1
    integer chosen_counter_unit = 0
    boolean no_counter = true
    string array strengthtext
    integer array dyanti_air
    integer totalanti_air = 0
    integer array dychance_air
    integer totalchance_air = 0
    integer array dyanti_casters
    integer totalanti_casters = 0
    integer array dychance_casters
    integer totalchance_casters = 0
    integer array dyanti_towers
    integer totalanti_towers = 0
    integer array dychance_towers
    integer totalchance_towers = 0
    integer array dyanti_piercing
    integer totalanti_piercing = 0
    integer array dychance_piercing
    integer totalchance_piercing = 0
    integer array dyanti_normal
    integer totalanti_normal = 0
    integer array dychance_normal
    integer totalchance_normal = 0
    integer array dyanti_siege
    integer totalanti_siege = 0
    integer array dychance_siege
    integer totalchance_siege = 0
    integer array dyanti_magic
    integer totalanti_magic = 0
    integer array dychance_magic
    integer totalchance_magic = 0
    integer array dyanti_unarmored
    integer totalanti_unarmored = 0
    integer array dychance_unarmored
    integer totalchance_unarmored = 0
    integer array dyanti_lightarmor
    integer totalanti_lightarmor = 0
    integer array dychance_lightarmor
    integer totalchance_lightarmor = 0
    integer array dyanti_mediumarmor
    integer totalanti_mediumarmor = 0
    integer array dychance_mediumarmor
    integer totalchance_mediumarmor = 0
    integer array dyanti_heavyarmor
    integer totalanti_heavyarmor = 0
    integer array dychance_heavyarmor
    integer totalchance_heavyarmor = 0
    
    playercolor        PLAYER_COLOR_MAROON             = null
    playercolor        PLAYER_COLOR_NAVY               = null
    playercolor        PLAYER_COLOR_TURQUOISE          = null
    playercolor        PLAYER_COLOR_VIOLET             = null
    playercolor        PLAYER_COLOR_WHEAT              = null
    playercolor        PLAYER_COLOR_PEACH              = null
    playercolor        PLAYER_COLOR_MINT               = null
    playercolor        PLAYER_COLOR_LAVENDER           = null
    playercolor        PLAYER_COLOR_COAL               = null
    playercolor        PLAYER_COLOR_SNOW               = null
    playercolor        PLAYER_COLOR_EMERALD            = null
    playercolor        PLAYER_COLOR_PEANUT             = null
endglobals

function GetBJMaxPlayers takes nothing returns integer
  return 12
endfunction

function BlzGroupAddGroupFast takes group whichGroup, group addGroup returns integer
  local group g = CreateGroup()
  local unit u = null
  local integer i = 0
  loop
    set u = FirstOfGroup(whichGroup)
    exitwhen u == null 
    call GroupAddUnit(g, u)
    call GroupRemoveUnit(whichGroup,u)
  endloop
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null 
    call GroupAddUnit(addGroup, u)
    set i = i + 1
    call GroupRemoveUnit(g,u)
    call GroupAddUnit(whichGroup, u)
  endloop
  return i
endfunction

function BlzGroupRemoveGroupFast takes group whichGroup, group removeGroup returns integer
  local group g = CreateGroup()
  local unit u = null
  local integer i = 0
  loop
    set u = FirstOfGroup(whichGroup)
    exitwhen u == null 
    call GroupAddUnit(g, u)
    call GroupRemoveUnit(whichGroup,u)
  endloop
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null 
    call GroupRemoveUnit(removeGroup, u)
    set i = i + 1
    call GroupRemoveUnit(g,u)
    call GroupAddUnit(whichGroup, u)
  endloop
  return i
endfunction

function BlzGroupGetSize takes group whichGroup returns integer
  local integer i = 0
  local unit u = null
  local group g = CreateGroup()
  loop
    set u = FirstOfGroup(whichGroup)
    exitwhen u == null 
    set i = i + 1
    call GroupAddUnit(g, u)
    call GroupRemoveUnit(whichGroup,u)
  endloop
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null 
    call GroupRemoveUnit(g,u)
    call GroupAddUnit(whichGroup,u)
  endloop
  return i
endfunction

  // Global Utility Functions ( A collection of functions used for debugging and
  // language utilities. Also contains the algorithm functions e.g. hashmaps etc)


 
 
 

 


function DoNothing takes nothing returns nothing
endfunction

function InitAMAIGameCache takes nothing returns nothing
	//call FlushGameCache(InitGameCache("AMAI_TM.w3v"))
  //call FlushGameCache(amaiCache) Do not flush as breaks further use of the cache
	//call FlushGameCache(InitGameCache("AMAI_Com.w3v"))
	//call FlushGameCache(InitGameCache("AMAI_Set.w3v"))
	//call FlushGameCache(InitGameCache("AMAI_CVM.w3v"))
    //set translation_map = InitHashtable()
    //set additional_info = InitGameCache("AMAI_AI.w3v")
    //set com = InitHashtable()
	//set settings = InitGameCache("AMAI_Set.w3v")
    //set chat_vars_map = InitHashtable()
endfunction

//===========================================================================
// (AMAI)  ColorText (Converts the player color to a text version)
//===========================================================================
function ColorText takes player CPlayer returns string
  //Required Variables
  local playercolor PColor = GetPlayerColor(CPlayer)  //Gets the Player's color
    
  //Finds the Nicer Text Version of the Player's Color
  if (PColor == PLAYER_COLOR_RED) then
    return "Red"
  elseif (PColor == PLAYER_COLOR_BLUE) then
    return "Blue"
  elseif (PColor == PLAYER_COLOR_CYAN) then
    return "Cyan"
  elseif (PColor == PLAYER_COLOR_PURPLE) then
    return "Purple"
  elseif (PColor == PLAYER_COLOR_YELLOW) then
    return "Yellow"
  elseif (PColor == PLAYER_COLOR_ORANGE) then
    return "Orange"
  elseif (PColor == PLAYER_COLOR_GREEN) then
    return "Green"
  elseif (PColor == PLAYER_COLOR_PINK) then
    return "Pink"
  elseif (PColor == PLAYER_COLOR_LIGHT_GRAY) then
    return "Light Gray"
  elseif (PColor == PLAYER_COLOR_LIGHT_BLUE) then
    return "Light Blue"
  elseif (PColor == PLAYER_COLOR_AQUA) then
    return "Aqua"
  elseif (PColor == PLAYER_COLOR_BROWN) then
    return "Brown"
  elseif (PColor == PLAYER_COLOR_MAROON) then
    return "Maroon"
  elseif (PColor == PLAYER_COLOR_NAVY) then
    return "Navy"
  elseif (PColor == PLAYER_COLOR_TURQUOISE) then
    return "Turquoise"
  elseif (PColor == PLAYER_COLOR_VIOLET) then
    return "Violet"
  elseif (PColor == PLAYER_COLOR_WHEAT) then
    return "Wheat"
  elseif (PColor == PLAYER_COLOR_PEACH) then
    return "Peach"
  elseif (PColor == PLAYER_COLOR_MINT) then
    return "Mint"
  elseif (PColor == PLAYER_COLOR_LAVENDER) then
    return "Lavender"
  elseif (PColor == PLAYER_COLOR_COAL) then
    return "Coal"
  elseif (PColor == PLAYER_COLOR_SNOW) then
    return "Snow"
  elseif (PColor == PLAYER_COLOR_EMERALD) then
    return "Emerald"
  elseif (PColor == PLAYER_COLOR_PEANUT) then
    return "Peanut"
  endif
  
  //Returns text version
  return ""
endfunction

function cs2s takes string name, playercolor c returns string
  if c == PLAYER_COLOR_RED then
      return "|CffFF0000"+name+"|r"
  elseif c == PLAYER_COLOR_BLUE then
      return "|Cff0064FF"+name+"|r"
  elseif c == PLAYER_COLOR_CYAN then
      return "|Cff1BE7BA"+name+"|r"
  elseif c == PLAYER_COLOR_PURPLE then
      return "|Cff550081"+name+"|r"
  elseif c == PLAYER_COLOR_YELLOW then
      return "|CffFFFC00"+name+"|r "
  elseif c == PLAYER_COLOR_ORANGE then
      return "|CffFF8A0D"+name+"|r"
  elseif c == PLAYER_COLOR_GREEN then
      return "|Cff21BF00"+name+"|r"
  elseif c == PLAYER_COLOR_PINK then
      return "|CffE45CAF"+name+"|r"
  elseif c == PLAYER_COLOR_LIGHT_GRAY then
      return "|Cff949696"+name+"|r"
  elseif c == PLAYER_COLOR_LIGHT_BLUE then
      return "|Cff7EBFF1"+name+"|r"
  elseif c == PLAYER_COLOR_AQUA then
      return "|Cff106247"+name+"|r"
  elseif c == PLAYER_COLOR_MAROON then
      return "|Cff9C0000"+name+"|r"
  elseif c == PLAYER_COLOR_NAVY then
      return "|Cff0000C3"+name+"|r"
  elseif c == PLAYER_COLOR_TURQUOISE then
      return "|Cff00EBFF"+name+"|r"
  elseif c == PLAYER_COLOR_VIOLET then
      return "|CffBD00FF"+name+"|r"
  elseif c == PLAYER_COLOR_WHEAT then
      return "|CffECCD87"+name+"|r"
  elseif c == PLAYER_COLOR_PEACH then
      return "|CffF7A58B"+name+"|r"
  elseif c == PLAYER_COLOR_MINT then
      return "|CffBFFF81"+name+"|r"
  elseif c == PLAYER_COLOR_LAVENDER then
      return "|CffDBB9EB"+name+"|r"
  elseif c == PLAYER_COLOR_COAL then
      return "|Cff4F5055"+name+"|r"
  elseif c == PLAYER_COLOR_SNOW then
      return "|CffECF0FF"+name+"|r"
  elseif c == PLAYER_COLOR_EMERALD then
      return "|Cff00781E"+name+"|r"
  elseif c == PLAYER_COLOR_PEANUT then
      return "|CffA57033"+name+"|r"
  else //Brown
      return "|Cff4F2B05"+name+"|r"
  endif
endfunction
function c2s takes playercolor c returns string
  return cs2s(ai_name, c) + ": "
endfunction

function AMAIPercentToInt takes real percentage, integer max returns integer
    local integer result = R2I(percentage * I2R(max) * 0.01)

    if (result < 0) then
        set result = 0
    elseif (result > max) then
        set result = max
    endif

    return result
endfunction

function AMAIPercentTo255 takes real percentage returns integer
    return AMAIPercentToInt(percentage, 255)
endfunction

function SetDebugTagColor takes texttag tt returns nothing
	local playercolor c = GetPlayerColor(ai_player)
	if c == PLAYER_COLOR_RED then
		call SetTextTagColor(tt, 255, 0, 0, AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_BLUE then
		call SetTextTagColor(tt, 0, 100, 255, AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_CYAN then
		call SetTextTagColor(tt, 27, 231, 186, AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_PURPLE then
		call SetTextTagColor(tt, 85, 0, 129, AMAIPercentTo255(100-0))	
	elseif c == PLAYER_COLOR_YELLOW then
		call SetTextTagColor(tt, 255, 252, 0, AMAIPercentTo255(100-0))	
	elseif c == PLAYER_COLOR_ORANGE then
		call SetTextTagColor(tt, 255, 138, 13, AMAIPercentTo255(100-0))	
	elseif c == PLAYER_COLOR_GREEN then
		call SetTextTagColor(tt, 32, 191, 0, AMAIPercentTo255(100-0))	
	elseif c == PLAYER_COLOR_PINK then
		call SetTextTagColor(tt, 228, 92, 0, AMAIPercentTo255(100-0))	
	elseif c == PLAYER_COLOR_LIGHT_GRAY then
		call SetTextTagColor(tt, 148, 150, 150, AMAIPercentTo255(100-0))	
	elseif c == PLAYER_COLOR_LIGHT_BLUE then
		call SetTextTagColor(tt, 126, 191, 241, AMAIPercentTo255(100-0))	
	elseif c == PLAYER_COLOR_AQUA then
		call SetTextTagColor(tt, 19, 98, 71, AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_MAROON then
		call SetTextTagColor(tt, 156, 0, 0, AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_NAVY then
		call SetTextTagColor(tt, 0, 0, 195, AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_TURQUOISE then
		call SetTextTagColor(tt, 0, 235, 255, AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_VIOLET then
		call SetTextTagColor(tt, 189, 0, 255, AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_WHEAT then
		call SetTextTagColor(tt, 236, 205, 135, AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_PEACH then
		call SetTextTagColor(tt, 247, 165, 139, AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_MINT then
		call SetTextTagColor(tt, 191, 255, 129, AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_LAVENDER then
	  call SetTextTagColor(tt, 219, 185, 235, AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_COAL then
		call SetTextTagColor(tt, 79, 80, 85, AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_SNOW then
		call SetTextTagColor(tt, 236, 240, 255, AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_EMERALD then
		call SetTextTagColor(tt, 0, 120, 30, AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_PEANUT then
		call SetTextTagColor(tt, 165, 112, 51, AMAIPercentTo255(100-0))
	else // PLAYER_COLOR_BROWN
		call SetTextTagColor(tt, 79, 43, 5, AMAIPercentTo255(100-0))	
	endif
	set c = null
endfunction

function UpdateDebugTextTag takes texttag tt, string s, real fontsize, real posx, real posy returns nothing
		call SetTextTagText(tt, s, ( fontsize * 0.023 / 10))  // *0.023/10 creates the correct font size from given real
		call SetTextTagPos(tt, posx, posy, 0)	
		call SetDebugTagColor(tt)
endfunction

function CreateDebugTagLoc takes string s, real fontsize, real posx, real posy, real lifespan, real fadespan returns nothing
	local texttag tt = null

	if debugging then
		set tt = CreateTextTag()
		call SetTextTagText(tt, s, ( fontsize * 0.023 / 10))  // *0.023/10 creates the correct font size from given real
		call SetTextTagPos(tt, posx, posy, 0)	
		call SetDebugTagColor(tt)
		call SetTextTagPermanent(tt, false)
		call SetTextTagLifespan(tt, lifespan)
		call SetTextTagFadepoint(tt, fadespan)
		set tt = null
	endif
endfunction

function CreateDebugTag takes string s, real fontsize, unit u, real lifespan, real fadespan returns nothing
	local texttag tt = null

	if debugging then
		set tt = CreateTextTag()
		call SetTextTagText(tt, s, ( fontsize * 0.023 / 10))  // *0.023/10 creates the correct font size from given real
		call SetTextTagPosUnit(tt, u, 0)	
		call SetDebugTagColor(tt)
		call SetTextTagPermanent(tt, false)
		call SetTextTagLifespan(tt, lifespan)
		call SetTextTagFadepoint(tt, fadespan)
		set tt = null
	endif
endfunction


function InitDigits takes nothing returns nothing
  set digit_map[0] = "0"
  set digit_map[1] = "1"
  set digit_map[2] = "2"
  set digit_map[3] = "3"
  set digit_map[4] = "4"
  set digit_map[5] = "5"
  set digit_map[6] = "6"
  set digit_map[7] = "7"
  set digit_map[8] = "8"
  set digit_map[9] = "9"
endfunction

function Int2Str takes integer ic returns string
  local string s = ""
  local integer i = ic
  local integer ialt = 0
  local boolean neg = false

  if digit_map[0] == null then
    call InitDigits() // If called before digits has been initialized do it ourselves.
  endif

  if i == 0 then
    set s = null
    return "0"
  endif
  if i < 0 then
    set neg = true
    set i = -i
  endif
  loop
    exitwhen i == 0
    set ialt = i
    set i = i / 10
    set s = digit_map[ ialt - 10*i ] + s
  endloop
  if neg then
    return "-"+s
  endif
  return s
endfunction

function Real2Str takes real num returns string
  local string s = ""
  local real r = num

  set s = Int2Str(R2I(r))
  set r = r - R2I(r) // Remove the integer bit to leave the decimal
  if r > 0 then
    set s = s + "." // The decimal point
    set r = r * 1000 // 3 decimal places
    set s = s + Int2Str(R2I(r))
  endif
  return s
endfunction

function B2S takes boolean b returns string
  if b then
    return "true"
  else
    return "false"
  endif
endfunction

function DebugSequenceStart takes string name returns nothing
  call FlushGameCache(InitGameCache("Debug.w3v"))
  set udg_debug_cache = InitGameCache("Debug.w3v")
  set udg_current_category = Int2Str(GetRandomInt(1, 100000000))
  call TimerStart(udg_debug_timer, 1000000, false, null)
  call StoreString(udg_debug_cache, udg_current_category, "Debug0", "SequenceStart "+name)
  set udg_unique_counter = 1
endfunction

function DebugSequenceEnd takes nothing returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), "SequenceEnd")
  call SaveGameCache(udg_debug_cache)
endfunction

function DumpString takes string label, string s returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), s)
  set udg_unique_counter = udg_unique_counter + 2
endfunction

function DumpInteger takes string label, integer i returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), Int2Str(i))
  set udg_unique_counter = udg_unique_counter + 2
endfunction

function DumpReal takes string label, real r returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), Int2Str(R2I(r * 1000)))
  set udg_unique_counter = udg_unique_counter + 2
endfunction

function DumpBoolean takes string label, boolean b returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), B2S(b))
  set udg_unique_counter = udg_unique_counter + 2
endfunction

function DumpHandle takes string label, handle h returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), Int2Str(GetHandleId(h)))
  set udg_unique_counter = udg_unique_counter + 2
endfunction

function EndDump takes string label returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), "EndDump "+label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), Int2Str(R2I(TimerGetElapsed(udg_debug_timer)*1000)))
  set udg_unique_counter = udg_unique_counter + 2
endfunction

function DumpMessage takes string label, string s returns nothing
  call DumpString("Message", s)
  call EndDump(label)
endfunction

function AddTrans takes string lang, string key, string value returns nothing

  set translation[translation_length] = value
  call SaveInteger(translation_map, StringHash(lang), StringHash(key), translation_length)
  set translation_length = translation_length + 1

endfunction

function ApplyTrans takes string s returns string
  //local integer transnum = LoadInteger(translation_map, StringHash(language), StringHash(s))
  //if transnum != null then
  local string trans = null
  if HaveSavedInteger(translation_map, StringHash(language), StringHash(s)) then
    //return translation[transnum]
    set trans = translation[LoadInteger(translation_map, StringHash(language), StringHash(s))]
  endif
  if (trans == null or trans == "") and HaveSavedInteger(translation_map, StringHash("English"), StringHash(s)) then // Backup translate to english
    set trans = translation[LoadInteger(translation_map, StringHash("English"), StringHash(s))]
  endif
  if (trans == null or trans == "") then
    //call DisplayTimedTextToPlayer(Player(0),0,0,15,message_add+s+":handle not saved")
    set trans = null
    return s
  else
    return trans
  endif
endfunction

function InitTrans takes nothing returns nothing
  local string lang = ""
  set lang = "English"
  call AddTrans(lang, "HUMAN", "human")
  call AddTrans(lang, "ORC", "orc")
  call AddTrans(lang, "ELF", "elf")
  call AddTrans(lang, "UNDEAD", "undead")
  call AddTrans(lang, "Red", "red")
  call AddTrans(lang, "Blue", "blue")
  call AddTrans(lang, "Cyan", "cyan")
  call AddTrans(lang, "Purple", "purple")
  call AddTrans(lang, "Yellow", "yellow")
  call AddTrans(lang, "Orange", "orange")
  call AddTrans(lang, "Green", "green")
  call AddTrans(lang, "Pink", "pink")
  call AddTrans(lang, "Light Gray", "light gray")
  call AddTrans(lang, "Light Blue", "light blue")
  call AddTrans(lang, "Aqua", "aqua")
  call AddTrans(lang, "Brown", "brown")
  call AddTrans(lang, "HUMAN:S", "humans")
  call AddTrans(lang, "ORC:S", "orcs")
  call AddTrans(lang, "ELF:S", "elves")
  call AddTrans(lang, "UNDEAD:S", "undead")
  call AddTrans(lang, "Red:S", "reds")
  call AddTrans(lang, "Blue:S", "blues")
  call AddTrans(lang, "Purple:S", "purples")
  call AddTrans(lang, "Yellow:S", "yellows")
  call AddTrans(lang, "Orange:S", "oranges")
  call AddTrans(lang, "Green:S", "greenies")
  call AddTrans(lang, "Pink:S", "pinkos")
  call AddTrans(lang, "Light Gray:S", "Light Grays")
  call AddTrans(lang, "Light Blue:S", "Light Blues")
  call AddTrans(lang, "Aqua:S", "Aquas")
  call AddTrans(lang, "Brown:S", "Brownies")
  call AddTrans(lang, "air", "")
  call AddTrans(lang, "casters", "")
  call AddTrans(lang, "towers", "")
  call AddTrans(lang, "piercing", "")
  call AddTrans(lang, "normal", "")
  call AddTrans(lang, "siege", "")
  call AddTrans(lang, "magic", "")
  call AddTrans(lang, "unarmored", "")
  call AddTrans(lang, "lightarmor", "")
  call AddTrans(lang, "mediumarmor", "")
  call AddTrans(lang, "heavyarmor", "")
  set lang = "Deutsch"
  call AddTrans(lang, "ORC", "Ork")
  call AddTrans(lang, "ORC:S", "Orks")
  call AddTrans(lang, "ORC:Armee", "der orkischen Horde")
  call AddTrans(lang, "HUMAN", "Mensch")
  call AddTrans(lang, "HUMAN:S", "Menschen")
  call AddTrans(lang, "HUMAN:Armee", "der menschlichen Legion")
  call AddTrans(lang, "ELF", "Elf")
  call AddTrans(lang, "ELF:S", "Elfen")
  call AddTrans(lang, "ELF:Armee", "der Gesandten des Cenarius")
  call AddTrans(lang, "UNDEAD", "Untoter")
  call AddTrans(lang, "UNDEAD:S", "Untote")
  call AddTrans(lang, "UNDEAD:Armee", "der Armee der Finsternis")
  call AddTrans(lang, "air", "luft")
  call AddTrans(lang, "casters", "laufrollen")
  call AddTrans(lang, "towers", "trme")
  call AddTrans(lang, "piercing", "durchdringend")
  call AddTrans(lang, "normal", "")
  call AddTrans(lang, "siege", "belagerung")
  call AddTrans(lang, "magic", "magie")
  call AddTrans(lang, "unarmored", "ungepanzert")
  call AddTrans(lang, "lightarmor", "leichte Rstung")
  call AddTrans(lang, "mediumarmor", "mittlere Rstung")
  call AddTrans(lang, "heavyarmor", "schwere Rstung")
  set lang = "Swedish"
  call AddTrans(lang, "HUMAN", "human")
  call AddTrans(lang, "HUMAN:EN", "humanen")
  call AddTrans(lang, "ORC", "orc")
  call AddTrans(lang, "ORC:EN", "orcen")
  call AddTrans(lang, "ELF", "night elf")
  call AddTrans(lang, "ELF:EN", "night elfen")
  call AddTrans(lang, "UNDEAD", "undead")
  call AddTrans(lang, "UNDEAD:EN", "undeaden")
  call AddTrans(lang, "Red", "rd")
  call AddTrans(lang, "Red:A", "rda")
  call AddTrans(lang, "Blue", "bl")
  call AddTrans(lang, "Blue:A", "bla")
  call AddTrans(lang, "Cyan", "ljusbl")
  call AddTrans(lang, "Cyan:A", "ljusbla")
  call AddTrans(lang, "Purple", "lila")
  call AddTrans(lang, "Purple:A", "lila")
  call AddTrans(lang, "Yellow", "gula")
  call AddTrans(lang, "Yellow:A", "gula")
  call AddTrans(lang, "Orange", "brandgula")
  call AddTrans(lang, "Orange:A", "brandgula")
  call AddTrans(lang, "Green", "grn")
  call AddTrans(lang, "Green:A", "grna")
  call AddTrans(lang, "Pink", "rosa")
  call AddTrans(lang, "Pink:A", "rosa")
  call AddTrans(lang, "Light Gray", "ljusgr")
  call AddTrans(lang, "Light Gray:A", "ljusgra")
  call AddTrans(lang, "Light Blue", "ljusbl")
  call AddTrans(lang, "Light Blue:A", "ljusbla")
  call AddTrans(lang, "Aqua", "vattenfrgad")
  call AddTrans(lang, "Aqua:A", "vattenfrgade")
  call AddTrans(lang, "Brown", "brun")
  call AddTrans(lang, "Brown:A", "bruna")
  call AddTrans(lang, "air", "luft")
  call AddTrans(lang, "casters", "")
  call AddTrans(lang, "towers", "torn")
  call AddTrans(lang, "piercing", "")
  call AddTrans(lang, "normal", "")
  call AddTrans(lang, "siege", "belgring")
  call AddTrans(lang, "magic", "magi")
  call AddTrans(lang, "unarmored", "obepansrad")
  call AddTrans(lang, "lightarmor", "ltt rustning")
  call AddTrans(lang, "mediumarmor", "medium rustning")
  call AddTrans(lang, "heavyarmor", "tung rustning")
  set lang = "French"
  call AddTrans(lang, "air", "")
  call AddTrans(lang, "casters", "roulettes")
  call AddTrans(lang, "towers", "tours")
  call AddTrans(lang, "piercing", "perant")
  call AddTrans(lang, "normal", "ordinaire")
  call AddTrans(lang, "siege", "sige")
  call AddTrans(lang, "magic", "la magie")
  call AddTrans(lang, "unarmored", "sans armure")
  call AddTrans(lang, "lightarmor", "armure lgre")
  call AddTrans(lang, "mediumarmor", "armure moyenne")
  call AddTrans(lang, "heavyarmor", "armure lourde")
  set lang = "Spanish"
  call AddTrans(lang, "ORC", "Orco")
  call AddTrans(lang, "ORC:s", "Orcos")
  call AddTrans(lang, "ORC:UBER", "Los brutales y fuertes orcos")
  call AddTrans(lang, "HUMAN", "Humano")
  call AddTrans(lang, "HUMAN:s", "Humanos")
  call AddTrans(lang, "HUMAN:UBER", "La alianza de humanos, elfos y enanos")
  call AddTrans(lang, "UNDEAD", "Muerto viviente")
  call AddTrans(lang, "UNDEAD:s", "Muertos vivientes")
  call AddTrans(lang, "UNDEAD:UBER", "Los invencibles muertos vivientes")
  call AddTrans(lang, "NIGHTELF", "Elfo nocturno")
  call AddTrans(lang, "NIGHTELF:s", "Elfos nocturnos")
  call AddTrans(lang, "NIGHTELF:UBER", "Los inmortales elfos nocturnos")
  call AddTrans(lang, "small", "pequeo")
  call AddTrans(lang, "medium", "mediano")
  call AddTrans(lang, "large", "grande")
  call AddTrans(lang, "small:s", "pequeos")
  call AddTrans(lang, "medium:s", "medianos")
  call AddTrans(lang, "large:s", "grandes")
  call AddTrans(lang, "Red", "rojo")
  call AddTrans(lang, "Red:s", "rojos")
  call AddTrans(lang, "Blue", "azul")
  call AddTrans(lang, "Blue:s", "azules")
  call AddTrans(lang, "Teal", "verde agua")
  call AddTrans(lang, "Teal:s", "verdes agua")
  call AddTrans(lang, "Purple", "prpura")
  call AddTrans(lang, "Purple:s", "prpuras")
  call AddTrans(lang, "Yellow", "amarillo")
  call AddTrans(lang, "Yellow:s", "amarillos")
  call AddTrans(lang, "Orange", "naranja")
  call AddTrans(lang, "Orange:s", "naranjas")
  call AddTrans(lang, "Green", "verde claro")
  call AddTrans(lang, "Green:s", "verdes claros")
  call AddTrans(lang, "Pink", "rosa")
  call AddTrans(lang, "Pink:s", "rosados")
  call AddTrans(lang, "Light Gray", "gris")
  call AddTrans(lang, "Light Gray:s", "grises")
  call AddTrans(lang, "Light Blue", "celeste")
  call AddTrans(lang, "Light Blue:s", "celestes")
  call AddTrans(lang, "Aqua", "verde oscuro")
  call AddTrans(lang, "Aqua:s", "verdes oscuros")
  call AddTrans(lang, "Brown", "caf")
  call AddTrans(lang, "Brown:s", "cafs")
  call AddTrans(lang, "air", "voladores")
  call AddTrans(lang, "casters", "hechiceros")
  call AddTrans(lang, "towers", "torres")
  call AddTrans(lang, "piercing", "armas perforantes")
  call AddTrans(lang, "normal", "armas normales")
  call AddTrans(lang, "siege", "armas de asedio")
  call AddTrans(lang, "magic", "magia")
  call AddTrans(lang, "unarmored", "tropas sin armadura")
  call AddTrans(lang, "lightarmor", "armadura ligera")
  call AddTrans(lang, "mediumarmor", "armadura media")
  call AddTrans(lang, "heavyarmor", "armadura pesada")
  set lang = "Romanian"
  call AddTrans(lang, "air", "aer")
  call AddTrans(lang, "casters", "")
  call AddTrans(lang, "towers", "turnuri")
  call AddTrans(lang, "piercing", "")
  call AddTrans(lang, "normal", "")
  call AddTrans(lang, "siege", "asediu")
  call AddTrans(lang, "magic", "magie")
  call AddTrans(lang, "unarmored", "neblindat")
  call AddTrans(lang, "lightarmor", "armura usoara")
  call AddTrans(lang, "mediumarmor", "armura medie")
  call AddTrans(lang, "heavyarmor", "armur grea")
  set lang = "Russian"
  call AddTrans(lang, "HUMAN", "")
  call AddTrans(lang, "HUMAN:S", "")
  call AddTrans(lang, "HUMAN:OFF", "")
  call AddTrans(lang, "HUMAN:AYA", "")
  call AddTrans(lang, "ORC", "")
  call AddTrans(lang, "ORC:S", "")
  call AddTrans(lang, "ORC:OFF", "")
  call AddTrans(lang, "ORC:AYA", "")
  call AddTrans(lang, "UNDEAD", "")
  call AddTrans(lang, "UNDEAD:S", "")
  call AddTrans(lang, "UNDEAD:OFF", "")
  call AddTrans(lang, "UNDEAD:AYA", "")
  call AddTrans(lang, "ELF", "")
  call AddTrans(lang, "ELF:I", " ")
  call AddTrans(lang, "ELF:S", "")
  call AddTrans(lang, "ELF:OFF", "")
  call AddTrans(lang, "ELF:AYA", "")
  call AddTrans(lang, "Red", "")
  call AddTrans(lang, "Red:A", "")
  call AddTrans(lang, "Red:E", "")
  call AddTrans(lang, "Red:X", "")
  call AddTrans(lang, "Blue", "")
  call AddTrans(lang, "Blue:A", "")
  call AddTrans(lang, "Blue:E", "")
  call AddTrans(lang, "Blue:X", "")
  call AddTrans(lang, "Cyan", "-")
  call AddTrans(lang, "Cyan:A", "-")
  call AddTrans(lang, "Cyan:E", "-")
  call AddTrans(lang, "Cyan:X", "-")
  call AddTrans(lang, "Purple", "")
  call AddTrans(lang, "Purple:A", "")
  call AddTrans(lang, "Purple:E", "")
  call AddTrans(lang, "Purple:X", "")
  call AddTrans(lang, "Yellow", "")
  call AddTrans(lang, "Yellow:A", "")
  call AddTrans(lang, "Yellow:E", "")
  call AddTrans(lang, "Yellow:X", "")
  call AddTrans(lang, "Orange", "")
  call AddTrans(lang, "Orange:A", "")
  call AddTrans(lang, "Orange:E", "")
  call AddTrans(lang, "Orange:X", "")
  call AddTrans(lang, "Green", "")
  call AddTrans(lang, "Green:A", "")
  call AddTrans(lang, "Green:E", "")
  call AddTrans(lang, "Green:X", "")
  call AddTrans(lang, "Pink", "")
  call AddTrans(lang, "Pink:A", "")
  call AddTrans(lang, "Pink:E", "")
  call AddTrans(lang, "Pink:X", "")
  call AddTrans(lang, "Light Gray", "")
  call AddTrans(lang, "Light Gray:A", "")
  call AddTrans(lang, "Light Gray:E", "")
  call AddTrans(lang, "Light Gray:X", "")
  call AddTrans(lang, "Light Blue", "-")
  call AddTrans(lang, "Light Blue:A", "-")
  call AddTrans(lang, "Light Blue:E", "-")
  call AddTrans(lang, "Light Blue:X", "-")
  call AddTrans(lang, "Aqua", "-")
  call AddTrans(lang, "Aqua:A", "-")
  call AddTrans(lang, "Aqua:E", "-")
  call AddTrans(lang, "Aqua:X", "-")
  call AddTrans(lang, "Brown", "")
  call AddTrans(lang, "Brown:A", "")
  call AddTrans(lang, "Brown:E", "")
  call AddTrans(lang, "Brown:X", "")
  call AddTrans(lang, "air", "")
  call AddTrans(lang, "casters", "")
  call AddTrans(lang, "towers", "")
  call AddTrans(lang, "piercing", "")
  call AddTrans(lang, "normal", "")
  call AddTrans(lang, "siege", "")
  call AddTrans(lang, "magic", "")
  call AddTrans(lang, "unarmored", " ")
  call AddTrans(lang, "lightarmor", " ")
  call AddTrans(lang, "mediumarmor", " ")
  call AddTrans(lang, "heavyarmor", " ")
  set lang = "Portuguese"
  call AddTrans(lang, "HUMAN", "human")
  call AddTrans(lang, "ORC", "orc")
  call AddTrans(lang, "ELF", "elf")
  call AddTrans(lang, "UNDEAD", "undead")
  call AddTrans(lang, "Red", "vermelho")
  call AddTrans(lang, "Blue", "azul")
  call AddTrans(lang, "Cyan", "ciano")
  call AddTrans(lang, "Purple", "roxo")
  call AddTrans(lang, "Yellow", "amarelo")
  call AddTrans(lang, "Orange", "laranja")
  call AddTrans(lang, "Green", "verde")
  call AddTrans(lang, "Pink", "rosa")
  call AddTrans(lang, "Light Gray", "cinza claro")
  call AddTrans(lang, "Light Blue", "azul claro")
  call AddTrans(lang, "Aqua", "aqua")
  call AddTrans(lang, "Brown", "marrons")
  call AddTrans(lang, "HUMAN:S", "humanos")
  call AddTrans(lang, "ORC:S", "orcs")
  call AddTrans(lang, "ELF:S", "elfos")
  call AddTrans(lang, "UNDEAD:S", "undeads")
  call AddTrans(lang, "Red:S", "vermelhos")
  call AddTrans(lang, "Blue:S", "azuis")
  call AddTrans(lang, "Purple:S", "roxos")
  call AddTrans(lang, "Yellow:S", "amarelos")
  call AddTrans(lang, "Orange:S", "laranjas")
  call AddTrans(lang, "Green:S", "verdes")
  call AddTrans(lang, "Pink:S", "rosas")
  call AddTrans(lang, "Light Gray:S", "cinzas claro")
  call AddTrans(lang, "Light Blue:S", "azuis claro")
  call AddTrans(lang, "Aqua:S", "aquas")
  call AddTrans(lang, "Brown:S", "marrons")
  call AddTrans(lang, "air", "ar")
  call AddTrans(lang, "casters", "rodzios")
  call AddTrans(lang, "towers", "torres")
  call AddTrans(lang, "piercing", "")
  call AddTrans(lang, "normal", "")
  call AddTrans(lang, "siege", "cerco")
  call AddTrans(lang, "magic", "magia")
  call AddTrans(lang, "unarmored", "sem armadura")
  call AddTrans(lang, "lightarmor", "armadura leve")
  call AddTrans(lang, "mediumarmor", "armadura mdia")
  call AddTrans(lang, "heavyarmor", "armadura pesada")
  set lang = "Norwegian"
  call AddTrans(lang, "air", "luft")
  call AddTrans(lang, "casters", "")
  call AddTrans(lang, "towers", "trn")
  call AddTrans(lang, "piercing", "")
  call AddTrans(lang, "normal", "")
  call AddTrans(lang, "siege", "beleiring")
  call AddTrans(lang, "magic", "magi")
  call AddTrans(lang, "unarmored", "ubepansrede")
  call AddTrans(lang, "lightarmor", "lett rustning")
  call AddTrans(lang, "mediumarmor", "middels rustning")
  call AddTrans(lang, "heavyarmor", "tung rustning")
  set lang = "Chinese"
  call AddTrans(lang, "HUMAN", "")
  call AddTrans(lang, "ORC", "")
  call AddTrans(lang, "ELF", "")
  call AddTrans(lang, "UNDEAD", "")
  call AddTrans(lang, "Red", "")
  call AddTrans(lang, "Blue", "")
  call AddTrans(lang, "Cyan", "")
  call AddTrans(lang, "Purple", "")
  call AddTrans(lang, "Yellow", "")
  call AddTrans(lang, "Orange", "")
  call AddTrans(lang, "Green", "")
  call AddTrans(lang, "Pink", "")
  call AddTrans(lang, "Light Gray", "")
  call AddTrans(lang, "Light Blue", "")
  call AddTrans(lang, "Aqua", "")
  call AddTrans(lang, "Brown", "")
  call AddTrans(lang, "Maroon", "")
  call AddTrans(lang, "Navy", "")
  call AddTrans(lang, "Turquoise", "")
  call AddTrans(lang, "Violet", "")
  call AddTrans(lang, "Wheat", "")
  call AddTrans(lang, "Peach", "")
  call AddTrans(lang, "Mint", "")
  call AddTrans(lang, "Lavender", "")
  call AddTrans(lang, "Coal", "")
  call AddTrans(lang, "Snow", "")
  call AddTrans(lang, "Emerald", "")
  call AddTrans(lang, "Peanut", "")
  call AddTrans(lang, "HUMAN:S", "")
  call AddTrans(lang, "ORC:S", "")
  call AddTrans(lang, "ELF:S", "")
  call AddTrans(lang, "UNDEAD:S", "")
  call AddTrans(lang, "Red:S", "")
  call AddTrans(lang, "Blue:S", "")
  call AddTrans(lang, "Purple:S", "")
  call AddTrans(lang, "Yellow:S", "")
  call AddTrans(lang, "Orange:S", "")
  call AddTrans(lang, "Green:S", "")
  call AddTrans(lang, "Pink:S", "")
  call AddTrans(lang, "Light Gray:S", "")
  call AddTrans(lang, "Light Blue:S", "")
  call AddTrans(lang, "Aqua:S", "")
  call AddTrans(lang, "Brown:S", "")
  call AddTrans(lang, "Maroon:S", "")
  call AddTrans(lang, "Navy:S", "")
  call AddTrans(lang, "Turquoise:S", "")
  call AddTrans(lang, "Violet:S", "")
  call AddTrans(lang, "Wheat:S", "")
  call AddTrans(lang, "Peach:S", "")
  call AddTrans(lang, "Mint:S", "")
  call AddTrans(lang, "Lavender:S", "")
  call AddTrans(lang, "Coal:S", "")
  call AddTrans(lang, "Snow:S", "")
  call AddTrans(lang, "Emerald:S", "")
  call AddTrans(lang, "Peanut:S", "")
  call AddTrans(lang, "air", "")
  call AddTrans(lang, "casters", "")
  call AddTrans(lang, "towers", "")
  call AddTrans(lang, "piercing", "")
  call AddTrans(lang, "normal", "")
  call AddTrans(lang, "siege", "")
  call AddTrans(lang, "magic", "")
  call AddTrans(lang, "unarmored", "")
  call AddTrans(lang, "lightarmor", "")
  call AddTrans(lang, "mediumarmor", "")
  call AddTrans(lang, "heavyarmor", "")
  set lang = null
endfunction


function DisplayToAll takes string s returns nothing
  local integer i = 0
  loop
    call DisplayTimedTextToPlayer(Player(i),0,0,15,message_add+s)
    set i = i + 1
    exitwhen i == GetBJMaxPlayers()
  endloop
  call StartSound(chatSound)
endfunction

function DisplayToAllImportant takes string s returns nothing
  local integer i = 0
  loop
    call DisplayTimedTextToPlayer(Player(i),0,0,15,message_add+s)
    set i = i + 1
    exitwhen i == GetBJMaxPlayers()
  endloop
  call StartSound(importantSound)
endfunction

function DisplayToAllies takes string s returns nothing
  if IsPlayerAlly(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(chatSound)
  endif
endfunction

function DisplayToAlliesImportant takes string s returns nothing
  if IsPlayerAlly(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(importantSound)
  endif
endfunction

function DisplayToEnemy takes string s returns nothing
  if IsPlayerEnemy(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(chatSound)
  endif
endfunction

function DisplayToEnemyImportant takes string s returns nothing
  if IsPlayerEnemy(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(importantSound)
  endif
endfunction

function DisplayToObservers takes string s returns nothing
  if IsPlayerObserver(GetLocalPlayer()) and not IsPlayerAlly(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(chatSound)
  endif
endfunction

function DisplayToObserversImportant takes string s returns nothing
  if IsPlayerObserver(GetLocalPlayer()) and not IsPlayerAlly(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(importantSound)
  endif
endfunction


	

function DisplayToAllFromPlayer takes string s, integer playernum, boolean important returns nothing
	local integer i = 0
	if Player(GetAiPlayer()) == Player(playernum) then
		loop
			call DisplayTimedTextToPlayer(Player(i),0,0,15,message_add+s)
			set i = i + 1
			exitwhen i == GetBJMaxPlayers()
		endloop
		if important then
			call StartSound(importantSound)
		else
			call StartSound(chatSound)
		endif
	endif
endfunction

function UpdateDebugPlayer takes nothing returns nothing
		if IsPlayerObserver(Player(debug_player)) == true then
			set debug_player = debug_player + 1
		endif
		if GetPlayerUnitCount(Player(debug_player), true) == 0 then
			set debug_player = debug_player + 1
		endif
		//if GetChar(GetPlayerName(Player(debug_player)), 1) != "A" then
		//	set debug_player = debug_player + 1 // If not containing AMAI in player name increment until it is
		//endif
		if GetPlayerSlotState(Player(debug_player)) != PLAYER_SLOT_STATE_PLAYING then
			set debug_player = debug_player + 1
		endif
		if debug_player > 24 then
			set debug_player = 24 // Do not go above 24
		endif
endfunction

function TracePlayer takes string s, integer playernum returns nothing
	if debugging then
		call DisplayToAllFromPlayer(s, playernum, false)
	endif	
endfunction

function Trace takes string s returns nothing
  if debugging then
    call UpdateDebugPlayer()
    call DisplayToAllFromPlayer(s, debug_player, false)
  endif
  if trace_on then
      call DisplayText(GetAiPlayer(),s)
  endif
endfunction

function TraceI takes string s, integer val returns nothing	
  if debugging then
    call UpdateDebugPlayer()
    call DisplayToAllFromPlayer(s+":"+Int2Str(val), debug_player, false)
  endif
  if trace_on then
    call DisplayTextI(GetAiPlayer(),s,val)
  endif
endfunction

function TraceII takes string message, integer v1, integer v2 returns nothing
  if debugging then
    call UpdateDebugPlayer()
    call DisplayToAllFromPlayer(message+":"+Int2Str(v1)+":"+Int2Str(v2), debug_player, false)
  endif
  if trace_on then
    call DisplayTextII(GetAiPlayer(),message,v1,v2)
  endif
endfunction

function TraceIII takes string message, integer v1, integer v2, integer v3 returns nothing
  if debugging then
    call UpdateDebugPlayer()
    call DisplayToAllFromPlayer(message+":"+Int2Str(v1)+":"+Int2Str(v2)+":"+Int2Str(v3), debug_player, false)
  endif
  if trace_on then
    call DisplayTextIII(GetAiPlayer(),message,v1,v2,v3)
  endif
endfunction

function DisplayToAllJobDebug takes string s returns nothing
  if job_debug then
    call DisplayToAllFromPlayer(s, debug_player, false)
  endif
endfunction

function DisplayToAlliesChat takes string s returns nothing
  if chatting then
    if IsPlayerAlly(ai_player,GetLocalPlayer()) then
      call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
      call StartSound(chatSound)
    endif
  endif
endfunction

function DisplayToEnemyChat takes string s returns nothing
  if chatting then
    if IsPlayerEnemy(ai_player,GetLocalPlayer()) then
      call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
      call StartSound(chatSound)
    endif
  endif
endfunction

function DisplayToAlliesDebug takes string s returns nothing
  if debugging then
    if IsPlayerAlly(ai_player,GetLocalPlayer()) then
      call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
      call StartSound(chatSound)
    endif
  endif
endfunction

function DisplayToPlayer takes string s, player p, boolean important returns nothing
  if p == GetLocalPlayer() then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    if important then
      call StartSound(importantSound)
    else
      call StartSound(chatSound)
    endif
  endif
endfunction

function PlayerEx takes integer slot returns player
  return Player(slot-1)
endfunction

function Abs takes integer a returns integer
  if a >= 0 then
    return a
  else
    return -a
  endif
endfunction

function RAbs takes real a returns real
  if a >= 0 then
    return a
  else
    return -a
  endif
endfunction

function Min takes integer A, integer B returns integer
    if A < B then
        return A
    else
        return B
    endif
endfunction

function RMin takes real A, real B returns real
    if A < B then
        return A
    else
        return B
    endif
endfunction

function Max takes integer A, integer B returns integer
    if A > B then
        return A
    else
        return B
    endif
endfunction

function RMax takes real A, real B returns real
    if A > B then
        return A
    else
        return B
    endif
endfunction

function ModuloInteger takes integer dividend, integer divisor returns integer
    local integer modulus = dividend - (dividend / divisor) * divisor

    // If the dividend was negative, the above modulus calculation will
    // be negative, but within (-divisor..0).  We can add (divisor) to
    // shift this result into the desired range of (0..divisor).
    if (modulus < 0) then
        set modulus = modulus + divisor
    endif

    return modulus
endfunction

function ModuloReal takes real dividend, real divisor returns real
    local real modulus = dividend - I2R(R2I(dividend / divisor)) * divisor

    // If the dividend was negative, the above modulus calculation will
    // be negative, but within (-divisor..0).  We can add (divisor) to
    // shift this result into the desired range of (0..divisor).
    if (modulus < 0) then
        set modulus = modulus + divisor
    endif

    return modulus
endfunction

function GetRandomDiff takes integer maxdiff returns integer
  if GetRandomInt(0,1) == 1 then
    return GetRandomInt(0,maxdiff)
  else
    return -GetRandomInt(0,maxdiff)
  endif
endfunction

function LinearInterpolation takes real x1, real x2, real y1, real y2, real p returns real
  local real i = x2 - x1
  if p <= x1 then
    return y1
  elseif p >= x2 then
    return y2
  else
    if i == 0 then
      set i = 1
    endif
    return y1 + ((p - x1)/(i)) * (y2 - y1)
  endif
endfunction

function GetUnitGoldCost2 takes integer id returns integer
  if needed3[id] == UPGRADED then
    return GetUnitGoldCost(old_id[id]) - GetUnitGoldCost(old_id[needed1[id]])
  else
    return GetUnitGoldCost(old_id[id])
  endif
endfunction

function GetUnitWoodCost2 takes integer id returns integer
  if needed3[id] == UPGRADED then
    return GetUnitWoodCost(old_id[id]) - GetUnitWoodCost(old_id[needed1[id]])
  else
    return GetUnitWoodCost(old_id[id])
  endif
endfunction

function GetExpansionPeon2 takes unit u returns unit
  local group g = CreateGroup()

  call GroupEnumUnitsOfPlayer(g, ai_player, null)	
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    exitwhen GetUnitTypeId(u) == old_id[racial_peon] and UnitAlive(u) and (GetUnitCurrentOrder(u) == OrderId("harvest") or GetUnitCurrentOrder(u) == 0) and not IsUnitHidden(u) and not IsUnitLoaded(u)
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  return u
endfunction

function LookupCT takes string s returns string
  //local integer i = StringHash(s)
  local integer i = 0
  //local string storedstring = ""
  //if (i >= JASS_MAX_ARRAY_SIZE) then
  // 	set i = i - (i/(JASS_MAX_ARRAY_SIZE-1) - 1) * JASS_MAX_ARRAY_SIZE
  //set i = i - (i/JASS_MAX_ARRAY_SIZE)*JASS_MAX_ARRAY_SIZE
  //endif

  loop
    exitwhen i >= char_table_length
    if (s == char_bug_table[i]) then
      //call DisplayTimedTextToPlayer(Player(0),0,0,15,message_add+"1:Char Match:" + s + " With stored char:" + char_table[i])
      return char_table[i]
    endif
    set i = i + 1
  endloop

  return ""
  // set storedstring = LoadStr(language_table, CHAR_TABLE, StringHash(s))
    // if (storedstring == null) then
    // return ""
  // else
    // //call DisplayTimedTextToPlayer(Player(0),0,0,15,message_add+"2:Char match:" + s + " With stored char:" + storedstring)
    // return storedstring
  // endif
endfunction

function AddToCT takes string s returns nothing
  local string firstchar = SubString(s,0,1)		// Substring dosn't work in AMAI and returns strange values (but is the same value so we do a comparison of the substring value then return the actual character
  local integer i = 0
  if (firstchar == null) then
    set firstchar = ""
  endif
  set i = StringHash(firstchar)
  //if (i >= JASS_MAX_ARRAY_SIZE) then
  //set i = i - (i/(JASS_MAX_ARRAY_SIZE-1) - 1) * JASS_MAX_ARRAY_SIZE
  //set i = i - (i/JASS_MAX_ARRAY_SIZE)*JASS_MAX_ARRAY_SIZE
  //endif

  set char_bug_table[char_table_length] = firstchar
  set char_table[char_table_length] = s
  set char_table_length = char_table_length + 1
  call SaveStr(language_table, CHAR_TABLE, i, s)
  //call DisplayTimedTextToPlayer(Player(0),0,0,15,message_add+s+" Hash:"+Int2Str(i)+": Returned:"+LoadStr(language_table, CHAR_TABLE, i))
  set firstchar = null
endfunction

function GetChar takes string s, integer num returns string
  local string linechar = SubString(s, num, num + 1)
  return LookupCT(linechar)
endfunction

function InitCT takes nothing returns nothing
  set chat_vars[0] = ""
  call AddToCT(" ")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT(" ")
  call AddToCT("!")
  call AddToCT("$")
  call AddToCT("%")
  call AddToCT("&")
  call AddToCT("'")
  call AddToCT("(")
  call AddToCT(")")
  call AddToCT("*")
  call AddToCT("+")
  call AddToCT(",")
  call AddToCT("-")
  call AddToCT(".")
  call AddToCT("/")
  call AddToCT("0")
  call AddToCT("1")
  call AddToCT("2")
  call AddToCT("3")
  call AddToCT("4")
  call AddToCT("5")
  call AddToCT("6")
  call AddToCT("7")
  call AddToCT("8")
  call AddToCT("9")
  call AddToCT(":")
  call AddToCT(";")
  call AddToCT("<")
  call AddToCT("=")
  call AddToCT(">")
  call AddToCT("?")
  call AddToCT("@")
  call AddToCT("A")
  call AddToCT("B")
  call AddToCT("C")
  call AddToCT("D")
  call AddToCT("E")
  call AddToCT("F")
  call AddToCT("G")
  call AddToCT("H")
  call AddToCT("I")
  call AddToCT("J")
  call AddToCT("K")
  call AddToCT("L")
  call AddToCT("M")
  call AddToCT("N")
  call AddToCT("O")
  call AddToCT("P")
  call AddToCT("Q")
  call AddToCT("R")
  call AddToCT("S")
  call AddToCT("T")
  call AddToCT("U")
  call AddToCT("V")
  call AddToCT("W")
  call AddToCT("X")
  call AddToCT("Y")
  call AddToCT("Z")
  call AddToCT("[")
  call AddToCT("]")
  call AddToCT("^")
  call AddToCT("_")
  call AddToCT("`")
  call AddToCT("a")
  call AddToCT("b")
  call AddToCT("c")
  call AddToCT("d")
  call AddToCT("e")
  call AddToCT("f")
  call AddToCT("g")
  call AddToCT("h")
  call AddToCT("i")
  call AddToCT("j")
  call AddToCT("k")
  call AddToCT("l")
  call AddToCT("m")
  call AddToCT("n")
  call AddToCT("o")
  call AddToCT("p")
  call AddToCT("q")
  call AddToCT("r")
  call AddToCT("s")
  call AddToCT("t")
  call AddToCT("u")
  call AddToCT("v")
  call AddToCT("w")
  call AddToCT("x")
  call AddToCT("y")
  call AddToCT("z")
  call AddToCT("{")
  call AddToCT("|")
  call AddToCT("}")
  call AddToCT("~")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("#")
  call AddToCT("\"") 
  call AddToCT("\\")
  //call AddToCT("{")
  //call AddToCT("}")
endfunction

function SetChatVar takes string key, string value returns nothing
  local integer i = 0 
  //if i == 0 then
  if (HaveSavedInteger(language_table, CHAT_VARS_TABLE, StringHash(key)) == false) then
    set i = chat_vars_length
    set chat_vars_length = chat_vars_length + 1
    //call StoreInteger(chat_vars_map, ai_id, key, i)
    call SaveInteger(language_table, CHAT_VARS_TABLE, StringHash(key), i)
  else
    set i = LoadInteger(language_table, CHAT_VARS_TABLE, StringHash(key))
  endif
  set chat_vars[i] = value
endfunction

function GetChatVar takes string key returns string
  //return chat_vars[GetStoredInteger(chat_vars_map, ai_id, key)]
  return chat_vars[LoadInteger(language_table, CHAT_VARS_TABLE, StringHash(key))]
endfunction

function SetChatVarB takes string key, boolean value returns nothing
  //call StoreBoolean(chat_vars_map, ai_id, key, value)
  call SaveBoolean(language_table, CHAT_VARS_TABLE, StringHash(key+"B"), value)
endfunction

function GetChatVarB takes string key returns boolean
  //return GetStoredBoolean(chat_vars_map, ai_id, key)
  return LoadBoolean(language_table, CHAT_VARS_TABLE, StringHash(key+"B"))
endfunction

function SetChatVarR takes string key, real value returns nothing
  call SaveReal(language_table, CHAT_VARS_TABLE, StringHash(key+"R"), value)
endfunction

function GetChatVarR takes string key returns real
  //return GetStoredReal(chat_vars_map, ai_id, key)
  return LoadReal(language_table, CHAT_VARS_TABLE, StringHash(key+"R"))
endfunction

function ApplyChatVars takes string s_in returns string
  local string s = ""
  local integer i = 0
  local integer l = StringLength(s_in)
  local boolean is_cv = false
  local boolean is_wf = false
  local boolean is_cond = false
  local string key = ""
  local string wf = ""
  local string c = ""
  loop
    exitwhen i >= l
    set c = GetChar(s_in, i)
    if c == "}" then
      set is_cond = false
    elseif is_cond then
    elseif c == "{" then
      set is_cond = true
    elseif c == "[" then
      set is_cv = true
      set key = ""
      set wf = ""
    elseif c == "]" then
      set is_cv = false
      set is_wf = false
      set s = s + ApplyTrans(GetChatVar(key)+wf)
    elseif is_cv then
      if c == ":" then
        set is_cv = false
        set is_wf = true
        set wf = ":"
      else
        set key = key + c
      endif
    elseif is_wf then
      set wf = wf + c
    else
      set s = s + c
    endif
    set i = i + 1
  endloop
  set key = null
  set wf = null
  set c = null
  return s
endfunction

function CompareReal takes real x, real y, integer compare returns boolean
  if compare == COMPARE_GREATER then
    return x > y
  elseif compare == COMPARE_GREATER_EQ then
    return x >= y
  elseif compare == COMPARE_LESS then
    return x < y
  else
    return x <= y
  endif
endfunction

  // local integer i = 1
  // local boolean is_compare = false
  // local integer compare = 0
  // local string key = ""
  // local string value = ""
  // local string c = ""
  // local boolean part_cond = true
  // local boolean not_cond = false
  // local boolean return_bool = false
  // local boolean exitloop = false

  // set chat_eq = COMPARE_TRUE
  // set c = GetChar(s, 0)
  // if c != "{" then
    // set return_bool = true
	 // // call DisplayTimedTextToPlayer(Player(0),0,0,15,message_add+B2S(return_bool)+":"+c)
	// //return true
  // else
  // loop
    // exitwhen (exitloop == true)
    // set c = GetChar(s, i)
    // if c == "}" then
      // if is_compare then
        // if key == "PlayerRace" then
          // set chat_race = value
          // set chat_eq = compare
		  // set return_bool = true
		  // set exitloop = true
          // //return true
        // elseif compare == COMPARE_EQ then
		  // set return_bool = (GetChatVar(key) == value)
		  // set exitloop = true
          // //return GetChatVar(key) == value
        // elseif compare == COMPARE_UNEQ then
		  // set return_bool = (GetChatVar(key) != value)
		  // set exitloop = true
          // //return GetChatVar(key) != value
        // else
		  // set return_bool = CompareReal(GetChatVarR(key), S2R(value), compare)
		  // set exitloop = true
          // //return CompareReal(GetChatVarR(key), S2R(value), compare)
        // endif
      // else
	    // set return_bool = (not_cond != GetChatVarB(key))
		// set exitloop = true
        // //return not_cond != GetChatVarB(key)
      // endif
    // elseif c == "," then
      // if is_compare then
        // if key == "PlayerRace" then
          // set chat_race = value
          // set chat_eq = compare
        // elseif compare == COMPARE_EQ then
          // set part_cond = (GetChatVar(key) == value)
        // elseif compare == COMPARE_UNEQ then
          // set part_cond = (GetChatVar(key) != value)
        // else
          // set part_cond = CompareReal(GetChatVarR(key), S2R(value), compare)
        // endif
      // else
        // set part_cond = (not_cond != GetChatVarB(key))
      // endif
      // if not part_cond then
		// set return_bool = false
		// set exitloop = true
        // //return false
      // else
      // set is_compare = false
      // set not_cond = false
      // set key = ""
      // set value = ""
      // set compare = 0
	  // endif
    // elseif c == "=" then
      // if is_compare then
        // if compare == COMPARE_GREATER then
          // set compare = COMPARE_GREATER_EQ
        // elseif compare == COMPARE_LESS then
          // set compare = COMPARE_LESS_EQ
        // endif
      // else
        // set is_compare = true
        // if not_cond then
          // set compare = COMPARE_UNEQ
        // else
          // set compare = COMPARE_EQ
        // endif
      // endif
    // elseif c == "<" then
      // set is_compare = true
      // set compare = COMPARE_LESS
    // elseif c == ">" then
      // set is_compare = true
      // set compare = COMPARE_GREATER
    // elseif c == "!" then
      // set not_cond = true
    // elseif is_compare then
      // set value = value + c
    // else
      // set key = key + c
    // endif
    // set i = i + 1
  // endloop
  // endif
  // //call DisplayTimedTextToPlayer(Player(0),0,0,15,message_add+B2S(return_bool)+":"+key)
  // return return_bool

function CheckChatCondition takes string s returns boolean
  local integer i = 1
  local boolean is_compare = false
  local integer compare = 0
  local string key = ""
  local string value = ""
  local string c = ""
  local boolean part_cond = true
  local boolean not_cond = false
  local boolean b = false
  set chat_eq = COMPARE_TRUE
  set c = GetChar(s, 0)
  if c != "{" then
    set key = null
    set value = null
    set c = null
    return true
  endif
  loop
    set c = GetChar(s, i)
    if c == "}" then
      if is_compare then
        if key == "PlayerRace" then
          set chat_race = value
          set chat_eq = compare
          set key = null
          set value = null
          set c = null
          return true
        elseif compare == COMPARE_EQ then
          set b = GetChatVar(key) == value
          set key = null
          set value = null
          set c = null
          return b
        elseif compare == COMPARE_UNEQ then
          set b = GetChatVar(key) != value
          set key = null
          set value = null
          set c = null
          return b
        else
          set b = CompareReal(GetChatVarR(key), S2R(value), compare)
          set key = null
          set value = null
          set c = null
          return b
        endif
      else
        set b = not_cond != GetChatVarB(key)
        set key = null
        set value = null
        set c = null
        return b
      endif
    elseif c == "," then
      if is_compare then
        if key == "PlayerRace" then
          set chat_race = value
          set chat_eq = compare
        elseif compare == COMPARE_EQ then
          set part_cond = GetChatVar(key) == value
        elseif compare == COMPARE_UNEQ then
          set part_cond = GetChatVar(key) != value
        else
          set part_cond = CompareReal(GetChatVarR(key), S2R(value), compare)
        endif
      else
        set part_cond = not_cond != GetChatVarB(key)
      endif
      if not part_cond then
        set key = null
        set value = null
        set c = null
        return false
      endif
      set is_compare = false
      set not_cond = false
      set key = ""
      set value = ""
      set compare = 0
    elseif c == "=" then
      if is_compare then
        if compare == COMPARE_GREATER then
          set compare = COMPARE_GREATER_EQ
        elseif compare == COMPARE_LESS then
          set compare = COMPARE_LESS_EQ
        endif
      else
        set is_compare = true
        if not_cond then
          set compare = COMPARE_UNEQ
        else
          set compare = COMPARE_EQ
        endif
      endif
    elseif c == "<" then
      set is_compare = true
      set compare = COMPARE_LESS
    elseif c == ">" then
      set is_compare = true
      set compare = COMPARE_GREATER
    elseif c == "!" then
      set not_cond = true
    elseif is_compare then
      set value = value + c
    else
      set key = key + c
    endif
    set i = i + 1
  endloop
  set key = null
  set value = null
  set c = null
  return false
endfunction

function ApplyChatConditions takes nothing returns nothing
  local integer i = 0
  local integer free = 0
  loop
    exitwhen i >= chat_list_length
    call SetChatVarR("Random",GetRandomReal(0,100))
    if CheckChatCondition(chat_list[i]) then
      set chat_list[free] = chat_list[i]
      set chat_list_race[free] = chat_race
      set chat_list_eq[free] = chat_eq
      set free = free + 1
    endif
    set i = i + 1
  endloop
  set chat_list_length = free
endfunction

   // Global Functions that are used in both AMAI and standard ai

function GetAMAIId takes integer id returns integer   
	local integer i = 0
	loop
		exitwhen i > OBJECT_NUM
		if old_id[i] == id then
			call Trace("Returned AMAI id - " + Int2Str(i) + ":" + UnitId2String(old_id[i]) + " for " + UnitId2String(id))
			return i
		endif
		set i = i + 1
	endloop
	call Trace("Couldn't get AMAI id - " + UnitId2String(id))
	return 0
endfunction

function GetGold takes nothing returns integer
  return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_GOLD)
endfunction

function GetWood takes nothing returns integer
  return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_LUMBER)
endfunction

function InitDefenseGroup takes nothing returns nothing
  set defense_length = 0
endfunction

function InitAssaultGroup takes nothing returns nothing
	if IsAMAI then
		set attack_length = 0
	else
		set harass_length = 0
	endif
endfunction

function GetUnitCountEx takes integer unitid, boolean only_done, integer townid returns integer

  if unitid == 0 then // can happen but lets speed up calculation a little instead of running the functions
    return 0
  endif

  if IsAMAI then
    if townid == -1 then
      if only_done then
        return GetUnitCountDone(old_id[unitid])
      else
        return GetUnitCount(old_id[unitid])
      endif
    else
      return GetTownUnitCount(old_id[unitid],townid,only_done)
    endif
  else
    if townid == -1 then
      if only_done then
        return GetUnitCountDone(unitid)
      else
        return GetUnitCount(unitid)
      endif
    else
      return GetTownUnitCount(unitid,townid,only_done)
    endif
  endif
endfunction

function TownCountEx takes integer unitid, boolean only_done, integer townid returns integer
  local integer have_qty = 0
  local integer newid = 0

  if IsAMAI then
    set have_qty = GetUnitCountEx(unitid,only_done,townid) + GetUnitCountEx(tc_add1[unitid],false,townid) + GetUnitCountEx(tc_add2[unitid],false,townid)
  else
    //set newid = GetAMAIId(unitid)
    //set have_qty = GetUnitCountEx(unitid,only_done,townid) + GetUnitCountEx(tc_add1[newid],false,townid) + GetUnitCountEx(tc_add2[newid],false,townid)
    set have_qty = GetUnitCountEx(unitid,only_done,townid)
    if unitid == PEASANT then
      set have_qty = have_qty + GetUnitCountEx(MILITIA,false,townid) + GetUnitCountEx(0, false,townid)
    endif
    if unitid == MILITIA then
      set have_qty = have_qty + GetUnitCountEx(PEASANT,false,townid) + GetUnitCountEx(0, false,townid)
    endif
    if unitid == KEEP then
      set have_qty = have_qty + GetUnitCountEx(CASTLE,false,townid) + GetUnitCountEx(0, false,townid)
    endif
    if unitid == TOWN_HALL then
      set have_qty = have_qty + GetUnitCountEx(KEEP,false,townid) + GetUnitCountEx(CASTLE, false,townid)
    endif
    if unitid == WATCH_TOWER then
      set have_qty = have_qty + GetUnitCountEx(GUARD_TOWER,false,townid) + GetUnitCountEx(CANNON_TOWER, false,townid)
    endif
    if unitid == GREAT_HALL then
      set have_qty = have_qty + GetUnitCountEx(STRONGHOLD,false,townid) + GetUnitCountEx(FORTRESS, false,townid)
    endif
    if unitid == STRONGHOLD then
      set have_qty = have_qty + GetUnitCountEx(FORTRESS,false,townid) + GetUnitCountEx(0, false,townid)
    endif
    if unitid == GARGOYLE then
      set have_qty = have_qty + GetUnitCountEx(0,false,townid) + GetUnitCountEx(GARGOYLE_MORPH, false,townid)
    endif
    if unitid == GARGOYLE_MORPH then
      set have_qty = have_qty + GetUnitCountEx(0,false,townid) + GetUnitCountEx(GARGOYLE, false,townid)
    endif
    if unitid == NECROPOLIS_1 then
      set have_qty = have_qty + GetUnitCountEx(NECROPOLIS_2,false,townid) + GetUnitCountEx(NECROPOLIS_3, false,townid)
    endif
    if unitid == NECROPOLIS_2 then
      set have_qty = have_qty + GetUnitCountEx(NECROPOLIS_3,false,townid) + GetUnitCountEx(0, false,townid)
    endif
    if unitid == ZIGGURAT_1 then
      set have_qty = have_qty + GetUnitCountEx(ZIGGURAT_2,false,townid) + GetUnitCountEx(0, false,townid)
    endif
    if unitid == DRUID_TALON then
      set have_qty = have_qty + GetUnitCountEx(0,false,townid) + GetUnitCountEx(DRUID_TALON_M, false,townid)
    endif
    if unitid == DRUID_TALON_M then
      set have_qty = have_qty + GetUnitCountEx(0,false,townid) + GetUnitCountEx(DRUID_TALON, false,townid)
    endif
    if unitid == DRUID_CLAW then
      set have_qty = have_qty + GetUnitCountEx(0,false,townid) + GetUnitCountEx(DRUID_CLAW_M, false,townid)
    endif
    if unitid == DRUID_CLAW_M then
      set have_qty = have_qty + GetUnitCountEx(0,false,townid) + GetUnitCountEx(DRUID_CLAW, false,townid)
    endif
    if unitid == TREE_AGES then
      set have_qty = have_qty + GetUnitCountEx(TREE_ETERNITY,false,townid) + GetUnitCountEx(0, false,townid)
    endif
    if unitid == TREE_LIFE then
      set have_qty = have_qty + GetUnitCountEx(TREE_AGES,false,townid) + GetUnitCountEx(TREE_ETERNITY, false,townid)
    endif
    if unitid == ILLIDAN_DEMON then
      set have_qty = have_qty + GetUnitCountEx(ILLIDAN,false,townid) + GetUnitCountEx(0, false,townid)
    endif
  endif

  return have_qty

endfunction

function TownCountDone takes integer base returns integer
  return TownCountEx(base,true,-1)
endfunction

function TownCount takes integer base returns integer
  return TownCountEx(base,false,-1)
endfunction

function TownCountTown takes integer base, integer townid returns integer
  return TownCountEx(base,false,townid)
endfunction

function HallsCompleted takes integer unitid returns boolean
  if IsAMAI then
    return GetUnitCount(old_id[unitid]) == GetUnitCountDone(old_id[unitid]) 
  endif
  return GetUnitCount(unitid) == GetUnitCountDone(unitid)
endfunction

function StaggerSleep takes real base, real spread returns nothing
  call Sleep(base + spread * I2R(GetAiPlayer()) / I2R(GetPlayers()))
endfunction

function FoodUsed takes nothing returns integer
  return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_FOOD_USED)
endfunction

function FoodCap takes nothing returns integer
  return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_FOOD_CAP)
endfunction

function FoodSpace takes nothing returns integer
  return FoodCap() - FoodUsed()
endfunction

function FoodAvail takes integer base returns integer
  return GetFoodMade(old_id[racial_farm]) * TownCount(racial_farm) + GetFoodMade(old_id[base]) * TownCount(base)
endfunction



function InitMapSizeVars takes nothing returns nothing
  local real x = path_right - path_left
  local real y = path_top - path_bottom
  local real a = (x/1000)*(y/1000)
  call SetChatVarR("MapSizeX", x)
  call SetChatVarR("MapSizeY", y)
  if a < 90 then
    call SetChatVar("MapSize", "extrasmall")
    set mapSize = 0
  elseif a < 120 then
    call SetChatVar("MapSize", "tiny")
    set mapSize = 1
  elseif a < 240 then
    call SetChatVar("MapSize", "small")
    set mapSize = 2
  elseif a < 380 then
    call SetChatVar("MapSize", "medium")
    set mapSize = 3
  elseif a < 540 then
    call SetChatVar("MapSize", "large")
    set mapSize = 4
  elseif a < 960 then
    call SetChatVar("MapSize", "extralarge")
    set mapSize = 5
  elseif a < 2048 then
    call SetChatVar("MapSize", "huge")
    set mapSize = 6
  else
    call SetChatVar("MapSize", "legendary")
    set mapSize = 7
  endif
endfunction

function InitDifficultyVars takes nothing returns nothing
  if difficulty == HARD then
    call SetChatVar("Difficulty", "Insane")
  elseif difficulty == NORMAL then
    call SetChatVar("Difficulty", "Normal")
  else
    call SetChatVar("Difficulty", "Easy")
  endif
  call SetChatVarR("Handicap", GetPlayerHandicap(ai_player))
endfunction

function InitChatVars takes nothing returns nothing
  call SetChatVar("Race", race_name[own_race])
  call SetChatVar("Color", ColorText(ai_player))
  call SetChatVarR("PlayerNum", c_ally_total + c_enemy_total + 1)
  call SetChatVar("PlayerNum", Int2Str(c_ally_total + c_enemy_total + 1))
  call SetChatVarB("1vs1", game_is_1on1)
  call SetChatVarB("FFA", game_is_ffa)
  call SetChatVarB("RaceChoiceRandom", player_race_pref[GetAiPlayer()] == R_RANDOM)
  call SetChatVar("MaxPlayerNum", Int2Str(GetPlayers()))
  call SetChatVarR("MaxPlayerNum", GetPlayers())
  call InitMapSizeVars()
  call InitDifficultyVars()
endfunction

function SetChatVarsPlayer takes player p returns nothing
  call SetChatVar("PlayerRace", race_name[player_race[GetPlayerId(p)]])
  call SetChatVar("PlayerColor", ColorText(p))
endfunction



function AIGetProjectedLoc takes location src, location targ, real distance, real deltaAngle returns location
  local real srcX = GetLocationX(src)
  local real srcY = GetLocationY(src)
  local real direction = Atan2(GetLocationY(targ) - srcY, GetLocationX(targ) - srcX) + deltaAngle
  return Location(srcX + distance * Cos(direction), srcY + distance * Sin(direction))
endfunction

function GetSumLoc takes location l1, location l2 returns location
  return Location(GetLocationX(l1) + GetLocationX(l2), GetLocationY(l1) + GetLocationY(l2))
endfunction
function GetSumLoc_dd takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) + GetLocationX(l2)
  local real locY = GetLocationY(l1) + GetLocationY(l2)  
  call RemoveLocation(l1)
  call RemoveLocation(l2)
  return Location(locX, locY)
endfunction
function GetSumLoc_kd takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) + GetLocationX(l2)
  local real locY = GetLocationY(l1) + GetLocationY(l2)  
  call RemoveLocation(l2)
  return Location(locX, locY)
endfunction
function GetSumLoc_dk takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) + GetLocationX(l2)
  local real locY = GetLocationY(l1) + GetLocationY(l2)  
  call RemoveLocation(l1)
  return Location(locX, locY)
endfunction

function GetSubtractionLoc takes location l1, location l2 returns location
  return Location(GetLocationX(l1) - GetLocationX(l2), GetLocationY(l1) - GetLocationY(l2))
endfunction

function GetSubtractionLoc_dd takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) - GetLocationX(l2)
  local real locY = GetLocationY(l1) - GetLocationY(l2)  
  call RemoveLocation(l1)
  call RemoveLocation(l2)
  return Location(locX, locY)
endfunction
function GetSubtractionLoc_kd takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) - GetLocationX(l2)
  local real locY = GetLocationY(l1) - GetLocationY(l2)  
  call RemoveLocation(l2)
  return Location(locX, locY)
endfunction
function GetSubtractionLoc_dk takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) - GetLocationX(l2)
  local real locY = GetLocationY(l1) - GetLocationY(l2)  
  call RemoveLocation(l1)
  return Location(locX, locY)
endfunction

function GetMultipleLoc takes location l, real m returns location
  return Location(GetLocationX(l) * m, GetLocationY(l) * m)
endfunction

function GetMultipleLoc_d takes location l, real m returns location
  local real locX = GetLocationX(l) * m 
  local real locY = GetLocationY(l) * m  
  call RemoveLocation(l)
  return Location(locX, locY)
endfunction

function GetDivisionLoc takes location l, real d returns location
  return Location(GetLocationX(l) / d, GetLocationY(l) / d)
endfunction

function GetDivisionLoc_d takes location l, real d returns location
  local real locX = GetLocationX(l) / d 
  local real locY = GetLocationY(l) / d  
  call RemoveLocation(l)
  return Location(locX, locY)
endfunction

function GetLengthOfLoc takes location l returns real
  local real x = GetLocationX(l)
  local real y = GetLocationY(l)
  return SquareRoot(x * x + y * y)
endfunction

function GetLengthOfLoc_d takes location l returns real
  local real x = GetLocationX(l)
  local real y = GetLocationY(l)
  call RemoveLocation(l)
  return SquareRoot(x * x + y * y)
endfunction

function GetNormalisedLoc takes location l returns location
  return GetDivisionLoc(l, RMax(GetLengthOfLoc(l),1.00))
endfunction

function GetNormalisedLoc_d takes location l returns location
  return GetDivisionLoc_d(l, RMax(GetLengthOfLoc(l),1.00))
endfunction

function GetProjectedLoc takes location l, location v, real r returns location
  local location loc = GetNormalisedLoc(v)
  local location loc2 = GetMultipleLoc_d(loc, r)
  local location returnloc = GetSumLoc_kd(l, loc2)
  local real x = GetLocationX(returnloc)
  local real y = GetLocationY(returnloc)
  set loc = null
  set loc2 = null
  call RemoveLocation(returnloc)
  set returnloc = null
  return Location(x, y)
endfunction

function GetProjectedLoc_dd takes location l, location v, real r returns location
  local location loc = GetNormalisedLoc_d(v)
  local location loc2 = GetMultipleLoc_d(loc, r)
  local location returnloc = GetSumLoc_dd(l, loc2)
  local real x = GetLocationX(returnloc)
  local real y = GetLocationY(returnloc)
  set loc = null
  set loc2 = null
  call RemoveLocation(returnloc)
  set returnloc = null
  return Location(x, y)
endfunction

function l_smult_kk takes location l1, location l2 returns real
  return GetLocationX(l1) * GetLocationX(l2) + GetLocationY(l1) * GetLocationY(l2)
endfunction

function GetAngleBetweenLocs takes location l1, location l2 returns real
  local real i = GetLengthOfLoc(l1) * GetLengthOfLoc(l2)
  if i == 0 then
    set i = 1
  endif
  return Acos(l_smult_kk(l1, l2) / i)
endfunction

function set_profiles takes nothing returns nothing

    set profilename[0] = "Hunter"
    set p_race[0] = R_RANDOM
    set p_aggression[0] = -10
    set p_uncertainty[0] = 10
    set p_minimum_attack_strength[0] = 7
    set p_farm_food[0] = 8
    set p_exp_first_time[0] = 6
    set p_exp_second_time[0] = 18
    set p_strat_persistence[0] = 1000
    set p_gold_unit_percentage[0] = 1.35
    set p_taunt_rate[0] = 1
    set p_expansion_target_bonus[0] = 7
    set p_comp_chosen_target_bonus[0] = 5
    set p_comp_chosen_target_rate[0] = 0.5
    set p_surrender[0] = 1

    set fav_hero[0] = MOON_CHICK
    set fav_hero[1] = PALADIN
    set fav_hero[2] = FAR_SEER
    set fav_hero[3] = DREAD_LORD
    set fav_hero[4] = 0

    set fav_unit[0] = HUNTRESS
    set fav_unit[1] = GRYPHON
    set fav_unit[2] = GRUNT
    set fav_unit[3] = GHOUL
    set p_rare[0] = 0

    set profilename[1] = "Crazy_Rusher"
    set p_race[1] = R_RANDOM
    set p_aggression[1] = 5
    set p_uncertainty[1] = 5
    set p_minimum_attack_strength[1] = 6
    set p_farm_food[1] = 7
    set p_exp_first_time[1] = 7
    set p_exp_second_time[1] = 12
    set p_strat_persistence[1] = 800
    set p_gold_unit_percentage[1] = 1.3
    set p_taunt_rate[1] = 1
    set p_expansion_target_bonus[1] = 8
    set p_comp_chosen_target_bonus[1] = 4
    set p_comp_chosen_target_rate[1] = 0.4
    set p_surrender[1] = 1

    set fav_hero[5] = DEMON_HUNTER
    set fav_hero[6] = MTN_KING
    set fav_hero[7] = FAR_SEER
    set fav_hero[8] = DEATH_KNIGHT
    set fav_hero[9] = 0

    set fav_unit[4] = ARCHER
    set fav_unit[5] = KNIGHT
    set fav_unit[6] = GRUNT
    set fav_unit[7] = GHOUL
    set p_rare[1] = 0

    set profilename[2] = "Crusher"
    set p_race[2] = R_RANDOM
    set p_aggression[2] = -6
    set p_uncertainty[2] = 7
    set p_minimum_attack_strength[2] = 7
    set p_farm_food[2] = 9
    set p_exp_first_time[2] = 6
    set p_exp_second_time[2] = 12
    set p_strat_persistence[2] = 900
    set p_gold_unit_percentage[2] = 1.35
    set p_taunt_rate[2] = 1
    set p_expansion_target_bonus[2] = 12
    set p_comp_chosen_target_bonus[2] = 6
    set p_comp_chosen_target_rate[2] = 0.6
    set p_surrender[2] = 1

    set fav_hero[10] = DEMON_HUNTER
    set fav_hero[11] = ARCHMAGE
    set fav_hero[12] = BLADE_MASTER
    set fav_hero[13] = DREAD_LORD
    set fav_hero[14] = 0

    set fav_unit[8] = HUNTRESS
    set fav_unit[9] = KNIGHT
    set fav_unit[10] = WYVERN
    set fav_unit[11] = GHOUL
    set p_rare[2] = 0

    set profilename[3] = "Zmasher"
    set p_race[3] = R_RANDOM
    set p_aggression[3] = -8
    set p_uncertainty[3] = 8
    set p_minimum_attack_strength[3] = 8
    set p_farm_food[3] = 8
    set p_exp_first_time[3] = 6
    set p_exp_second_time[3] = 12
    set p_strat_persistence[3] = 850
    set p_gold_unit_percentage[3] = 1.35
    set p_taunt_rate[3] = 1
    set p_expansion_target_bonus[3] = 5
    set p_comp_chosen_target_bonus[3] = 4
    set p_comp_chosen_target_rate[3] = 0.4
    set p_surrender[3] = 1

    set fav_hero[15] = MOON_CHICK
    set fav_hero[16] = ARCHMAGE
    set fav_hero[17] = FAR_SEER
    set fav_hero[18] = LICH
    set fav_hero[19] = 0

    set fav_unit[12] = HUNTRESS
    set fav_unit[13] = GRYPHON
    set fav_unit[14] = GRUNT
    set fav_unit[15] = CRYPT_FIEND
    set p_rare[3] = 0

    set profilename[4] = "Aggressario"
    set p_race[4] = R_RANDOM
    set p_aggression[4] = -2
    set p_uncertainty[4] = 6
    set p_minimum_attack_strength[4] = 8
    set p_farm_food[4] = 9
    set p_exp_first_time[4] = 7
    set p_exp_second_time[4] = 15
    set p_strat_persistence[4] = 1000
    set p_gold_unit_percentage[4] = 1.35
    set p_taunt_rate[4] = 1
    set p_expansion_target_bonus[4] = 12
    set p_comp_chosen_target_bonus[4] = 7
    set p_comp_chosen_target_rate[4] = 0.3
    set p_surrender[4] = 1

    set fav_hero[20] = KEEPER
    set fav_hero[21] = ARCHMAGE
    set fav_hero[22] = TAUREN_CHIEF
    set fav_hero[23] = DEATH_KNIGHT
    set fav_hero[24] = 0

    set fav_unit[16] = HUNTRESS
    set fav_unit[17] = RIFLEMAN
    set fav_unit[18] = GRUNT
    set fav_unit[19] = GHOUL
    set p_rare[4] = 0

    set profilename[5] = "chick3n"
    set p_race[5] = R_RANDOM
    set p_aggression[5] = -15
    set p_uncertainty[5] = 4
    set p_minimum_attack_strength[5] = 7
    set p_farm_food[5] = 10
    set p_exp_first_time[5] = 7
    set p_exp_second_time[5] = 16
    set p_strat_persistence[5] = 1050
    set p_gold_unit_percentage[5] = 1.3
    set p_taunt_rate[5] = 1
    set p_expansion_target_bonus[5] = 3
    set p_comp_chosen_target_bonus[5] = 3
    set p_comp_chosen_target_rate[5] = 0.8
    set p_surrender[5] = 1

    set fav_hero[25] = DEMON_HUNTER
    set fav_hero[26] = MTN_KING
    set fav_hero[27] = FAR_SEER
    set fav_hero[28] = DREAD_LORD
    set fav_hero[29] = 0

    set fav_unit[20] = ARCHER
    set fav_unit[21] = MORTAR
    set fav_unit[22] = GRUNT
    set fav_unit[23] = GHOUL
    set p_rare[5] = 0

    set profilename[6] = "CPU"
    set p_race[6] = R_RANDOM
    set p_aggression[6] = -9
    set p_uncertainty[6] = 5
    set p_minimum_attack_strength[6] = 7
    set p_farm_food[6] = 9
    set p_exp_first_time[6] = 64
    set p_exp_second_time[6] = 180
    set p_strat_persistence[6] = 850
    set p_gold_unit_percentage[6] = 1.35
    set p_taunt_rate[6] = 1
    set p_expansion_target_bonus[6] = 8
    set p_comp_chosen_target_bonus[6] = 6
    set p_comp_chosen_target_rate[6] = 0.5
    set p_surrender[6] = 1

    set fav_hero[30] = DEMON_HUNTER
    set fav_hero[31] = ARCHMAGE
    set fav_hero[32] = BLADE_MASTER
    set fav_hero[33] = DREAD_LORD
    set fav_hero[34] = 0

    set fav_unit[24] = HUNTRESS
    set fav_unit[25] = KNIGHT
    set fav_unit[26] = GRUNT
    set fav_unit[27] = GHOUL
    set p_rare[6] = 0

    set profilename[7] = "ErRoR"
    set p_race[7] = R_RANDOM
    set p_aggression[7] = -10
    set p_uncertainty[7] = 7
    set p_minimum_attack_strength[7] = 8
    set p_farm_food[7] = 8
    set p_exp_first_time[7] = 7
    set p_exp_second_time[7] = 13
    set p_strat_persistence[7] = 900
    set p_gold_unit_percentage[7] = 1.4
    set p_taunt_rate[7] = 1
    set p_expansion_target_bonus[7] = 7
    set p_comp_chosen_target_bonus[7] = 7
    set p_comp_chosen_target_rate[7] = 0.6
    set p_surrender[7] = 1

    set fav_hero[35] = MOON_CHICK
    set fav_hero[36] = ARCHMAGE
    set fav_hero[37] = FAR_SEER
    set fav_hero[38] = DEATH_KNIGHT
    set fav_hero[39] = 0

    set fav_unit[28] = HUNTRESS
    set fav_unit[29] = GRYPHON
    set fav_unit[30] = CATAPULT
    set fav_unit[31] = CRYPT_FIEND
    set p_rare[7] = 0

    set profilename[8] = "RomuLus"
    set p_race[8] = R_RANDOM
    set p_aggression[8] = -11
    set p_uncertainty[8] = 4
    set p_minimum_attack_strength[8] = 7
    set p_farm_food[8] = 7
    set p_exp_first_time[8] = 6
    set p_exp_second_time[8] = 12
    set p_strat_persistence[8] = 750
    set p_gold_unit_percentage[8] = 1.35
    set p_taunt_rate[8] = 1
    set p_expansion_target_bonus[8] = 7
    set p_comp_chosen_target_bonus[8] = 3
    set p_comp_chosen_target_rate[8] = 0.5
    set p_surrender[8] = 1

    set fav_hero[40] = KEEPER
    set fav_hero[41] = MTN_KING
    set fav_hero[42] = FAR_SEER
    set fav_hero[43] = LICH
    set fav_hero[44] = 0

    set fav_unit[32] = HUNTRESS
    set fav_unit[33] = KNIGHT
    set fav_unit[34] = WYVERN
    set fav_unit[35] = NECRO
    set p_rare[8] = 0

    set profilename[9] = "ReMus"
    set p_race[9] = R_RANDOM
    set p_aggression[9] = -11
    set p_uncertainty[9] = 5
    set p_minimum_attack_strength[9] = 8
    set p_farm_food[9] = 6
    set p_exp_first_time[9] = 6
    set p_exp_second_time[9] = 14
    set p_strat_persistence[9] = 900
    set p_gold_unit_percentage[9] = 1.35
    set p_taunt_rate[9] = 1
    set p_expansion_target_bonus[9] = 8
    set p_comp_chosen_target_bonus[9] = 4
    set p_comp_chosen_target_rate[9] = 0.5
    set p_surrender[9] = 1

    set fav_hero[45] = DEMON_HUNTER
    set fav_hero[46] = ARCHMAGE
    set fav_hero[47] = FAR_SEER
    set fav_hero[48] = DEATH_KNIGHT
    set fav_hero[49] = 0

    set fav_unit[36] = DRYAD
    set fav_unit[37] = RIFLEMAN
    set fav_unit[38] = TAUREN
    set fav_unit[39] = CRYPT_FIEND
    set p_rare[9] = 0

    set profilename[10] = "Xerox"
    set p_race[10] = R_RANDOM
    set p_aggression[10] = -7
    set p_uncertainty[10] = 9
    set p_minimum_attack_strength[10] = 7
    set p_farm_food[10] = 10
    set p_exp_first_time[10] = 6
    set p_exp_second_time[10] = 12
    set p_strat_persistence[10] = 950
    set p_gold_unit_percentage[10] = 1.3
    set p_taunt_rate[10] = 1
    set p_expansion_target_bonus[10] = 12
    set p_comp_chosen_target_bonus[10] = 5
    set p_comp_chosen_target_rate[10] = 0.6
    set p_surrender[10] = 1

    set fav_hero[50] = DEMON_HUNTER
    set fav_hero[51] = ARCHMAGE
    set fav_hero[52] = FAR_SEER
    set fav_hero[53] = DREAD_LORD
    set fav_hero[54] = 0

    set fav_unit[40] = HUNTRESS
    set fav_unit[41] = KNIGHT
    set fav_unit[42] = GRUNT
    set fav_unit[43] = CRYPT_FIEND
    set p_rare[10] = 0

    set profilename[11] = "Xenon"
    set p_race[11] = R_RANDOM
    set p_aggression[11] = -7
    set p_uncertainty[11] = 8
    set p_minimum_attack_strength[11] = 7
    set p_farm_food[11] = 8
    set p_exp_first_time[11] = 7
    set p_exp_second_time[11] = 12
    set p_strat_persistence[11] = 900
    set p_gold_unit_percentage[11] = 1.4
    set p_taunt_rate[11] = 1
    set p_expansion_target_bonus[11] = 11
    set p_comp_chosen_target_bonus[11] = 6
    set p_comp_chosen_target_rate[11] = 0.4
    set p_surrender[11] = 1

    set fav_hero[55] = KEEPER
    set fav_hero[56] = ARCHMAGE
    set fav_hero[57] = TAUREN_CHIEF
    set fav_hero[58] = DREAD_LORD
    set fav_hero[59] = 0

    set fav_unit[44] = ARCHER
    set fav_unit[45] = GRYPHON
    set fav_unit[46] = GRUNT
    set fav_unit[47] = GHOUL
    set p_rare[11] = 0

    set profilename[12] = "Zitrax"
    set p_race[12] = R_RANDOM
    set p_aggression[12] = -9
    set p_uncertainty[12] = 11
    set p_minimum_attack_strength[12] = 7
    set p_farm_food[12] = 8
    set p_exp_first_time[12] = 6
    set p_exp_second_time[12] = 17
    set p_strat_persistence[12] = 850
    set p_gold_unit_percentage[12] = 1.35
    set p_taunt_rate[12] = 1
    set p_expansion_target_bonus[12] = 5
    set p_comp_chosen_target_bonus[12] = 8
    set p_comp_chosen_target_rate[12] = 0.6
    set p_surrender[12] = 1

    set fav_hero[60] = MOON_CHICK
    set fav_hero[61] = MTN_KING
    set fav_hero[62] = FAR_SEER
    set fav_hero[63] = DEATH_KNIGHT
    set fav_hero[64] = 0

    set fav_unit[48] = HUNTRESS
    set fav_unit[49] = RIFLEMAN
    set fav_unit[50] = HEAD_HUNTER
    set fav_unit[51] = GHOUL
    set p_rare[12] = 0

    set profilename[13] = "Menace"
    set p_race[13] = R_RANDOM
    set p_aggression[13] = -11
    set p_uncertainty[13] = 12
    set p_minimum_attack_strength[13] = 6
    set p_farm_food[13] = 9
    set p_exp_first_time[13] = 7
    set p_exp_second_time[13] = 17
    set p_strat_persistence[13] = 950
    set p_gold_unit_percentage[13] = 1.35
    set p_taunt_rate[13] = 1
    set p_expansion_target_bonus[13] = 6
    set p_comp_chosen_target_bonus[13] = 6
    set p_comp_chosen_target_rate[13] = 0.7
    set p_surrender[13] = 1

    set fav_hero[65] = KEEPER
    set fav_hero[66] = ARCHMAGE
    set fav_hero[67] = BLADE_MASTER
    set fav_hero[68] = DEATH_KNIGHT
    set fav_hero[69] = 0

    set fav_unit[52] = HUNTRESS
    set fav_unit[53] = MORTAR
    set fav_unit[54] = GRUNT
    set fav_unit[55] = FROST_WYRM
    set p_rare[13] = 0

    set profilename[14] = "Razkal"
    set p_race[14] = R_RANDOM
    set p_aggression[14] = -8
    set p_uncertainty[14] = 8
    set p_minimum_attack_strength[14] = 7
    set p_farm_food[14] = 6
    set p_exp_first_time[14] = 6
    set p_exp_second_time[14] = 12
    set p_strat_persistence[14] = 970
    set p_gold_unit_percentage[14] = 1.3
    set p_taunt_rate[14] = 1
    set p_expansion_target_bonus[14] = 7
    set p_comp_chosen_target_bonus[14] = 7
    set p_comp_chosen_target_rate[14] = 0.6
    set p_surrender[14] = 1

    set fav_hero[70] = DEMON_HUNTER
    set fav_hero[71] = ARCHMAGE
    set fav_hero[72] = FAR_SEER
    set fav_hero[73] = DEATH_KNIGHT
    set fav_hero[74] = 0

    set fav_unit[56] = DRYAD
    set fav_unit[57] = KNIGHT
    set fav_unit[58] = WYVERN
    set fav_unit[59] = NECRO
    set p_rare[14] = 0

    set profilename[15] = "Terra"
    set p_race[15] = R_RANDOM
    set p_aggression[15] = -9
    set p_uncertainty[15] = 7
    set p_minimum_attack_strength[15] = 7
    set p_farm_food[15] = 9
    set p_exp_first_time[15] = 6
    set p_exp_second_time[15] = 14
    set p_strat_persistence[15] = 980
    set p_gold_unit_percentage[15] = 1.4
    set p_taunt_rate[15] = 1
    set p_expansion_target_bonus[15] = 5
    set p_comp_chosen_target_bonus[15] = 8
    set p_comp_chosen_target_rate[15] = 0.5
    set p_surrender[15] = 1

    set fav_hero[75] = DEMON_HUNTER
    set fav_hero[76] = MTN_KING
    set fav_hero[77] = FAR_SEER
    set fav_hero[78] = LICH
    set fav_hero[79] = 0

    set fav_unit[60] = HUNTRESS
    set fav_unit[61] = GRYPHON
    set fav_unit[62] = CATAPULT
    set fav_unit[63] = CRYPT_FIEND
    set p_rare[15] = 0

    set profilename[16] = "Utopio"
    set p_race[16] = R_RANDOM
    set p_aggression[16] = -8
    set p_uncertainty[16] = 9
    set p_minimum_attack_strength[16] = 8
    set p_farm_food[16] = 8
    set p_exp_first_time[16] = 6
    set p_exp_second_time[16] = 15
    set p_strat_persistence[16] = 970
    set p_gold_unit_percentage[16] = 1.35
    set p_taunt_rate[16] = 1
    set p_expansion_target_bonus[16] = 8
    set p_comp_chosen_target_bonus[16] = 5
    set p_comp_chosen_target_rate[16] = 0.4
    set p_surrender[16] = 1

    set fav_hero[80] = KEEPER
    set fav_hero[81] = ARCHMAGE
    set fav_hero[82] = FAR_SEER
    set fav_hero[83] = DEATH_KNIGHT
    set fav_hero[84] = 0

    set fav_unit[64] = DRUID_CLAW
    set fav_unit[65] = RIFLEMAN
    set fav_unit[66] = WYVERN
    set fav_unit[67] = GHOUL
    set p_rare[16] = 0

    set profilename[17] = "Q"
    set p_race[17] = R_RANDOM
    set p_aggression[17] = -11
    set p_uncertainty[17] = 8
    set p_minimum_attack_strength[17] = 7
    set p_farm_food[17] = 7
    set p_exp_first_time[17] = 7
    set p_exp_second_time[17] = 16
    set p_strat_persistence[17] = 985
    set p_gold_unit_percentage[17] = 1.3
    set p_taunt_rate[17] = 1
    set p_expansion_target_bonus[17] = 9
    set p_comp_chosen_target_bonus[17] = 6
    set p_comp_chosen_target_rate[17] = 0.5
    set p_surrender[17] = 1

    set fav_hero[85] = MOON_CHICK
    set fav_hero[86] = MTN_KING
    set fav_hero[87] = FAR_SEER
    set fav_hero[88] = DEATH_KNIGHT
    set fav_hero[89] = 0

    set fav_unit[68] = HUNTRESS
    set fav_unit[69] = KNIGHT
    set fav_unit[70] = HEAD_HUNTER
    set fav_unit[71] = CRYPT_FIEND
    set p_rare[17] = 0

    set profilename[18] = "MaTrIx"
    set p_race[18] = R_RANDOM
    set p_aggression[18] = -10
    set p_uncertainty[18] = 5
    set p_minimum_attack_strength[18] = 7
    set p_farm_food[18] = 10
    set p_exp_first_time[18] = 7
    set p_exp_second_time[18] = 14
    set p_strat_persistence[18] = 970
    set p_gold_unit_percentage[18] = 1.4
    set p_taunt_rate[18] = 1
    set p_expansion_target_bonus[18] = 5
    set p_comp_chosen_target_bonus[18] = 8
    set p_comp_chosen_target_rate[18] = 0.6
    set p_surrender[18] = 1

    set fav_hero[90] = DEMON_HUNTER
    set fav_hero[91] = MTN_KING
    set fav_hero[92] = FAR_SEER
    set fav_hero[93] = DREAD_LORD
    set fav_hero[94] = 0

    set fav_unit[72] = CHIMAERA
    set fav_unit[73] = KNIGHT
    set fav_unit[74] = GRUNT
    set fav_unit[75] = GHOUL
    set p_rare[18] = 0

    set profilename[19] = "BORG"
    set p_race[19] = R_RANDOM
    set p_aggression[19] = -12
    set p_uncertainty[19] = 6
    set p_minimum_attack_strength[19] = 7
    set p_farm_food[19] = 8
    set p_exp_first_time[19] = 6
    set p_exp_second_time[19] = 13
    set p_strat_persistence[19] = 1050
    set p_gold_unit_percentage[19] = 1.35
    set p_taunt_rate[19] = 1
    set p_expansion_target_bonus[19] = 10
    set p_comp_chosen_target_bonus[19] = 7
    set p_comp_chosen_target_rate[19] = 0.6
    set p_surrender[19] = 1

    set fav_hero[95] = DEMON_HUNTER
    set fav_hero[96] = ARCHMAGE
    set fav_hero[97] = TAUREN_CHIEF
    set fav_hero[98] = DREAD_LORD
    set fav_hero[99] = 0

    set fav_unit[76] = DRYAD
    set fav_unit[77] = KNIGHT
    set fav_unit[78] = GRUNT
    set fav_unit[79] = GHOUL
    set p_rare[19] = 0

    set profilename[20] = "Cybernetic"
    set p_race[20] = R_RANDOM
    set p_aggression[20] = -7
    set p_uncertainty[20] = 5
    set p_minimum_attack_strength[20] = 7
    set p_farm_food[20] = 9
    set p_exp_first_time[20] = 6
    set p_exp_second_time[20] = 15
    set p_strat_persistence[20] = 900
    set p_gold_unit_percentage[20] = 1.35
    set p_taunt_rate[20] = 1
    set p_expansion_target_bonus[20] = 13
    set p_comp_chosen_target_bonus[20] = 5
    set p_comp_chosen_target_rate[20] = 0.5
    set p_surrender[20] = 1

    set fav_hero[100] = DEMON_HUNTER
    set fav_hero[101] = PALADIN
    set fav_hero[102] = FAR_SEER
    set fav_hero[103] = DEATH_KNIGHT
    set fav_hero[104] = 0

    set fav_unit[80] = DRUID_TALON
    set fav_unit[81] = GRYPHON
    set fav_unit[82] = TAUREN
    set fav_unit[83] = NECRO
    set p_rare[20] = 0

    set profilename[21] = "CyberPro"
    set p_race[21] = R_RANDOM
    set p_aggression[21] = -6
    set p_uncertainty[21] = 6
    set p_minimum_attack_strength[21] = 8
    set p_farm_food[21] = 10
    set p_exp_first_time[21] = 6
    set p_exp_second_time[21] = 14
    set p_strat_persistence[21] = 800
    set p_gold_unit_percentage[21] = 1.4
    set p_taunt_rate[21] = 1
    set p_expansion_target_bonus[21] = 11
    set p_comp_chosen_target_bonus[21] = 3
    set p_comp_chosen_target_rate[21] = 0.5
    set p_surrender[21] = 1

    set fav_hero[105] = KEEPER
    set fav_hero[106] = ARCHMAGE
    set fav_hero[107] = BLADE_MASTER
    set fav_hero[108] = LICH
    set fav_hero[109] = 0

    set fav_unit[84] = ARCHER
    set fav_unit[85] = RIFLEMAN
    set fav_unit[86] = WYVERN
    set fav_unit[87] = CRYPT_FIEND
    set p_rare[21] = 0

    set profilename[22] = "Cyrrix"
    set p_race[22] = R_RANDOM
    set p_aggression[22] = -7
    set p_uncertainty[22] = 5
    set p_minimum_attack_strength[22] = 8
    set p_farm_food[22] = 8
    set p_exp_first_time[22] = 7
    set p_exp_second_time[22] = 13
    set p_strat_persistence[22] = 900
    set p_gold_unit_percentage[22] = 1.3
    set p_taunt_rate[22] = 1
    set p_expansion_target_bonus[22] = 10
    set p_comp_chosen_target_bonus[22] = 4
    set p_comp_chosen_target_rate[22] = 0.4
    set p_surrender[22] = 1

    set fav_hero[110] = DEMON_HUNTER
    set fav_hero[111] = ARCHMAGE
    set fav_hero[112] = TAUREN_CHIEF
    set fav_hero[113] = DREAD_LORD
    set fav_hero[114] = 0

    set fav_unit[88] = DRYAD
    set fav_unit[89] = KNIGHT
    set fav_unit[90] = HEAD_HUNTER
    set fav_unit[91] = FROST_WYRM
    set p_rare[22] = 0

    set profilename[23] = "ArraXy"
    set p_race[23] = R_RANDOM
    set p_aggression[23] = -10
    set p_uncertainty[23] = 9
    set p_minimum_attack_strength[23] = 7
    set p_farm_food[23] = 11
    set p_exp_first_time[23] = 7
    set p_exp_second_time[23] = 16
    set p_strat_persistence[23] = 1000
    set p_gold_unit_percentage[23] = 1.35
    set p_taunt_rate[23] = 1
    set p_expansion_target_bonus[23] = 8
    set p_comp_chosen_target_bonus[23] = 6
    set p_comp_chosen_target_rate[23] = 0.5
    set p_surrender[23] = 1

    set fav_hero[115] = MOON_CHICK
    set fav_hero[116] = ARCHMAGE
    set fav_hero[117] = FAR_SEER
    set fav_hero[118] = DEATH_KNIGHT
    set fav_hero[119] = 0

    set fav_unit[92] = HUNTRESS
    set fav_unit[93] = MORTAR
    set fav_unit[94] = CATAPULT
    set fav_unit[95] = NECRO
    set p_rare[23] = 0

    set profilename[24] = "Trollus"
    set p_race[24] = R_RANDOM
    set p_aggression[24] = -8
    set p_uncertainty[24] = 8
    set p_minimum_attack_strength[24] = 7
    set p_farm_food[24] = 8
    set p_exp_first_time[24] = 7
    set p_exp_second_time[24] = 13
    set p_strat_persistence[24] = 950
    set p_gold_unit_percentage[24] = 1.35
    set p_taunt_rate[24] = 1
    set p_expansion_target_bonus[24] = 9
    set p_comp_chosen_target_bonus[24] = 7
    set p_comp_chosen_target_rate[24] = 0.4
    set p_surrender[24] = 1

    set fav_hero[120] = DEMON_HUNTER
    set fav_hero[121] = ARCHMAGE
    set fav_hero[122] = FAR_SEER
    set fav_hero[123] = DEATH_KNIGHT
    set fav_hero[124] = 0

    set fav_unit[96] = CHIMAERA
    set fav_unit[97] = RIFLEMAN
    set fav_unit[98] = GRUNT
    set fav_unit[99] = GHOUL
    set p_rare[24] = 0

    set profilename[25] = "Aaargh"
    set p_race[25] = R_RANDOM
    set p_aggression[25] = -9
    set p_uncertainty[25] = 9
    set p_minimum_attack_strength[25] = 7
    set p_farm_food[25] = 9
    set p_exp_first_time[25] = 6
    set p_exp_second_time[25] = 18
    set p_strat_persistence[25] = 900
    set p_gold_unit_percentage[25] = 1.4
    set p_taunt_rate[25] = 1
    set p_expansion_target_bonus[25] = 7
    set p_comp_chosen_target_bonus[25] = 5
    set p_comp_chosen_target_rate[25] = 0.4
    set p_surrender[25] = 1

    set fav_hero[125] = DEMON_HUNTER
    set fav_hero[126] = MTN_KING
    set fav_hero[127] = TAUREN_CHIEF
    set fav_hero[128] = LICH
    set fav_hero[129] = 0

    set fav_unit[100] = ARCHER
    set fav_unit[101] = GRYPHON
    set fav_unit[102] = HEAD_HUNTER
    set fav_unit[103] = GHOUL
    set p_rare[25] = 0

    set profile_length = 25

endfunction

function IsProfileUsed takes integer profile returns boolean
  //return LoadBoolean(com, PROFILE_USED, profile)
  return GetStoredBoolean(amaiCache, Int2Str(PROFILE_USED), Int2Str(profile))
endfunction

function SetProfileUsed takes integer profile returns nothing
  call SaveBoolean(com, PROFILE_USED, profile, true)
  call StoreBoolean(amaiCache, Int2Str(PROFILE_USED), Int2Str(profile), true) // Profile selection has to use gamecaches as hashtables are not saved between AI's
endfunction

function SetProfileNotUsed takes integer profile returns nothing
  call SaveBoolean(com, PROFILE_USED, profile, false)
  call StoreBoolean(amaiCache, Int2Str(PROFILE_USED), Int2Str(profile), false)
endfunction

function GetUnusedProfile takes player p returns integer
  local integer i = 0
  local integer array unusedProfiles
  local integer unusedCount = 0
  local integer array unusedRareProfiles
  local integer unusedRareCount = 0
  local integer profile = 0
  local integer p_sum = 0
  loop
    if p_rare[i] == 0 and (p_race[i] == R_RANDOM or p_race[i] == own_race) and (not IsProfileUsed(i)) then
       set unusedProfiles[unusedCount] = i
       set unusedCount = unusedCount + 1
    elseif p_rare[i] == 1 and (p_race[i] == R_RANDOM or p_race[i] == own_race) and (not IsProfileUsed(i)) then
       set unusedRareProfiles[unusedRareCount] = i
       set unusedRareCount = unusedRareCount + 1
    endif
    set i = i + 1
    exitwhen i >= profile_length
  endloop
  if (unusedRareCount > 0 and GetRandomInt(0,9) == 0) then
    set profile = GetRandomInt(0, unusedRareCount - 1)
    set profile = unusedRareProfiles[profile]
    call TracePlayer("Rare Profile select " + Int2Str(profile), GetPlayerId(ai_player))
  elseif unusedCount > 0 then // pick from unused profiles
    set profile = GetRandomInt(0, unusedCount - 1)
    set profile = unusedProfiles[profile]
    call TracePlayer("Profile select " + Int2Str(profile), GetPlayerId(ai_player))
  else // fail safe - pick anything as no valid profile available
    set profile = GetRandomInt(0, profile_length - 1)
    call TracePlayer("FAILSAFE Profile Selection " + Int2Str(profile), GetPlayerId(ai_player))
  endif
  call SetProfileUsed(profile)
  return profile
endfunction

function InitProfile takes nothing returns nothing
  local integer i = 0
  local integer countplayers = 0

  call set_profiles()

  if debug_profile != -1 then
    set profile = debug_profile
  else

    call Sleep((GetPlayerId(ai_player)*0.02)) // Staggered entry into method for thread safety with profile cache

    loop
      exitwhen not IsProfileUsed(-1)
      call Sleep(0.01)
    endloop

    call SetProfileUsed(-1) // current AI locks to ensure only it is processing profiles
    call TracePlayer("Has locked profile selection ID:" + Int2Str(GetPlayerId(ai_player)), GetPlayerId(ai_player))

    set profile = GetUnusedProfile(ai_player)
    call SetProfileNotUsed(-1)
  endif

  if not fixedcomputername then
    set ai_name = profilename[profile]
  elseif add_tag then
    set ai_name = "AMAI"
  else
    set ai_name = "Computer"
  endif

  call SetChatVar("Name", ai_name)

  if add_tag == true and not fixedcomputername and not add_skill then
    set ai_name = "[AMAI]"+ai_name
  elseif add_tag == true and not fixedcomputername and add_skill then
    if difficulty == EASY then
      set ai_name = "[AMAI Easy]"+ai_name
    elseif difficulty == HARD then
      set ai_name = "[AMAI Insane]"+ai_name
    else
      set ai_name = "[AMAI Normal]"+ai_name
    endif
  elseif add_skill == true then
    if difficulty == EASY then
      set ai_name = ai_name+" (Easy)"
    elseif difficulty == HARD then
      set ai_name = ai_name+" (Insane)"
    else
      set ai_name = ai_name+" (Normal)"
    endif
  endif

  call SetPlayerName(ai_player, ai_name)
  set message_add = c2s(GetPlayerColor(ai_player))

  set attacking_aggression = attacking_aggression + p_aggression[profile]
  set uncertainty = p_uncertainty[profile]
  set area_uncertainty = uncertainty / 2
  set minimum_attack_strength = p_minimum_attack_strength[profile]
  set farm_food = p_farm_food[profile]
  set exp_first_time = p_exp_first_time[profile]
  set exp_second_time = p_exp_second_time[profile]
  set strat_persistence = p_strat_persistence[profile]
  set gold_unit_percentage = p_gold_unit_percentage[profile]
  set taunt_rate = p_taunt_rate[profile]
  set expansion_target_bonus = p_expansion_target_bonus[profile]
  set comp_chosen_target_bonus = p_comp_chosen_target_bonus[profile]
  set comp_chosen_target_rate = p_comp_chosen_target_rate[profile]

endfunction

function AddFavoriteUnitRP takes nothing returns nothing
  local integer i = 0
  local string team = "Team" + Int2Str(GetPlayerTeam(ai_player)) + "StratUsed"
  if debug_strategy != -1 then
    set rp_strat[debug_strategy] = 100000000
  endif
  loop
    exitwhen i >= rp_strat_length
    if key_unit[i] == fav_unit[profile*RACE_NUMBER+own_race-1] then
      set rp_strat[i] = rp_strat[i] + fav_unit_add
    endif
    set i = i + 1
  endloop
  if ai_time < 10 then
    set i = 0
    loop
      exitwhen i >= 4
      set strategy_type_used[i] = LoadBoolean(com, TEAM_STATEGY_INUSE, i)
      set i = i + 1
    endloop
    set i = 0
    loop
      exitwhen i >= rp_strat_length
      if strategy_type_used[strategy_type[i]] then
        set rp_strat[i] = rp_strat[i] - strategy_type_used_penalty
      endif
      set i = i + 1
    endloop
  endif
  set team = null
endfunction

function AddFavoriteHeroRP takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= hero_number
    if all_heroes[i] == fav_hero[profile*(RACE_NUMBER+1)+own_race-1] or all_heroes[i] == fav_hero[profile*(RACE_NUMBER+1)+R_NEUTRAL-1] then
      set hero_rp[i] = hero_rp[i] + fav_hero_add
    endif
    set i = i + 1
  endloop
endfunction

function InitAiUnits takes nothing returns nothing
	if IsAMAI then
	else
	// Set the unit ids to that of the original ai for compatability with non AMAI scripts

		set ARCHMAGE = oARCHMAGE
		set PALADIN = oPALADIN
		set MTN_KING = oMTN_KING
		set BLADE_MASTER = oBLADE_MASTER
		set FAR_SEER = oFAR_SEER
		set TAUREN_CHIEF = oTAUREN_CHIEF
		set DEATH_KNIGHT = oDEATH_KNIGHT
		set DREAD_LORD = oDREAD_LORD
		set LICH = oLICH
		set DEMON_HUNTER = oDEMON_HUNTER
		set KEEPER = oKEEPER
		set MOON_PRIESTESS = oMOON_PRIESTESS
		set COPTER = oCOPTER
		set ELEMENTAL = oELEMENTAL
		set FOOTMAN = oFOOTMAN
		set GRYPHON = oGRYPHON
		set KNIGHT = oKNIGHT
		set MORTAR = oMORTAR
		set PEASANT = oPEASANT
		set PRIEST = oPRIEST
		set RIFLEMAN = oRIFLEMAN
		set SORCERESS = oSORCERESS
		set STEAM_TANK = oSTEAM_TANK
		set MILITIA = oMILITIA
		set AVIARY = oAVIARY
		set BARRACKS = oBARRACKS
		set BLACKSMITH = oBLACKSMITH
		set CANNON_TOWER = oCANNON_TOWER
		set CASTLE = oCASTLE
		set GUARD_TOWER = oGUARD_TOWER
		set HOUSE = oHOUSE
		set HUMAN_ALTAR = oHUMAN_ALTAR
		set KEEP = oKEEP
		set LUMBER_MILL = oLUMBER_MILL
		set SANCTUM = oSANCTUM
		set TOWN_HALL = oTOWN_HALL
		set WATCH_TOWER = oWATCH_TOWER
		set WORKSHOP = oWORKSHOP
		set UPG_SIGHT = oUPG_SIGHT
		set UPG_DEFEND = oUPG_DEFEND
		set UPG_HAMMERS = oUPG_HAMMERS
		set UPG_BREEDING = oUPG_BREEDING
		set UPG_GUN_RANGE = oUPG_GUN_RANGE
		set UPG_SENTINEL = oUPG_SENTINEL
		set UPG_BOMBS = oUPG_BOMBS
		set CATAPULT = oCATAPULT
		set WITCH_DOCTOR = oWITCH_DOCTOR
		set GRUNT = oGRUNT
		set HEAD_HUNTER = oHEAD_HUNTER
		set KODO_BEAST = oKODO_BEAST
		set PEON = oPEON
		set RAIDER = oRAIDER
		set SHAMAN = oSHAMAN
		set TAUREN = oTAUREN
		set WYVERN = oWYVERN
		set ORC_ALTAR = oORC_ALTAR
		set ORC_BARRACKS = oORC_BARRACKS
		set BESTIARY = oBESTIARY
		set FORGE = oFORGE
		set FORTRESS = oFORTRESS
		set GREAT_HALL = oGREAT_HALL
		set LODGE = oLODGE
		set STRONGHOLD = oSTRONGHOLD
		set BURROW = oBURROW
		set TOTEM = oTOTEM
		set ORC_WATCH_TOWER = oORC_WATCH_TOWER
		set UPG_ORC_WAR_DRUMS = oUPG_ORC_WAR_DRUMS
		set UPG_ORC_PILLAGE = oUPG_ORC_PILLAGE
		set UPG_ORC_BERSERK = oUPG_ORC_BERSERK
		set UPG_ORC_PULVERIZE = oUPG_ORC_PULVERIZE
		set UPG_ORC_ENSNARE = oUPG_ORC_ENSNARE
		set UPG_ORC_VENOM = oUPG_ORC_VENOM
		set UPG_ORC_REGEN = oUPG_ORC_REGEN
		set ABOMINATION = oABOMINATION
		set ACOLYTE = oACOLYTE
		set BANSHEE = oBANSHEE
		set CRYPT_FIEND = oCRYPT_FIEND
		set FROST_WYRM = oFROST_WYRM
		set GARGOYLE = oGARGOYLE
		set GARGOYLE_MORPH = oGARGOYLE_MORPH
		set GHOUL = oGHOUL
		set MEAT_WAGON = oMEAT_WAGON
		set NECRO = oNECRO
		set SKEL_WARRIOR = oSKEL_WARRIOR
		set SHADE = oSHADE
		set UNDEAD_MINE = oUNDEAD_MINE
		set UNDEAD_ALTAR = oUNDEAD_ALTAR
		set BONEYARD = oBONEYARD
		set NECROPOLIS_1 = oNECROPOLIS_1
		set NECROPOLIS_2 = oNECROPOLIS_2
		set NECROPOLIS_3 = oNECROPOLIS_3
		set SAC_PIT = oSAC_PIT
		set CRYPT = oCRYPT
		set SLAUGHTERHOUSE = oSLAUGHTERHOUSE
		set DAMNED_TEMPLE = oDAMNED_TEMPLE
		set ZIGGURAT_1 = oZIGGURAT_1
		set ZIGGURAT_2 = oZIGGURAT_2
		set GRAVEYARD = oGRAVEYARD
		set UPG_CANNIBALIZE = oUPG_CANNIBALIZE
		set UPG_GHOUL_FRENZY = oUPG_GHOUL_FRENZY
		set UPG_FIEND_WEB = oUPG_FIEND_WEB
		set UPG_STONE_FORM = oUPG_STONE_FORM
		set UPG_WYRM_BREATH = oUPG_WYRM_BREATH
		set UPG_SKEL_LIFE = oUPG_SKEL_LIFE
		set UPG_PLAGUE = oUPG_PLAGUE
		set WISP = oWISP
		set ARCHER = oARCHER
		set DRUID_TALON = oDRUID_TALON
		set DRUID_TALON_M = oDRUID_TALON_M
		set BALLISTA = oBALLISTA
		set DRUID_CLAW = oDRUID_CLAW
		set DRUID_CLAW_M = oDRUID_CLAW_M
		set DRYAD = oDRYAD
		set HIPPO = oHIPPO
		set HIPPO_RIDER = oHIPPO_RIDER
		set HUNTRESS = oHUNTRESS
		set CHIMAERA = oCHIMAERA
		set ANCIENT_LORE = oANCIENT_LORE
		set ANCIENT_WAR = oANCIENT_WAR
		set ANCIENT_WIND = oANCIENT_WIND
		set TREE_AGES = oTREE_AGES
		set TREE_ETERNITY = oTREE_ETERNITY
		set TREE_LIFE = oTREE_LIFE
		set ANCIENT_PROTECT = oANCIENT_PROTECT
		set ELF_ALTAR = oELF_ALTAR
		set CHIMAERA_ROOST = oCHIMAERA_ROOST
		set HUNTERS_HALL = oHUNTERS_HALL
		set MOON_WELL = oMOON_WELL
		set ELF_MINE = oELF_MINE
		set UPG_ULTRAVISION = oUPG_ULTRAVISION
		set UPG_BLESSING = oUPG_BLESSING
		set UPG_SCOUT = oUPG_SCOUT
		set UPG_GLAIVE = oUPG_GLAIVE
		set UPG_BOWS = oUPG_BOWS
		set UPG_MARKSMAN = oUPG_MARKSMAN
		set UPG_ABOLISH = oUPG_ABOLISH
		set UPG_CHIM_ACID = oUPG_CHIM_ACID
		set UPG_HIPPO_TAME = oUPG_HIPPO_TAME
		set UPG_BOLT = oUPG_BOLT
		set UPG_MARK_CLAW = oUPG_MARK_CLAW
		set UPG_MARK_TALON = oUPG_MARK_TALON
		set UPG_MELEE = oUPG_MELEE
		set UPG_RANGED = oUPG_RANGED
		set UPG_ARMOR = oUPG_ARMOR
		set UPG_LEATHER = oUPG_LEATHER
		set UPG_MASONRY = oUPG_MASONRY
		set UPG_WOOD = oUPG_WOOD
		set UPG_PRAYING = oUPG_PRAYING
		set UPG_SORCERY = oUPG_SORCERY
		set UPG_ORC_MELEE = oUPG_ORC_MELEE
		set UPG_ORC_RANGED = oUPG_ORC_RANGED
		set UPG_ORC_ARMOR = oUPG_ORC_ARMOR
		set UPG_ORC_SPIKES = oUPG_ORC_SPIKES
		set UPG_ORC_DOCS = oUPG_ORC_DOCS
		set UPG_ORC_SHAMAN = oUPG_ORC_SHAMAN
		set UPG_UNHOLY_STR = oUPG_UNHOLY_STR
		set UPG_CR_ATTACK = oUPG_CR_ATTACK
		set UPG_UNHOLY_ARMOR = oUPG_UNHOLY_ARMOR
		set UPG_CR_ARMOR = oUPG_CR_ARMOR
		set UPG_NECROS = oUPG_NECROS
		set UPG_BANSHEE = oUPG_BANSHEE
		set UPG_STR_MOON = oUPG_STR_MOON
		set UPG_STR_WILD = oUPG_STR_WILD
		set UPG_MOON_ARMOR = oUPG_MOON_ARMOR
		set UPG_HIDES = oUPG_HIDES
		set UPG_DRUID_TALON = oUPG_DRUID_TALON
		set UPG_DRUID_CLAW = oUPG_DRUID_CLAW
		set HEALING_POTION = oHEALING_POTION
		set MANA_POTION = oMANA_POTION
		set CIRCLET_OF_NOBILITY = oCIRCLET_OF_NOBILITY
		set PERIAPT_OF_VITALITY = oPERIAPT_OF_VITALITY
		set BOOTS_OF_SPEED = oBOOTS_OF_SPEED
		set M_SCROLL_OF_HEALING = oM_SCROLL_OF_HEALING
		set SCROLL_OF_PROTECTION = oSCROLL_OF_PROTECTION
		set TOWN_PORTAL = oTOWN_PORTAL
		set POTION_OF_INVISIBILITY = oPOTION_OF_INVISIBILITY
		set POTION_OF_LESSER_INVULNERBILITY = oPOTION_OF_LESSER_INVULNERBILITY
		set SATYR_SHADOWDANCER = oSATYR_SHADOWDANCER
		set FURBOLG_SHAMAN = oFURBOLG_SHAMAN
		set THUNDER_LIZARD = oTHUNDER_LIZARD
		set CENTAUR_OUTRUNNER = oCENTAUR_OUTRUNNER
		set HARPY_ROGUE = oHARPY_ROGUE
		set RAZORMANE_MEDICINE_MAN = oRAZORMANE_MEDICINE_MAN
		set HARPY_WINDWITCH = oHARPY_WINDWITCH
		set FEL_BEAST = oFEL_BEAST
		set DRAENEI_DISCIPLE = oDRAENEI_DISCIPLE
		set VOIDWALKER = oVOIDWALKER
		set DRAENEI_DARKSLAYER = oDRAENEI_DARKSLAYER
		set ROGUE = oROGUE
		set ASSASSIN = oASSASSIN
		set KOBOLD_GEOMANCER = oKOBOLD_GEOMANCER
		set FOREST_TROLL_HIGH_PRIEST = oFOREST_TROLL_HIGH_PRIEST
		set BURNING_ARCHER = oBURNING_ARCHER
		set WILDKIN = oWILDKIN
		set MURLOC_FLESHEATER = oMURLOC_FLESHEATER
		set SLUDGE_FLINGER = oSLUDGE_FLINGER
		set SATYR_SOULSTEALER = oSATYR_SOULSTEALER
		set BARBED_ARACHNATHID = oBARBED_ARACHNATHID
		set BLUE_DRAGONSPAWN_MEDDLER = oBLUE_DRAGONSPAWN_MEDDLER
		set MAGNATAUR_WARRIOR = oMAGNATAUR_WARRIOR
		set POLAR_FURBOLG_SHAMAN = oPOLAR_FURBOLG_SHAMAN
		set GNOLL_BRUTE = oGNOLL_BRUTE
		set GNOLL_WARDEN = oGNOLL_WARDEN
		set OGRE_MAGI = oOGRE_MAGI
		set MUD_GOLEM = oMUD_GOLEM
		set FOREST_TROLL_BERSERKER = oFOREST_TROLL_BERSERKER
		set FOREST_TROLL_SHADOW_PRIEST = oFOREST_TROLL_SHADOW_PRIEST
		set OGRE_MAULER = oOGRE_MAULER
		set GNOLL_OVERSEER = oGNOLL_OVERSEER
		set ICE_TROLL_BERSERKER = oICE_TROLL_BERSERKER
		set ICE_TROLL_TRAPPER = oICE_TROLL_TRAPPER
		set NERUBIAN_WARRIOR = oNERUBIAN_WARRIOR
		set FROST_REVENANT = oFROST_REVENANT
		set NERUBIAN_WEBSPINNER = oNERUBIAN_WEBSPINNER
		set MURGUL_SNARECASTER = oMURGUL_SNARECASTER
		set MAKRURA_SNAPPER = oMAKRURA_SNAPPER
		set MAKRURA_DEEPSEER = oMAKRURA_DEEPSEER
		set GIANT_SEA_TURTLE = oGIANT_SEA_TURTLE
		set KOBOLD = oKOBOLD
		set MURLOC_HUNTSMAN = oMURLOC_HUNTSMAN
		set BLACK_DRAGON_1 = oBLACK_DRAGON_1
		set BLACK_DRAGON_2 = oBLACK_DRAGON_2
		set BLACK_DRAGON_3 = oBLACK_DRAGON_3
		set BLUE_DRAGON_1 = oBLUE_DRAGON_1
		set BLUE_DRAGON_2 = oBLUE_DRAGON_2
		set BLUE_DRAGON_3 = oBLUE_DRAGON_3
		set BRONZE_DRAGON_1 = oBRONZE_DRAGON_1
		set BRONZE_DRAGON_2 = oBRONZE_DRAGON_2
		set BRONZE_DRAGON_3 = oBRONZE_DRAGON_3
		set GREEN_DRAGON_1 = oGREEN_DRAGON_1
		set GREEN_DRAGON_2 = oGREEN_DRAGON_2
		set GREEN_DRAGON_3 = oGREEN_DRAGON_3
		set NETHER_DRAGON_1 = oNETHER_DRAGON_1
		set NETHER_DRAGON_2 = oNETHER_DRAGON_2
		set NETHER_DRAGON_3 = oNETHER_DRAGON_3
		set RED_DRAGON_1 = oRED_DRAGON_1
		set RED_DRAGON_2 = oRED_DRAGON_2
		set RED_DRAGON_3 = oRED_DRAGON_3
		set ZEPPELIN = oZEPPELIN
		set SAPPER = oSAPPER
		set SHREDDER = oSHREDDER
		set GOLD_MINE = oGOLD_MINE
		set JAINA = oJAINA
		set MURADIN = oMURADIN
		set CHURCH = oCHURCH
		set MAGE_TOWER = oMAGE_TOWER
		set GROM = oGROM
		set THRALL = oTHRALL
		set PIG_FARM = oPIG_FARM
		set CHAOS_GRUNT = oCHAOS_GRUNT
		set CHAOS_WARLOCK = oCHAOS_WARLOCK
		set CHAOS_RAIDER = oCHAOS_RAIDER
		set CHAOS_PEON = oCHAOS_PEON
		set CHAOS_KODO = oCHAOS_KODO
		set CHAOS_GROM = oCHAOS_GROM
		set CHAOS_BLADEMASTER = oCHAOS_BLADEMASTER
		set CHAOS_BURROW = oCHAOS_BURROW
		set MALGANIS = oMALGANIS
		set TICHONDRIUS  = oTICHONDRIUS 
		set PIT_LORD = oPIT_LORD
		set SYLVANUS = oSYLVANUS
		set CENARIUS = oCENARIUS
		set ILLIDAN = oILLIDAN
		set ILLIDAN_DEMON = oILLIDAN_DEMON
		set MAIEV = oMAIEV
		set HIGH_ARCHER  = oHIGH_ARCHER 
		set HIGH_FOOTMAN = oHIGH_FOOTMAN
		set HIGH_FOOTMEN = oHIGH_FOOTMEN
		set HIGH_SWORDMAN = oHIGH_SWORDMAN
		set DRAGON_HAWK = oDRAGON_HAWK
		set CORRUPT_TREANT = oCORRUPT_TREANT
		set POISON_TREANT = oPOISON_TREANT
		set PLAGUE_TREANT = oPLAGUE_TREANT
		set SHANDRIS = oSHANDRIS
		set ELF_FARM = oELF_FARM
		set ELF_GUARD_TOWER = oELF_GUARD_TOWER
		set HIGH_SKY = oHIGH_SKY
		set HIGH_EARTH = oHIGH_EARTH
		set HIGH_TOWER = oHIGH_TOWER
		set ELF_HIGH_BARRACKS = oELF_HIGH_BARRACKS
		set CORRUPT_LIFE = oCORRUPT_LIFE
		set CORRUPT_WELL = oCORRUPT_WELL
		set CORRUPT_PROTECTOR = oCORRUPT_PROTECTOR
		set CORRUPT_WAR = oCORRUPT_WAR
		set UPG_ORC_CHAOS = oUPG_ORC_CHAOS

		set FOOTMEN = FOOTMAN
		set RIFLEMEN = RIFLEMAN
		set TANK = STEAM_TANK
		set GYRO = COPTER
		set PIT_FIEND = CRYPT_FIEND
		set ORC_DRAGON = RED_DRAGON_3
		set ZEPPLIN = ZEPPELIN
		set MOON_CHICK = MOON_PRIESTESS
		set MOON_BABE = MOON_PRIESTESS
		set MOON_HONEY = MOON_PRIESTESS
	endif
endfunction

function InitArrays takes nothing returns nothing

  set old_id[ARCHMAGE] = oARCHMAGE
  set buy_type[ARCHMAGE] = BT_HERO
  set needed1[ARCHMAGE] = HUMAN_ALTAR
  set needed2[ARCHMAGE] = KEEP
  set needed3[ARCHMAGE] = CASTLE
  set tc_add1[ARCHMAGE] = 0
  set tc_add2[ARCHMAGE] = 0
  set available_time[ARCHMAGE] = R2I(0 / 5)
  set regenerate_time[ARCHMAGE] = R2I(0 / 5)
  set gold_price[ARCHMAGE] = 0
  set wood_price[ARCHMAGE] = 0
  set hero_rush_bonus[ARCHMAGE] = 0

  set old_id[PALADIN] = oPALADIN
  set buy_type[PALADIN] = BT_HERO
  set needed1[PALADIN] = HUMAN_ALTAR
  set needed2[PALADIN] = KEEP
  set needed3[PALADIN] = CASTLE
  set tc_add1[PALADIN] = 0
  set tc_add2[PALADIN] = 0
  set available_time[PALADIN] = R2I(0 / 5)
  set regenerate_time[PALADIN] = R2I(0 / 5)
  set gold_price[PALADIN] = 0
  set wood_price[PALADIN] = 0
  set hero_rush_bonus[PALADIN] = 0

  set old_id[MTN_KING] = oMTN_KING
  set buy_type[MTN_KING] = BT_HERO
  set needed1[MTN_KING] = HUMAN_ALTAR
  set needed2[MTN_KING] = KEEP
  set needed3[MTN_KING] = CASTLE
  set tc_add1[MTN_KING] = 0
  set tc_add2[MTN_KING] = 0
  set available_time[MTN_KING] = R2I(0 / 5)
  set regenerate_time[MTN_KING] = R2I(0 / 5)
  set gold_price[MTN_KING] = 0
  set wood_price[MTN_KING] = 0
  set hero_rush_bonus[MTN_KING] = 0

  set old_id[BLADE_MASTER] = oBLADE_MASTER
  set buy_type[BLADE_MASTER] = BT_HERO
  set needed1[BLADE_MASTER] = ORC_ALTAR
  set needed2[BLADE_MASTER] = STRONGHOLD
  set needed3[BLADE_MASTER] = FORTRESS
  set tc_add1[BLADE_MASTER] = 0
  set tc_add2[BLADE_MASTER] = 0
  set available_time[BLADE_MASTER] = R2I(0 / 5)
  set regenerate_time[BLADE_MASTER] = R2I(0 / 5)
  set gold_price[BLADE_MASTER] = 0
  set wood_price[BLADE_MASTER] = 0
  set hero_rush_bonus[BLADE_MASTER] = 0

  set old_id[FAR_SEER] = oFAR_SEER
  set buy_type[FAR_SEER] = BT_HERO
  set needed1[FAR_SEER] = ORC_ALTAR
  set needed2[FAR_SEER] = STRONGHOLD
  set needed3[FAR_SEER] = FORTRESS
  set tc_add1[FAR_SEER] = 0
  set tc_add2[FAR_SEER] = 0
  set available_time[FAR_SEER] = R2I(0 / 5)
  set regenerate_time[FAR_SEER] = R2I(0 / 5)
  set gold_price[FAR_SEER] = 0
  set wood_price[FAR_SEER] = 0
  set hero_rush_bonus[FAR_SEER] = 0

  set old_id[TAUREN_CHIEF] = oTAUREN_CHIEF
  set buy_type[TAUREN_CHIEF] = BT_HERO
  set needed1[TAUREN_CHIEF] = ORC_ALTAR
  set needed2[TAUREN_CHIEF] = STRONGHOLD
  set needed3[TAUREN_CHIEF] = FORTRESS
  set tc_add1[TAUREN_CHIEF] = 0
  set tc_add2[TAUREN_CHIEF] = 0
  set available_time[TAUREN_CHIEF] = R2I(0 / 5)
  set regenerate_time[TAUREN_CHIEF] = R2I(0 / 5)
  set gold_price[TAUREN_CHIEF] = 0
  set wood_price[TAUREN_CHIEF] = 0
  set hero_rush_bonus[TAUREN_CHIEF] = 0

  set old_id[DEATH_KNIGHT] = oDEATH_KNIGHT
  set buy_type[DEATH_KNIGHT] = BT_HERO
  set needed1[DEATH_KNIGHT] = UNDEAD_ALTAR
  set needed2[DEATH_KNIGHT] = NECROPOLIS_2
  set needed3[DEATH_KNIGHT] = NECROPOLIS_3
  set tc_add1[DEATH_KNIGHT] = 0
  set tc_add2[DEATH_KNIGHT] = 0
  set available_time[DEATH_KNIGHT] = R2I(0 / 5)
  set regenerate_time[DEATH_KNIGHT] = R2I(0 / 5)
  set gold_price[DEATH_KNIGHT] = 0
  set wood_price[DEATH_KNIGHT] = 0
  set hero_rush_bonus[DEATH_KNIGHT] = 0

  set old_id[DREAD_LORD] = oDREAD_LORD
  set buy_type[DREAD_LORD] = BT_HERO
  set needed1[DREAD_LORD] = UNDEAD_ALTAR
  set needed2[DREAD_LORD] = NECROPOLIS_2
  set needed3[DREAD_LORD] = NECROPOLIS_3
  set tc_add1[DREAD_LORD] = 0
  set tc_add2[DREAD_LORD] = 0
  set available_time[DREAD_LORD] = R2I(0 / 5)
  set regenerate_time[DREAD_LORD] = R2I(0 / 5)
  set gold_price[DREAD_LORD] = 0
  set wood_price[DREAD_LORD] = 0
  set hero_rush_bonus[DREAD_LORD] = 0

  set old_id[LICH] = oLICH
  set buy_type[LICH] = BT_HERO
  set needed1[LICH] = UNDEAD_ALTAR
  set needed2[LICH] = NECROPOLIS_2
  set needed3[LICH] = NECROPOLIS_3
  set tc_add1[LICH] = 0
  set tc_add2[LICH] = 0
  set available_time[LICH] = R2I(0 / 5)
  set regenerate_time[LICH] = R2I(0 / 5)
  set gold_price[LICH] = 0
  set wood_price[LICH] = 0
  set hero_rush_bonus[LICH] = 0

  set old_id[DEMON_HUNTER] = oDEMON_HUNTER
  set buy_type[DEMON_HUNTER] = BT_HERO
  set needed1[DEMON_HUNTER] = ELF_ALTAR
  set needed2[DEMON_HUNTER] = TREE_AGES
  set needed3[DEMON_HUNTER] = TREE_ETERNITY
  set tc_add1[DEMON_HUNTER] = 0
  set tc_add2[DEMON_HUNTER] = 0
  set available_time[DEMON_HUNTER] = R2I(0 / 5)
  set regenerate_time[DEMON_HUNTER] = R2I(0 / 5)
  set gold_price[DEMON_HUNTER] = 0
  set wood_price[DEMON_HUNTER] = 0
  set hero_rush_bonus[DEMON_HUNTER] = 0

  set old_id[KEEPER] = oKEEPER
  set buy_type[KEEPER] = BT_HERO
  set needed1[KEEPER] = ELF_ALTAR
  set needed2[KEEPER] = TREE_AGES
  set needed3[KEEPER] = TREE_ETERNITY
  set tc_add1[KEEPER] = 0
  set tc_add2[KEEPER] = 0
  set available_time[KEEPER] = R2I(0 / 5)
  set regenerate_time[KEEPER] = R2I(0 / 5)
  set gold_price[KEEPER] = 0
  set wood_price[KEEPER] = 0
  set hero_rush_bonus[KEEPER] = 0

  set old_id[MOON_PRIESTESS] = oMOON_PRIESTESS
  set buy_type[MOON_PRIESTESS] = BT_HERO
  set needed1[MOON_PRIESTESS] = ELF_ALTAR
  set needed2[MOON_PRIESTESS] = TREE_AGES
  set needed3[MOON_PRIESTESS] = TREE_ETERNITY
  set tc_add1[MOON_PRIESTESS] = 0
  set tc_add2[MOON_PRIESTESS] = 0
  set available_time[MOON_PRIESTESS] = R2I(0 / 5)
  set regenerate_time[MOON_PRIESTESS] = R2I(0 / 5)
  set gold_price[MOON_PRIESTESS] = 0
  set wood_price[MOON_PRIESTESS] = 0
  set hero_rush_bonus[MOON_PRIESTESS] = 0

  set old_id[COPTER] = oCOPTER
  set buy_type[COPTER] = BT_UNIT
  set needed1[COPTER] = WORKSHOP
  set needed2[COPTER] = 0
  set needed3[COPTER] = 0
  set tc_add1[COPTER] = 0
  set tc_add2[COPTER] = 0
  set available_time[COPTER] = R2I(0 / 5)
  set regenerate_time[COPTER] = R2I(0 / 5)
  set gold_price[COPTER] = 0
  set wood_price[COPTER] = 0
  set hero_rush_bonus[COPTER] = 0

  set old_id[ELEMENTAL] = oELEMENTAL
  set buy_type[ELEMENTAL] = BT_UNIT
  set needed1[ELEMENTAL] = ARCHMAGE
  set needed2[ELEMENTAL] = 0
  set needed3[ELEMENTAL] = 0
  set tc_add1[ELEMENTAL] = 0
  set tc_add2[ELEMENTAL] = 0
  set available_time[ELEMENTAL] = R2I(0 / 5)
  set regenerate_time[ELEMENTAL] = R2I(0 / 5)
  set gold_price[ELEMENTAL] = 0
  set wood_price[ELEMENTAL] = 0
  set hero_rush_bonus[ELEMENTAL] = 0

  set old_id[FOOTMAN] = oFOOTMAN
  set buy_type[FOOTMAN] = BT_UNIT
  set needed1[FOOTMAN] = BARRACKS
  set needed2[FOOTMAN] = 0
  set needed3[FOOTMAN] = 0
  set tc_add1[FOOTMAN] = 0
  set tc_add2[FOOTMAN] = 0
  set available_time[FOOTMAN] = R2I(0 / 5)
  set regenerate_time[FOOTMAN] = R2I(0 / 5)
  set gold_price[FOOTMAN] = 0
  set wood_price[FOOTMAN] = 0
  set hero_rush_bonus[FOOTMAN] = 0

  set old_id[GRYPHON] = oGRYPHON
  set buy_type[GRYPHON] = BT_UNIT
  set needed1[GRYPHON] = AVIARY
  set needed2[GRYPHON] = 0
  set needed3[GRYPHON] = 0
  set tc_add1[GRYPHON] = 0
  set tc_add2[GRYPHON] = 0
  set available_time[GRYPHON] = R2I(0 / 5)
  set regenerate_time[GRYPHON] = R2I(0 / 5)
  set gold_price[GRYPHON] = 0
  set wood_price[GRYPHON] = 0
  set hero_rush_bonus[GRYPHON] = 0

  set old_id[KNIGHT] = oKNIGHT
  set buy_type[KNIGHT] = BT_UNIT
  set needed1[KNIGHT] = BARRACKS
  set needed2[KNIGHT] = CASTLE
  set needed3[KNIGHT] = BLACKSMITH
  set tc_add1[KNIGHT] = 0
  set tc_add2[KNIGHT] = 0
  set available_time[KNIGHT] = R2I(0 / 5)
  set regenerate_time[KNIGHT] = R2I(0 / 5)
  set gold_price[KNIGHT] = 0
  set wood_price[KNIGHT] = 0
  set hero_rush_bonus[KNIGHT] = 0

  set old_id[MORTAR] = oMORTAR
  set buy_type[MORTAR] = BT_UNIT
  set needed1[MORTAR] = WORKSHOP
  set needed2[MORTAR] = 0
  set needed3[MORTAR] = 0
  set tc_add1[MORTAR] = 0
  set tc_add2[MORTAR] = 0
  set available_time[MORTAR] = R2I(0 / 5)
  set regenerate_time[MORTAR] = R2I(0 / 5)
  set gold_price[MORTAR] = 0
  set wood_price[MORTAR] = 0
  set hero_rush_bonus[MORTAR] = 0

  set old_id[PEASANT] = oPEASANT
  set buy_type[PEASANT] = BT_UNIT
  set needed1[PEASANT] = TOWN_HALL
  set needed2[PEASANT] = 0
  set needed3[PEASANT] = 0
  set tc_add1[PEASANT] = MILITIA
  set tc_add2[PEASANT] = 0
  set available_time[PEASANT] = R2I(0 / 5)
  set regenerate_time[PEASANT] = R2I(0 / 5)
  set gold_price[PEASANT] = 0
  set wood_price[PEASANT] = 0
  set hero_rush_bonus[PEASANT] = 0

  set old_id[PRIEST] = oPRIEST
  set buy_type[PRIEST] = BT_UNIT
  set needed1[PRIEST] = SANCTUM
  set needed2[PRIEST] = 0
  set needed3[PRIEST] = 0
  set tc_add1[PRIEST] = 0
  set tc_add2[PRIEST] = 0
  set available_time[PRIEST] = R2I(0 / 5)
  set regenerate_time[PRIEST] = R2I(0 / 5)
  set gold_price[PRIEST] = 0
  set wood_price[PRIEST] = 0
  set hero_rush_bonus[PRIEST] = 0

  set old_id[RIFLEMAN] = oRIFLEMAN
  set buy_type[RIFLEMAN] = BT_UNIT
  set needed1[RIFLEMAN] = BARRACKS
  set needed2[RIFLEMAN] = BLACKSMITH
  set needed3[RIFLEMAN] = 0
  set tc_add1[RIFLEMAN] = 0
  set tc_add2[RIFLEMAN] = 0
  set available_time[RIFLEMAN] = R2I(0 / 5)
  set regenerate_time[RIFLEMAN] = R2I(0 / 5)
  set gold_price[RIFLEMAN] = 0
  set wood_price[RIFLEMAN] = 0
  set hero_rush_bonus[RIFLEMAN] = 0

  set old_id[SORCERESS] = oSORCERESS
  set buy_type[SORCERESS] = BT_UNIT
  set needed1[SORCERESS] = SANCTUM
  set needed2[SORCERESS] = 0
  set needed3[SORCERESS] = 0
  set tc_add1[SORCERESS] = 0
  set tc_add2[SORCERESS] = 0
  set available_time[SORCERESS] = R2I(0 / 5)
  set regenerate_time[SORCERESS] = R2I(0 / 5)
  set gold_price[SORCERESS] = 0
  set wood_price[SORCERESS] = 0
  set hero_rush_bonus[SORCERESS] = 0

  set old_id[STEAM_TANK] = oSTEAM_TANK
  set buy_type[STEAM_TANK] = BT_UNIT
  set needed1[STEAM_TANK] = WORKSHOP
  set needed2[STEAM_TANK] = CASTLE
  set needed3[STEAM_TANK] = 0
  set tc_add1[STEAM_TANK] = 0
  set tc_add2[STEAM_TANK] = 0
  set available_time[STEAM_TANK] = R2I(0 / 5)
  set regenerate_time[STEAM_TANK] = R2I(0 / 5)
  set gold_price[STEAM_TANK] = 0
  set wood_price[STEAM_TANK] = 0
  set hero_rush_bonus[STEAM_TANK] = 0

  set old_id[MILITIA] = oMILITIA
  set buy_type[MILITIA] = BT_UNIT
  set needed1[MILITIA] = 0
  set needed2[MILITIA] = 0
  set needed3[MILITIA] = 0
  set tc_add1[MILITIA] = PEASANT
  set tc_add2[MILITIA] = 0
  set available_time[MILITIA] = R2I(0 / 5)
  set regenerate_time[MILITIA] = R2I(0 / 5)
  set gold_price[MILITIA] = 0
  set wood_price[MILITIA] = 0
  set hero_rush_bonus[MILITIA] = 0

  set old_id[AVIARY] = oAVIARY
  set buy_type[AVIARY] = BT_BUILDING
  set needed1[AVIARY] = PEASANT 
  set needed2[AVIARY] = CASTLE
  set needed3[AVIARY] = LUMBER_MILL
  set tc_add1[AVIARY] = 0
  set tc_add2[AVIARY] = 0
  set available_time[AVIARY] = R2I(0 / 5)
  set regenerate_time[AVIARY] = R2I(0 / 5)
  set gold_price[AVIARY] = 0
  set wood_price[AVIARY] = 0
  set hero_rush_bonus[AVIARY] = 0

  set old_id[BARRACKS] = oBARRACKS
  set buy_type[BARRACKS] = BT_BUILDING
  set needed1[BARRACKS] = PEASANT 
  set needed2[BARRACKS] = 0
  set needed3[BARRACKS] = 0
  set tc_add1[BARRACKS] = 0
  set tc_add2[BARRACKS] = 0
  set available_time[BARRACKS] = R2I(0 / 5)
  set regenerate_time[BARRACKS] = R2I(0 / 5)
  set gold_price[BARRACKS] = 0
  set wood_price[BARRACKS] = 0
  set hero_rush_bonus[BARRACKS] = 0

  set old_id[BLACKSMITH] = oBLACKSMITH
  set buy_type[BLACKSMITH] = BT_BUILDING
  set needed1[BLACKSMITH] = PEASANT 
  set needed2[BLACKSMITH] = TOWN_HALL
  set needed3[BLACKSMITH] = 0
  set tc_add1[BLACKSMITH] = 0
  set tc_add2[BLACKSMITH] = 0
  set available_time[BLACKSMITH] = R2I(0 / 5)
  set regenerate_time[BLACKSMITH] = R2I(0 / 5)
  set gold_price[BLACKSMITH] = 0
  set wood_price[BLACKSMITH] = 0
  set hero_rush_bonus[BLACKSMITH] = 0

  set old_id[CANNON_TOWER] = oCANNON_TOWER
  set buy_type[CANNON_TOWER] = BT_BUILDING
  set needed1[CANNON_TOWER] = WATCH_TOWER
  set needed2[CANNON_TOWER] = WORKSHOP
  set needed3[CANNON_TOWER] = UPGRADED
  set tc_add1[CANNON_TOWER] = 0
  set tc_add2[CANNON_TOWER] = 0
  set available_time[CANNON_TOWER] = R2I(0 / 5)
  set regenerate_time[CANNON_TOWER] = R2I(0 / 5)
  set gold_price[CANNON_TOWER] = 0
  set wood_price[CANNON_TOWER] = 0
  set hero_rush_bonus[CANNON_TOWER] = 0

  set old_id[CASTLE] = oCASTLE
  set buy_type[CASTLE] = BT_BUILDING
  set needed1[CASTLE] = KEEP          
  set needed2[CASTLE] = HUMAN_ALTAR
  set needed3[CASTLE] = UPGRADED
  set tc_add1[CASTLE] = 0
  set tc_add2[CASTLE] = 0
  set available_time[CASTLE] = R2I(0 / 5)
  set regenerate_time[CASTLE] = R2I(0 / 5)
  set gold_price[CASTLE] = 0
  set wood_price[CASTLE] = 0
  set hero_rush_bonus[CASTLE] = 0

  set old_id[GUARD_TOWER] = oGUARD_TOWER
  set buy_type[GUARD_TOWER] = BT_BUILDING
  set needed1[GUARD_TOWER] = WATCH_TOWER
  set needed2[GUARD_TOWER] = 0
  set needed3[GUARD_TOWER] = 0
  set tc_add1[GUARD_TOWER] = 0
  set tc_add2[GUARD_TOWER] = 0
  set available_time[GUARD_TOWER] = R2I(0 / 5)
  set regenerate_time[GUARD_TOWER] = R2I(0 / 5)
  set gold_price[GUARD_TOWER] = 0
  set wood_price[GUARD_TOWER] = 0
  set hero_rush_bonus[GUARD_TOWER] = 0

  set old_id[HOUSE] = oHOUSE
  set buy_type[HOUSE] = BT_BUILDING
  set needed1[HOUSE] = PEASANT 
  set needed2[HOUSE] = 0
  set needed3[HOUSE] = 0
  set tc_add1[HOUSE] = 0
  set tc_add2[HOUSE] = 0
  set available_time[HOUSE] = R2I(0 / 5)
  set regenerate_time[HOUSE] = R2I(0 / 5)
  set gold_price[HOUSE] = 0
  set wood_price[HOUSE] = 0
  set hero_rush_bonus[HOUSE] = 0

  set old_id[HUMAN_ALTAR] = oHUMAN_ALTAR
  set buy_type[HUMAN_ALTAR] = BT_BUILDING
  set needed1[HUMAN_ALTAR] = PEASANT 
  set needed2[HUMAN_ALTAR] = 0
  set needed3[HUMAN_ALTAR] = 0
  set tc_add1[HUMAN_ALTAR] = 0
  set tc_add2[HUMAN_ALTAR] = 0
  set available_time[HUMAN_ALTAR] = R2I(0 / 5)
  set regenerate_time[HUMAN_ALTAR] = R2I(0 / 5)
  set gold_price[HUMAN_ALTAR] = 0
  set wood_price[HUMAN_ALTAR] = 0
  set hero_rush_bonus[HUMAN_ALTAR] = 0

  set old_id[KEEP] = oKEEP
  set buy_type[KEEP] = BT_BUILDING
  set needed1[KEEP] = TOWN_HALL 
  set needed2[KEEP] = 0
  set needed3[KEEP] = UPGRADED
  set tc_add1[KEEP] = CASTLE
  set tc_add2[KEEP] = 0
  set available_time[KEEP] = R2I(0 / 5)
  set regenerate_time[KEEP] = R2I(0 / 5)
  set gold_price[KEEP] = 0
  set wood_price[KEEP] = 0
  set hero_rush_bonus[KEEP] = 0

  set old_id[LUMBER_MILL] = oLUMBER_MILL
  set buy_type[LUMBER_MILL] = BT_BUILDING
  set needed1[LUMBER_MILL] = PEASANT 
  set needed2[LUMBER_MILL] = 0
  set needed3[LUMBER_MILL] = 0
  set tc_add1[LUMBER_MILL] = 0
  set tc_add2[LUMBER_MILL] = 0
  set available_time[LUMBER_MILL] = R2I(0 / 5)
  set regenerate_time[LUMBER_MILL] = R2I(0 / 5)
  set gold_price[LUMBER_MILL] = 0
  set wood_price[LUMBER_MILL] = 0
  set hero_rush_bonus[LUMBER_MILL] = 0

  set old_id[SANCTUM] = oSANCTUM
  set buy_type[SANCTUM] = BT_BUILDING
  set needed1[SANCTUM] = PEASANT 
  set needed2[SANCTUM] = KEEP
  set needed3[SANCTUM] = 0
  set tc_add1[SANCTUM] = 0
  set tc_add2[SANCTUM] = 0
  set available_time[SANCTUM] = R2I(0 / 5)
  set regenerate_time[SANCTUM] = R2I(0 / 5)
  set gold_price[SANCTUM] = 0
  set wood_price[SANCTUM] = 0
  set hero_rush_bonus[SANCTUM] = 0

  set old_id[TOWN_HALL] = oTOWN_HALL
  set buy_type[TOWN_HALL] = BT_BUILDING
  set needed1[TOWN_HALL] = 0
  set needed2[TOWN_HALL] = 0
  set needed3[TOWN_HALL] = 0
  set tc_add1[TOWN_HALL] = KEEP
  set tc_add2[TOWN_HALL] = CASTLE
  set available_time[TOWN_HALL] = R2I(0 / 5)
  set regenerate_time[TOWN_HALL] = R2I(0 / 5)
  set gold_price[TOWN_HALL] = 0
  set wood_price[TOWN_HALL] = 0
  set hero_rush_bonus[TOWN_HALL] = 0

  set old_id[WATCH_TOWER] = oWATCH_TOWER
  set buy_type[WATCH_TOWER] = BT_BUILDING
  set needed1[WATCH_TOWER] = PEASANT 
  set needed2[WATCH_TOWER] = LUMBER_MILL
  set needed3[WATCH_TOWER] = UPGRADED
  set tc_add1[WATCH_TOWER] = GUARD_TOWER
  set tc_add2[WATCH_TOWER] = CANNON_TOWER
  set available_time[WATCH_TOWER] = R2I(0 / 5)
  set regenerate_time[WATCH_TOWER] = R2I(0 / 5)
  set gold_price[WATCH_TOWER] = 0
  set wood_price[WATCH_TOWER] = 0
  set hero_rush_bonus[WATCH_TOWER] = 0

  set old_id[WORKSHOP] = oWORKSHOP
  set buy_type[WORKSHOP] = BT_BUILDING
  set needed1[WORKSHOP] = PEASANT 
  set needed2[WORKSHOP] = KEEP
  set needed3[WORKSHOP] = BLACKSMITH
  set tc_add1[WORKSHOP] = 0
  set tc_add2[WORKSHOP] = 0
  set available_time[WORKSHOP] = R2I(0 / 5)
  set regenerate_time[WORKSHOP] = R2I(0 / 5)
  set gold_price[WORKSHOP] = 0
  set wood_price[WORKSHOP] = 0
  set hero_rush_bonus[WORKSHOP] = 0

  set old_id[UPG_SIGHT] = oUPG_SIGHT
  set buy_type[UPG_SIGHT] = BT_UPGRADE
  set needed1[UPG_SIGHT] = SANCTUM
  set needed2[UPG_SIGHT] = 0
  set needed3[UPG_SIGHT] = 0
  set tc_add1[UPG_SIGHT] = 0
  set tc_add2[UPG_SIGHT] = 0
  set available_time[UPG_SIGHT] = R2I(0 / 5)
  set regenerate_time[UPG_SIGHT] = R2I(0 / 5)
  set gold_price[UPG_SIGHT] = 0
  set wood_price[UPG_SIGHT] = 0
  set hero_rush_bonus[UPG_SIGHT] = 0

  set old_id[UPG_DEFEND] = oUPG_DEFEND
  set buy_type[UPG_DEFEND] = BT_UPGRADE
  set needed1[UPG_DEFEND] = BARRACKS
  set needed2[UPG_DEFEND] = 0
  set needed3[UPG_DEFEND] = 0
  set tc_add1[UPG_DEFEND] = 0
  set tc_add2[UPG_DEFEND] = 0
  set available_time[UPG_DEFEND] = R2I(0 / 5)
  set regenerate_time[UPG_DEFEND] = R2I(0 / 5)
  set gold_price[UPG_DEFEND] = 0
  set wood_price[UPG_DEFEND] = 0
  set hero_rush_bonus[UPG_DEFEND] = 0

  set old_id[UPG_HAMMERS] = oUPG_HAMMERS
  set buy_type[UPG_HAMMERS] = BT_UPGRADE
  set needed1[UPG_HAMMERS] = AVIARY
  set needed2[UPG_HAMMERS] = CASTLE
  set needed3[UPG_HAMMERS] = 0
  set tc_add1[UPG_HAMMERS] = 0
  set tc_add2[UPG_HAMMERS] = 0
  set available_time[UPG_HAMMERS] = R2I(0 / 5)
  set regenerate_time[UPG_HAMMERS] = R2I(0 / 5)
  set gold_price[UPG_HAMMERS] = 0
  set wood_price[UPG_HAMMERS] = 0
  set hero_rush_bonus[UPG_HAMMERS] = 0

  set old_id[UPG_BREEDING] = oUPG_BREEDING
  set buy_type[UPG_BREEDING] = BT_UPGRADE
  set needed1[UPG_BREEDING] = BARRACKS
  set needed2[UPG_BREEDING] = CASTLE
  set needed3[UPG_BREEDING] = BLACKSMITH
  set tc_add1[UPG_BREEDING] = 0
  set tc_add2[UPG_BREEDING] = 0
  set available_time[UPG_BREEDING] = R2I(0 / 5)
  set regenerate_time[UPG_BREEDING] = R2I(0 / 5)
  set gold_price[UPG_BREEDING] = 0
  set wood_price[UPG_BREEDING] = 0
  set hero_rush_bonus[UPG_BREEDING] = 0

  set old_id[UPG_GUN_RANGE] = oUPG_GUN_RANGE
  set buy_type[UPG_GUN_RANGE] = BT_UPGRADE
  set needed1[UPG_GUN_RANGE] = BARRACKS
  set needed2[UPG_GUN_RANGE] = WORKSHOP
  set needed3[UPG_GUN_RANGE] = 0
  set tc_add1[UPG_GUN_RANGE] = 0
  set tc_add2[UPG_GUN_RANGE] = 0
  set available_time[UPG_GUN_RANGE] = R2I(0 / 5)
  set regenerate_time[UPG_GUN_RANGE] = R2I(0 / 5)
  set gold_price[UPG_GUN_RANGE] = 0
  set wood_price[UPG_GUN_RANGE] = 0
  set hero_rush_bonus[UPG_GUN_RANGE] = 0

  set old_id[UPG_SENTINEL] = oUPG_SENTINEL
  set buy_type[UPG_SENTINEL] = BT_UPGRADE
  set needed1[UPG_SENTINEL] = WORKSHOP
  set needed2[UPG_SENTINEL] = KEEP
  set needed3[UPG_SENTINEL] = 0
  set tc_add1[UPG_SENTINEL] = 0
  set tc_add2[UPG_SENTINEL] = 0
  set available_time[UPG_SENTINEL] = R2I(0 / 5)
  set regenerate_time[UPG_SENTINEL] = R2I(0 / 5)
  set gold_price[UPG_SENTINEL] = 0
  set wood_price[UPG_SENTINEL] = 0
  set hero_rush_bonus[UPG_SENTINEL] = 0

  set old_id[UPG_BOMBS] = oUPG_BOMBS
  set buy_type[UPG_BOMBS] = BT_UPGRADE
  set needed1[UPG_BOMBS] = WORKSHOP
  set needed2[UPG_BOMBS] = CASTLE
  set needed3[UPG_BOMBS] = 0
  set tc_add1[UPG_BOMBS] = 0
  set tc_add2[UPG_BOMBS] = 0
  set available_time[UPG_BOMBS] = R2I(0 / 5)
  set regenerate_time[UPG_BOMBS] = R2I(0 / 5)
  set gold_price[UPG_BOMBS] = 0
  set wood_price[UPG_BOMBS] = 0
  set hero_rush_bonus[UPG_BOMBS] = 0

  set old_id[CATAPULT] = oCATAPULT
  set buy_type[CATAPULT] = BT_UNIT
  set needed1[CATAPULT] = ORC_BARRACKS
  set needed2[CATAPULT] = STRONGHOLD
  set needed3[CATAPULT] = FORGE
  set tc_add1[CATAPULT] = 0
  set tc_add2[CATAPULT] = 0
  set available_time[CATAPULT] = R2I(0 / 5)
  set regenerate_time[CATAPULT] = R2I(0 / 5)
  set gold_price[CATAPULT] = 0
  set wood_price[CATAPULT] = 0
  set hero_rush_bonus[CATAPULT] = 0

  set old_id[WITCH_DOCTOR] = oWITCH_DOCTOR
  set buy_type[WITCH_DOCTOR] = BT_UNIT
  set needed1[WITCH_DOCTOR] = LODGE
  set needed2[WITCH_DOCTOR] = 0
  set needed3[WITCH_DOCTOR] = 0
  set tc_add1[WITCH_DOCTOR] = 0
  set tc_add2[WITCH_DOCTOR] = 0
  set available_time[WITCH_DOCTOR] = R2I(0 / 5)
  set regenerate_time[WITCH_DOCTOR] = R2I(0 / 5)
  set gold_price[WITCH_DOCTOR] = 0
  set wood_price[WITCH_DOCTOR] = 0
  set hero_rush_bonus[WITCH_DOCTOR] = 0

  set old_id[GRUNT] = oGRUNT
  set buy_type[GRUNT] = BT_UNIT
  set needed1[GRUNT] = ORC_BARRACKS
  set needed2[GRUNT] = 0
  set needed3[GRUNT] = 0
  set tc_add1[GRUNT] = 0
  set tc_add2[GRUNT] = 0
  set available_time[GRUNT] = R2I(0 / 5)
  set regenerate_time[GRUNT] = R2I(0 / 5)
  set gold_price[GRUNT] = 0
  set wood_price[GRUNT] = 0
  set hero_rush_bonus[GRUNT] = 0

  set old_id[HEAD_HUNTER] = oHEAD_HUNTER
  set buy_type[HEAD_HUNTER] = BT_UNIT
  set needed1[HEAD_HUNTER] = ORC_BARRACKS
  set needed2[HEAD_HUNTER] = FORGE
  set needed3[HEAD_HUNTER] = 0
  set tc_add1[HEAD_HUNTER] = 0
  set tc_add2[HEAD_HUNTER] = 0
  set available_time[HEAD_HUNTER] = R2I(0 / 5)
  set regenerate_time[HEAD_HUNTER] = R2I(0 / 5)
  set gold_price[HEAD_HUNTER] = 0
  set wood_price[HEAD_HUNTER] = 0
  set hero_rush_bonus[HEAD_HUNTER] = 0

  set old_id[KODO_BEAST] = oKODO_BEAST
  set buy_type[KODO_BEAST] = BT_UNIT
  set needed1[KODO_BEAST] = BESTIARY
  set needed2[KODO_BEAST] = FORGE
  set needed3[KODO_BEAST] = 0
  set tc_add1[KODO_BEAST] = 0
  set tc_add2[KODO_BEAST] = 0
  set available_time[KODO_BEAST] = R2I(0 / 5)
  set regenerate_time[KODO_BEAST] = R2I(0 / 5)
  set gold_price[KODO_BEAST] = 0
  set wood_price[KODO_BEAST] = 0
  set hero_rush_bonus[KODO_BEAST] = 0

  set old_id[PEON] = oPEON
  set buy_type[PEON] = BT_UNIT
  set needed1[PEON] = GREAT_HALL
  set needed2[PEON] = 0
  set needed3[PEON] = 0
  set tc_add1[PEON] = 0
  set tc_add2[PEON] = 0
  set available_time[PEON] = R2I(0 / 5)
  set regenerate_time[PEON] = R2I(0 / 5)
  set gold_price[PEON] = 0
  set wood_price[PEON] = 0
  set hero_rush_bonus[PEON] = 0

  set old_id[RAIDER] = oRAIDER
  set buy_type[RAIDER] = BT_UNIT
  set needed1[RAIDER] = BESTIARY
  set needed2[RAIDER] = 0
  set needed3[RAIDER] = 0
  set tc_add1[RAIDER] = 0
  set tc_add2[RAIDER] = 0
  set available_time[RAIDER] = R2I(0 / 5)
  set regenerate_time[RAIDER] = R2I(0 / 5)
  set gold_price[RAIDER] = 0
  set wood_price[RAIDER] = 0
  set hero_rush_bonus[RAIDER] = 0

  set old_id[SHAMAN] = oSHAMAN
  set buy_type[SHAMAN] = BT_UNIT
  set needed1[SHAMAN] = LODGE
  set needed2[SHAMAN] = 0
  set needed3[SHAMAN] = 0
  set tc_add1[SHAMAN] = 0
  set tc_add2[SHAMAN] = 0
  set available_time[SHAMAN] = R2I(0 / 5)
  set regenerate_time[SHAMAN] = R2I(0 / 5)
  set gold_price[SHAMAN] = 0
  set wood_price[SHAMAN] = 0
  set hero_rush_bonus[SHAMAN] = 0

  set old_id[TAUREN] = oTAUREN
  set buy_type[TAUREN] = BT_UNIT
  set needed1[TAUREN] = TOTEM
  set needed2[TAUREN] = 0
  set needed3[TAUREN] = 0
  set tc_add1[TAUREN] = 0
  set tc_add2[TAUREN] = 0
  set available_time[TAUREN] = R2I(0 / 5)
  set regenerate_time[TAUREN] = R2I(0 / 5)
  set gold_price[TAUREN] = 0
  set wood_price[TAUREN] = 0
  set hero_rush_bonus[TAUREN] = 0

  set old_id[WYVERN] = oWYVERN
  set buy_type[WYVERN] = BT_UNIT
  set needed1[WYVERN] = BESTIARY
  set needed2[WYVERN] = FORTRESS
  set needed3[WYVERN] = 0
  set tc_add1[WYVERN] = 0
  set tc_add2[WYVERN] = 0
  set available_time[WYVERN] = R2I(0 / 5)
  set regenerate_time[WYVERN] = R2I(0 / 5)
  set gold_price[WYVERN] = 0
  set wood_price[WYVERN] = 0
  set hero_rush_bonus[WYVERN] = 0

  set old_id[ORC_ALTAR] = oORC_ALTAR
  set buy_type[ORC_ALTAR] = BT_BUILDING
  set needed1[ORC_ALTAR] = PEON
  set needed2[ORC_ALTAR] = 0
  set needed3[ORC_ALTAR] = 0
  set tc_add1[ORC_ALTAR] = 0
  set tc_add2[ORC_ALTAR] = 0
  set available_time[ORC_ALTAR] = R2I(0 / 5)
  set regenerate_time[ORC_ALTAR] = R2I(0 / 5)
  set gold_price[ORC_ALTAR] = 0
  set wood_price[ORC_ALTAR] = 0
  set hero_rush_bonus[ORC_ALTAR] = 0

  set old_id[ORC_BARRACKS] = oORC_BARRACKS
  set buy_type[ORC_BARRACKS] = BT_BUILDING
  set needed1[ORC_BARRACKS] = PEON
  set needed2[ORC_BARRACKS] = 0
  set needed3[ORC_BARRACKS] = 0
  set tc_add1[ORC_BARRACKS] = 0
  set tc_add2[ORC_BARRACKS] = 0
  set available_time[ORC_BARRACKS] = R2I(0 / 5)
  set regenerate_time[ORC_BARRACKS] = R2I(0 / 5)
  set gold_price[ORC_BARRACKS] = 0
  set wood_price[ORC_BARRACKS] = 0
  set hero_rush_bonus[ORC_BARRACKS] = 0

  set old_id[BESTIARY] = oBESTIARY
  set buy_type[BESTIARY] = BT_BUILDING
  set needed1[BESTIARY] = PEON
  set needed2[BESTIARY] = STRONGHOLD
  set needed3[BESTIARY] = 0
  set tc_add1[BESTIARY] = 0
  set tc_add2[BESTIARY] = 0
  set available_time[BESTIARY] = R2I(0 / 5)
  set regenerate_time[BESTIARY] = R2I(0 / 5)
  set gold_price[BESTIARY] = 0
  set wood_price[BESTIARY] = 0
  set hero_rush_bonus[BESTIARY] = 0

  set old_id[FORGE] = oFORGE
  set buy_type[FORGE] = BT_BUILDING
  set needed1[FORGE] = PEON
  set needed2[FORGE] = 0
  set needed3[FORGE] = 0
  set tc_add1[FORGE] = 0
  set tc_add2[FORGE] = 0
  set available_time[FORGE] = R2I(0 / 5)
  set regenerate_time[FORGE] = R2I(0 / 5)
  set gold_price[FORGE] = 0
  set wood_price[FORGE] = 0
  set hero_rush_bonus[FORGE] = 0

  set old_id[FORTRESS] = oFORTRESS
  set buy_type[FORTRESS] = BT_BUILDING
  set needed1[FORTRESS] = STRONGHOLD
  set needed2[FORTRESS] = ORC_ALTAR
  set needed3[FORTRESS] = UPGRADED
  set tc_add1[FORTRESS] = 0
  set tc_add2[FORTRESS] = 0
  set available_time[FORTRESS] = R2I(0 / 5)
  set regenerate_time[FORTRESS] = R2I(0 / 5)
  set gold_price[FORTRESS] = 0
  set wood_price[FORTRESS] = 0
  set hero_rush_bonus[FORTRESS] = 0

  set old_id[GREAT_HALL] = oGREAT_HALL
  set buy_type[GREAT_HALL] = BT_BUILDING
  set needed1[GREAT_HALL] = 0
  set needed2[GREAT_HALL] = 0
  set needed3[GREAT_HALL] = 0
  set tc_add1[GREAT_HALL] = STRONGHOLD
  set tc_add2[GREAT_HALL] = FORTRESS
  set available_time[GREAT_HALL] = R2I(0 / 5)
  set regenerate_time[GREAT_HALL] = R2I(0 / 5)
  set gold_price[GREAT_HALL] = 0
  set wood_price[GREAT_HALL] = 0
  set hero_rush_bonus[GREAT_HALL] = 0

  set old_id[LODGE] = oLODGE
  set buy_type[LODGE] = BT_BUILDING
  set needed1[LODGE] = PEON
  set needed2[LODGE] = STRONGHOLD
  set needed3[LODGE] = 0
  set tc_add1[LODGE] = 0
  set tc_add2[LODGE] = 0
  set available_time[LODGE] = R2I(0 / 5)
  set regenerate_time[LODGE] = R2I(0 / 5)
  set gold_price[LODGE] = 0
  set wood_price[LODGE] = 0
  set hero_rush_bonus[LODGE] = 0

  set old_id[STRONGHOLD] = oSTRONGHOLD
  set buy_type[STRONGHOLD] = BT_BUILDING
  set needed1[STRONGHOLD] = GREAT_HALL
  set needed2[STRONGHOLD] = 0
  set needed3[STRONGHOLD] = UPGRADED
  set tc_add1[STRONGHOLD] = FORTRESS
  set tc_add2[STRONGHOLD] = 0
  set available_time[STRONGHOLD] = R2I(0 / 5)
  set regenerate_time[STRONGHOLD] = R2I(0 / 5)
  set gold_price[STRONGHOLD] = 0
  set wood_price[STRONGHOLD] = 0
  set hero_rush_bonus[STRONGHOLD] = 0

  set old_id[BURROW] = oBURROW
  set buy_type[BURROW] = BT_BUILDING
  set needed1[BURROW] = PEON
  set needed2[BURROW] = 0
  set needed3[BURROW] = 0
  set tc_add1[BURROW] = 0
  set tc_add2[BURROW] = 0
  set available_time[BURROW] = R2I(0 / 5)
  set regenerate_time[BURROW] = R2I(0 / 5)
  set gold_price[BURROW] = 0
  set wood_price[BURROW] = 0
  set hero_rush_bonus[BURROW] = 0

  set old_id[TOTEM] = oTOTEM
  set buy_type[TOTEM] = BT_BUILDING
  set needed1[TOTEM] = PEON
  set needed2[TOTEM] = FORTRESS
  set needed3[TOTEM] = FORGE
  set tc_add1[TOTEM] = 0
  set tc_add2[TOTEM] = 0
  set available_time[TOTEM] = R2I(0 / 5)
  set regenerate_time[TOTEM] = R2I(0 / 5)
  set gold_price[TOTEM] = 0
  set wood_price[TOTEM] = 0
  set hero_rush_bonus[TOTEM] = 0

  set old_id[ORC_WATCH_TOWER] = oORC_WATCH_TOWER
  set buy_type[ORC_WATCH_TOWER] = BT_BUILDING
  set needed1[ORC_WATCH_TOWER] = PEON
  set needed2[ORC_WATCH_TOWER] = FORGE
  set needed3[ORC_WATCH_TOWER] = 0
  set tc_add1[ORC_WATCH_TOWER] = 0
  set tc_add2[ORC_WATCH_TOWER] = 0
  set available_time[ORC_WATCH_TOWER] = R2I(0 / 5)
  set regenerate_time[ORC_WATCH_TOWER] = R2I(0 / 5)
  set gold_price[ORC_WATCH_TOWER] = 0
  set wood_price[ORC_WATCH_TOWER] = 0
  set hero_rush_bonus[ORC_WATCH_TOWER] = 0

  set old_id[UPG_ORC_WAR_DRUMS] = oUPG_ORC_WAR_DRUMS
  set buy_type[UPG_ORC_WAR_DRUMS] = BT_UPGRADE
  set needed1[UPG_ORC_WAR_DRUMS] = BESTIARY
  set needed2[UPG_ORC_WAR_DRUMS] = FORTRESS
  set needed3[UPG_ORC_WAR_DRUMS] = FORGE
  set tc_add1[UPG_ORC_WAR_DRUMS] = 0
  set tc_add2[UPG_ORC_WAR_DRUMS] = 0
  set available_time[UPG_ORC_WAR_DRUMS] = R2I(0 / 5)
  set regenerate_time[UPG_ORC_WAR_DRUMS] = R2I(0 / 5)
  set gold_price[UPG_ORC_WAR_DRUMS] = 0
  set wood_price[UPG_ORC_WAR_DRUMS] = 0
  set hero_rush_bonus[UPG_ORC_WAR_DRUMS] = 0

  set old_id[UPG_ORC_PILLAGE] = oUPG_ORC_PILLAGE
  set buy_type[UPG_ORC_PILLAGE] = BT_UPGRADE
  set needed1[UPG_ORC_PILLAGE] = GREAT_HALL
  set needed2[UPG_ORC_PILLAGE] = 0
  set needed3[UPG_ORC_PILLAGE] = 0
  set tc_add1[UPG_ORC_PILLAGE] = 0
  set tc_add2[UPG_ORC_PILLAGE] = 0
  set available_time[UPG_ORC_PILLAGE] = R2I(0 / 5)
  set regenerate_time[UPG_ORC_PILLAGE] = R2I(0 / 5)
  set gold_price[UPG_ORC_PILLAGE] = 0
  set wood_price[UPG_ORC_PILLAGE] = 0
  set hero_rush_bonus[UPG_ORC_PILLAGE] = 0

  set old_id[UPG_ORC_BERSERK] = oUPG_ORC_BERSERK
  set buy_type[UPG_ORC_BERSERK] = BT_UPGRADE
  set needed1[UPG_ORC_BERSERK] = ORC_BARRACKS
  set needed2[UPG_ORC_BERSERK] = STRONGHOLD
  set needed3[UPG_ORC_BERSERK] = 0
  set tc_add1[UPG_ORC_BERSERK] = 0
  set tc_add2[UPG_ORC_BERSERK] = 0
  set available_time[UPG_ORC_BERSERK] = R2I(0 / 5)
  set regenerate_time[UPG_ORC_BERSERK] = R2I(0 / 5)
  set gold_price[UPG_ORC_BERSERK] = 0
  set wood_price[UPG_ORC_BERSERK] = 0
  set hero_rush_bonus[UPG_ORC_BERSERK] = 0

  set old_id[UPG_ORC_PULVERIZE] = oUPG_ORC_PULVERIZE
  set buy_type[UPG_ORC_PULVERIZE] = BT_UPGRADE
  set needed1[UPG_ORC_PULVERIZE] = TOTEM
  set needed2[UPG_ORC_PULVERIZE] = 0
  set needed3[UPG_ORC_PULVERIZE] = 0
  set tc_add1[UPG_ORC_PULVERIZE] = 0
  set tc_add2[UPG_ORC_PULVERIZE] = 0
  set available_time[UPG_ORC_PULVERIZE] = R2I(0 / 5)
  set regenerate_time[UPG_ORC_PULVERIZE] = R2I(0 / 5)
  set gold_price[UPG_ORC_PULVERIZE] = 0
  set wood_price[UPG_ORC_PULVERIZE] = 0
  set hero_rush_bonus[UPG_ORC_PULVERIZE] = 0

  set old_id[UPG_ORC_ENSNARE] = oUPG_ORC_ENSNARE
  set buy_type[UPG_ORC_ENSNARE] = BT_UPGRADE
  set needed1[UPG_ORC_ENSNARE] = BESTIARY
  set needed2[UPG_ORC_ENSNARE] = 0
  set needed3[UPG_ORC_ENSNARE] = 0
  set tc_add1[UPG_ORC_ENSNARE] = 0
  set tc_add2[UPG_ORC_ENSNARE] = 0
  set available_time[UPG_ORC_ENSNARE] = R2I(0 / 5)
  set regenerate_time[UPG_ORC_ENSNARE] = R2I(0 / 5)
  set gold_price[UPG_ORC_ENSNARE] = 0
  set wood_price[UPG_ORC_ENSNARE] = 0
  set hero_rush_bonus[UPG_ORC_ENSNARE] = 0

  set old_id[UPG_ORC_VENOM] = oUPG_ORC_VENOM
  set buy_type[UPG_ORC_VENOM] = BT_UPGRADE
  set needed1[UPG_ORC_VENOM] = BESTIARY
  set needed2[UPG_ORC_VENOM] = FORTRESS
  set needed3[UPG_ORC_VENOM] = 0
  set tc_add1[UPG_ORC_VENOM] = 0
  set tc_add2[UPG_ORC_VENOM] = 0
  set available_time[UPG_ORC_VENOM] = R2I(0 / 5)
  set regenerate_time[UPG_ORC_VENOM] = R2I(0 / 5)
  set gold_price[UPG_ORC_VENOM] = 0
  set wood_price[UPG_ORC_VENOM] = 0
  set hero_rush_bonus[UPG_ORC_VENOM] = 0

  set old_id[UPG_ORC_REGEN] = oUPG_ORC_REGEN
  set buy_type[UPG_ORC_REGEN] = BT_UPGRADE
  set needed1[UPG_ORC_REGEN] = ORC_BARRACKS
  set needed2[UPG_ORC_REGEN] = STRONGHOLD
  set needed3[UPG_ORC_REGEN] = FORGE
  set tc_add1[UPG_ORC_REGEN] = 0
  set tc_add2[UPG_ORC_REGEN] = 0
  set available_time[UPG_ORC_REGEN] = R2I(0 / 5)
  set regenerate_time[UPG_ORC_REGEN] = R2I(0 / 5)
  set gold_price[UPG_ORC_REGEN] = 0
  set wood_price[UPG_ORC_REGEN] = 0
  set hero_rush_bonus[UPG_ORC_REGEN] = 0

  set old_id[ABOMINATION] = oABOMINATION
  set buy_type[ABOMINATION] = BT_UNIT
  set needed1[ABOMINATION] = SLAUGHTERHOUSE
  set needed2[ABOMINATION] = NECROPOLIS_3
  set needed3[ABOMINATION] = 0
  set tc_add1[ABOMINATION] = 0
  set tc_add2[ABOMINATION] = 0
  set available_time[ABOMINATION] = R2I(0 / 5)
  set regenerate_time[ABOMINATION] = R2I(0 / 5)
  set gold_price[ABOMINATION] = 0
  set wood_price[ABOMINATION] = 0
  set hero_rush_bonus[ABOMINATION] = 0

  set old_id[ACOLYTE] = oACOLYTE
  set buy_type[ACOLYTE] = BT_UNIT
  set needed1[ACOLYTE] = NECROPOLIS_1
  set needed2[ACOLYTE] = 0
  set needed3[ACOLYTE] = 0
  set tc_add1[ACOLYTE] = 0
  set tc_add2[ACOLYTE] = 0
  set available_time[ACOLYTE] = R2I(0 / 5)
  set regenerate_time[ACOLYTE] = R2I(0 / 5)
  set gold_price[ACOLYTE] = 0
  set wood_price[ACOLYTE] = 0
  set hero_rush_bonus[ACOLYTE] = 0

  set old_id[BANSHEE] = oBANSHEE
  set buy_type[BANSHEE] = BT_UNIT
  set needed1[BANSHEE] = DAMNED_TEMPLE
  set needed2[BANSHEE] = 0
  set needed3[BANSHEE] = 0
  set tc_add1[BANSHEE] = 0
  set tc_add2[BANSHEE] = 0
  set available_time[BANSHEE] = R2I(0 / 5)
  set regenerate_time[BANSHEE] = R2I(0 / 5)
  set gold_price[BANSHEE] = 0
  set wood_price[BANSHEE] = 0
  set hero_rush_bonus[BANSHEE] = 0

  set old_id[CRYPT_FIEND] = oCRYPT_FIEND
  set buy_type[CRYPT_FIEND] = BT_UNIT
  set needed1[CRYPT_FIEND] = CRYPT
  set needed2[CRYPT_FIEND] = GRAVEYARD
  set needed3[CRYPT_FIEND] = 0
  set tc_add1[CRYPT_FIEND] = 0
  set tc_add2[CRYPT_FIEND] = 0
  set available_time[CRYPT_FIEND] = R2I(0 / 5)
  set regenerate_time[CRYPT_FIEND] = R2I(0 / 5)
  set gold_price[CRYPT_FIEND] = 0
  set wood_price[CRYPT_FIEND] = 0
  set hero_rush_bonus[CRYPT_FIEND] = 0

  set old_id[FROST_WYRM] = oFROST_WYRM
  set buy_type[FROST_WYRM] = BT_UNIT
  set needed1[FROST_WYRM] = BONEYARD
  set needed2[FROST_WYRM] = 0
  set needed3[FROST_WYRM] = 0
  set tc_add1[FROST_WYRM] = 0
  set tc_add2[FROST_WYRM] = 0
  set available_time[FROST_WYRM] = R2I(0 / 5)
  set regenerate_time[FROST_WYRM] = R2I(0 / 5)
  set gold_price[FROST_WYRM] = 0
  set wood_price[FROST_WYRM] = 0
  set hero_rush_bonus[FROST_WYRM] = 0

  set old_id[GARGOYLE] = oGARGOYLE
  set buy_type[GARGOYLE] = BT_UNIT
  set needed1[GARGOYLE] = CRYPT
  set needed2[GARGOYLE] = NECROPOLIS_3
  set needed3[GARGOYLE] = GRAVEYARD
  set tc_add1[GARGOYLE] = 0
  set tc_add2[GARGOYLE] = GARGOYLE_MORPH
  set available_time[GARGOYLE] = R2I(0 / 5)
  set regenerate_time[GARGOYLE] = R2I(0 / 5)
  set gold_price[GARGOYLE] = 0
  set wood_price[GARGOYLE] = 0
  set hero_rush_bonus[GARGOYLE] = 0

  set old_id[GARGOYLE_MORPH] = oGARGOYLE_MORPH
  set buy_type[GARGOYLE_MORPH] = BT_UNIT
  set needed1[GARGOYLE_MORPH] = 0
  set needed2[GARGOYLE_MORPH] = 0
  set needed3[GARGOYLE_MORPH] = 0
  set tc_add1[GARGOYLE_MORPH] = 0
  set tc_add2[GARGOYLE_MORPH] = GARGOYLE
  set available_time[GARGOYLE_MORPH] = R2I(0 / 5)
  set regenerate_time[GARGOYLE_MORPH] = R2I(0 / 5)
  set gold_price[GARGOYLE_MORPH] = 0
  set wood_price[GARGOYLE_MORPH] = 0
  set hero_rush_bonus[GARGOYLE_MORPH] = 0

  set old_id[GHOUL] = oGHOUL
  set buy_type[GHOUL] = BT_UNIT
  set needed1[GHOUL] = CRYPT
  set needed2[GHOUL] = 0
  set needed3[GHOUL] = 0
  set tc_add1[GHOUL] = 0
  set tc_add2[GHOUL] = 0
  set available_time[GHOUL] = R2I(0 / 5)
  set regenerate_time[GHOUL] = R2I(0 / 5)
  set gold_price[GHOUL] = 0
  set wood_price[GHOUL] = 0
  set hero_rush_bonus[GHOUL] = 0

  set old_id[MEAT_WAGON] = oMEAT_WAGON
  set buy_type[MEAT_WAGON] = BT_UNIT
  set needed1[MEAT_WAGON] = SLAUGHTERHOUSE
  set needed2[MEAT_WAGON] = 0
  set needed3[MEAT_WAGON] = 0
  set tc_add1[MEAT_WAGON] = 0
  set tc_add2[MEAT_WAGON] = 0
  set available_time[MEAT_WAGON] = R2I(0 / 5)
  set regenerate_time[MEAT_WAGON] = R2I(0 / 5)
  set gold_price[MEAT_WAGON] = 0
  set wood_price[MEAT_WAGON] = 0
  set hero_rush_bonus[MEAT_WAGON] = 0

  set old_id[NECRO] = oNECRO
  set buy_type[NECRO] = BT_UNIT
  set needed1[NECRO] = DAMNED_TEMPLE
  set needed2[NECRO] = 0
  set needed3[NECRO] = 0
  set tc_add1[NECRO] = 0
  set tc_add2[NECRO] = 0
  set available_time[NECRO] = R2I(0 / 5)
  set regenerate_time[NECRO] = R2I(0 / 5)
  set gold_price[NECRO] = 0
  set wood_price[NECRO] = 0
  set hero_rush_bonus[NECRO] = 0

  set old_id[SKEL_WARRIOR] = oSKEL_WARRIOR
  set buy_type[SKEL_WARRIOR] = BT_UNIT
  set needed1[SKEL_WARRIOR] = 0
  set needed2[SKEL_WARRIOR] = 0
  set needed3[SKEL_WARRIOR] = 0
  set tc_add1[SKEL_WARRIOR] = 0
  set tc_add2[SKEL_WARRIOR] = 0
  set available_time[SKEL_WARRIOR] = R2I(0 / 5)
  set regenerate_time[SKEL_WARRIOR] = R2I(0 / 5)
  set gold_price[SKEL_WARRIOR] = 0
  set wood_price[SKEL_WARRIOR] = 0
  set hero_rush_bonus[SKEL_WARRIOR] = 0

  set old_id[SHADE] = oSHADE
  set buy_type[SHADE] = BT_UNIT
  set needed1[SHADE] = ACOLYTE
  set needed2[SHADE] = SAC_PIT
  set needed3[SHADE] = 0
  set tc_add1[SHADE] = 0
  set tc_add2[SHADE] = 0
  set available_time[SHADE] = R2I(0 / 5)
  set regenerate_time[SHADE] = R2I(0 / 5)
  set gold_price[SHADE] = 0
  set wood_price[SHADE] = 0
  set hero_rush_bonus[SHADE] = 0

  set old_id[UNDEAD_MINE] = oUNDEAD_MINE
  set buy_type[UNDEAD_MINE] = BT_BUILDING
  set needed1[UNDEAD_MINE] = ACOLYTE
  set needed2[UNDEAD_MINE] = 0
  set needed3[UNDEAD_MINE] = 0
  set tc_add1[UNDEAD_MINE] = 0
  set tc_add2[UNDEAD_MINE] = 0
  set available_time[UNDEAD_MINE] = R2I(0 / 5)
  set regenerate_time[UNDEAD_MINE] = R2I(0 / 5)
  set gold_price[UNDEAD_MINE] = 0
  set wood_price[UNDEAD_MINE] = 0
  set hero_rush_bonus[UNDEAD_MINE] = 0

  set old_id[UNDEAD_ALTAR] = oUNDEAD_ALTAR
  set buy_type[UNDEAD_ALTAR] = BT_BUILDING
  set needed1[UNDEAD_ALTAR] = ACOLYTE
  set needed2[UNDEAD_ALTAR] = 0
  set needed3[UNDEAD_ALTAR] = 0
  set tc_add1[UNDEAD_ALTAR] = 0
  set tc_add2[UNDEAD_ALTAR] = 0
  set available_time[UNDEAD_ALTAR] = R2I(0 / 5)
  set regenerate_time[UNDEAD_ALTAR] = R2I(0 / 5)
  set gold_price[UNDEAD_ALTAR] = 0
  set wood_price[UNDEAD_ALTAR] = 0
  set hero_rush_bonus[UNDEAD_ALTAR] = 0

  set old_id[BONEYARD] = oBONEYARD
  set buy_type[BONEYARD] = BT_BUILDING
  set needed1[BONEYARD] = ACOLYTE
  set needed2[BONEYARD] = NECROPOLIS_3
  set needed3[BONEYARD] = SAC_PIT
  set tc_add1[BONEYARD] = 0
  set tc_add2[BONEYARD] = 0
  set available_time[BONEYARD] = R2I(0 / 5)
  set regenerate_time[BONEYARD] = R2I(0 / 5)
  set gold_price[BONEYARD] = 0
  set wood_price[BONEYARD] = 0
  set hero_rush_bonus[BONEYARD] = 0

  set old_id[NECROPOLIS_1] = oNECROPOLIS_1
  set buy_type[NECROPOLIS_1] = BT_BUILDING
  set needed1[NECROPOLIS_1] = 0
  set needed2[NECROPOLIS_1] = 0
  set needed3[NECROPOLIS_1] = 0
  set tc_add1[NECROPOLIS_1] = NECROPOLIS_2
  set tc_add2[NECROPOLIS_1] = NECROPOLIS_3
  set available_time[NECROPOLIS_1] = R2I(0 / 5)
  set regenerate_time[NECROPOLIS_1] = R2I(0 / 5)
  set gold_price[NECROPOLIS_1] = 0
  set wood_price[NECROPOLIS_1] = 0
  set hero_rush_bonus[NECROPOLIS_1] = 0

  set old_id[NECROPOLIS_2] = oNECROPOLIS_2
  set buy_type[NECROPOLIS_2] = BT_BUILDING
  set needed1[NECROPOLIS_2] = NECROPOLIS_1
  set needed2[NECROPOLIS_2] = 0
  set needed3[NECROPOLIS_2] = UPGRADED
  set tc_add1[NECROPOLIS_2] = NECROPOLIS_3
  set tc_add2[NECROPOLIS_2] = 0
  set available_time[NECROPOLIS_2] = R2I(0 / 5)
  set regenerate_time[NECROPOLIS_2] = R2I(0 / 5)
  set gold_price[NECROPOLIS_2] = 0
  set wood_price[NECROPOLIS_2] = 0
  set hero_rush_bonus[NECROPOLIS_2] = 0

  set old_id[NECROPOLIS_3] = oNECROPOLIS_3
  set buy_type[NECROPOLIS_3] = BT_BUILDING
  set needed1[NECROPOLIS_3] = NECROPOLIS_2
  set needed2[NECROPOLIS_3] = UNDEAD_ALTAR
  set needed3[NECROPOLIS_3] = UPGRADED
  set tc_add1[NECROPOLIS_3] = 0
  set tc_add2[NECROPOLIS_3] = 0
  set available_time[NECROPOLIS_3] = R2I(0 / 5)
  set regenerate_time[NECROPOLIS_3] = R2I(0 / 5)
  set gold_price[NECROPOLIS_3] = 0
  set wood_price[NECROPOLIS_3] = 0
  set hero_rush_bonus[NECROPOLIS_3] = 0

  set old_id[SAC_PIT] = oSAC_PIT
  set buy_type[SAC_PIT] = BT_BUILDING
  set needed1[SAC_PIT] = ACOLYTE
  set needed2[SAC_PIT] = NECROPOLIS_2
  set needed3[SAC_PIT] = 0
  set tc_add1[SAC_PIT] = 0
  set tc_add2[SAC_PIT] = 0
  set available_time[SAC_PIT] = R2I(0 / 5)
  set regenerate_time[SAC_PIT] = R2I(0 / 5)
  set gold_price[SAC_PIT] = 0
  set wood_price[SAC_PIT] = 0
  set hero_rush_bonus[SAC_PIT] = 0

  set old_id[CRYPT] = oCRYPT
  set buy_type[CRYPT] = BT_BUILDING
  set needed1[CRYPT] = ACOLYTE
  set needed2[CRYPT] = 0
  set needed3[CRYPT] = 0
  set tc_add1[CRYPT] = 0
  set tc_add2[CRYPT] = 0
  set available_time[CRYPT] = R2I(0 / 5)
  set regenerate_time[CRYPT] = R2I(0 / 5)
  set gold_price[CRYPT] = 0
  set wood_price[CRYPT] = 0
  set hero_rush_bonus[CRYPT] = 0

  set old_id[SLAUGHTERHOUSE] = oSLAUGHTERHOUSE
  set buy_type[SLAUGHTERHOUSE] = BT_BUILDING
  set needed1[SLAUGHTERHOUSE] = ACOLYTE
  set needed2[SLAUGHTERHOUSE] = NECROPOLIS_2
  set needed3[SLAUGHTERHOUSE] = GRAVEYARD
  set tc_add1[SLAUGHTERHOUSE] = 0
  set tc_add2[SLAUGHTERHOUSE] = 0
  set available_time[SLAUGHTERHOUSE] = R2I(0 / 5)
  set regenerate_time[SLAUGHTERHOUSE] = R2I(0 / 5)
  set gold_price[SLAUGHTERHOUSE] = 0
  set wood_price[SLAUGHTERHOUSE] = 0
  set hero_rush_bonus[SLAUGHTERHOUSE] = 0

  set old_id[DAMNED_TEMPLE] = oDAMNED_TEMPLE
  set buy_type[DAMNED_TEMPLE] = BT_BUILDING
  set needed1[DAMNED_TEMPLE] = ACOLYTE
  set needed2[DAMNED_TEMPLE] = NECROPOLIS_2
  set needed3[DAMNED_TEMPLE] = 0
  set tc_add1[DAMNED_TEMPLE] = 0
  set tc_add2[DAMNED_TEMPLE] = 0
  set available_time[DAMNED_TEMPLE] = R2I(0 / 5)
  set regenerate_time[DAMNED_TEMPLE] = R2I(0 / 5)
  set gold_price[DAMNED_TEMPLE] = 0
  set wood_price[DAMNED_TEMPLE] = 0
  set hero_rush_bonus[DAMNED_TEMPLE] = 0

  set old_id[ZIGGURAT_1] = oZIGGURAT_1
  set buy_type[ZIGGURAT_1] = BT_BUILDING
  set needed1[ZIGGURAT_1] = ACOLYTE
  set needed2[ZIGGURAT_1] = 0
  set needed3[ZIGGURAT_1] = 0
  set tc_add1[ZIGGURAT_1] = ZIGGURAT_2
  set tc_add2[ZIGGURAT_1] = 0
  set available_time[ZIGGURAT_1] = R2I(0 / 5)
  set regenerate_time[ZIGGURAT_1] = R2I(0 / 5)
  set gold_price[ZIGGURAT_1] = 0
  set wood_price[ZIGGURAT_1] = 0
  set hero_rush_bonus[ZIGGURAT_1] = 0

  set old_id[ZIGGURAT_2] = oZIGGURAT_2
  set buy_type[ZIGGURAT_2] = BT_BUILDING
  set needed1[ZIGGURAT_2] = ZIGGURAT_1
  set needed2[ZIGGURAT_2] = GRAVEYARD
  set needed3[ZIGGURAT_2] = UPGRADED
  set tc_add1[ZIGGURAT_2] = 0
  set tc_add2[ZIGGURAT_2] = 0
  set available_time[ZIGGURAT_2] = R2I(0 / 5)
  set regenerate_time[ZIGGURAT_2] = R2I(0 / 5)
  set gold_price[ZIGGURAT_2] = 0
  set wood_price[ZIGGURAT_2] = 0
  set hero_rush_bonus[ZIGGURAT_2] = 0

  set old_id[GRAVEYARD] = oGRAVEYARD
  set buy_type[GRAVEYARD] = BT_BUILDING
  set needed1[GRAVEYARD] = ACOLYTE
  set needed2[GRAVEYARD] = 0
  set needed3[GRAVEYARD] = 0
  set tc_add1[GRAVEYARD] = 0
  set tc_add2[GRAVEYARD] = 0
  set available_time[GRAVEYARD] = R2I(0 / 5)
  set regenerate_time[GRAVEYARD] = R2I(0 / 5)
  set gold_price[GRAVEYARD] = 0
  set wood_price[GRAVEYARD] = 0
  set hero_rush_bonus[GRAVEYARD] = 0

  set old_id[UPG_CANNIBALIZE] = oUPG_CANNIBALIZE
  set buy_type[UPG_CANNIBALIZE] = BT_UPGRADE
  set needed1[UPG_CANNIBALIZE] = CRYPT
  set needed2[UPG_CANNIBALIZE] = 0
  set needed3[UPG_CANNIBALIZE] = 0
  set tc_add1[UPG_CANNIBALIZE] = 0
  set tc_add2[UPG_CANNIBALIZE] = 0
  set available_time[UPG_CANNIBALIZE] = R2I(0 / 5)
  set regenerate_time[UPG_CANNIBALIZE] = R2I(0 / 5)
  set gold_price[UPG_CANNIBALIZE] = 0
  set wood_price[UPG_CANNIBALIZE] = 0
  set hero_rush_bonus[UPG_CANNIBALIZE] = 0

  set old_id[UPG_GHOUL_FRENZY] = oUPG_GHOUL_FRENZY
  set buy_type[UPG_GHOUL_FRENZY] = BT_UPGRADE
  set needed1[UPG_GHOUL_FRENZY] = CRYPT
  set needed2[UPG_GHOUL_FRENZY] = NECROPOLIS_3
  set needed3[UPG_GHOUL_FRENZY] = GRAVEYARD
  set tc_add1[UPG_GHOUL_FRENZY] = 0
  set tc_add2[UPG_GHOUL_FRENZY] = 0
  set available_time[UPG_GHOUL_FRENZY] = R2I(0 / 5)
  set regenerate_time[UPG_GHOUL_FRENZY] = R2I(0 / 5)
  set gold_price[UPG_GHOUL_FRENZY] = 0
  set wood_price[UPG_GHOUL_FRENZY] = 0
  set hero_rush_bonus[UPG_GHOUL_FRENZY] = 0

  set old_id[UPG_FIEND_WEB] = oUPG_FIEND_WEB
  set buy_type[UPG_FIEND_WEB] = BT_UPGRADE
  set needed1[UPG_FIEND_WEB] = CRYPT
  set needed2[UPG_FIEND_WEB] = GRAVEYARD
  set needed3[UPG_FIEND_WEB] = 0
  set tc_add1[UPG_FIEND_WEB] = 0
  set tc_add2[UPG_FIEND_WEB] = 0
  set available_time[UPG_FIEND_WEB] = R2I(0 / 5)
  set regenerate_time[UPG_FIEND_WEB] = R2I(0 / 5)
  set gold_price[UPG_FIEND_WEB] = 0
  set wood_price[UPG_FIEND_WEB] = 0
  set hero_rush_bonus[UPG_FIEND_WEB] = 0

  set old_id[UPG_STONE_FORM] = oUPG_STONE_FORM
  set buy_type[UPG_STONE_FORM] = BT_UPGRADE
  set needed1[UPG_STONE_FORM] = CRYPT
  set needed2[UPG_STONE_FORM] = NECROPOLIS_3
  set needed3[UPG_STONE_FORM] = GRAVEYARD
  set tc_add1[UPG_STONE_FORM] = 0
  set tc_add2[UPG_STONE_FORM] = 0
  set available_time[UPG_STONE_FORM] = R2I(0 / 5)
  set regenerate_time[UPG_STONE_FORM] = R2I(0 / 5)
  set gold_price[UPG_STONE_FORM] = 0
  set wood_price[UPG_STONE_FORM] = 0
  set hero_rush_bonus[UPG_STONE_FORM] = 0

  set old_id[UPG_WYRM_BREATH] = oUPG_WYRM_BREATH
  set buy_type[UPG_WYRM_BREATH] = BT_UPGRADE
  set needed1[UPG_WYRM_BREATH] = BONEYARD
  set needed2[UPG_WYRM_BREATH] = 0
  set needed3[UPG_WYRM_BREATH] = 0
  set tc_add1[UPG_WYRM_BREATH] = 0
  set tc_add2[UPG_WYRM_BREATH] = 0
  set available_time[UPG_WYRM_BREATH] = R2I(0 / 5)
  set regenerate_time[UPG_WYRM_BREATH] = R2I(0 / 5)
  set gold_price[UPG_WYRM_BREATH] = 0
  set wood_price[UPG_WYRM_BREATH] = 0
  set hero_rush_bonus[UPG_WYRM_BREATH] = 0

  set old_id[UPG_SKEL_LIFE] = oUPG_SKEL_LIFE
  set buy_type[UPG_SKEL_LIFE] = BT_UPGRADE
  set needed1[UPG_SKEL_LIFE] = DAMNED_TEMPLE
  set needed2[UPG_SKEL_LIFE] = 0
  set needed3[UPG_SKEL_LIFE] = 0
  set tc_add1[UPG_SKEL_LIFE] = 0
  set tc_add2[UPG_SKEL_LIFE] = 0
  set available_time[UPG_SKEL_LIFE] = R2I(0 / 5)
  set regenerate_time[UPG_SKEL_LIFE] = R2I(0 / 5)
  set gold_price[UPG_SKEL_LIFE] = 0
  set wood_price[UPG_SKEL_LIFE] = 0
  set hero_rush_bonus[UPG_SKEL_LIFE] = 0

  set old_id[UPG_PLAGUE] = oUPG_PLAGUE
  set buy_type[UPG_PLAGUE] = BT_UPGRADE
  set needed1[UPG_PLAGUE] = SLAUGHTERHOUSE
  set needed2[UPG_PLAGUE] = 0
  set needed3[UPG_PLAGUE] = 0
  set tc_add1[UPG_PLAGUE] = 0
  set tc_add2[UPG_PLAGUE] = 0
  set available_time[UPG_PLAGUE] = R2I(0 / 5)
  set regenerate_time[UPG_PLAGUE] = R2I(0 / 5)
  set gold_price[UPG_PLAGUE] = 0
  set wood_price[UPG_PLAGUE] = 0
  set hero_rush_bonus[UPG_PLAGUE] = 0

  set old_id[WISP] = oWISP
  set buy_type[WISP] = BT_UNIT
  set needed1[WISP] = TREE_LIFE
  set needed2[WISP] = 0
  set needed3[WISP] = 0
  set tc_add1[WISP] = 0
  set tc_add2[WISP] = 0
  set available_time[WISP] = R2I(0 / 5)
  set regenerate_time[WISP] = R2I(0 / 5)
  set gold_price[WISP] = 0
  set wood_price[WISP] = 0
  set hero_rush_bonus[WISP] = 0

  set old_id[ARCHER] = oARCHER
  set buy_type[ARCHER] = BT_UNIT
  set needed1[ARCHER] = ANCIENT_WAR
  set needed2[ARCHER] = 0
  set needed3[ARCHER] = 0
  set tc_add1[ARCHER] = 0
  set tc_add2[ARCHER] = 0
  set available_time[ARCHER] = R2I(0 / 5)
  set regenerate_time[ARCHER] = R2I(0 / 5)
  set gold_price[ARCHER] = 0
  set wood_price[ARCHER] = 0
  set hero_rush_bonus[ARCHER] = 0

  set old_id[DRUID_TALON] = oDRUID_TALON
  set buy_type[DRUID_TALON] = BT_UNIT
  set needed1[DRUID_TALON] = ANCIENT_WIND
  set needed2[DRUID_TALON] = 0
  set needed3[DRUID_TALON] = 0
  set tc_add1[DRUID_TALON] = 0
  set tc_add2[DRUID_TALON] = DRUID_TALON_M
  set available_time[DRUID_TALON] = R2I(0 / 5)
  set regenerate_time[DRUID_TALON] = R2I(0 / 5)
  set gold_price[DRUID_TALON] = 0
  set wood_price[DRUID_TALON] = 0
  set hero_rush_bonus[DRUID_TALON] = 0

  set old_id[DRUID_TALON_M] = oDRUID_TALON_M
  set buy_type[DRUID_TALON_M] = BT_UNIT
  set needed1[DRUID_TALON_M] = 0
  set needed2[DRUID_TALON_M] = 0
  set needed3[DRUID_TALON_M] = 0
  set tc_add1[DRUID_TALON_M] = 0
  set tc_add2[DRUID_TALON_M] = DRUID_TALON
  set available_time[DRUID_TALON_M] = R2I(0 / 5)
  set regenerate_time[DRUID_TALON_M] = R2I(0 / 5)
  set gold_price[DRUID_TALON_M] = 0
  set wood_price[DRUID_TALON_M] = 0
  set hero_rush_bonus[DRUID_TALON_M] = 0

  set old_id[BALLISTA] = oBALLISTA
  set buy_type[BALLISTA] = BT_UNIT
  set needed1[BALLISTA] = ANCIENT_WAR
  set needed2[BALLISTA] = TREE_AGES
  set needed3[BALLISTA] = HUNTERS_HALL
  set tc_add1[BALLISTA] = 0
  set tc_add2[BALLISTA] = 0
  set available_time[BALLISTA] = R2I(0 / 5)
  set regenerate_time[BALLISTA] = R2I(0 / 5)
  set gold_price[BALLISTA] = 0
  set wood_price[BALLISTA] = 0
  set hero_rush_bonus[BALLISTA] = 0

  set old_id[DRUID_CLAW] = oDRUID_CLAW
  set buy_type[DRUID_CLAW] = BT_UNIT
  set needed1[DRUID_CLAW] = ANCIENT_LORE
  set needed2[DRUID_CLAW] = TREE_AGES
  set needed3[DRUID_CLAW] = 0
  set tc_add1[DRUID_CLAW] = 0
  set tc_add2[DRUID_CLAW] = DRUID_CLAW_M
  set available_time[DRUID_CLAW] = R2I(0 / 5)
  set regenerate_time[DRUID_CLAW] = R2I(0 / 5)
  set gold_price[DRUID_CLAW] = 0
  set wood_price[DRUID_CLAW] = 0
  set hero_rush_bonus[DRUID_CLAW] = 0

  set old_id[DRUID_CLAW_M] = oDRUID_CLAW_M
  set buy_type[DRUID_CLAW_M] = BT_UNIT
  set needed1[DRUID_CLAW_M] = 0
  set needed2[DRUID_CLAW_M] = 0
  set needed3[DRUID_CLAW_M] = 0
  set tc_add1[DRUID_CLAW_M] = 0
  set tc_add2[DRUID_CLAW_M] = DRUID_CLAW
  set available_time[DRUID_CLAW_M] = R2I(0 / 5)
  set regenerate_time[DRUID_CLAW_M] = R2I(0 / 5)
  set gold_price[DRUID_CLAW_M] = 0
  set wood_price[DRUID_CLAW_M] = 0
  set hero_rush_bonus[DRUID_CLAW_M] = 0

  set old_id[DRYAD] = oDRYAD
  set buy_type[DRYAD] = BT_UNIT
  set needed1[DRYAD] = ANCIENT_LORE
  set needed2[DRYAD] = 0
  set needed3[DRYAD] = 0
  set tc_add1[DRYAD] = 0
  set tc_add2[DRYAD] = 0
  set available_time[DRYAD] = R2I(0 / 5)
  set regenerate_time[DRYAD] = R2I(0 / 5)
  set gold_price[DRYAD] = 0
  set wood_price[DRYAD] = 0
  set hero_rush_bonus[DRYAD] = 0

  set old_id[HIPPO] = oHIPPO
  set buy_type[HIPPO] = BT_UNIT
  set needed1[HIPPO] = ANCIENT_WIND
  set needed2[HIPPO] = 0
  set needed3[HIPPO] = 0
  set tc_add1[HIPPO] = 0
  set tc_add2[HIPPO] = 0
  set available_time[HIPPO] = R2I(0 / 5)
  set regenerate_time[HIPPO] = R2I(0 / 5)
  set gold_price[HIPPO] = 0
  set wood_price[HIPPO] = 0
  set hero_rush_bonus[HIPPO] = 0

  set old_id[HIPPO_RIDER] = oHIPPO_RIDER
  set buy_type[HIPPO_RIDER] = BT_UNIT
  set needed1[HIPPO_RIDER] = 0
  set needed2[HIPPO_RIDER] = 0
  set needed3[HIPPO_RIDER] = 0
  set tc_add1[HIPPO_RIDER] = 0
  set tc_add2[HIPPO_RIDER] = 0
  set available_time[HIPPO_RIDER] = R2I(0 / 5)
  set regenerate_time[HIPPO_RIDER] = R2I(0 / 5)
  set gold_price[HIPPO_RIDER] = 0
  set wood_price[HIPPO_RIDER] = 0
  set hero_rush_bonus[HIPPO_RIDER] = 0

  set old_id[HUNTRESS] = oHUNTRESS
  set buy_type[HUNTRESS] = BT_UNIT
  set needed1[HUNTRESS] = ANCIENT_WAR
  set needed2[HUNTRESS] = HUNTERS_HALL
  set needed3[HUNTRESS] = 0
  set tc_add1[HUNTRESS] = 0
  set tc_add2[HUNTRESS] = 0
  set available_time[HUNTRESS] = R2I(0 / 5)
  set regenerate_time[HUNTRESS] = R2I(0 / 5)
  set gold_price[HUNTRESS] = 0
  set wood_price[HUNTRESS] = 0
  set hero_rush_bonus[HUNTRESS] = 0

  set old_id[CHIMAERA] = oCHIMAERA
  set buy_type[CHIMAERA] = BT_UNIT
  set needed1[CHIMAERA] = CHIMAERA_ROOST
  set needed2[CHIMAERA] = 0
  set needed3[CHIMAERA] = 0
  set tc_add1[CHIMAERA] = 0
  set tc_add2[CHIMAERA] = 0
  set available_time[CHIMAERA] = R2I(0 / 5)
  set regenerate_time[CHIMAERA] = R2I(0 / 5)
  set gold_price[CHIMAERA] = 0
  set wood_price[CHIMAERA] = 0
  set hero_rush_bonus[CHIMAERA] = 0

  set old_id[ANCIENT_LORE] = oANCIENT_LORE
  set buy_type[ANCIENT_LORE] = BT_BUILDING
  set needed1[ANCIENT_LORE] = WISP
  set needed2[ANCIENT_LORE] = TREE_AGES
  set needed3[ANCIENT_LORE] = HUNTERS_HALL
  set tc_add1[ANCIENT_LORE] = 0
  set tc_add2[ANCIENT_LORE] = 0
  set available_time[ANCIENT_LORE] = R2I(0 / 5)
  set regenerate_time[ANCIENT_LORE] = R2I(0 / 5)
  set gold_price[ANCIENT_LORE] = 0
  set wood_price[ANCIENT_LORE] = 0
  set hero_rush_bonus[ANCIENT_LORE] = 0

  set old_id[ANCIENT_WAR] = oANCIENT_WAR
  set buy_type[ANCIENT_WAR] = BT_BUILDING
  set needed1[ANCIENT_WAR] = WISP
  set needed2[ANCIENT_WAR] = 0
  set needed3[ANCIENT_WAR] = 0
  set tc_add1[ANCIENT_WAR] = 0
  set tc_add2[ANCIENT_WAR] = 0
  set available_time[ANCIENT_WAR] = R2I(0 / 5)
  set regenerate_time[ANCIENT_WAR] = R2I(0 / 5)
  set gold_price[ANCIENT_WAR] = 0
  set wood_price[ANCIENT_WAR] = 0
  set hero_rush_bonus[ANCIENT_WAR] = 0

  set old_id[ANCIENT_WIND] = oANCIENT_WIND
  set buy_type[ANCIENT_WIND] = BT_BUILDING
  set needed1[ANCIENT_WIND] = WISP
  set needed2[ANCIENT_WIND] = TREE_AGES
  set needed3[ANCIENT_WIND] = 0
  set tc_add1[ANCIENT_WIND] = 0
  set tc_add2[ANCIENT_WIND] = 0
  set available_time[ANCIENT_WIND] = R2I(0 / 5)
  set regenerate_time[ANCIENT_WIND] = R2I(0 / 5)
  set gold_price[ANCIENT_WIND] = 0
  set wood_price[ANCIENT_WIND] = 0
  set hero_rush_bonus[ANCIENT_WIND] = 0

  set old_id[TREE_AGES] = oTREE_AGES
  set buy_type[TREE_AGES] = BT_BUILDING
  set needed1[TREE_AGES] = TREE_LIFE
  set needed2[TREE_AGES] = 0
  set needed3[TREE_AGES] = UPGRADED
  set tc_add1[TREE_AGES] = TREE_ETERNITY
  set tc_add2[TREE_AGES] = 0
  set available_time[TREE_AGES] = R2I(0 / 5)
  set regenerate_time[TREE_AGES] = R2I(0 / 5)
  set gold_price[TREE_AGES] = 0
  set wood_price[TREE_AGES] = 0
  set hero_rush_bonus[TREE_AGES] = 0

  set old_id[TREE_ETERNITY] = oTREE_ETERNITY
  set buy_type[TREE_ETERNITY] = BT_BUILDING
  set needed1[TREE_ETERNITY] = TREE_AGES
  set needed2[TREE_ETERNITY] = ELF_ALTAR
  set needed3[TREE_ETERNITY] = UPGRADED
  set tc_add1[TREE_ETERNITY] = 0
  set tc_add2[TREE_ETERNITY] = 0
  set available_time[TREE_ETERNITY] = R2I(0 / 5)
  set regenerate_time[TREE_ETERNITY] = R2I(0 / 5)
  set gold_price[TREE_ETERNITY] = 0
  set wood_price[TREE_ETERNITY] = 0
  set hero_rush_bonus[TREE_ETERNITY] = 0

  set old_id[TREE_LIFE] = oTREE_LIFE
  set buy_type[TREE_LIFE] = BT_BUILDING
  set needed1[TREE_LIFE] = 0
  set needed2[TREE_LIFE] = 0
  set needed3[TREE_LIFE] = 0
  set tc_add1[TREE_LIFE] = TREE_AGES
  set tc_add2[TREE_LIFE] = TREE_ETERNITY
  set available_time[TREE_LIFE] = R2I(0 / 5)
  set regenerate_time[TREE_LIFE] = R2I(0 / 5)
  set gold_price[TREE_LIFE] = 0
  set wood_price[TREE_LIFE] = 0
  set hero_rush_bonus[TREE_LIFE] = 0

  set old_id[ANCIENT_PROTECT] = oANCIENT_PROTECT
  set buy_type[ANCIENT_PROTECT] = BT_BUILDING
  set needed1[ANCIENT_PROTECT] = WISP
  set needed2[ANCIENT_PROTECT] = HUNTERS_HALL
  set needed3[ANCIENT_PROTECT] = 0
  set tc_add1[ANCIENT_PROTECT] = 0
  set tc_add2[ANCIENT_PROTECT] = 0
  set available_time[ANCIENT_PROTECT] = R2I(0 / 5)
  set regenerate_time[ANCIENT_PROTECT] = R2I(0 / 5)
  set gold_price[ANCIENT_PROTECT] = 0
  set wood_price[ANCIENT_PROTECT] = 0
  set hero_rush_bonus[ANCIENT_PROTECT] = 0

  set old_id[ELF_ALTAR] = oELF_ALTAR
  set buy_type[ELF_ALTAR] = BT_BUILDING
  set needed1[ELF_ALTAR] = WISP
  set needed2[ELF_ALTAR] = 0
  set needed3[ELF_ALTAR] = 0
  set tc_add1[ELF_ALTAR] = 0
  set tc_add2[ELF_ALTAR] = 0
  set available_time[ELF_ALTAR] = R2I(0 / 5)
  set regenerate_time[ELF_ALTAR] = R2I(0 / 5)
  set gold_price[ELF_ALTAR] = 0
  set wood_price[ELF_ALTAR] = 0
  set hero_rush_bonus[ELF_ALTAR] = 0

  set old_id[CHIMAERA_ROOST] = oCHIMAERA_ROOST
  set buy_type[CHIMAERA_ROOST] = BT_BUILDING
  set needed1[CHIMAERA_ROOST] = WISP
  set needed2[CHIMAERA_ROOST] = TREE_ETERNITY
  set needed3[CHIMAERA_ROOST] = ANCIENT_WIND
  set tc_add1[CHIMAERA_ROOST] = 0
  set tc_add2[CHIMAERA_ROOST] = 0
  set available_time[CHIMAERA_ROOST] = R2I(0 / 5)
  set regenerate_time[CHIMAERA_ROOST] = R2I(0 / 5)
  set gold_price[CHIMAERA_ROOST] = 0
  set wood_price[CHIMAERA_ROOST] = 0
  set hero_rush_bonus[CHIMAERA_ROOST] = 0

  set old_id[HUNTERS_HALL] = oHUNTERS_HALL
  set buy_type[HUNTERS_HALL] = BT_BUILDING
  set needed1[HUNTERS_HALL] = WISP
  set needed2[HUNTERS_HALL] = TREE_LIFE
  set needed3[HUNTERS_HALL] = 0
  set tc_add1[HUNTERS_HALL] = 0
  set tc_add2[HUNTERS_HALL] = 0
  set available_time[HUNTERS_HALL] = R2I(0 / 5)
  set regenerate_time[HUNTERS_HALL] = R2I(0 / 5)
  set gold_price[HUNTERS_HALL] = 0
  set wood_price[HUNTERS_HALL] = 0
  set hero_rush_bonus[HUNTERS_HALL] = 0

  set old_id[MOON_WELL] = oMOON_WELL
  set buy_type[MOON_WELL] = BT_BUILDING
  set needed1[MOON_WELL] = WISP
  set needed2[MOON_WELL] = 0
  set needed3[MOON_WELL] = 0
  set tc_add1[MOON_WELL] = 0
  set tc_add2[MOON_WELL] = 0
  set available_time[MOON_WELL] = R2I(0 / 5)
  set regenerate_time[MOON_WELL] = R2I(0 / 5)
  set gold_price[MOON_WELL] = 0
  set wood_price[MOON_WELL] = 0
  set hero_rush_bonus[MOON_WELL] = 0

  set old_id[ELF_MINE] = oELF_MINE
  set buy_type[ELF_MINE] = BT_BUILDING
  set needed1[ELF_MINE] = WISP
  set needed2[ELF_MINE] = 0
  set needed3[ELF_MINE] = 0
  set tc_add1[ELF_MINE] = 0
  set tc_add2[ELF_MINE] = 0
  set available_time[ELF_MINE] = R2I(0 / 5)
  set regenerate_time[ELF_MINE] = R2I(0 / 5)
  set gold_price[ELF_MINE] = 0
  set wood_price[ELF_MINE] = 0
  set hero_rush_bonus[ELF_MINE] = 0

  set old_id[UPG_ULTRAVISION] = oUPG_ULTRAVISION
  set buy_type[UPG_ULTRAVISION] = BT_UPGRADE
  set needed1[UPG_ULTRAVISION] = HUNTERS_HALL
  set needed2[UPG_ULTRAVISION] = 0
  set needed3[UPG_ULTRAVISION] = 0
  set tc_add1[UPG_ULTRAVISION] = 0
  set tc_add2[UPG_ULTRAVISION] = 0
  set available_time[UPG_ULTRAVISION] = R2I(0 / 5)
  set regenerate_time[UPG_ULTRAVISION] = R2I(0 / 5)
  set gold_price[UPG_ULTRAVISION] = 0
  set wood_price[UPG_ULTRAVISION] = 0
  set hero_rush_bonus[UPG_ULTRAVISION] = 0

  set old_id[UPG_BLESSING] = oUPG_BLESSING
  set buy_type[UPG_BLESSING] = BT_UPGRADE
  set needed1[UPG_BLESSING] = TREE_LIFE
  set needed2[UPG_BLESSING] = TREE_AGES
  set needed3[UPG_BLESSING] = 0
  set tc_add1[UPG_BLESSING] = 0
  set tc_add2[UPG_BLESSING] = 0
  set available_time[UPG_BLESSING] = R2I(0 / 5)
  set regenerate_time[UPG_BLESSING] = R2I(0 / 5)
  set gold_price[UPG_BLESSING] = 0
  set wood_price[UPG_BLESSING] = 0
  set hero_rush_bonus[UPG_BLESSING] = 0

  set old_id[UPG_SCOUT] = oUPG_SCOUT
  set buy_type[UPG_SCOUT] = BT_UPGRADE
  set needed1[UPG_SCOUT] = ANCIENT_WAR
  set needed2[UPG_SCOUT] = TREE_AGES
  set needed3[UPG_SCOUT] = HUNTERS_HALL
  set tc_add1[UPG_SCOUT] = 0
  set tc_add2[UPG_SCOUT] = 0
  set available_time[UPG_SCOUT] = R2I(0 / 5)
  set regenerate_time[UPG_SCOUT] = R2I(0 / 5)
  set gold_price[UPG_SCOUT] = 0
  set wood_price[UPG_SCOUT] = 0
  set hero_rush_bonus[UPG_SCOUT] = 0

  set old_id[UPG_GLAIVE] = oUPG_GLAIVE
  set buy_type[UPG_GLAIVE] = BT_UPGRADE
  set needed1[UPG_GLAIVE] = ANCIENT_WAR
  set needed2[UPG_GLAIVE] = TREE_ETERNITY
  set needed3[UPG_GLAIVE] = HUNTERS_HALL
  set tc_add1[UPG_GLAIVE] = 0
  set tc_add2[UPG_GLAIVE] = 0
  set available_time[UPG_GLAIVE] = R2I(0 / 5)
  set regenerate_time[UPG_GLAIVE] = R2I(0 / 5)
  set gold_price[UPG_GLAIVE] = 0
  set wood_price[UPG_GLAIVE] = 0
  set hero_rush_bonus[UPG_GLAIVE] = 0

  set old_id[UPG_BOWS] = oUPG_BOWS
  set buy_type[UPG_BOWS] = BT_UPGRADE
  set needed1[UPG_BOWS] = ANCIENT_WAR
  set needed2[UPG_BOWS] = TREE_AGES
  set needed3[UPG_BOWS] = 0
  set tc_add1[UPG_BOWS] = 0
  set tc_add2[UPG_BOWS] = 0
  set available_time[UPG_BOWS] = R2I(0 / 5)
  set regenerate_time[UPG_BOWS] = R2I(0 / 5)
  set gold_price[UPG_BOWS] = 0
  set wood_price[UPG_BOWS] = 0
  set hero_rush_bonus[UPG_BOWS] = 0

  set old_id[UPG_MARKSMAN] = oUPG_MARKSMAN
  set buy_type[UPG_MARKSMAN] = BT_UPGRADE
  set needed1[UPG_MARKSMAN] = ANCIENT_WAR
  set needed2[UPG_MARKSMAN] = TREE_ETERNITY
  set needed3[UPG_MARKSMAN] = HUNTERS_HALL
  set tc_add1[UPG_MARKSMAN] = 0
  set tc_add2[UPG_MARKSMAN] = 0
  set available_time[UPG_MARKSMAN] = R2I(0 / 5)
  set regenerate_time[UPG_MARKSMAN] = R2I(0 / 5)
  set gold_price[UPG_MARKSMAN] = 0
  set wood_price[UPG_MARKSMAN] = 0
  set hero_rush_bonus[UPG_MARKSMAN] = 0

  set old_id[UPG_ABOLISH] = oUPG_ABOLISH
  set buy_type[UPG_ABOLISH] = BT_UPGRADE
  set needed1[UPG_ABOLISH] = ANCIENT_LORE
  set needed2[UPG_ABOLISH] = 0
  set needed3[UPG_ABOLISH] = 0
  set tc_add1[UPG_ABOLISH] = 0
  set tc_add2[UPG_ABOLISH] = 0
  set available_time[UPG_ABOLISH] = R2I(0 / 5)
  set regenerate_time[UPG_ABOLISH] = R2I(0 / 5)
  set gold_price[UPG_ABOLISH] = 0
  set wood_price[UPG_ABOLISH] = 0
  set hero_rush_bonus[UPG_ABOLISH] = 0

  set old_id[UPG_CHIM_ACID] = oUPG_CHIM_ACID
  set buy_type[UPG_CHIM_ACID] = BT_UPGRADE
  set needed1[UPG_CHIM_ACID] = CHIMAERA_ROOST
  set needed2[UPG_CHIM_ACID] = 0
  set needed3[UPG_CHIM_ACID] = 0
  set tc_add1[UPG_CHIM_ACID] = 0
  set tc_add2[UPG_CHIM_ACID] = 0
  set available_time[UPG_CHIM_ACID] = R2I(0 / 5)
  set regenerate_time[UPG_CHIM_ACID] = R2I(0 / 5)
  set gold_price[UPG_CHIM_ACID] = 0
  set wood_price[UPG_CHIM_ACID] = 0
  set hero_rush_bonus[UPG_CHIM_ACID] = 0

  set old_id[UPG_HIPPO_TAME] = oUPG_HIPPO_TAME
  set buy_type[UPG_HIPPO_TAME] = BT_UPGRADE
  set needed1[UPG_HIPPO_TAME] = ANCIENT_WIND
  set needed2[UPG_HIPPO_TAME] = 0
  set needed3[UPG_HIPPO_TAME] = 0
  set tc_add1[UPG_HIPPO_TAME] = 0
  set tc_add2[UPG_HIPPO_TAME] = 0
  set available_time[UPG_HIPPO_TAME] = R2I(0 / 5)
  set regenerate_time[UPG_HIPPO_TAME] = R2I(0 / 5)
  set gold_price[UPG_HIPPO_TAME] = 0
  set wood_price[UPG_HIPPO_TAME] = 0
  set hero_rush_bonus[UPG_HIPPO_TAME] = 0

  set old_id[UPG_BOLT] = oUPG_BOLT
  set buy_type[UPG_BOLT] = BT_UPGRADE
  set needed1[UPG_BOLT] = ANCIENT_WAR
  set needed2[UPG_BOLT] = TREE_AGES
  set needed3[UPG_BOLT] = HUNTERS_HALL
  set tc_add1[UPG_BOLT] = 0
  set tc_add2[UPG_BOLT] = 0
  set available_time[UPG_BOLT] = R2I(0 / 5)
  set regenerate_time[UPG_BOLT] = R2I(0 / 5)
  set gold_price[UPG_BOLT] = 0
  set wood_price[UPG_BOLT] = 0
  set hero_rush_bonus[UPG_BOLT] = 0

  set old_id[UPG_MARK_CLAW] = oUPG_MARK_CLAW
  set buy_type[UPG_MARK_CLAW] = BT_UPGRADE
  set needed1[UPG_MARK_CLAW] = ANCIENT_LORE
  set needed2[UPG_MARK_CLAW] = 0
  set needed3[UPG_MARK_CLAW] = 0
  set tc_add1[UPG_MARK_CLAW] = 0
  set tc_add2[UPG_MARK_CLAW] = 0
  set available_time[UPG_MARK_CLAW] = R2I(0 / 5)
  set regenerate_time[UPG_MARK_CLAW] = R2I(0 / 5)
  set gold_price[UPG_MARK_CLAW] = 0
  set wood_price[UPG_MARK_CLAW] = 0
  set hero_rush_bonus[UPG_MARK_CLAW] = 0

  set old_id[UPG_MARK_TALON] = oUPG_MARK_TALON
  set buy_type[UPG_MARK_TALON] = BT_UPGRADE
  set needed1[UPG_MARK_TALON] = ANCIENT_WIND
  set needed2[UPG_MARK_TALON] = 0
  set needed3[UPG_MARK_TALON] = 0
  set tc_add1[UPG_MARK_TALON] = 0
  set tc_add2[UPG_MARK_TALON] = 0
  set available_time[UPG_MARK_TALON] = R2I(0 / 5)
  set regenerate_time[UPG_MARK_TALON] = R2I(0 / 5)
  set gold_price[UPG_MARK_TALON] = 0
  set wood_price[UPG_MARK_TALON] = 0
  set hero_rush_bonus[UPG_MARK_TALON] = 0

  set old_id[UPG_MELEE] = oUPG_MELEE
  set buy_type[UPG_MELEE] = BT_ML_UPGRADE
  set needed1[UPG_MELEE] = BLACKSMITH
  set needed2[UPG_MELEE] = KEEP
  set needed3[UPG_MELEE] = CASTLE
  set tc_add1[UPG_MELEE] = 0
  set tc_add2[UPG_MELEE] = 0
  set available_time[UPG_MELEE] = R2I(0 / 5)
  set regenerate_time[UPG_MELEE] = R2I(0 / 5)
  set gold_price[UPG_MELEE] = 0
  set wood_price[UPG_MELEE] = 0
  set hero_rush_bonus[UPG_MELEE] = 0

  set old_id[UPG_RANGED] = oUPG_RANGED
  set buy_type[UPG_RANGED] = BT_ML_UPGRADE
  set needed1[UPG_RANGED] = BLACKSMITH
  set needed2[UPG_RANGED] = KEEP
  set needed3[UPG_RANGED] = CASTLE
  set tc_add1[UPG_RANGED] = 0
  set tc_add2[UPG_RANGED] = 0
  set available_time[UPG_RANGED] = R2I(0 / 5)
  set regenerate_time[UPG_RANGED] = R2I(0 / 5)
  set gold_price[UPG_RANGED] = 0
  set wood_price[UPG_RANGED] = 0
  set hero_rush_bonus[UPG_RANGED] = 0

  set old_id[UPG_ARMOR] = oUPG_ARMOR
  set buy_type[UPG_ARMOR] = BT_ML_UPGRADE
  set needed1[UPG_ARMOR] = BLACKSMITH
  set needed2[UPG_ARMOR] = KEEP
  set needed3[UPG_ARMOR] = CASTLE
  set tc_add1[UPG_ARMOR] = 0
  set tc_add2[UPG_ARMOR] = 0
  set available_time[UPG_ARMOR] = R2I(0 / 5)
  set regenerate_time[UPG_ARMOR] = R2I(0 / 5)
  set gold_price[UPG_ARMOR] = 0
  set wood_price[UPG_ARMOR] = 0
  set hero_rush_bonus[UPG_ARMOR] = 0

  set old_id[UPG_LEATHER] = oUPG_LEATHER
  set buy_type[UPG_LEATHER] = BT_ML_UPGRADE
  set needed1[UPG_LEATHER] = BLACKSMITH
  set needed2[UPG_LEATHER] = KEEP
  set needed3[UPG_LEATHER] = CASTLE
  set tc_add1[UPG_LEATHER] = 0
  set tc_add2[UPG_LEATHER] = 0
  set available_time[UPG_LEATHER] = R2I(0 / 5)
  set regenerate_time[UPG_LEATHER] = R2I(0 / 5)
  set gold_price[UPG_LEATHER] = 0
  set wood_price[UPG_LEATHER] = 0
  set hero_rush_bonus[UPG_LEATHER] = 0

  set old_id[UPG_MASONRY] = oUPG_MASONRY
  set buy_type[UPG_MASONRY] = BT_ML_UPGRADE
  set needed1[UPG_MASONRY] = LUMBER_MILL
  set needed2[UPG_MASONRY] = KEEP
  set needed3[UPG_MASONRY] = CASTLE
  set tc_add1[UPG_MASONRY] = 0
  set tc_add2[UPG_MASONRY] = 0
  set available_time[UPG_MASONRY] = R2I(0 / 5)
  set regenerate_time[UPG_MASONRY] = R2I(0 / 5)
  set gold_price[UPG_MASONRY] = 0
  set wood_price[UPG_MASONRY] = 0
  set hero_rush_bonus[UPG_MASONRY] = 0

  set old_id[UPG_WOOD] = oUPG_WOOD
  set buy_type[UPG_WOOD] = BT_ML_UPGRADE
  set needed1[UPG_WOOD] = LUMBER_MILL
  set needed2[UPG_WOOD] = KEEP
  set needed3[UPG_WOOD] = CASTLE
  set tc_add1[UPG_WOOD] = 0
  set tc_add2[UPG_WOOD] = 0
  set available_time[UPG_WOOD] = R2I(0 / 5)
  set regenerate_time[UPG_WOOD] = R2I(0 / 5)
  set gold_price[UPG_WOOD] = 0
  set wood_price[UPG_WOOD] = 0
  set hero_rush_bonus[UPG_WOOD] = 0

  set old_id[UPG_PRAYING] = oUPG_PRAYING
  set buy_type[UPG_PRAYING] = BT_ML_UPGRADE
  set needed1[UPG_PRAYING] = SANCTUM
  set needed2[UPG_PRAYING] = CASTLE
  set needed3[UPG_PRAYING] = 0
  set tc_add1[UPG_PRAYING] = 0
  set tc_add2[UPG_PRAYING] = 0
  set available_time[UPG_PRAYING] = R2I(0 / 5)
  set regenerate_time[UPG_PRAYING] = R2I(0 / 5)
  set gold_price[UPG_PRAYING] = 0
  set wood_price[UPG_PRAYING] = 0
  set hero_rush_bonus[UPG_PRAYING] = 0

  set old_id[UPG_SORCERY] = oUPG_SORCERY
  set buy_type[UPG_SORCERY] = BT_ML_UPGRADE
  set needed1[UPG_SORCERY] = SANCTUM
  set needed2[UPG_SORCERY] = CASTLE
  set needed3[UPG_SORCERY] = 0
  set tc_add1[UPG_SORCERY] = 0
  set tc_add2[UPG_SORCERY] = 0
  set available_time[UPG_SORCERY] = R2I(0 / 5)
  set regenerate_time[UPG_SORCERY] = R2I(0 / 5)
  set gold_price[UPG_SORCERY] = 0
  set wood_price[UPG_SORCERY] = 0
  set hero_rush_bonus[UPG_SORCERY] = 0

  set old_id[UPG_ORC_MELEE] = oUPG_ORC_MELEE
  set buy_type[UPG_ORC_MELEE] = BT_ML_UPGRADE
  set needed1[UPG_ORC_MELEE] = FORGE
  set needed2[UPG_ORC_MELEE] = STRONGHOLD
  set needed3[UPG_ORC_MELEE] = FORTRESS
  set tc_add1[UPG_ORC_MELEE] = 0
  set tc_add2[UPG_ORC_MELEE] = 0
  set available_time[UPG_ORC_MELEE] = R2I(0 / 5)
  set regenerate_time[UPG_ORC_MELEE] = R2I(0 / 5)
  set gold_price[UPG_ORC_MELEE] = 0
  set wood_price[UPG_ORC_MELEE] = 0
  set hero_rush_bonus[UPG_ORC_MELEE] = 0

  set old_id[UPG_ORC_RANGED] = oUPG_ORC_RANGED
  set buy_type[UPG_ORC_RANGED] = BT_ML_UPGRADE
  set needed1[UPG_ORC_RANGED] = FORGE
  set needed2[UPG_ORC_RANGED] = STRONGHOLD
  set needed3[UPG_ORC_RANGED] = FORTRESS
  set tc_add1[UPG_ORC_RANGED] = 0
  set tc_add2[UPG_ORC_RANGED] = 0
  set available_time[UPG_ORC_RANGED] = R2I(0 / 5)
  set regenerate_time[UPG_ORC_RANGED] = R2I(0 / 5)
  set gold_price[UPG_ORC_RANGED] = 0
  set wood_price[UPG_ORC_RANGED] = 0
  set hero_rush_bonus[UPG_ORC_RANGED] = 0

  set old_id[UPG_ORC_ARMOR] = oUPG_ORC_ARMOR
  set buy_type[UPG_ORC_ARMOR] = BT_ML_UPGRADE
  set needed1[UPG_ORC_ARMOR] = FORGE
  set needed2[UPG_ORC_ARMOR] = STRONGHOLD
  set needed3[UPG_ORC_ARMOR] = FORTRESS
  set tc_add1[UPG_ORC_ARMOR] = 0
  set tc_add2[UPG_ORC_ARMOR] = 0
  set available_time[UPG_ORC_ARMOR] = R2I(0 / 5)
  set regenerate_time[UPG_ORC_ARMOR] = R2I(0 / 5)
  set gold_price[UPG_ORC_ARMOR] = 0
  set wood_price[UPG_ORC_ARMOR] = 0
  set hero_rush_bonus[UPG_ORC_ARMOR] = 0

  set old_id[UPG_ORC_SPIKES] = oUPG_ORC_SPIKES
  set buy_type[UPG_ORC_SPIKES] = BT_ML_UPGRADE
  set needed1[UPG_ORC_SPIKES] = FORGE
  set needed2[UPG_ORC_SPIKES] = STRONGHOLD
  set needed3[UPG_ORC_SPIKES] = FORTRESS
  set tc_add1[UPG_ORC_SPIKES] = 0
  set tc_add2[UPG_ORC_SPIKES] = 0
  set available_time[UPG_ORC_SPIKES] = R2I(0 / 5)
  set regenerate_time[UPG_ORC_SPIKES] = R2I(0 / 5)
  set gold_price[UPG_ORC_SPIKES] = 0
  set wood_price[UPG_ORC_SPIKES] = 0
  set hero_rush_bonus[UPG_ORC_SPIKES] = 0

  set old_id[UPG_ORC_DOCS] = oUPG_ORC_DOCS
  set buy_type[UPG_ORC_DOCS] = BT_ML_UPGRADE
  set needed1[UPG_ORC_DOCS] = LODGE
  set needed2[UPG_ORC_DOCS] = FORTRESS
  set needed3[UPG_ORC_DOCS] = 0
  set tc_add1[UPG_ORC_DOCS] = 0
  set tc_add2[UPG_ORC_DOCS] = 0
  set available_time[UPG_ORC_DOCS] = R2I(0 / 5)
  set regenerate_time[UPG_ORC_DOCS] = R2I(0 / 5)
  set gold_price[UPG_ORC_DOCS] = 0
  set wood_price[UPG_ORC_DOCS] = 0
  set hero_rush_bonus[UPG_ORC_DOCS] = 0

  set old_id[UPG_ORC_SHAMAN] = oUPG_ORC_SHAMAN
  set buy_type[UPG_ORC_SHAMAN] = BT_ML_UPGRADE
  set needed1[UPG_ORC_SHAMAN] = LODGE
  set needed2[UPG_ORC_SHAMAN] = FORTRESS
  set needed3[UPG_ORC_SHAMAN] = 0
  set tc_add1[UPG_ORC_SHAMAN] = 0
  set tc_add2[UPG_ORC_SHAMAN] = 0
  set available_time[UPG_ORC_SHAMAN] = R2I(0 / 5)
  set regenerate_time[UPG_ORC_SHAMAN] = R2I(0 / 5)
  set gold_price[UPG_ORC_SHAMAN] = 0
  set wood_price[UPG_ORC_SHAMAN] = 0
  set hero_rush_bonus[UPG_ORC_SHAMAN] = 0

  set old_id[UPG_UNHOLY_STR] = oUPG_UNHOLY_STR
  set buy_type[UPG_UNHOLY_STR] = BT_ML_UPGRADE
  set needed1[UPG_UNHOLY_STR] = GRAVEYARD
  set needed2[UPG_UNHOLY_STR] = NECROPOLIS_2
  set needed3[UPG_UNHOLY_STR] = NECROPOLIS_3
  set tc_add1[UPG_UNHOLY_STR] = 0
  set tc_add2[UPG_UNHOLY_STR] = 0
  set available_time[UPG_UNHOLY_STR] = R2I(0 / 5)
  set regenerate_time[UPG_UNHOLY_STR] = R2I(0 / 5)
  set gold_price[UPG_UNHOLY_STR] = 0
  set wood_price[UPG_UNHOLY_STR] = 0
  set hero_rush_bonus[UPG_UNHOLY_STR] = 0

  set old_id[UPG_CR_ATTACK] = oUPG_CR_ATTACK
  set buy_type[UPG_CR_ATTACK] = BT_ML_UPGRADE
  set needed1[UPG_CR_ATTACK] = GRAVEYARD
  set needed2[UPG_CR_ATTACK] = NECROPOLIS_2
  set needed3[UPG_CR_ATTACK] = NECROPOLIS_3
  set tc_add1[UPG_CR_ATTACK] = 0
  set tc_add2[UPG_CR_ATTACK] = 0
  set available_time[UPG_CR_ATTACK] = R2I(0 / 5)
  set regenerate_time[UPG_CR_ATTACK] = R2I(0 / 5)
  set gold_price[UPG_CR_ATTACK] = 0
  set wood_price[UPG_CR_ATTACK] = 0
  set hero_rush_bonus[UPG_CR_ATTACK] = 0

  set old_id[UPG_UNHOLY_ARMOR] = oUPG_UNHOLY_ARMOR
  set buy_type[UPG_UNHOLY_ARMOR] = BT_ML_UPGRADE
  set needed1[UPG_UNHOLY_ARMOR] = GRAVEYARD
  set needed2[UPG_UNHOLY_ARMOR] = NECROPOLIS_2
  set needed3[UPG_UNHOLY_ARMOR] = NECROPOLIS_3
  set tc_add1[UPG_UNHOLY_ARMOR] = 0
  set tc_add2[UPG_UNHOLY_ARMOR] = 0
  set available_time[UPG_UNHOLY_ARMOR] = R2I(0 / 5)
  set regenerate_time[UPG_UNHOLY_ARMOR] = R2I(0 / 5)
  set gold_price[UPG_UNHOLY_ARMOR] = 0
  set wood_price[UPG_UNHOLY_ARMOR] = 0
  set hero_rush_bonus[UPG_UNHOLY_ARMOR] = 0

  set old_id[UPG_CR_ARMOR] = oUPG_CR_ARMOR
  set buy_type[UPG_CR_ARMOR] = BT_ML_UPGRADE
  set needed1[UPG_CR_ARMOR] = GRAVEYARD
  set needed2[UPG_CR_ARMOR] = NECROPOLIS_2
  set needed3[UPG_CR_ARMOR] = NECROPOLIS_3
  set tc_add1[UPG_CR_ARMOR] = 0
  set tc_add2[UPG_CR_ARMOR] = 0
  set available_time[UPG_CR_ARMOR] = R2I(0 / 5)
  set regenerate_time[UPG_CR_ARMOR] = R2I(0 / 5)
  set gold_price[UPG_CR_ARMOR] = 0
  set wood_price[UPG_CR_ARMOR] = 0
  set hero_rush_bonus[UPG_CR_ARMOR] = 0

  set old_id[UPG_NECROS] = oUPG_NECROS
  set buy_type[UPG_NECROS] = BT_ML_UPGRADE
  set needed1[UPG_NECROS] = DAMNED_TEMPLE
  set needed2[UPG_NECROS] = NECROPOLIS_3
  set needed3[UPG_NECROS] = 0
  set tc_add1[UPG_NECROS] = 0
  set tc_add2[UPG_NECROS] = 0
  set available_time[UPG_NECROS] = R2I(0 / 5)
  set regenerate_time[UPG_NECROS] = R2I(0 / 5)
  set gold_price[UPG_NECROS] = 0
  set wood_price[UPG_NECROS] = 0
  set hero_rush_bonus[UPG_NECROS] = 0

  set old_id[UPG_BANSHEE] = oUPG_BANSHEE
  set buy_type[UPG_BANSHEE] = BT_ML_UPGRADE
  set needed1[UPG_BANSHEE] = DAMNED_TEMPLE
  set needed2[UPG_BANSHEE] = NECROPOLIS_3
  set needed3[UPG_BANSHEE] = 0
  set tc_add1[UPG_BANSHEE] = 0
  set tc_add2[UPG_BANSHEE] = 0
  set available_time[UPG_BANSHEE] = R2I(0 / 5)
  set regenerate_time[UPG_BANSHEE] = R2I(0 / 5)
  set gold_price[UPG_BANSHEE] = 0
  set wood_price[UPG_BANSHEE] = 0
  set hero_rush_bonus[UPG_BANSHEE] = 0

  set old_id[UPG_STR_MOON] = oUPG_STR_MOON
  set buy_type[UPG_STR_MOON] = BT_ML_UPGRADE
  set needed1[UPG_STR_MOON] = HUNTERS_HALL
  set needed2[UPG_STR_MOON] = TREE_AGES
  set needed3[UPG_STR_MOON] = TREE_ETERNITY
  set tc_add1[UPG_STR_MOON] = 0
  set tc_add2[UPG_STR_MOON] = 0
  set available_time[UPG_STR_MOON] = R2I(0 / 5)
  set regenerate_time[UPG_STR_MOON] = R2I(0 / 5)
  set gold_price[UPG_STR_MOON] = 0
  set wood_price[UPG_STR_MOON] = 0
  set hero_rush_bonus[UPG_STR_MOON] = 0

  set old_id[UPG_STR_WILD] = oUPG_STR_WILD
  set buy_type[UPG_STR_WILD] = BT_ML_UPGRADE
  set needed1[UPG_STR_WILD] = HUNTERS_HALL
  set needed2[UPG_STR_WILD] = TREE_AGES
  set needed3[UPG_STR_WILD] = TREE_ETERNITY
  set tc_add1[UPG_STR_WILD] = 0
  set tc_add2[UPG_STR_WILD] = 0
  set available_time[UPG_STR_WILD] = R2I(0 / 5)
  set regenerate_time[UPG_STR_WILD] = R2I(0 / 5)
  set gold_price[UPG_STR_WILD] = 0
  set wood_price[UPG_STR_WILD] = 0
  set hero_rush_bonus[UPG_STR_WILD] = 0

  set old_id[UPG_MOON_ARMOR] = oUPG_MOON_ARMOR
  set buy_type[UPG_MOON_ARMOR] = BT_ML_UPGRADE
  set needed1[UPG_MOON_ARMOR] = HUNTERS_HALL
  set needed2[UPG_MOON_ARMOR] = TREE_AGES
  set needed3[UPG_MOON_ARMOR] = TREE_ETERNITY
  set tc_add1[UPG_MOON_ARMOR] = 0
  set tc_add2[UPG_MOON_ARMOR] = 0
  set available_time[UPG_MOON_ARMOR] = R2I(0 / 5)
  set regenerate_time[UPG_MOON_ARMOR] = R2I(0 / 5)
  set gold_price[UPG_MOON_ARMOR] = 0
  set wood_price[UPG_MOON_ARMOR] = 0
  set hero_rush_bonus[UPG_MOON_ARMOR] = 0

  set old_id[UPG_HIDES] = oUPG_HIDES
  set buy_type[UPG_HIDES] = BT_ML_UPGRADE
  set needed1[UPG_HIDES] = HUNTERS_HALL
  set needed2[UPG_HIDES] = TREE_AGES
  set needed3[UPG_HIDES] = TREE_ETERNITY
  set tc_add1[UPG_HIDES] = 0
  set tc_add2[UPG_HIDES] = 0
  set available_time[UPG_HIDES] = R2I(0 / 5)
  set regenerate_time[UPG_HIDES] = R2I(0 / 5)
  set gold_price[UPG_HIDES] = 0
  set wood_price[UPG_HIDES] = 0
  set hero_rush_bonus[UPG_HIDES] = 0

  set old_id[UPG_DRUID_TALON] = oUPG_DRUID_TALON
  set buy_type[UPG_DRUID_TALON] = BT_ML_UPGRADE
  set needed1[UPG_DRUID_TALON] = ANCIENT_WIND
  set needed2[UPG_DRUID_TALON] = TREE_ETERNITY
  set needed3[UPG_DRUID_TALON] = 0
  set tc_add1[UPG_DRUID_TALON] = 0
  set tc_add2[UPG_DRUID_TALON] = 0
  set available_time[UPG_DRUID_TALON] = R2I(0 / 5)
  set regenerate_time[UPG_DRUID_TALON] = R2I(0 / 5)
  set gold_price[UPG_DRUID_TALON] = 0
  set wood_price[UPG_DRUID_TALON] = 0
  set hero_rush_bonus[UPG_DRUID_TALON] = 0

  set old_id[UPG_DRUID_CLAW] = oUPG_DRUID_CLAW
  set buy_type[UPG_DRUID_CLAW] = BT_ML_UPGRADE
  set needed1[UPG_DRUID_CLAW] = ANCIENT_LORE
  set needed2[UPG_DRUID_CLAW] = TREE_ETERNITY
  set needed3[UPG_DRUID_CLAW] = 0
  set tc_add1[UPG_DRUID_CLAW] = 0
  set tc_add2[UPG_DRUID_CLAW] = 0
  set available_time[UPG_DRUID_CLAW] = R2I(0 / 5)
  set regenerate_time[UPG_DRUID_CLAW] = R2I(0 / 5)
  set gold_price[UPG_DRUID_CLAW] = 0
  set wood_price[UPG_DRUID_CLAW] = 0
  set hero_rush_bonus[UPG_DRUID_CLAW] = 0

  set old_id[HEALING_POTION] = oHEALING_POTION
  set buy_type[HEALING_POTION] = BT_MERCHANT_ITEM
  set needed1[HEALING_POTION] = 0
  set needed2[HEALING_POTION] = 0
  set needed3[HEALING_POTION] = 0
  set tc_add1[HEALING_POTION] = 0
  set tc_add2[HEALING_POTION] = 0
  set available_time[HEALING_POTION] = R2I(0 / 5)
  set regenerate_time[HEALING_POTION] = R2I(24 / 5)
  set gold_price[HEALING_POTION] = 150
  set wood_price[HEALING_POTION] = 0
  set hero_rush_bonus[HEALING_POTION] = 0

  set old_id[MANA_POTION] = oMANA_POTION
  set buy_type[MANA_POTION] = BT_MERCHANT_ITEM
  set needed1[MANA_POTION] = 0
  set needed2[MANA_POTION] = 0
  set needed3[MANA_POTION] = 0
  set tc_add1[MANA_POTION] = 0
  set tc_add2[MANA_POTION] = 0
  set available_time[MANA_POTION] = R2I(0 / 5)
  set regenerate_time[MANA_POTION] = R2I(24 / 5)
  set gold_price[MANA_POTION] = 200
  set wood_price[MANA_POTION] = 0
  set hero_rush_bonus[MANA_POTION] = 0

  set old_id[CIRCLET_OF_NOBILITY] = oCIRCLET_OF_NOBILITY
  set buy_type[CIRCLET_OF_NOBILITY] = BT_MERCHANT_ITEM
  set needed1[CIRCLET_OF_NOBILITY] = 0
  set needed2[CIRCLET_OF_NOBILITY] = 0
  set needed3[CIRCLET_OF_NOBILITY] = 0
  set tc_add1[CIRCLET_OF_NOBILITY] = 0
  set tc_add2[CIRCLET_OF_NOBILITY] = 0
  set available_time[CIRCLET_OF_NOBILITY] = R2I(0 / 5)
  set regenerate_time[CIRCLET_OF_NOBILITY] = R2I(18 / 5)
  set gold_price[CIRCLET_OF_NOBILITY] = 175
  set wood_price[CIRCLET_OF_NOBILITY] = 0
  set hero_rush_bonus[CIRCLET_OF_NOBILITY] = 0

  set old_id[PERIAPT_OF_VITALITY] = oPERIAPT_OF_VITALITY
  set buy_type[PERIAPT_OF_VITALITY] = BT_MERCHANT_ITEM
  set needed1[PERIAPT_OF_VITALITY] = 0
  set needed2[PERIAPT_OF_VITALITY] = 0
  set needed3[PERIAPT_OF_VITALITY] = 0
  set tc_add1[PERIAPT_OF_VITALITY] = 0
  set tc_add2[PERIAPT_OF_VITALITY] = 0
  set available_time[PERIAPT_OF_VITALITY] = R2I(0 / 5)
  set regenerate_time[PERIAPT_OF_VITALITY] = R2I(24 / 5)
  set gold_price[PERIAPT_OF_VITALITY] = 350
  set wood_price[PERIAPT_OF_VITALITY] = 0
  set hero_rush_bonus[PERIAPT_OF_VITALITY] = 0

  set old_id[BOOTS_OF_SPEED] = oBOOTS_OF_SPEED
  set buy_type[BOOTS_OF_SPEED] = BT_MERCHANT_ITEM
  set needed1[BOOTS_OF_SPEED] = 0
  set needed2[BOOTS_OF_SPEED] = 0
  set needed3[BOOTS_OF_SPEED] = 0
  set tc_add1[BOOTS_OF_SPEED] = 0
  set tc_add2[BOOTS_OF_SPEED] = 0
  set available_time[BOOTS_OF_SPEED] = R2I(0 / 5)
  set regenerate_time[BOOTS_OF_SPEED] = R2I(12 / 5)
  set gold_price[BOOTS_OF_SPEED] = 150
  set wood_price[BOOTS_OF_SPEED] = 0
  set hero_rush_bonus[BOOTS_OF_SPEED] = 0

  set old_id[M_SCROLL_OF_HEALING] = oM_SCROLL_OF_HEALING
  set buy_type[M_SCROLL_OF_HEALING] = BT_MERCHANT_ITEM
  set needed1[M_SCROLL_OF_HEALING] = 0
  set needed2[M_SCROLL_OF_HEALING] = 0
  set needed3[M_SCROLL_OF_HEALING] = 0
  set tc_add1[M_SCROLL_OF_HEALING] = 0
  set tc_add2[M_SCROLL_OF_HEALING] = 0
  set available_time[M_SCROLL_OF_HEALING] = R2I(88 / 5)
  set regenerate_time[M_SCROLL_OF_HEALING] = R2I(24 / 5)
  set gold_price[M_SCROLL_OF_HEALING] = 250
  set wood_price[M_SCROLL_OF_HEALING] = 0
  set hero_rush_bonus[M_SCROLL_OF_HEALING] = 0

  set old_id[SCROLL_OF_PROTECTION] = oSCROLL_OF_PROTECTION
  set buy_type[SCROLL_OF_PROTECTION] = BT_MERCHANT_ITEM
  set needed1[SCROLL_OF_PROTECTION] = 0
  set needed2[SCROLL_OF_PROTECTION] = 0
  set needed3[SCROLL_OF_PROTECTION] = 0
  set tc_add1[SCROLL_OF_PROTECTION] = 0
  set tc_add2[SCROLL_OF_PROTECTION] = 0
  set available_time[SCROLL_OF_PROTECTION] = R2I(88 / 5)
  set regenerate_time[SCROLL_OF_PROTECTION] = R2I(24 / 5)
  set gold_price[SCROLL_OF_PROTECTION] = 150
  set wood_price[SCROLL_OF_PROTECTION] = 0
  set hero_rush_bonus[SCROLL_OF_PROTECTION] = 0

  set old_id[TOWN_PORTAL] = oTOWN_PORTAL
  set buy_type[TOWN_PORTAL] = BT_MERCHANT_ITEM
  set needed1[TOWN_PORTAL] = 0
  set needed2[TOWN_PORTAL] = 0
  set needed3[TOWN_PORTAL] = 0
  set tc_add1[TOWN_PORTAL] = 0
  set tc_add2[TOWN_PORTAL] = 0
  set available_time[TOWN_PORTAL] = R2I(88 / 5)
  set regenerate_time[TOWN_PORTAL] = R2I(24 / 5)
  set gold_price[TOWN_PORTAL] = 250
  set wood_price[TOWN_PORTAL] = 0
  set hero_rush_bonus[TOWN_PORTAL] = 0

  set old_id[POTION_OF_INVISIBILITY] = oPOTION_OF_INVISIBILITY
  set buy_type[POTION_OF_INVISIBILITY] = BT_MERCHANT_ITEM
  set needed1[POTION_OF_INVISIBILITY] = 0
  set needed2[POTION_OF_INVISIBILITY] = 0
  set needed3[POTION_OF_INVISIBILITY] = 0
  set tc_add1[POTION_OF_INVISIBILITY] = 0
  set tc_add2[POTION_OF_INVISIBILITY] = 0
  set available_time[POTION_OF_INVISIBILITY] = R2I(88 / 5)
  set regenerate_time[POTION_OF_INVISIBILITY] = R2I(24 / 5)
  set gold_price[POTION_OF_INVISIBILITY] = 100
  set wood_price[POTION_OF_INVISIBILITY] = 0
  set hero_rush_bonus[POTION_OF_INVISIBILITY] = 0

  set old_id[POTION_OF_LESSER_INVULNERBILITY] = oPOTION_OF_LESSER_INVULNERBILITY
  set buy_type[POTION_OF_LESSER_INVULNERBILITY] = BT_MERCHANT_ITEM
  set needed1[POTION_OF_LESSER_INVULNERBILITY] = 0
  set needed2[POTION_OF_LESSER_INVULNERBILITY] = 0
  set needed3[POTION_OF_LESSER_INVULNERBILITY] = 0
  set tc_add1[POTION_OF_LESSER_INVULNERBILITY] = 0
  set tc_add2[POTION_OF_LESSER_INVULNERBILITY] = 0
  set available_time[POTION_OF_LESSER_INVULNERBILITY] = R2I(88 / 5)
  set regenerate_time[POTION_OF_LESSER_INVULNERBILITY] = R2I(24 / 5)
  set gold_price[POTION_OF_LESSER_INVULNERBILITY] = 150
  set wood_price[POTION_OF_LESSER_INVULNERBILITY] = 0
  set hero_rush_bonus[POTION_OF_LESSER_INVULNERBILITY] = 0

  set old_id[SATYR_SHADOWDANCER] = oSATYR_SHADOWDANCER
  set buy_type[SATYR_SHADOWDANCER] = BT_MERC
  set needed1[SATYR_SHADOWDANCER] = 0
  set needed2[SATYR_SHADOWDANCER] = 0
  set needed3[SATYR_SHADOWDANCER] = 0
  set tc_add1[SATYR_SHADOWDANCER] = 0
  set tc_add2[SATYR_SHADOWDANCER] = 0
  set available_time[SATYR_SHADOWDANCER] = R2I(66 / 5)
  set regenerate_time[SATYR_SHADOWDANCER] = R2I(32 / 5)
  set gold_price[SATYR_SHADOWDANCER] = 0
  set wood_price[SATYR_SHADOWDANCER] = 0
  set hero_rush_bonus[SATYR_SHADOWDANCER] = 0

  set old_id[FURBOLG_SHAMAN] = oFURBOLG_SHAMAN
  set buy_type[FURBOLG_SHAMAN] = BT_MERC
  set needed1[FURBOLG_SHAMAN] = 0
  set needed2[FURBOLG_SHAMAN] = 0
  set needed3[FURBOLG_SHAMAN] = 0
  set tc_add1[FURBOLG_SHAMAN] = 0
  set tc_add2[FURBOLG_SHAMAN] = 0
  set available_time[FURBOLG_SHAMAN] = R2I(72 / 5)
  set regenerate_time[FURBOLG_SHAMAN] = R2I(32 / 5)
  set gold_price[FURBOLG_SHAMAN] = 0
  set wood_price[FURBOLG_SHAMAN] = 0
  set hero_rush_bonus[FURBOLG_SHAMAN] = 0

  set old_id[THUNDER_LIZARD] = oTHUNDER_LIZARD
  set buy_type[THUNDER_LIZARD] = BT_MERC
  set needed1[THUNDER_LIZARD] = 0
  set needed2[THUNDER_LIZARD] = 0
  set needed3[THUNDER_LIZARD] = 0
  set tc_add1[THUNDER_LIZARD] = 0
  set tc_add2[THUNDER_LIZARD] = 0
  set available_time[THUNDER_LIZARD] = R2I(88 / 5)
  set regenerate_time[THUNDER_LIZARD] = R2I(52 / 5)
  set gold_price[THUNDER_LIZARD] = 0
  set wood_price[THUNDER_LIZARD] = 0
  set hero_rush_bonus[THUNDER_LIZARD] = 0

  set old_id[CENTAUR_OUTRUNNER] = oCENTAUR_OUTRUNNER
  set buy_type[CENTAUR_OUTRUNNER] = BT_MERC
  set needed1[CENTAUR_OUTRUNNER] = 0
  set needed2[CENTAUR_OUTRUNNER] = 0
  set needed3[CENTAUR_OUTRUNNER] = 0
  set tc_add1[CENTAUR_OUTRUNNER] = 0
  set tc_add2[CENTAUR_OUTRUNNER] = 0
  set available_time[CENTAUR_OUTRUNNER] = R2I(12 / 5)
  set regenerate_time[CENTAUR_OUTRUNNER] = R2I(22 / 5)
  set gold_price[CENTAUR_OUTRUNNER] = 0
  set wood_price[CENTAUR_OUTRUNNER] = 0
  set hero_rush_bonus[CENTAUR_OUTRUNNER] = 0

  set old_id[HARPY_ROGUE] = oHARPY_ROGUE
  set buy_type[HARPY_ROGUE] = BT_MERC
  set needed1[HARPY_ROGUE] = 0
  set needed2[HARPY_ROGUE] = 0
  set needed3[HARPY_ROGUE] = 0
  set tc_add1[HARPY_ROGUE] = 0
  set tc_add2[HARPY_ROGUE] = 0
  set available_time[HARPY_ROGUE] = R2I(72 / 5)
  set regenerate_time[HARPY_ROGUE] = R2I(22 / 5)
  set gold_price[HARPY_ROGUE] = 0
  set wood_price[HARPY_ROGUE] = 0
  set hero_rush_bonus[HARPY_ROGUE] = 0

  set old_id[RAZORMANE_MEDICINE_MAN] = oRAZORMANE_MEDICINE_MAN
  set buy_type[RAZORMANE_MEDICINE_MAN] = BT_MERC
  set needed1[RAZORMANE_MEDICINE_MAN] = 0
  set needed2[RAZORMANE_MEDICINE_MAN] = 0
  set needed3[RAZORMANE_MEDICINE_MAN] = 0
  set tc_add1[RAZORMANE_MEDICINE_MAN] = 0
  set tc_add2[RAZORMANE_MEDICINE_MAN] = 0
  set available_time[RAZORMANE_MEDICINE_MAN] = R2I(88 / 5)
  set regenerate_time[RAZORMANE_MEDICINE_MAN] = R2I(42 / 5)
  set gold_price[RAZORMANE_MEDICINE_MAN] = 0
  set wood_price[RAZORMANE_MEDICINE_MAN] = 0
  set hero_rush_bonus[RAZORMANE_MEDICINE_MAN] = 0

  set old_id[HARPY_WINDWITCH] = oHARPY_WINDWITCH
  set buy_type[HARPY_WINDWITCH] = BT_MERC
  set needed1[HARPY_WINDWITCH] = 0
  set needed2[HARPY_WINDWITCH] = 0
  set needed3[HARPY_WINDWITCH] = 0
  set tc_add1[HARPY_WINDWITCH] = 0
  set tc_add2[HARPY_WINDWITCH] = 0
  set available_time[HARPY_WINDWITCH] = R2I(132 / 5)
  set regenerate_time[HARPY_WINDWITCH] = R2I(32 / 5)
  set gold_price[HARPY_WINDWITCH] = 0
  set wood_price[HARPY_WINDWITCH] = 0
  set hero_rush_bonus[HARPY_WINDWITCH] = 0

  set old_id[FEL_BEAST] = oFEL_BEAST
  set buy_type[FEL_BEAST] = BT_MERC
  set needed1[FEL_BEAST] = 0
  set needed2[FEL_BEAST] = 0
  set needed3[FEL_BEAST] = 0
  set tc_add1[FEL_BEAST] = 0
  set tc_add2[FEL_BEAST] = 0
  set available_time[FEL_BEAST] = R2I(12 / 5)
  set regenerate_time[FEL_BEAST] = R2I(22 / 5)
  set gold_price[FEL_BEAST] = 0
  set wood_price[FEL_BEAST] = 0
  set hero_rush_bonus[FEL_BEAST] = 0

  set old_id[DRAENEI_DISCIPLE] = oDRAENEI_DISCIPLE
  set buy_type[DRAENEI_DISCIPLE] = BT_MERC
  set needed1[DRAENEI_DISCIPLE] = 0
  set needed2[DRAENEI_DISCIPLE] = 0
  set needed3[DRAENEI_DISCIPLE] = 0
  set tc_add1[DRAENEI_DISCIPLE] = 0
  set tc_add2[DRAENEI_DISCIPLE] = 0
  set available_time[DRAENEI_DISCIPLE] = R2I(27 / 5)
  set regenerate_time[DRAENEI_DISCIPLE] = R2I(22 / 5)
  set gold_price[DRAENEI_DISCIPLE] = 0
  set wood_price[DRAENEI_DISCIPLE] = 0
  set hero_rush_bonus[DRAENEI_DISCIPLE] = 0

  set old_id[VOIDWALKER] = oVOIDWALKER
  set buy_type[VOIDWALKER] = BT_MERC
  set needed1[VOIDWALKER] = 0
  set needed2[VOIDWALKER] = 0
  set needed3[VOIDWALKER] = 0
  set tc_add1[VOIDWALKER] = 0
  set tc_add2[VOIDWALKER] = 0
  set available_time[VOIDWALKER] = R2I(88 / 5)
  set regenerate_time[VOIDWALKER] = R2I(42 / 5)
  set gold_price[VOIDWALKER] = 0
  set wood_price[VOIDWALKER] = 0
  set hero_rush_bonus[VOIDWALKER] = 0

  set old_id[DRAENEI_DARKSLAYER] = oDRAENEI_DARKSLAYER
  set buy_type[DRAENEI_DARKSLAYER] = BT_MERC
  set needed1[DRAENEI_DARKSLAYER] = 0
  set needed2[DRAENEI_DARKSLAYER] = 0
  set needed3[DRAENEI_DARKSLAYER] = 0
  set tc_add1[DRAENEI_DARKSLAYER] = 0
  set tc_add2[DRAENEI_DARKSLAYER] = 0
  set available_time[DRAENEI_DARKSLAYER] = R2I(66 / 5)
  set regenerate_time[DRAENEI_DARKSLAYER] = R2I(42 / 5)
  set gold_price[DRAENEI_DARKSLAYER] = 0
  set wood_price[DRAENEI_DARKSLAYER] = 0
  set hero_rush_bonus[DRAENEI_DARKSLAYER] = 0

  set old_id[ROGUE] = oROGUE
  set buy_type[ROGUE] = BT_MERC
  set needed1[ROGUE] = 0
  set needed2[ROGUE] = 0
  set needed3[ROGUE] = 0
  set tc_add1[ROGUE] = 0
  set tc_add2[ROGUE] = 0
  set available_time[ROGUE] = R2I(88 / 5)
  set regenerate_time[ROGUE] = R2I(22 / 5)
  set gold_price[ROGUE] = 0
  set wood_price[ROGUE] = 0
  set hero_rush_bonus[ROGUE] = 0

  set old_id[ASSASSIN] = oASSASSIN
  set buy_type[ASSASSIN] = BT_MERC
  set needed1[ASSASSIN] = 0
  set needed2[ASSASSIN] = 0
  set needed3[ASSASSIN] = 0
  set tc_add1[ASSASSIN] = 0
  set tc_add2[ASSASSIN] = 0
  set available_time[ASSASSIN] = R2I(88 / 5)
  set regenerate_time[ASSASSIN] = R2I(32 / 5)
  set gold_price[ASSASSIN] = 0
  set wood_price[ASSASSIN] = 0
  set hero_rush_bonus[ASSASSIN] = 0

  set old_id[KOBOLD_GEOMANCER] = oKOBOLD_GEOMANCER
  set buy_type[KOBOLD_GEOMANCER] = BT_MERC
  set needed1[KOBOLD_GEOMANCER] = 0
  set needed2[KOBOLD_GEOMANCER] = 0
  set needed3[KOBOLD_GEOMANCER] = 0
  set tc_add1[KOBOLD_GEOMANCER] = 0
  set tc_add2[KOBOLD_GEOMANCER] = 0
  set available_time[KOBOLD_GEOMANCER] = R2I(88 / 5)
  set regenerate_time[KOBOLD_GEOMANCER] = R2I(32 / 5)
  set gold_price[KOBOLD_GEOMANCER] = 0
  set wood_price[KOBOLD_GEOMANCER] = 0
  set hero_rush_bonus[KOBOLD_GEOMANCER] = 0

  set old_id[FOREST_TROLL_HIGH_PRIEST] = oFOREST_TROLL_HIGH_PRIEST
  set buy_type[FOREST_TROLL_HIGH_PRIEST] = BT_MERC
  set needed1[FOREST_TROLL_HIGH_PRIEST] = 0
  set needed2[FOREST_TROLL_HIGH_PRIEST] = 0
  set needed3[FOREST_TROLL_HIGH_PRIEST] = 0
  set tc_add1[FOREST_TROLL_HIGH_PRIEST] = 0
  set tc_add2[FOREST_TROLL_HIGH_PRIEST] = 0
  set available_time[FOREST_TROLL_HIGH_PRIEST] = R2I(88 / 5)
  set regenerate_time[FOREST_TROLL_HIGH_PRIEST] = R2I(42 / 5)
  set gold_price[FOREST_TROLL_HIGH_PRIEST] = 0
  set wood_price[FOREST_TROLL_HIGH_PRIEST] = 0
  set hero_rush_bonus[FOREST_TROLL_HIGH_PRIEST] = 0

  set old_id[BURNING_ARCHER] = oBURNING_ARCHER
  set buy_type[BURNING_ARCHER] = BT_MERC
  set needed1[BURNING_ARCHER] = 0
  set needed2[BURNING_ARCHER] = 0
  set needed3[BURNING_ARCHER] = 0
  set tc_add1[BURNING_ARCHER] = 0
  set tc_add2[BURNING_ARCHER] = 0
  set available_time[BURNING_ARCHER] = R2I(12 / 5)
  set regenerate_time[BURNING_ARCHER] = R2I(22 / 5)
  set gold_price[BURNING_ARCHER] = 0
  set wood_price[BURNING_ARCHER] = 0
  set hero_rush_bonus[BURNING_ARCHER] = 0

  set old_id[WILDKIN] = oWILDKIN
  set buy_type[WILDKIN] = BT_MERC
  set needed1[WILDKIN] = 0
  set needed2[WILDKIN] = 0
  set needed3[WILDKIN] = 0
  set tc_add1[WILDKIN] = 0
  set tc_add2[WILDKIN] = 0
  set available_time[WILDKIN] = R2I(44 / 5)
  set regenerate_time[WILDKIN] = R2I(32 / 5)
  set gold_price[WILDKIN] = 0
  set wood_price[WILDKIN] = 0
  set hero_rush_bonus[WILDKIN] = 0

  set old_id[MURLOC_FLESHEATER] = oMURLOC_FLESHEATER
  set buy_type[MURLOC_FLESHEATER] = BT_MERC
  set needed1[MURLOC_FLESHEATER] = 0
  set needed2[MURLOC_FLESHEATER] = 0
  set needed3[MURLOC_FLESHEATER] = 0
  set tc_add1[MURLOC_FLESHEATER] = 0
  set tc_add2[MURLOC_FLESHEATER] = 0
  set available_time[MURLOC_FLESHEATER] = R2I(12 / 5)
  set regenerate_time[MURLOC_FLESHEATER] = R2I(22 / 5)
  set gold_price[MURLOC_FLESHEATER] = 0
  set wood_price[MURLOC_FLESHEATER] = 0
  set hero_rush_bonus[MURLOC_FLESHEATER] = 0

  set old_id[SLUDGE_FLINGER] = oSLUDGE_FLINGER
  set buy_type[SLUDGE_FLINGER] = BT_MERC
  set needed1[SLUDGE_FLINGER] = 0
  set needed2[SLUDGE_FLINGER] = 0
  set needed3[SLUDGE_FLINGER] = 0
  set tc_add1[SLUDGE_FLINGER] = 0
  set tc_add2[SLUDGE_FLINGER] = 0
  set available_time[SLUDGE_FLINGER] = R2I(66 / 5)
  set regenerate_time[SLUDGE_FLINGER] = R2I(32 / 5)
  set gold_price[SLUDGE_FLINGER] = 0
  set wood_price[SLUDGE_FLINGER] = 0
  set hero_rush_bonus[SLUDGE_FLINGER] = 0

  set old_id[SATYR_SOULSTEALER] = oSATYR_SOULSTEALER
  set buy_type[SATYR_SOULSTEALER] = BT_MERC
  set needed1[SATYR_SOULSTEALER] = 0
  set needed2[SATYR_SOULSTEALER] = 0
  set needed3[SATYR_SOULSTEALER] = 0
  set tc_add1[SATYR_SOULSTEALER] = 0
  set tc_add2[SATYR_SOULSTEALER] = 0
  set available_time[SATYR_SOULSTEALER] = R2I(88 / 5)
  set regenerate_time[SATYR_SOULSTEALER] = R2I(42 / 5)
  set gold_price[SATYR_SOULSTEALER] = 0
  set wood_price[SATYR_SOULSTEALER] = 0
  set hero_rush_bonus[SATYR_SOULSTEALER] = 0

  set old_id[BARBED_ARACHNATHID] = oBARBED_ARACHNATHID
  set buy_type[BARBED_ARACHNATHID] = BT_MERC
  set needed1[BARBED_ARACHNATHID] = 0
  set needed2[BARBED_ARACHNATHID] = 0
  set needed3[BARBED_ARACHNATHID] = 0
  set tc_add1[BARBED_ARACHNATHID] = 0
  set tc_add2[BARBED_ARACHNATHID] = 0
  set available_time[BARBED_ARACHNATHID] = R2I(88 / 5)
  set regenerate_time[BARBED_ARACHNATHID] = R2I(12 / 5)
  set gold_price[BARBED_ARACHNATHID] = 0
  set wood_price[BARBED_ARACHNATHID] = 0
  set hero_rush_bonus[BARBED_ARACHNATHID] = 0

  set old_id[BLUE_DRAGONSPAWN_MEDDLER] = oBLUE_DRAGONSPAWN_MEDDLER
  set buy_type[BLUE_DRAGONSPAWN_MEDDLER] = BT_MERC
  set needed1[BLUE_DRAGONSPAWN_MEDDLER] = 0
  set needed2[BLUE_DRAGONSPAWN_MEDDLER] = 0
  set needed3[BLUE_DRAGONSPAWN_MEDDLER] = 0
  set tc_add1[BLUE_DRAGONSPAWN_MEDDLER] = 0
  set tc_add2[BLUE_DRAGONSPAWN_MEDDLER] = 0
  set available_time[BLUE_DRAGONSPAWN_MEDDLER] = R2I(44 / 5)
  set regenerate_time[BLUE_DRAGONSPAWN_MEDDLER] = R2I(22 / 5)
  set gold_price[BLUE_DRAGONSPAWN_MEDDLER] = 0
  set wood_price[BLUE_DRAGONSPAWN_MEDDLER] = 0
  set hero_rush_bonus[BLUE_DRAGONSPAWN_MEDDLER] = 0

  set old_id[MAGNATAUR_WARRIOR] = oMAGNATAUR_WARRIOR
  set buy_type[MAGNATAUR_WARRIOR] = BT_MERC
  set needed1[MAGNATAUR_WARRIOR] = 0
  set needed2[MAGNATAUR_WARRIOR] = 0
  set needed3[MAGNATAUR_WARRIOR] = 0
  set tc_add1[MAGNATAUR_WARRIOR] = 0
  set tc_add2[MAGNATAUR_WARRIOR] = 0
  set available_time[MAGNATAUR_WARRIOR] = R2I(88 / 5)
  set regenerate_time[MAGNATAUR_WARRIOR] = R2I(42 / 5)
  set gold_price[MAGNATAUR_WARRIOR] = 0
  set wood_price[MAGNATAUR_WARRIOR] = 0
  set hero_rush_bonus[MAGNATAUR_WARRIOR] = 0

  set old_id[POLAR_FURBOLG_SHAMAN] = oPOLAR_FURBOLG_SHAMAN
  set buy_type[POLAR_FURBOLG_SHAMAN] = BT_MERC
  set needed1[POLAR_FURBOLG_SHAMAN] = 0
  set needed2[POLAR_FURBOLG_SHAMAN] = 0
  set needed3[POLAR_FURBOLG_SHAMAN] = 0
  set tc_add1[POLAR_FURBOLG_SHAMAN] = 0
  set tc_add2[POLAR_FURBOLG_SHAMAN] = 0
  set available_time[POLAR_FURBOLG_SHAMAN] = R2I(66 / 5)
  set regenerate_time[POLAR_FURBOLG_SHAMAN] = R2I(32 / 5)
  set gold_price[POLAR_FURBOLG_SHAMAN] = 0
  set wood_price[POLAR_FURBOLG_SHAMAN] = 0
  set hero_rush_bonus[POLAR_FURBOLG_SHAMAN] = 0

  set old_id[GNOLL_BRUTE] = oGNOLL_BRUTE
  set buy_type[GNOLL_BRUTE] = BT_MERC
  set needed1[GNOLL_BRUTE] = 0
  set needed2[GNOLL_BRUTE] = 0
  set needed3[GNOLL_BRUTE] = 0
  set tc_add1[GNOLL_BRUTE] = 0
  set tc_add2[GNOLL_BRUTE] = 0
  set available_time[GNOLL_BRUTE] = R2I(12 / 5)
  set regenerate_time[GNOLL_BRUTE] = R2I(22 / 5)
  set gold_price[GNOLL_BRUTE] = 0
  set wood_price[GNOLL_BRUTE] = 0
  set hero_rush_bonus[GNOLL_BRUTE] = 0

  set old_id[GNOLL_WARDEN] = oGNOLL_WARDEN
  set buy_type[GNOLL_WARDEN] = BT_MERC
  set needed1[GNOLL_WARDEN] = 0
  set needed2[GNOLL_WARDEN] = 0
  set needed3[GNOLL_WARDEN] = 0
  set tc_add1[GNOLL_WARDEN] = 0
  set tc_add2[GNOLL_WARDEN] = 0
  set available_time[GNOLL_WARDEN] = R2I(36 / 5)
  set regenerate_time[GNOLL_WARDEN] = R2I(22 / 5)
  set gold_price[GNOLL_WARDEN] = 0
  set wood_price[GNOLL_WARDEN] = 0
  set hero_rush_bonus[GNOLL_WARDEN] = 0

  set old_id[OGRE_MAGI] = oOGRE_MAGI
  set buy_type[OGRE_MAGI] = BT_MERC
  set needed1[OGRE_MAGI] = 0
  set needed2[OGRE_MAGI] = 0
  set needed3[OGRE_MAGI] = 0
  set tc_add1[OGRE_MAGI] = 0
  set tc_add2[OGRE_MAGI] = 0
  set available_time[OGRE_MAGI] = R2I(88 / 5)
  set regenerate_time[OGRE_MAGI] = R2I(42 / 5)
  set gold_price[OGRE_MAGI] = 0
  set wood_price[OGRE_MAGI] = 0
  set hero_rush_bonus[OGRE_MAGI] = 0

  set old_id[MUD_GOLEM] = oMUD_GOLEM
  set buy_type[MUD_GOLEM] = BT_MERC
  set needed1[MUD_GOLEM] = 0
  set needed2[MUD_GOLEM] = 0
  set needed3[MUD_GOLEM] = 0
  set tc_add1[MUD_GOLEM] = 0
  set tc_add2[MUD_GOLEM] = 0
  set available_time[MUD_GOLEM] = R2I(88 / 5)
  set regenerate_time[MUD_GOLEM] = R2I(22 / 5)
  set gold_price[MUD_GOLEM] = 0
  set wood_price[MUD_GOLEM] = 0
  set hero_rush_bonus[MUD_GOLEM] = 0

  set old_id[FOREST_TROLL_BERSERKER] = oFOREST_TROLL_BERSERKER
  set buy_type[FOREST_TROLL_BERSERKER] = BT_MERC
  set needed1[FOREST_TROLL_BERSERKER] = 0
  set needed2[FOREST_TROLL_BERSERKER] = 0
  set needed3[FOREST_TROLL_BERSERKER] = 0
  set tc_add1[FOREST_TROLL_BERSERKER] = 0
  set tc_add2[FOREST_TROLL_BERSERKER] = 0
  set available_time[FOREST_TROLL_BERSERKER] = R2I(44 / 5)
  set regenerate_time[FOREST_TROLL_BERSERKER] = R2I(42 / 5)
  set gold_price[FOREST_TROLL_BERSERKER] = 0
  set wood_price[FOREST_TROLL_BERSERKER] = 0
  set hero_rush_bonus[FOREST_TROLL_BERSERKER] = 0

  set old_id[FOREST_TROLL_SHADOW_PRIEST] = oFOREST_TROLL_SHADOW_PRIEST
  set buy_type[FOREST_TROLL_SHADOW_PRIEST] = BT_MERC
  set needed1[FOREST_TROLL_SHADOW_PRIEST] = 0
  set needed2[FOREST_TROLL_SHADOW_PRIEST] = 0
  set needed3[FOREST_TROLL_SHADOW_PRIEST] = 0
  set tc_add1[FOREST_TROLL_SHADOW_PRIEST] = 0
  set tc_add2[FOREST_TROLL_SHADOW_PRIEST] = 0
  set available_time[FOREST_TROLL_SHADOW_PRIEST] = R2I(24 / 5)
  set regenerate_time[FOREST_TROLL_SHADOW_PRIEST] = R2I(22 / 5)
  set gold_price[FOREST_TROLL_SHADOW_PRIEST] = 0
  set wood_price[FOREST_TROLL_SHADOW_PRIEST] = 0
  set hero_rush_bonus[FOREST_TROLL_SHADOW_PRIEST] = 0

  set old_id[OGRE_MAULER] = oOGRE_MAULER
  set buy_type[OGRE_MAULER] = BT_MERC
  set needed1[OGRE_MAULER] = 0
  set needed2[OGRE_MAULER] = 0
  set needed3[OGRE_MAULER] = 0
  set tc_add1[OGRE_MAULER] = 0
  set tc_add2[OGRE_MAULER] = 0
  set available_time[OGRE_MAULER] = R2I(88 / 5)
  set regenerate_time[OGRE_MAULER] = R2I(32 / 5)
  set gold_price[OGRE_MAULER] = 0
  set wood_price[OGRE_MAULER] = 0
  set hero_rush_bonus[OGRE_MAULER] = 0

  set old_id[GNOLL_OVERSEER] = oGNOLL_OVERSEER
  set buy_type[GNOLL_OVERSEER] = BT_MERC
  set needed1[GNOLL_OVERSEER] = 0
  set needed2[GNOLL_OVERSEER] = 0
  set needed3[GNOLL_OVERSEER] = 0
  set tc_add1[GNOLL_OVERSEER] = 0
  set tc_add2[GNOLL_OVERSEER] = 0
  set available_time[GNOLL_OVERSEER] = R2I(88 / 5)
  set regenerate_time[GNOLL_OVERSEER] = R2I(42 / 5)
  set gold_price[GNOLL_OVERSEER] = 0
  set wood_price[GNOLL_OVERSEER] = 0
  set hero_rush_bonus[GNOLL_OVERSEER] = 0

  set old_id[ICE_TROLL_BERSERKER] = oICE_TROLL_BERSERKER
  set buy_type[ICE_TROLL_BERSERKER] = BT_MERC
  set needed1[ICE_TROLL_BERSERKER] = 0
  set needed2[ICE_TROLL_BERSERKER] = 0
  set needed3[ICE_TROLL_BERSERKER] = 0
  set tc_add1[ICE_TROLL_BERSERKER] = 0
  set tc_add2[ICE_TROLL_BERSERKER] = 0
  set available_time[ICE_TROLL_BERSERKER] = R2I(88 / 5)
  set regenerate_time[ICE_TROLL_BERSERKER] = R2I(32 / 5)
  set gold_price[ICE_TROLL_BERSERKER] = 0
  set wood_price[ICE_TROLL_BERSERKER] = 0
  set hero_rush_bonus[ICE_TROLL_BERSERKER] = 0

  set old_id[ICE_TROLL_TRAPPER] = oICE_TROLL_TRAPPER
  set buy_type[ICE_TROLL_TRAPPER] = BT_MERC
  set needed1[ICE_TROLL_TRAPPER] = 0
  set needed2[ICE_TROLL_TRAPPER] = 0
  set needed3[ICE_TROLL_TRAPPER] = 0
  set tc_add1[ICE_TROLL_TRAPPER] = 0
  set tc_add2[ICE_TROLL_TRAPPER] = 0
  set available_time[ICE_TROLL_TRAPPER] = R2I(88 / 5)
  set regenerate_time[ICE_TROLL_TRAPPER] = R2I(22 / 5)
  set gold_price[ICE_TROLL_TRAPPER] = 0
  set wood_price[ICE_TROLL_TRAPPER] = 0
  set hero_rush_bonus[ICE_TROLL_TRAPPER] = 0

  set old_id[NERUBIAN_WARRIOR] = oNERUBIAN_WARRIOR
  set buy_type[NERUBIAN_WARRIOR] = BT_MERC
  set needed1[NERUBIAN_WARRIOR] = 0
  set needed2[NERUBIAN_WARRIOR] = 0
  set needed3[NERUBIAN_WARRIOR] = 0
  set tc_add1[NERUBIAN_WARRIOR] = 0
  set tc_add2[NERUBIAN_WARRIOR] = 0
  set available_time[NERUBIAN_WARRIOR] = R2I(12 / 5)
  set regenerate_time[NERUBIAN_WARRIOR] = R2I(22 / 5)
  set gold_price[NERUBIAN_WARRIOR] = 0
  set wood_price[NERUBIAN_WARRIOR] = 0
  set hero_rush_bonus[NERUBIAN_WARRIOR] = 0

  set old_id[FROST_REVENANT] = oFROST_REVENANT
  set buy_type[FROST_REVENANT] = BT_MERC
  set needed1[FROST_REVENANT] = 0
  set needed2[FROST_REVENANT] = 0
  set needed3[FROST_REVENANT] = 0
  set tc_add1[FROST_REVENANT] = 0
  set tc_add2[FROST_REVENANT] = 0
  set available_time[FROST_REVENANT] = R2I(88 / 5)
  set regenerate_time[FROST_REVENANT] = R2I(32 / 5)
  set gold_price[FROST_REVENANT] = 0
  set wood_price[FROST_REVENANT] = 0
  set hero_rush_bonus[FROST_REVENANT] = 0

  set old_id[NERUBIAN_WEBSPINNER] = oNERUBIAN_WEBSPINNER
  set buy_type[NERUBIAN_WEBSPINNER] = BT_MERC
  set needed1[NERUBIAN_WEBSPINNER] = 0
  set needed2[NERUBIAN_WEBSPINNER] = 0
  set needed3[NERUBIAN_WEBSPINNER] = 0
  set tc_add1[NERUBIAN_WEBSPINNER] = 0
  set tc_add2[NERUBIAN_WEBSPINNER] = 0
  set available_time[NERUBIAN_WEBSPINNER] = R2I(44 / 5)
  set regenerate_time[NERUBIAN_WEBSPINNER] = R2I(22 / 5)
  set gold_price[NERUBIAN_WEBSPINNER] = 0
  set wood_price[NERUBIAN_WEBSPINNER] = 0
  set hero_rush_bonus[NERUBIAN_WEBSPINNER] = 0

  set old_id[MURGUL_SNARECASTER] = oMURGUL_SNARECASTER
  set buy_type[MURGUL_SNARECASTER] = BT_MERC
  set needed1[MURGUL_SNARECASTER] = 0
  set needed2[MURGUL_SNARECASTER] = 0
  set needed3[MURGUL_SNARECASTER] = 0
  set tc_add1[MURGUL_SNARECASTER] = 0
  set tc_add2[MURGUL_SNARECASTER] = 0
  set available_time[MURGUL_SNARECASTER] = R2I(88 / 5)
  set regenerate_time[MURGUL_SNARECASTER] = R2I(32 / 5)
  set gold_price[MURGUL_SNARECASTER] = 0
  set wood_price[MURGUL_SNARECASTER] = 0
  set hero_rush_bonus[MURGUL_SNARECASTER] = 0

  set old_id[MAKRURA_SNAPPER] = oMAKRURA_SNAPPER
  set buy_type[MAKRURA_SNAPPER] = BT_MERC
  set needed1[MAKRURA_SNAPPER] = 0
  set needed2[MAKRURA_SNAPPER] = 0
  set needed3[MAKRURA_SNAPPER] = 0
  set tc_add1[MAKRURA_SNAPPER] = 0
  set tc_add2[MAKRURA_SNAPPER] = 0
  set available_time[MAKRURA_SNAPPER] = R2I(52 / 5)
  set regenerate_time[MAKRURA_SNAPPER] = R2I(42 / 5)
  set gold_price[MAKRURA_SNAPPER] = 0
  set wood_price[MAKRURA_SNAPPER] = 0
  set hero_rush_bonus[MAKRURA_SNAPPER] = 0

  set old_id[MAKRURA_DEEPSEER] = oMAKRURA_DEEPSEER
  set buy_type[MAKRURA_DEEPSEER] = BT_MERC
  set needed1[MAKRURA_DEEPSEER] = 0
  set needed2[MAKRURA_DEEPSEER] = 0
  set needed3[MAKRURA_DEEPSEER] = 0
  set tc_add1[MAKRURA_DEEPSEER] = 0
  set tc_add2[MAKRURA_DEEPSEER] = 0
  set available_time[MAKRURA_DEEPSEER] = R2I(88 / 5)
  set regenerate_time[MAKRURA_DEEPSEER] = R2I(42 / 5)
  set gold_price[MAKRURA_DEEPSEER] = 0
  set wood_price[MAKRURA_DEEPSEER] = 0
  set hero_rush_bonus[MAKRURA_DEEPSEER] = 0

  set old_id[GIANT_SEA_TURTLE] = oGIANT_SEA_TURTLE
  set buy_type[GIANT_SEA_TURTLE] = BT_MERC
  set needed1[GIANT_SEA_TURTLE] = 0
  set needed2[GIANT_SEA_TURTLE] = 0
  set needed3[GIANT_SEA_TURTLE] = 0
  set tc_add1[GIANT_SEA_TURTLE] = 0
  set tc_add2[GIANT_SEA_TURTLE] = 0
  set available_time[GIANT_SEA_TURTLE] = R2I(12 / 5)
  set regenerate_time[GIANT_SEA_TURTLE] = R2I(32 / 5)
  set gold_price[GIANT_SEA_TURTLE] = 0
  set wood_price[GIANT_SEA_TURTLE] = 0
  set hero_rush_bonus[GIANT_SEA_TURTLE] = 0

  set old_id[KOBOLD] = oKOBOLD
  set buy_type[KOBOLD] = BT_MERC
  set needed1[KOBOLD] = 0
  set needed2[KOBOLD] = 0
  set needed3[KOBOLD] = 0
  set tc_add1[KOBOLD] = 0
  set tc_add2[KOBOLD] = 0
  set available_time[KOBOLD] = R2I(12 / 5)
  set regenerate_time[KOBOLD] = R2I(12 / 5)
  set gold_price[KOBOLD] = 0
  set wood_price[KOBOLD] = 0
  set hero_rush_bonus[KOBOLD] = 0

  set old_id[MURLOC_HUNTSMAN] = oMURLOC_HUNTSMAN
  set buy_type[MURLOC_HUNTSMAN] = BT_MERC
  set needed1[MURLOC_HUNTSMAN] = 0
  set needed2[MURLOC_HUNTSMAN] = 0
  set needed3[MURLOC_HUNTSMAN] = 0
  set tc_add1[MURLOC_HUNTSMAN] = 0
  set tc_add2[MURLOC_HUNTSMAN] = 0
  set available_time[MURLOC_HUNTSMAN] = R2I(22 / 5)
  set regenerate_time[MURLOC_HUNTSMAN] = R2I(22 / 5)
  set gold_price[MURLOC_HUNTSMAN] = 0
  set wood_price[MURLOC_HUNTSMAN] = 0
  set hero_rush_bonus[MURLOC_HUNTSMAN] = 0

  set old_id[BLACK_DRAGON_1] = oBLACK_DRAGON_1
  set buy_type[BLACK_DRAGON_1] = BT_DRAGON
  set needed1[BLACK_DRAGON_1] = 0
  set needed2[BLACK_DRAGON_1] = 0
  set needed3[BLACK_DRAGON_1] = 0
  set tc_add1[BLACK_DRAGON_1] = 0
  set tc_add2[BLACK_DRAGON_1] = 0
  set available_time[BLACK_DRAGON_1] = R2I(88 / 5)
  set regenerate_time[BLACK_DRAGON_1] = R2I(26 / 5)
  set gold_price[BLACK_DRAGON_1] = 0
  set wood_price[BLACK_DRAGON_1] = 0
  set hero_rush_bonus[BLACK_DRAGON_1] = 0

  set old_id[BLACK_DRAGON_2] = oBLACK_DRAGON_2
  set buy_type[BLACK_DRAGON_2] = BT_DRAGON
  set needed1[BLACK_DRAGON_2] = 0
  set needed2[BLACK_DRAGON_2] = 0
  set needed3[BLACK_DRAGON_2] = 0
  set tc_add1[BLACK_DRAGON_2] = 0
  set tc_add2[BLACK_DRAGON_2] = 0
  set available_time[BLACK_DRAGON_2] = R2I(88 / 5)
  set regenerate_time[BLACK_DRAGON_2] = R2I(50 / 5)
  set gold_price[BLACK_DRAGON_2] = 0
  set wood_price[BLACK_DRAGON_2] = 0
  set hero_rush_bonus[BLACK_DRAGON_2] = 0

  set old_id[BLACK_DRAGON_3] = oBLACK_DRAGON_3
  set buy_type[BLACK_DRAGON_3] = BT_DRAGON
  set needed1[BLACK_DRAGON_3] = 0
  set needed2[BLACK_DRAGON_3] = 0
  set needed3[BLACK_DRAGON_3] = 0
  set tc_add1[BLACK_DRAGON_3] = 0
  set tc_add2[BLACK_DRAGON_3] = 0
  set available_time[BLACK_DRAGON_3] = R2I(184 / 5)
  set regenerate_time[BLACK_DRAGON_3] = R2I(82 / 5)
  set gold_price[BLACK_DRAGON_3] = 0
  set wood_price[BLACK_DRAGON_3] = 0
  set hero_rush_bonus[BLACK_DRAGON_3] = 0

  set old_id[BLUE_DRAGON_1] = oBLUE_DRAGON_1
  set buy_type[BLUE_DRAGON_1] = BT_DRAGON
  set needed1[BLUE_DRAGON_1] = 0
  set needed2[BLUE_DRAGON_1] = 0
  set needed3[BLUE_DRAGON_1] = 0
  set tc_add1[BLUE_DRAGON_1] = 0
  set tc_add2[BLUE_DRAGON_1] = 0
  set available_time[BLUE_DRAGON_1] = R2I(88 / 5)
  set regenerate_time[BLUE_DRAGON_1] = R2I(26 / 5)
  set gold_price[BLUE_DRAGON_1] = 0
  set wood_price[BLUE_DRAGON_1] = 0
  set hero_rush_bonus[BLUE_DRAGON_1] = 0

  set old_id[BLUE_DRAGON_2] = oBLUE_DRAGON_2
  set buy_type[BLUE_DRAGON_2] = BT_DRAGON
  set needed1[BLUE_DRAGON_2] = 0
  set needed2[BLUE_DRAGON_2] = 0
  set needed3[BLUE_DRAGON_2] = 0
  set tc_add1[BLUE_DRAGON_2] = 0
  set tc_add2[BLUE_DRAGON_2] = 0
  set available_time[BLUE_DRAGON_2] = R2I(88 / 5)
  set regenerate_time[BLUE_DRAGON_2] = R2I(50 / 5)
  set gold_price[BLUE_DRAGON_2] = 0
  set wood_price[BLUE_DRAGON_2] = 0
  set hero_rush_bonus[BLUE_DRAGON_2] = 0

  set old_id[BLUE_DRAGON_3] = oBLUE_DRAGON_3
  set buy_type[BLUE_DRAGON_3] = BT_DRAGON
  set needed1[BLUE_DRAGON_3] = 0
  set needed2[BLUE_DRAGON_3] = 0
  set needed3[BLUE_DRAGON_3] = 0
  set tc_add1[BLUE_DRAGON_3] = 0
  set tc_add2[BLUE_DRAGON_3] = 0
  set available_time[BLUE_DRAGON_3] = R2I(184 / 5)
  set regenerate_time[BLUE_DRAGON_3] = R2I(82 / 5)
  set gold_price[BLUE_DRAGON_3] = 0
  set wood_price[BLUE_DRAGON_3] = 0
  set hero_rush_bonus[BLUE_DRAGON_3] = 0

  set old_id[BRONZE_DRAGON_1] = oBRONZE_DRAGON_1
  set buy_type[BRONZE_DRAGON_1] = BT_DRAGON
  set needed1[BRONZE_DRAGON_1] = 0
  set needed2[BRONZE_DRAGON_1] = 0
  set needed3[BRONZE_DRAGON_1] = 0
  set tc_add1[BRONZE_DRAGON_1] = 0
  set tc_add2[BRONZE_DRAGON_1] = 0
  set available_time[BRONZE_DRAGON_1] = R2I(88 / 5)
  set regenerate_time[BRONZE_DRAGON_1] = R2I(26 / 5)
  set gold_price[BRONZE_DRAGON_1] = 0
  set wood_price[BRONZE_DRAGON_1] = 0
  set hero_rush_bonus[BRONZE_DRAGON_1] = 0

  set old_id[BRONZE_DRAGON_2] = oBRONZE_DRAGON_2
  set buy_type[BRONZE_DRAGON_2] = BT_DRAGON
  set needed1[BRONZE_DRAGON_2] = 0
  set needed2[BRONZE_DRAGON_2] = 0
  set needed3[BRONZE_DRAGON_2] = 0
  set tc_add1[BRONZE_DRAGON_2] = 0
  set tc_add2[BRONZE_DRAGON_2] = 0
  set available_time[BRONZE_DRAGON_2] = R2I(88 / 5)
  set regenerate_time[BRONZE_DRAGON_2] = R2I(50 / 5)
  set gold_price[BRONZE_DRAGON_2] = 0
  set wood_price[BRONZE_DRAGON_2] = 0
  set hero_rush_bonus[BRONZE_DRAGON_2] = 0

  set old_id[BRONZE_DRAGON_3] = oBRONZE_DRAGON_3
  set buy_type[BRONZE_DRAGON_3] = BT_DRAGON
  set needed1[BRONZE_DRAGON_3] = 0
  set needed2[BRONZE_DRAGON_3] = 0
  set needed3[BRONZE_DRAGON_3] = 0
  set tc_add1[BRONZE_DRAGON_3] = 0
  set tc_add2[BRONZE_DRAGON_3] = 0
  set available_time[BRONZE_DRAGON_3] = R2I(184 / 5)
  set regenerate_time[BRONZE_DRAGON_3] = R2I(82 / 5)
  set gold_price[BRONZE_DRAGON_3] = 0
  set wood_price[BRONZE_DRAGON_3] = 0
  set hero_rush_bonus[BRONZE_DRAGON_3] = 0

  set old_id[GREEN_DRAGON_1] = oGREEN_DRAGON_1
  set buy_type[GREEN_DRAGON_1] = BT_DRAGON
  set needed1[GREEN_DRAGON_1] = 0
  set needed2[GREEN_DRAGON_1] = 0
  set needed3[GREEN_DRAGON_1] = 0
  set tc_add1[GREEN_DRAGON_1] = 0
  set tc_add2[GREEN_DRAGON_1] = 0
  set available_time[GREEN_DRAGON_1] = R2I(88 / 5)
  set regenerate_time[GREEN_DRAGON_1] = R2I(26 / 5)
  set gold_price[GREEN_DRAGON_1] = 0
  set wood_price[GREEN_DRAGON_1] = 0
  set hero_rush_bonus[GREEN_DRAGON_1] = 0

  set old_id[GREEN_DRAGON_2] = oGREEN_DRAGON_2
  set buy_type[GREEN_DRAGON_2] = BT_DRAGON
  set needed1[GREEN_DRAGON_2] = 0
  set needed2[GREEN_DRAGON_2] = 0
  set needed3[GREEN_DRAGON_2] = 0
  set tc_add1[GREEN_DRAGON_2] = 0
  set tc_add2[GREEN_DRAGON_2] = 0
  set available_time[GREEN_DRAGON_2] = R2I(88 / 5)
  set regenerate_time[GREEN_DRAGON_2] = R2I(50 / 5)
  set gold_price[GREEN_DRAGON_2] = 0
  set wood_price[GREEN_DRAGON_2] = 0
  set hero_rush_bonus[GREEN_DRAGON_2] = 0

  set old_id[GREEN_DRAGON_3] = oGREEN_DRAGON_3
  set buy_type[GREEN_DRAGON_3] = BT_DRAGON
  set needed1[GREEN_DRAGON_3] = 0
  set needed2[GREEN_DRAGON_3] = 0
  set needed3[GREEN_DRAGON_3] = 0
  set tc_add1[GREEN_DRAGON_3] = 0
  set tc_add2[GREEN_DRAGON_3] = 0
  set available_time[GREEN_DRAGON_3] = R2I(184 / 5)
  set regenerate_time[GREEN_DRAGON_3] = R2I(82 / 5)
  set gold_price[GREEN_DRAGON_3] = 0
  set wood_price[GREEN_DRAGON_3] = 0
  set hero_rush_bonus[GREEN_DRAGON_3] = 0

  set old_id[NETHER_DRAGON_1] = oNETHER_DRAGON_1
  set buy_type[NETHER_DRAGON_1] = BT_DRAGON
  set needed1[NETHER_DRAGON_1] = 0
  set needed2[NETHER_DRAGON_1] = 0
  set needed3[NETHER_DRAGON_1] = 0
  set tc_add1[NETHER_DRAGON_1] = 0
  set tc_add2[NETHER_DRAGON_1] = 0
  set available_time[NETHER_DRAGON_1] = R2I(88 / 5)
  set regenerate_time[NETHER_DRAGON_1] = R2I(26 / 5)
  set gold_price[NETHER_DRAGON_1] = 0
  set wood_price[NETHER_DRAGON_1] = 0
  set hero_rush_bonus[NETHER_DRAGON_1] = 0

  set old_id[NETHER_DRAGON_2] = oNETHER_DRAGON_2
  set buy_type[NETHER_DRAGON_2] = BT_DRAGON
  set needed1[NETHER_DRAGON_2] = 0
  set needed2[NETHER_DRAGON_2] = 0
  set needed3[NETHER_DRAGON_2] = 0
  set tc_add1[NETHER_DRAGON_2] = 0
  set tc_add2[NETHER_DRAGON_2] = 0
  set available_time[NETHER_DRAGON_2] = R2I(88 / 5)
  set regenerate_time[NETHER_DRAGON_2] = R2I(50 / 5)
  set gold_price[NETHER_DRAGON_2] = 0
  set wood_price[NETHER_DRAGON_2] = 0
  set hero_rush_bonus[NETHER_DRAGON_2] = 0

  set old_id[NETHER_DRAGON_3] = oNETHER_DRAGON_3
  set buy_type[NETHER_DRAGON_3] = BT_DRAGON
  set needed1[NETHER_DRAGON_3] = 0
  set needed2[NETHER_DRAGON_3] = 0
  set needed3[NETHER_DRAGON_3] = 0
  set tc_add1[NETHER_DRAGON_3] = 0
  set tc_add2[NETHER_DRAGON_3] = 0
  set available_time[NETHER_DRAGON_3] = R2I(184 / 5)
  set regenerate_time[NETHER_DRAGON_3] = R2I(82 / 5)
  set gold_price[NETHER_DRAGON_3] = 0
  set wood_price[NETHER_DRAGON_3] = 0
  set hero_rush_bonus[NETHER_DRAGON_3] = 0

  set old_id[RED_DRAGON_1] = oRED_DRAGON_1
  set buy_type[RED_DRAGON_1] = BT_DRAGON
  set needed1[RED_DRAGON_1] = 0
  set needed2[RED_DRAGON_1] = 0
  set needed3[RED_DRAGON_1] = 0
  set tc_add1[RED_DRAGON_1] = 0
  set tc_add2[RED_DRAGON_1] = 0
  set available_time[RED_DRAGON_1] = R2I(88 / 5)
  set regenerate_time[RED_DRAGON_1] = R2I(26 / 5)
  set gold_price[RED_DRAGON_1] = 0
  set wood_price[RED_DRAGON_1] = 0
  set hero_rush_bonus[RED_DRAGON_1] = 0

  set old_id[RED_DRAGON_2] = oRED_DRAGON_2
  set buy_type[RED_DRAGON_2] = BT_DRAGON
  set needed1[RED_DRAGON_2] = 0
  set needed2[RED_DRAGON_2] = 0
  set needed3[RED_DRAGON_2] = 0
  set tc_add1[RED_DRAGON_2] = 0
  set tc_add2[RED_DRAGON_2] = 0
  set available_time[RED_DRAGON_2] = R2I(88 / 5)
  set regenerate_time[RED_DRAGON_2] = R2I(50 / 5)
  set gold_price[RED_DRAGON_2] = 0
  set wood_price[RED_DRAGON_2] = 0
  set hero_rush_bonus[RED_DRAGON_2] = 0

  set old_id[RED_DRAGON_3] = oRED_DRAGON_3
  set buy_type[RED_DRAGON_3] = BT_DRAGON
  set needed1[RED_DRAGON_3] = 0
  set needed2[RED_DRAGON_3] = 0
  set needed3[RED_DRAGON_3] = 0
  set tc_add1[RED_DRAGON_3] = 0
  set tc_add2[RED_DRAGON_3] = 0
  set available_time[RED_DRAGON_3] = R2I(184 / 5)
  set regenerate_time[RED_DRAGON_3] = R2I(82 / 5)
  set gold_price[RED_DRAGON_3] = 0
  set wood_price[RED_DRAGON_3] = 0
  set hero_rush_bonus[RED_DRAGON_3] = 0

  set old_id[ZEPPELIN] = oZEPPELIN
  set buy_type[ZEPPELIN] = BT_GOBLIN_MERC
  set needed1[ZEPPELIN] = 0
  set needed2[ZEPPELIN] = 0
  set needed3[ZEPPELIN] = 0
  set tc_add1[ZEPPELIN] = 0
  set tc_add2[ZEPPELIN] = 0
  set available_time[ZEPPELIN] = R2I(44 / 5)
  set regenerate_time[ZEPPELIN] = R2I(6 / 5)
  set gold_price[ZEPPELIN] = 0
  set wood_price[ZEPPELIN] = 0
  set hero_rush_bonus[ZEPPELIN] = 0

  set old_id[SAPPER] = oSAPPER
  set buy_type[SAPPER] = BT_GOBLIN_MERC
  set needed1[SAPPER] = 0
  set needed2[SAPPER] = 0
  set needed3[SAPPER] = 0
  set tc_add1[SAPPER] = 0
  set tc_add2[SAPPER] = 0
  set available_time[SAPPER] = R2I(88 / 5)
  set regenerate_time[SAPPER] = R2I(9 / 5)
  set gold_price[SAPPER] = 0
  set wood_price[SAPPER] = 0
  set hero_rush_bonus[SAPPER] = 0

  set old_id[SHREDDER] = oSHREDDER
  set buy_type[SHREDDER] = BT_GOBLIN_MERC
  set needed1[SHREDDER] = 0
  set needed2[SHREDDER] = 0
  set needed3[SHREDDER] = 0
  set tc_add1[SHREDDER] = 0
  set tc_add2[SHREDDER] = 0
  set available_time[SHREDDER] = R2I(60 / 5)
  set regenerate_time[SHREDDER] = R2I(16 / 5)
  set gold_price[SHREDDER] = 0
  set wood_price[SHREDDER] = 0
  set hero_rush_bonus[SHREDDER] = 0

  set old_id[GOLD_MINE] = oGOLD_MINE
  set buy_type[GOLD_MINE] = BT_BUILDING
  set needed1[GOLD_MINE] = 0
  set needed2[GOLD_MINE] = 0
  set needed3[GOLD_MINE] = 0
  set tc_add1[GOLD_MINE] = 0
  set tc_add2[GOLD_MINE] = 0
  set available_time[GOLD_MINE] = R2I(0 / 5)
  set regenerate_time[GOLD_MINE] = R2I(0 / 5)
  set gold_price[GOLD_MINE] = 0
  set wood_price[GOLD_MINE] = 0
  set hero_rush_bonus[GOLD_MINE] = 0

  set old_id[JAINA] = oJAINA
  set buy_type[JAINA] = BT_HERO
  set needed1[JAINA] = HUMAN_ALTAR
  set needed2[JAINA] = KEEP
  set needed3[JAINA] = CASTLE
  set tc_add1[JAINA] = 0
  set tc_add2[JAINA] = 0
  set available_time[JAINA] = R2I(0 / 5)
  set regenerate_time[JAINA] = R2I(0 / 5)
  set gold_price[JAINA] = 0
  set wood_price[JAINA] = 0
  set hero_rush_bonus[JAINA] = 0

  set old_id[MURADIN] = oMURADIN
  set buy_type[MURADIN] = BT_HERO
  set needed1[MURADIN] = HUMAN_ALTAR
  set needed2[MURADIN] = KEEP
  set needed3[MURADIN] = CASTLE
  set tc_add1[MURADIN] = 0
  set tc_add2[MURADIN] = 0
  set available_time[MURADIN] = R2I(0 / 5)
  set regenerate_time[MURADIN] = R2I(0 / 5)
  set gold_price[MURADIN] = 0
  set wood_price[MURADIN] = 0
  set hero_rush_bonus[MURADIN] = 0

  set old_id[CHURCH] = oCHURCH
  set buy_type[CHURCH] = BT_BUILDING
  set needed1[CHURCH] = 0
  set needed2[CHURCH] = 0
  set needed3[CHURCH] = 0
  set tc_add1[CHURCH] = 0
  set tc_add2[CHURCH] = 0
  set available_time[CHURCH] = R2I(0 / 5)
  set regenerate_time[CHURCH] = R2I(0 / 5)
  set gold_price[CHURCH] = 0
  set wood_price[CHURCH] = 0
  set hero_rush_bonus[CHURCH] = 0

  set old_id[MAGE_TOWER] = oMAGE_TOWER
  set buy_type[MAGE_TOWER] = BT_BUILDING
  set needed1[MAGE_TOWER] = 0
  set needed2[MAGE_TOWER] = 0
  set needed3[MAGE_TOWER] = 0
  set tc_add1[MAGE_TOWER] = 0
  set tc_add2[MAGE_TOWER] = 0
  set available_time[MAGE_TOWER] = R2I(0 / 5)
  set regenerate_time[MAGE_TOWER] = R2I(0 / 5)
  set gold_price[MAGE_TOWER] = 0
  set wood_price[MAGE_TOWER] = 0
  set hero_rush_bonus[MAGE_TOWER] = 0

  set old_id[GROM] = oGROM
  set buy_type[GROM] = BT_HERO
  set needed1[GROM] = ORC_ALTAR
  set needed2[GROM] = STRONGHOLD
  set needed3[GROM] = FORTRESS
  set tc_add1[GROM] = 0
  set tc_add2[GROM] = 0
  set available_time[GROM] = R2I(0 / 5)
  set regenerate_time[GROM] = R2I(0 / 5)
  set gold_price[GROM] = 0
  set wood_price[GROM] = 0
  set hero_rush_bonus[GROM] = 0

  set old_id[THRALL] = oTHRALL
  set buy_type[THRALL] = BT_HERO
  set needed1[THRALL] = ORC_ALTAR
  set needed2[THRALL] = STRONGHOLD
  set needed3[THRALL] = FORTRESS
  set tc_add1[THRALL] = 0
  set tc_add2[THRALL] = 0
  set available_time[THRALL] = R2I(0 / 5)
  set regenerate_time[THRALL] = R2I(0 / 5)
  set gold_price[THRALL] = 0
  set wood_price[THRALL] = 0
  set hero_rush_bonus[THRALL] = 0

  set old_id[PIG_FARM] = oPIG_FARM
  set buy_type[PIG_FARM] = BT_BUILDING
  set needed1[PIG_FARM] = 0
  set needed2[PIG_FARM] = 0
  set needed3[PIG_FARM] = 0
  set tc_add1[PIG_FARM] = 0
  set tc_add2[PIG_FARM] = 0
  set available_time[PIG_FARM] = R2I(0 / 5)
  set regenerate_time[PIG_FARM] = R2I(0 / 5)
  set gold_price[PIG_FARM] = 0
  set wood_price[PIG_FARM] = 0
  set hero_rush_bonus[PIG_FARM] = 0

  set old_id[CHAOS_GRUNT] = oCHAOS_GRUNT
  set buy_type[CHAOS_GRUNT] = BT_UNIT
  set needed1[CHAOS_GRUNT] = ORC_BARRACKS
  set needed2[CHAOS_GRUNT] = 0
  set needed3[CHAOS_GRUNT] = 0
  set tc_add1[CHAOS_GRUNT] = 0
  set tc_add2[CHAOS_GRUNT] = 0
  set available_time[CHAOS_GRUNT] = R2I(0 / 5)
  set regenerate_time[CHAOS_GRUNT] = R2I(0 / 5)
  set gold_price[CHAOS_GRUNT] = 0
  set wood_price[CHAOS_GRUNT] = 0
  set hero_rush_bonus[CHAOS_GRUNT] = 0

  set old_id[CHAOS_WARLOCK] = oCHAOS_WARLOCK
  set buy_type[CHAOS_WARLOCK] = BT_UNIT
  set needed1[CHAOS_WARLOCK] = LODGE
  set needed2[CHAOS_WARLOCK] = 0
  set needed3[CHAOS_WARLOCK] = 0
  set tc_add1[CHAOS_WARLOCK] = 0
  set tc_add2[CHAOS_WARLOCK] = 0
  set available_time[CHAOS_WARLOCK] = R2I(0 / 5)
  set regenerate_time[CHAOS_WARLOCK] = R2I(0 / 5)
  set gold_price[CHAOS_WARLOCK] = 0
  set wood_price[CHAOS_WARLOCK] = 0
  set hero_rush_bonus[CHAOS_WARLOCK] = 0

  set old_id[CHAOS_RAIDER] = oCHAOS_RAIDER
  set buy_type[CHAOS_RAIDER] = BT_UNIT
  set needed1[CHAOS_RAIDER] = BESTIARY
  set needed2[CHAOS_RAIDER] = 0
  set needed3[CHAOS_RAIDER] = 0
  set tc_add1[CHAOS_RAIDER] = 0
  set tc_add2[CHAOS_RAIDER] = 0
  set available_time[CHAOS_RAIDER] = R2I(0 / 5)
  set regenerate_time[CHAOS_RAIDER] = R2I(0 / 5)
  set gold_price[CHAOS_RAIDER] = 0
  set wood_price[CHAOS_RAIDER] = 0
  set hero_rush_bonus[CHAOS_RAIDER] = 0

  set old_id[CHAOS_PEON] = oCHAOS_PEON
  set buy_type[CHAOS_PEON] = BT_UNIT
  set needed1[CHAOS_PEON] = GREAT_HALL
  set needed2[CHAOS_PEON] = 0
  set needed3[CHAOS_PEON] = 0
  set tc_add1[CHAOS_PEON] = 0
  set tc_add2[CHAOS_PEON] = 0
  set available_time[CHAOS_PEON] = R2I(0 / 5)
  set regenerate_time[CHAOS_PEON] = R2I(0 / 5)
  set gold_price[CHAOS_PEON] = 0
  set wood_price[CHAOS_PEON] = 0
  set hero_rush_bonus[CHAOS_PEON] = 0

  set old_id[CHAOS_KODO] = oCHAOS_KODO
  set buy_type[CHAOS_KODO] = BT_UNIT
  set needed1[CHAOS_KODO] = BESTIARY
  set needed2[CHAOS_KODO] = 0
  set needed3[CHAOS_KODO] = 0
  set tc_add1[CHAOS_KODO] = 0
  set tc_add2[CHAOS_KODO] = 0
  set available_time[CHAOS_KODO] = R2I(0 / 5)
  set regenerate_time[CHAOS_KODO] = R2I(0 / 5)
  set gold_price[CHAOS_KODO] = 0
  set wood_price[CHAOS_KODO] = 0
  set hero_rush_bonus[CHAOS_KODO] = 0

  set old_id[CHAOS_GROM] = oCHAOS_GROM
  set buy_type[CHAOS_GROM] = BT_UNIT
  set needed1[CHAOS_GROM] = ORC_ALTAR
  set needed2[CHAOS_GROM] = STRONGHOLD
  set needed3[CHAOS_GROM] = FORTRESS
  set tc_add1[CHAOS_GROM] = 0
  set tc_add2[CHAOS_GROM] = 0
  set available_time[CHAOS_GROM] = R2I(0 / 5)
  set regenerate_time[CHAOS_GROM] = R2I(0 / 5)
  set gold_price[CHAOS_GROM] = 0
  set wood_price[CHAOS_GROM] = 0
  set hero_rush_bonus[CHAOS_GROM] = 0

  set old_id[CHAOS_BLADEMASTER] = oCHAOS_BLADEMASTER
  set buy_type[CHAOS_BLADEMASTER] = BT_HERO
  set needed1[CHAOS_BLADEMASTER] = ORC_ALTAR
  set needed2[CHAOS_BLADEMASTER] = STRONGHOLD
  set needed3[CHAOS_BLADEMASTER] = FORTRESS
  set tc_add1[CHAOS_BLADEMASTER] = 0
  set tc_add2[CHAOS_BLADEMASTER] = 0
  set available_time[CHAOS_BLADEMASTER] = R2I(0 / 5)
  set regenerate_time[CHAOS_BLADEMASTER] = R2I(0 / 5)
  set gold_price[CHAOS_BLADEMASTER] = 0
  set wood_price[CHAOS_BLADEMASTER] = 0
  set hero_rush_bonus[CHAOS_BLADEMASTER] = 0

  set old_id[CHAOS_BURROW] = oCHAOS_BURROW
  set buy_type[CHAOS_BURROW] = BT_BUILDING
  set needed1[CHAOS_BURROW] = CHAOS_PEON
  set needed2[CHAOS_BURROW] = 0
  set needed3[CHAOS_BURROW] = 0
  set tc_add1[CHAOS_BURROW] = 0
  set tc_add2[CHAOS_BURROW] = 0
  set available_time[CHAOS_BURROW] = R2I(0 / 5)
  set regenerate_time[CHAOS_BURROW] = R2I(0 / 5)
  set gold_price[CHAOS_BURROW] = 0
  set wood_price[CHAOS_BURROW] = 0
  set hero_rush_bonus[CHAOS_BURROW] = 0

  set old_id[MALGANIS] = oMALGANIS
  set buy_type[MALGANIS] = BT_HERO
  set needed1[MALGANIS] = UNDEAD_ALTAR
  set needed2[MALGANIS] = NECROPOLIS_2
  set needed3[MALGANIS] = NECROPOLIS_3
  set tc_add1[MALGANIS] = 0
  set tc_add2[MALGANIS] = 0
  set available_time[MALGANIS] = R2I(0 / 5)
  set regenerate_time[MALGANIS] = R2I(0 / 5)
  set gold_price[MALGANIS] = 0
  set wood_price[MALGANIS] = 0
  set hero_rush_bonus[MALGANIS] = 0

  set old_id[TICHONDRIUS ] = oTICHONDRIUS 
  set buy_type[TICHONDRIUS ] = BT_HERO
  set needed1[TICHONDRIUS ] = UNDEAD_ALTAR
  set needed2[TICHONDRIUS ] = NECROPOLIS_2
  set needed3[TICHONDRIUS ] = NECROPOLIS_3
  set tc_add1[TICHONDRIUS ] = 0
  set tc_add2[TICHONDRIUS ] = 0
  set available_time[TICHONDRIUS ] = R2I(0 / 5)
  set regenerate_time[TICHONDRIUS ] = R2I(0 / 5)
  set gold_price[TICHONDRIUS ] = 0
  set wood_price[TICHONDRIUS ] = 0
  set hero_rush_bonus[TICHONDRIUS ] = 0

  set old_id[PIT_LORD] = oPIT_LORD
  set buy_type[PIT_LORD] = BT_HERO
  set needed1[PIT_LORD] = UNDEAD_ALTAR
  set needed2[PIT_LORD] = NECROPOLIS_2
  set needed3[PIT_LORD] = NECROPOLIS_3
  set tc_add1[PIT_LORD] = 0
  set tc_add2[PIT_LORD] = 0
  set available_time[PIT_LORD] = R2I(0 / 5)
  set regenerate_time[PIT_LORD] = R2I(0 / 5)
  set gold_price[PIT_LORD] = 0
  set wood_price[PIT_LORD] = 0
  set hero_rush_bonus[PIT_LORD] = 0

  set old_id[SYLVANUS] = oSYLVANUS
  set buy_type[SYLVANUS] = BT_HERO
  set needed1[SYLVANUS] = ELF_ALTAR
  set needed2[SYLVANUS] = TREE_AGES
  set needed3[SYLVANUS] = TREE_ETERNITY
  set tc_add1[SYLVANUS] = 0
  set tc_add2[SYLVANUS] = 0
  set available_time[SYLVANUS] = R2I(0 / 5)
  set regenerate_time[SYLVANUS] = R2I(0 / 5)
  set gold_price[SYLVANUS] = 0
  set wood_price[SYLVANUS] = 0
  set hero_rush_bonus[SYLVANUS] = 0

  set old_id[CENARIUS] = oCENARIUS
  set buy_type[CENARIUS] = BT_HERO
  set needed1[CENARIUS] = ELF_ALTAR
  set needed2[CENARIUS] = TREE_AGES
  set needed3[CENARIUS] = TREE_ETERNITY
  set tc_add1[CENARIUS] = 0
  set tc_add2[CENARIUS] = 0
  set available_time[CENARIUS] = R2I(0 / 5)
  set regenerate_time[CENARIUS] = R2I(0 / 5)
  set gold_price[CENARIUS] = 0
  set wood_price[CENARIUS] = 0
  set hero_rush_bonus[CENARIUS] = 0

  set old_id[ILLIDAN] = oILLIDAN
  set buy_type[ILLIDAN] = BT_HERO
  set needed1[ILLIDAN] = ELF_ALTAR
  set needed2[ILLIDAN] = TREE_AGES
  set needed3[ILLIDAN] = TREE_ETERNITY
  set tc_add1[ILLIDAN] = 0
  set tc_add2[ILLIDAN] = 0
  set available_time[ILLIDAN] = R2I(0 / 5)
  set regenerate_time[ILLIDAN] = R2I(0 / 5)
  set gold_price[ILLIDAN] = 0
  set wood_price[ILLIDAN] = 0
  set hero_rush_bonus[ILLIDAN] = 0

  set old_id[ILLIDAN_DEMON] = oILLIDAN_DEMON
  set buy_type[ILLIDAN_DEMON] = BT_HERO
  set needed1[ILLIDAN_DEMON] = ELF_ALTAR
  set needed2[ILLIDAN_DEMON] = TREE_AGES
  set needed3[ILLIDAN_DEMON] = TREE_ETERNITY
  set tc_add1[ILLIDAN_DEMON] = ILLIDAN
  set tc_add2[ILLIDAN_DEMON] = 0
  set available_time[ILLIDAN_DEMON] = R2I(0 / 5)
  set regenerate_time[ILLIDAN_DEMON] = R2I(0 / 5)
  set gold_price[ILLIDAN_DEMON] = 0
  set wood_price[ILLIDAN_DEMON] = 0
  set hero_rush_bonus[ILLIDAN_DEMON] = 0

  set old_id[MAIEV] = oMAIEV
  set buy_type[MAIEV] = BT_HERO
  set needed1[MAIEV] = ELF_ALTAR
  set needed2[MAIEV] = TREE_AGES
  set needed3[MAIEV] = TREE_ETERNITY
  set tc_add1[MAIEV] = 0
  set tc_add2[MAIEV] = 0
  set available_time[MAIEV] = R2I(0 / 5)
  set regenerate_time[MAIEV] = R2I(0 / 5)
  set gold_price[MAIEV] = 0
  set wood_price[MAIEV] = 0
  set hero_rush_bonus[MAIEV] = 0

  set old_id[HIGH_ARCHER ] = oHIGH_ARCHER 
  set buy_type[HIGH_ARCHER ] = BT_UNIT
  set needed1[HIGH_ARCHER ] = 0
  set needed2[HIGH_ARCHER ] = 0
  set needed3[HIGH_ARCHER ] = 0
  set tc_add1[HIGH_ARCHER ] = 0
  set tc_add2[HIGH_ARCHER ] = 0
  set available_time[HIGH_ARCHER ] = R2I(0 / 5)
  set regenerate_time[HIGH_ARCHER ] = R2I(0 / 5)
  set gold_price[HIGH_ARCHER ] = 0
  set wood_price[HIGH_ARCHER ] = 0
  set hero_rush_bonus[HIGH_ARCHER ] = 0

  set old_id[HIGH_FOOTMAN] = oHIGH_FOOTMAN
  set buy_type[HIGH_FOOTMAN] = BT_UNIT
  set needed1[HIGH_FOOTMAN] = 0
  set needed2[HIGH_FOOTMAN] = 0
  set needed3[HIGH_FOOTMAN] = 0
  set tc_add1[HIGH_FOOTMAN] = 0
  set tc_add2[HIGH_FOOTMAN] = 0
  set available_time[HIGH_FOOTMAN] = R2I(0 / 5)
  set regenerate_time[HIGH_FOOTMAN] = R2I(0 / 5)
  set gold_price[HIGH_FOOTMAN] = 0
  set wood_price[HIGH_FOOTMAN] = 0
  set hero_rush_bonus[HIGH_FOOTMAN] = 0

  set old_id[HIGH_FOOTMEN] = oHIGH_FOOTMEN
  set buy_type[HIGH_FOOTMEN] = BT_UNIT
  set needed1[HIGH_FOOTMEN] = 0
  set needed2[HIGH_FOOTMEN] = 0
  set needed3[HIGH_FOOTMEN] = 0
  set tc_add1[HIGH_FOOTMEN] = 0
  set tc_add2[HIGH_FOOTMEN] = 0
  set available_time[HIGH_FOOTMEN] = R2I(0 / 5)
  set regenerate_time[HIGH_FOOTMEN] = R2I(0 / 5)
  set gold_price[HIGH_FOOTMEN] = 0
  set wood_price[HIGH_FOOTMEN] = 0
  set hero_rush_bonus[HIGH_FOOTMEN] = 0

  set old_id[HIGH_SWORDMAN] = oHIGH_SWORDMAN
  set buy_type[HIGH_SWORDMAN] = BT_UNIT
  set needed1[HIGH_SWORDMAN] = 0
  set needed2[HIGH_SWORDMAN] = 0
  set needed3[HIGH_SWORDMAN] = 0
  set tc_add1[HIGH_SWORDMAN] = 0
  set tc_add2[HIGH_SWORDMAN] = 0
  set available_time[HIGH_SWORDMAN] = R2I(0 / 5)
  set regenerate_time[HIGH_SWORDMAN] = R2I(0 / 5)
  set gold_price[HIGH_SWORDMAN] = 0
  set wood_price[HIGH_SWORDMAN] = 0
  set hero_rush_bonus[HIGH_SWORDMAN] = 0

  set old_id[DRAGON_HAWK] = oDRAGON_HAWK
  set buy_type[DRAGON_HAWK] = BT_UNIT
  set needed1[DRAGON_HAWK] = 0
  set needed2[DRAGON_HAWK] = 0
  set needed3[DRAGON_HAWK] = 0
  set tc_add1[DRAGON_HAWK] = 0
  set tc_add2[DRAGON_HAWK] = 0
  set available_time[DRAGON_HAWK] = R2I(0 / 5)
  set regenerate_time[DRAGON_HAWK] = R2I(0 / 5)
  set gold_price[DRAGON_HAWK] = 0
  set wood_price[DRAGON_HAWK] = 0
  set hero_rush_bonus[DRAGON_HAWK] = 0

  set old_id[CORRUPT_TREANT] = oCORRUPT_TREANT
  set buy_type[CORRUPT_TREANT] = BT_UNIT
  set needed1[CORRUPT_TREANT] = 0
  set needed2[CORRUPT_TREANT] = 0
  set needed3[CORRUPT_TREANT] = 0
  set tc_add1[CORRUPT_TREANT] = 0
  set tc_add2[CORRUPT_TREANT] = 0
  set available_time[CORRUPT_TREANT] = R2I(0 / 5)
  set regenerate_time[CORRUPT_TREANT] = R2I(0 / 5)
  set gold_price[CORRUPT_TREANT] = 0
  set wood_price[CORRUPT_TREANT] = 0
  set hero_rush_bonus[CORRUPT_TREANT] = 0

  set old_id[POISON_TREANT] = oPOISON_TREANT
  set buy_type[POISON_TREANT] = BT_UNIT
  set needed1[POISON_TREANT] = 0
  set needed2[POISON_TREANT] = 0
  set needed3[POISON_TREANT] = 0
  set tc_add1[POISON_TREANT] = 0
  set tc_add2[POISON_TREANT] = 0
  set available_time[POISON_TREANT] = R2I(0 / 5)
  set regenerate_time[POISON_TREANT] = R2I(0 / 5)
  set gold_price[POISON_TREANT] = 0
  set wood_price[POISON_TREANT] = 0
  set hero_rush_bonus[POISON_TREANT] = 0

  set old_id[PLAGUE_TREANT] = oPLAGUE_TREANT
  set buy_type[PLAGUE_TREANT] = BT_UNIT
  set needed1[PLAGUE_TREANT] = 0
  set needed2[PLAGUE_TREANT] = 0
  set needed3[PLAGUE_TREANT] = 0
  set tc_add1[PLAGUE_TREANT] = 0
  set tc_add2[PLAGUE_TREANT] = 0
  set available_time[PLAGUE_TREANT] = R2I(0 / 5)
  set regenerate_time[PLAGUE_TREANT] = R2I(0 / 5)
  set gold_price[PLAGUE_TREANT] = 0
  set wood_price[PLAGUE_TREANT] = 0
  set hero_rush_bonus[PLAGUE_TREANT] = 0

  set old_id[SHANDRIS] = oSHANDRIS
  set buy_type[SHANDRIS] = BT_UNIT
  set needed1[SHANDRIS] = 0
  set needed2[SHANDRIS] = 0
  set needed3[SHANDRIS] = 0
  set tc_add1[SHANDRIS] = 0
  set tc_add2[SHANDRIS] = 0
  set available_time[SHANDRIS] = R2I(0 / 5)
  set regenerate_time[SHANDRIS] = R2I(0 / 5)
  set gold_price[SHANDRIS] = 0
  set wood_price[SHANDRIS] = 0
  set hero_rush_bonus[SHANDRIS] = 0

  set old_id[ELF_FARM] = oELF_FARM
  set buy_type[ELF_FARM] = BT_BUILDING
  set needed1[ELF_FARM] = 0
  set needed2[ELF_FARM] = 0
  set needed3[ELF_FARM] = 0
  set tc_add1[ELF_FARM] = 0
  set tc_add2[ELF_FARM] = 0
  set available_time[ELF_FARM] = R2I(0 / 5)
  set regenerate_time[ELF_FARM] = R2I(0 / 5)
  set gold_price[ELF_FARM] = 0
  set wood_price[ELF_FARM] = 0
  set hero_rush_bonus[ELF_FARM] = 0

  set old_id[ELF_GUARD_TOWER] = oELF_GUARD_TOWER
  set buy_type[ELF_GUARD_TOWER] = BT_BUILDING
  set needed1[ELF_GUARD_TOWER] = 0
  set needed2[ELF_GUARD_TOWER] = 0
  set needed3[ELF_GUARD_TOWER] = 0
  set tc_add1[ELF_GUARD_TOWER] = 0
  set tc_add2[ELF_GUARD_TOWER] = 0
  set available_time[ELF_GUARD_TOWER] = R2I(0 / 5)
  set regenerate_time[ELF_GUARD_TOWER] = R2I(0 / 5)
  set gold_price[ELF_GUARD_TOWER] = 0
  set wood_price[ELF_GUARD_TOWER] = 0
  set hero_rush_bonus[ELF_GUARD_TOWER] = 0

  set old_id[HIGH_SKY] = oHIGH_SKY
  set buy_type[HIGH_SKY] = BT_BUILDING
  set needed1[HIGH_SKY] = 0
  set needed2[HIGH_SKY] = 0
  set needed3[HIGH_SKY] = 0
  set tc_add1[HIGH_SKY] = 0
  set tc_add2[HIGH_SKY] = 0
  set available_time[HIGH_SKY] = R2I(0 / 5)
  set regenerate_time[HIGH_SKY] = R2I(0 / 5)
  set gold_price[HIGH_SKY] = 0
  set wood_price[HIGH_SKY] = 0
  set hero_rush_bonus[HIGH_SKY] = 0

  set old_id[HIGH_EARTH] = oHIGH_EARTH
  set buy_type[HIGH_EARTH] = BT_BUILDING
  set needed1[HIGH_EARTH] = 0
  set needed2[HIGH_EARTH] = 0
  set needed3[HIGH_EARTH] = 0
  set tc_add1[HIGH_EARTH] = 0
  set tc_add2[HIGH_EARTH] = 0
  set available_time[HIGH_EARTH] = R2I(0 / 5)
  set regenerate_time[HIGH_EARTH] = R2I(0 / 5)
  set gold_price[HIGH_EARTH] = 0
  set wood_price[HIGH_EARTH] = 0
  set hero_rush_bonus[HIGH_EARTH] = 0

  set old_id[HIGH_TOWER] = oHIGH_TOWER
  set buy_type[HIGH_TOWER] = BT_BUILDING
  set needed1[HIGH_TOWER] = 0
  set needed2[HIGH_TOWER] = 0
  set needed3[HIGH_TOWER] = 0
  set tc_add1[HIGH_TOWER] = 0
  set tc_add2[HIGH_TOWER] = 0
  set available_time[HIGH_TOWER] = R2I(0 / 5)
  set regenerate_time[HIGH_TOWER] = R2I(0 / 5)
  set gold_price[HIGH_TOWER] = 0
  set wood_price[HIGH_TOWER] = 0
  set hero_rush_bonus[HIGH_TOWER] = 0

  set old_id[ELF_HIGH_BARRACKS] = oELF_HIGH_BARRACKS
  set buy_type[ELF_HIGH_BARRACKS] = BT_BUILDING
  set needed1[ELF_HIGH_BARRACKS] = 0
  set needed2[ELF_HIGH_BARRACKS] = 0
  set needed3[ELF_HIGH_BARRACKS] = 0
  set tc_add1[ELF_HIGH_BARRACKS] = 0
  set tc_add2[ELF_HIGH_BARRACKS] = 0
  set available_time[ELF_HIGH_BARRACKS] = R2I(0 / 5)
  set regenerate_time[ELF_HIGH_BARRACKS] = R2I(0 / 5)
  set gold_price[ELF_HIGH_BARRACKS] = 0
  set wood_price[ELF_HIGH_BARRACKS] = 0
  set hero_rush_bonus[ELF_HIGH_BARRACKS] = 0

  set old_id[CORRUPT_LIFE] = oCORRUPT_LIFE
  set buy_type[CORRUPT_LIFE] = BT_BUILDING
  set needed1[CORRUPT_LIFE] = 0
  set needed2[CORRUPT_LIFE] = 0
  set needed3[CORRUPT_LIFE] = 0
  set tc_add1[CORRUPT_LIFE] = 0
  set tc_add2[CORRUPT_LIFE] = 0
  set available_time[CORRUPT_LIFE] = R2I(0 / 5)
  set regenerate_time[CORRUPT_LIFE] = R2I(0 / 5)
  set gold_price[CORRUPT_LIFE] = 0
  set wood_price[CORRUPT_LIFE] = 0
  set hero_rush_bonus[CORRUPT_LIFE] = 0

  set old_id[CORRUPT_WELL] = oCORRUPT_WELL
  set buy_type[CORRUPT_WELL] = BT_BUILDING
  set needed1[CORRUPT_WELL] = 0
  set needed2[CORRUPT_WELL] = 0
  set needed3[CORRUPT_WELL] = 0
  set tc_add1[CORRUPT_WELL] = 0
  set tc_add2[CORRUPT_WELL] = 0
  set available_time[CORRUPT_WELL] = R2I(0 / 5)
  set regenerate_time[CORRUPT_WELL] = R2I(0 / 5)
  set gold_price[CORRUPT_WELL] = 0
  set wood_price[CORRUPT_WELL] = 0
  set hero_rush_bonus[CORRUPT_WELL] = 0

  set old_id[CORRUPT_PROTECTOR] = oCORRUPT_PROTECTOR
  set buy_type[CORRUPT_PROTECTOR] = BT_BUILDING
  set needed1[CORRUPT_PROTECTOR] = 0
  set needed2[CORRUPT_PROTECTOR] = 0
  set needed3[CORRUPT_PROTECTOR] = 0
  set tc_add1[CORRUPT_PROTECTOR] = 0
  set tc_add2[CORRUPT_PROTECTOR] = 0
  set available_time[CORRUPT_PROTECTOR] = R2I(0 / 5)
  set regenerate_time[CORRUPT_PROTECTOR] = R2I(0 / 5)
  set gold_price[CORRUPT_PROTECTOR] = 0
  set wood_price[CORRUPT_PROTECTOR] = 0
  set hero_rush_bonus[CORRUPT_PROTECTOR] = 0

  set old_id[CORRUPT_WAR] = oCORRUPT_WAR
  set buy_type[CORRUPT_WAR] = BT_BUILDING
  set needed1[CORRUPT_WAR] = 0
  set needed2[CORRUPT_WAR] = 0
  set needed3[CORRUPT_WAR] = 0
  set tc_add1[CORRUPT_WAR] = 0
  set tc_add2[CORRUPT_WAR] = 0
  set available_time[CORRUPT_WAR] = R2I(0 / 5)
  set regenerate_time[CORRUPT_WAR] = R2I(0 / 5)
  set gold_price[CORRUPT_WAR] = 0
  set wood_price[CORRUPT_WAR] = 0
  set hero_rush_bonus[CORRUPT_WAR] = 0

  set old_id[UPG_ORC_CHAOS] = oUPG_ORC_CHAOS
  set buy_type[UPG_ORC_CHAOS] = BT_UPGRADE
  set needed1[UPG_ORC_CHAOS] = 0
  set needed2[UPG_ORC_CHAOS] = 0
  set needed3[UPG_ORC_CHAOS] = 0
  set tc_add1[UPG_ORC_CHAOS] = 0
  set tc_add2[UPG_ORC_CHAOS] = 0
  set available_time[UPG_ORC_CHAOS] = R2I(0 / 5)
  set regenerate_time[UPG_ORC_CHAOS] = R2I(0 / 5)
  set gold_price[UPG_ORC_CHAOS] = 0
  set wood_price[UPG_ORC_CHAOS] = 0
  set hero_rush_bonus[UPG_ORC_CHAOS] = 0

  //    call RLHashSet(o%1, %1)
endfunction

function InitChatArraysEnglish takes nothing returns nothing

  set chat_AGG[0] = "I'm as good as dead. Good game."
  set chat_AGG[1] = "I got owned by a [PlayerColor] [PlayerRace]. gg"
  set chat_AGG[2] = "It was fun while it lasted. But you can still win!"
  set chat_AGG[3] = "Sorry guys I gotta go. Have fun."
  set chat_AGG[4] = "I hate n00bs! You made me loose!"
  set chat_AGG[5] = "Somehow, I can't help but blame this all on you."
  set chat_AGG[6] = "Game over man, game over!!!"
  set chat_AGG[7] = "It's over for me.  Keep at it, you might get 'em."
  set chat_AGG[8] = "The end is nigh!"
  set chat_AGG[9] = "I'm sorry, my friend. We have lost this game."
  set chat_AGG[10] = "I apologize, my friend. We have failed this mission."
  set chat_AGG[11] = "I regret, my friend. We have been defeated by the enemy."
  set chat_AGG[12] = "I lament, my friend. We have fallen short of our goal."
  set chat_AGG[13] = "I grieve, my friend. We have met our doom."
  set chat_AGG_length = 14

  set chat_Ally[0] = "Come on rally up here against [TargetColor]!"
  set chat_Ally[1] = "Gather up you [PlayerRace] army for an assault on [TargetColor]!"
  set chat_Ally[2] = "Let's get ready to attack those [TargetColor] weaklings."
  set chat_Ally[3] = "Regroup here and attack [TargetColor]."
  set chat_Ally[4] = "Everyone attack [TargetColor] here!"
  set chat_Ally[5] = "I need some help over here for an attack on [TargetColor]."
  set chat_Ally[6] = "Stay on target... Stay on target against [TargetColor]!"
  set chat_Ally[7] = "This is where we should attack [TargetColor]"
  set chat_Ally[8] = "Bring the pain, right here against these pathetic [TargetColor] [TargetRace]!"
  set chat_Ally[9] = "Let's get an attack on [TargetColor] going here."
  set chat_Ally[10] = "Attack [TargetColor]. I have spotted a weakness in the enemy's defense."
  set chat_Ally[11] = "Attack [TargetColor]. I have prepared a surprise for the enemy."
  set chat_Ally[12] = "Attack [TargetColor]. I have secured a strategic position for us."
  set chat_Ally[13] = "Attack [TargetColor]. I have found a valuable resource for us to capture."
  set chat_Ally[14] = "Attack [TargetColor]. I have created a diversion for the enemy."
  set chat_Ally[15] = "Attack [TargetColor]. I have set a trap for the enemy."
  set chat_Ally[16] = "Attack [TargetColor]. I have detected a vulnerable target for us to eliminate."
  set chat_Ally[17] = "Attack [TargetColor]. I have arranged a backup for us."
  set chat_Ally[18] = "Attack [TargetColor]. I have calculated the optimal timing for us to strike."
  set chat_Ally[19] = "Attack [TargetColor]. I have a plan to win this game."
  set chat_Ally_length = 20

  set chat_Attack[0] = "I'm going on the offensive here."
  set chat_Attack[1] = "Im gonna attack these [TargetColor] [TargetRace], come on!"
  set chat_Attack[2] = "Red-5 Standing by."
  set chat_Attack[3] = "Cover me boys im going in!"
  set chat_Attack[4] = "Attacking the [TargetColor] [TargetRace] over here."
  set chat_Attack[5] = "Attacking the [TargetColor] [TargetRace] at this location."
  set chat_Attack[6] = "Charlie's in the bush!"
  set chat_Attack[7] = "The shield is down!"
  set chat_Attack[8] = "Let's hit the [TargetRace] army right here."
  set chat_Attack[9] = "Now's our chance, let's get 'em!"
  set chat_Attack_length = 10

  set chat_Creep[0] = "I'm gonna creep a bit."
  set chat_Creep[1] = "Gonna level up my [Race].  Killing these creeps now."
  set chat_Creep[2] = "Getting rid of these creeps."
  set chat_Creep[3] = "Creeping over here."
  set chat_Creep[4] = "Creeps are as good as dead."
  set chat_Creep[5] = "Follow me [TargetRace], let's go creeping."
  set chat_Creep[6] = "Let's level up."
  set chat_Creep[7] = "Good loot over here, come on!"
  set chat_Creep[8] = "Come get some items with me."
  set chat_Creep[9] = "Let's creep for a while."
  set chat_Creep_length = 10

  set chat_Done[0] = "What do you want to do now?  [TargetColor] [TargetRace] again?"
  set chat_Done[1] = "Good move attacking that [TargetColor] [TargetRace]."
  set chat_Done[2] = "I'm gonna do something else now."
  set chat_Done[3] = "Off for more dirtywork.  Lotta [RandomRace] to kill."
  set chat_Done[4] = "Im going to find some [RandomRace] to kill."
  set chat_Done[5] = "Attack sequence completed."
  set chat_Done[6] = "Been there, seen it, got the T-shirt."
  set chat_Done[7] = "Havoc wreaked.  Lotta dead [TargetRace] back there."
  set chat_Done[8] = "Left a path of death and destruction in my wake."
  set chat_Done[9] = "Asteroids do not concern me admiral."
  set chat_Done_length = 10

  set chat_EGG[0] = "Hacker! I'm out of here!"
  set chat_EGG[1] = "GG. Rematch sometime please."
  set chat_EGG[2] = "You're lucky I got [Race].  I hate playing as [Race]."
  set chat_EGG[3] = "g2g, looks like my entire [Race] army is wiped out!"
  set chat_EGG[4] = "Curse you! Looks like im dead."
  set chat_EGG[5] = "Dead man walking... dead man walking..."
  set chat_EGG[6] = "Next time [TargetColor]..."
  set chat_EGG[7] = "DOH!  Owned by a [PlayerColor] [PlayerRace]."
  set chat_EGG[8] = "You will pay for this [PlayerColor]!"
  set chat_EGG[9] = "These are not the droids you're looking for..."
  set chat_EGG[10] = "You are good, just wait for my next upgrade!"
  set chat_EGG[11] = "My workers went on strike! No wonder thou art victorious!"
  set chat_EGG[12] = "REMATCH!"
  set chat_EGG[13] = "I can't believe my [Color] [Race] lost to the likes of you!"
  set chat_EGG[14] = "I admit defeat. You have proven yourself to be a worthy opponent."
  set chat_EGG[15] = "I concede. You have outsmarted and outplayed me."
  set chat_EGG[16] = "I surrender. You have overwhelmed me with your superior tactics and skills."
  set chat_EGG[17] = "I yield. You have impressed me with your courage and determination."
  set chat_EGG[18] = "I quit. You have humbled me with your strength and resilience."
  set chat_EGG[19] = "I resign. You have astonished me with your creativity and innovation."
  set chat_EGG[20] = "I withdraw. You have amazed me with your speed and efficiency."
  set chat_EGG[21] = "I retreat. You have dazzled me with your flair and style."
  set chat_EGG[22] = "I capitulate. You have inspired me with your vision and passion."
  set chat_EGG[23] = "I give up. You have defeated me fair and square."
  set chat_EGG_length = 24

  set chat_Expansion[0] = "This expansion needs to be freed up."
  set chat_Expansion[1] = "I'm going to get more gold so I can build my [Race] army bigger."
  set chat_Expansion[2] = "Removing creeps at this expansion."
  set chat_Expansion[3] = "I might expand here soon."
  set chat_Expansion[4] = "Im going to creep here. Come on!"
  set chat_Expansion[5] = "Removing creeps."
  set chat_Expansion[6] = "Must...have...gold...must create more [Race:S]"
  set chat_Expansion[7] = "Help the war machine expand."
  set chat_Expansion[8] = "No deficite spending, gonna expand here.  We can always use more [Race:S]"
  set chat_Expansion[9] = "I need cash, gonna have to expand."
  set chat_Expansion_length = 10

  set chat_Goldproblem[0] = "{OwnGold<200} I've got only [OwnGold] gold. Give me some or I'll have to leave in 10 secs."
  set chat_Goldproblem[1] = "I am in urgent need of gold! Please spare me some or I'll have to leave in 10 seconds!"
  set chat_Goldproblem[2] = "{OwnGold<100}I'm outta cash.  I need gold in 10 seconds or I have to leave."
  set chat_Goldproblem[3] = "Donate some money to my cause or I'm leaving in 10 seconds."
  set chat_Goldproblem[4] = "You have 10 seconds to pay homage or else I'm outta here."
  set chat_Goldproblem[5] = "{OwnGold<100}In 10 seconds I've gotta leave if I don't get some gold from you."
  set chat_Goldproblem[6] = "Need some bling-bling yo!  Hook me up or I gotta jet in 10 seconds."
  set chat_Goldproblem[7] = "This sux! Only [OwnGold] gold.  I need gold within 10 seconds or I'm out."
  set chat_Goldproblem[8] = "If I don't get gold within 10 seconds I'm going to have to leave cause I've only got [OwnGold]."
  set chat_Goldproblem[9] = "I need money!  Give me some within 10 seconds or else I'll have to quit."
  set chat_Goldproblem_length = 10

  set chat_Greet[0] = "This will be an easy game."
  set chat_Greet[1] = "I told you not to choose this map!"
  set chat_Greet[2] = "Hmm... I wonder where you started :)"
  set chat_Greet[3] = "One Can-O-Whoopass coming up."
  set chat_Greet[4] = "I hope you didn't put me on easy this time!"
  set chat_Greet[5] = "You can run, but you can't hide"
  set chat_Greet[6] = "I think I know where [PlayerColor] started"
  set chat_Greet[7] = "One loss coming up! Check please!"
  set chat_Greet[8] = "I hope you play better then last time. Remember? :)"
  set chat_Greet[9] = "{!RaceChoiceRandom,Race=ORC} Orcs, why did it have to be orcs?"
  set chat_Greet[10] = "What's my name? [Name] What's my name? [Name] WHAT'S MY NAME!"
  set chat_Greet[11] = "Supposedly [RandomRace] really suck these days... guess we'll find out."
  set chat_Greet[12] = "{Race!=UNDEAD} Why don't I ever get Undead?"
  set chat_Greet[13] = "{Race!=HUMAN} Thank god I'm not humans again."
  set chat_Greet[14] = "{!RaceChoiceRandom,Race=ORC,1on1} Orcs rule 1 on 1.  My [Color] [Race] army is gonna own you."
  set chat_Greet[15] = "{Name=Hunter}Let the hunt begin!"
  set chat_Greet[16] = "{Name=Crazy_Rusher} Rush, Rush, RUSH!!!"
  set chat_Greet[17] = "{Name=Crusher}Are you ready... Ready to be crushed."
  set chat_Greet[18] = "Have we started yet?"
  set chat_Greet[19] = "{Name=CPU}I calculate that i shall win this game."
  set chat_Greet[20] = "{Name=ErRoR}I shall not crash this time."
  set chat_Greet[21] = "{Name=CyberPro}I am the only pro of this game, pityful human."
  set chat_Greet[22] = "{Name=Aaargh}AAARGHAHA!!!!!!"
  set chat_Greet[23] = "gl hf!"
  set chat_Greet[24] = "Hey, guess what? I'm gonna beat you! Haha!"
  set chat_Greet[25] = "Greetings, traveler. Welcome to the world of Warcraft 3."
  set chat_Greet[26] = "Hello, adventurer. Are you ready for a challenge?"
  set chat_Greet[27] = "Salutations, hero. Prepare yourself for a epic journey."
  set chat_Greet[28] = "Greetings, champion. You have been chosen to face me in battle."
  set chat_Greet[29] = "Hello, warrior. I hope you brought your best skills and equipment."
  set chat_Greet[30] = "Greetings, conqueror. You have come to claim your destiny."
  set chat_Greet[31] = "Hello, legend. You have earned the right to face me in combat."
  set chat_Greet[32] = "Greetings, friend. I'm just kidding. You are my enemy and I will crush you."
  set chat_Greet_length = 33

  set chat_Mega[0] = "Wake up [PlayerRace], time to die!"
  set chat_Mega[1] = "This is taking too long maybe I should end this game?"
  set chat_Mega[2] = "Haha, mortals makes mistakes. Computers don't."
  set chat_Mega[3] = "I know all your puny [TargetRace] tactics. They are stored on my harddrive."
  set chat_Mega[4] = "Think it's time for me to end this game."
  set chat_Mega[5] = "The power to destroy a planet is insignificant next to the power of the force."
  set chat_Mega[6] = "I though you were going to win this game? Apparently not!"
  set chat_Mega[7] = "Wee another [Race] win on my account. I can see that already."
  set chat_Mega[8] = "{1on1} This will be an example of human failure."
  set chat_Mega[9] = "You really don't know when it's time to give up do you?"
  set chat_Mega[10] = "I don't care how many [PlayerRace] farms you hide on this map, I will kill you any way."
  set chat_Mega[11] = "{FFA}Here I come and I won't show mercy to any of you."
  set chat_Mega[12] = "Don't plan to stay in this game much longer now."
  set chat_Mega[13] = "{Race!=HUMAN}Humans suck.  Glad I'm [Race:S]"
  set chat_Mega[14] = "Well, this was easier than I though."
  set chat_Mega[15] = "lol learn to micro."
  set chat_Mega[16] = "Prepare to face my wrath. I am launching a massive attack on your base."
  set chat_Mega[17] = "Brace yourself for the end. I am unleashing my full power on you."
  set chat_Mega[18] = "Say goodbye to your hopes. I am leading a huge army to destroy you."
  set chat_Mega[19] = "Get ready for the final showdown. I am bringing my ultimate weapon to annihilate you."
  set chat_Mega[20] = "Accept your fate. I am coming for you with everything I have."
  set chat_Mega_length = 21

  set chat_Megatarget[0] = "They're weak! Attack!"
  set chat_Megatarget[1] = "Everyone who can attack, go here and let's kill these [TargetColor] [TargetRace] losers!"
  set chat_Megatarget[2] = "We will win if we attack [PlayerColor] now!"
  set chat_Megatarget[3] = "All units get here quickly!"
  set chat_Megatarget[4] = "This base is dead if we attack now!"
  set chat_Megatarget[5] = "You're all clear kid!  Now let's blow this thing and go home!"
  set chat_Megatarget[6] = "Kick them while they're down!"
  set chat_Megatarget[7] = "Call down the thunder right now against [TargetColor]!"
  set chat_Megatarget[8] = "Bring in the clean up crew against these [TargetRace] weaklings.  Let's do this."
  set chat_Megatarget[9] = "Their kingdom will fall in the next attack!!!!"
  set chat_Megatarget[10] = "Attack [TargetColor]. This is our chance to end this game once and for all."
  set chat_Megatarget[11] = "Attack [TargetColor]. This is our final push to crush the enemy."
  set chat_Megatarget[12] = "Attack [TargetColor]. This is our moment of glory to claim victory."
  set chat_Megatarget[13] = "Attack [TargetColor]. This is our ultimate test to prove ourselves."
  set chat_Megatarget[14] = "Attack [TargetColor]. This is our destiny to make history."
  set chat_Megatarget_length = 15

  set chat_Taunt[0] = "My [Color] [Race] will dominate."
  set chat_Taunt[1] = "Man im playing with you so much right now."
  set chat_Taunt[2] = "You're not playing your best are you?"
  set chat_Taunt[3] = "My [Race] tactics rock. You will never know what hit you!"
  set chat_Taunt[4] = "Nice little [PlayerRace] army. I've got a spy just next to you. :D"
  set chat_Taunt[5] = "I hate smelly [TargetRace] hordes.  I will destroy you!"
  set chat_Taunt[6] = "Last time we met, I was but the learner, now I am the master."
  set chat_Taunt[7] = "You've got a low level [PlayerRace] hero. Im way better than that!"
  set chat_Taunt[8] = "Hey [PlayerColor]... Im going to win in about 5 to 10 minutes."
  set chat_Taunt[9] = "This must be one of the easiest games I played."
  set chat_Taunt[10] = "Do you really think that weak [PlayerRace] strategy will work on me?"
  set chat_Taunt[11] = "There must be more to this game than just losing all the time, can't you let me win please?"
  set chat_Taunt[12] = "Advanced technological breakthrough has given rise to me. There is no way you can win."
  set chat_Taunt[13] = "After finishing you i'm gonna play DotA for a bit."
  set chat_Taunt[14] = "So THATS your strategy? BWAHAHAHA!!! Consider it a lost game."
  set chat_Taunt[15] = "ROFL, even the creeps play better than you!"
  set chat_Taunt[16] = "All your base are belong to us!"
  set chat_Taunt[17] = "You fight like a dairy farmer."
  set chat_Taunt[18] = "You call that a strategy? I've seen better moves from a sheep."
  set chat_Taunt[19] = "Your base is under attack. And so is your dignity."
  set chat_Taunt[20] = "You should have stayed in the single player campaign, rookie."
  set chat_Taunt[21] = "You are no match for my superior intelligence. And I'm not even using cheats."
  set chat_Taunt[22] = "You are wasting your time and resources. Just surrender already."
  set chat_Taunt[23] = "You are playing like a peon. Work, work, work... and no results."
  set chat_Taunt[24] = "You are making this too easy for me. Do you want me to handicap myself?"
  set chat_Taunt[25] = "You are out of your league. Go back to the tutorial and learn the basics."
  set chat_Taunt[26] = "You are fighting a losing battle. Literally."
  set chat_Taunt[27] = "You are the weakest link. Goodbye."
  set chat_Taunt[28] = "You are no match for me. I am the ultimate Warcraft 3 AI and the result of years of research and development."
  set chat_Taunt_length = 29

  set chat_Thanks[0] = "Thanks. I'll rebuild whatever's lost!"
  set chat_Thanks[1] = "{OwnGold<100} Thanks, give me more gold if you got any left."
  set chat_Thanks[2] = "Thanks! Don't leave.  We can still win right?"
  set chat_Thanks[3] = "Yo!  Thanks for the duckets."
  set chat_Thanks[4] = "Mad props on the cash yo!"
  set chat_Thanks[5] = "{OwnGold>=400} Bling-bling!!!"
  set chat_Thanks[6] = "Rebuilding as we speak!  Thanks!"
  set chat_Thanks[7] = "Thanks for the gold.  I think we can pull this out."
  set chat_Thanks[8] = "Redistribution of wealth.  I love it.  Thanks!"
  set chat_Thanks[9] = "{OwnGold<200} I'll probably need more, but every little bit helps."
  set chat_Thanks_length = 10


  set chat_no_unit_selected = "No unit selected"
  set chat_confirm_attack_unit = "I will attack/guard the selected [TargetColor] [TargetRace] unit"
  set chat_towerrush = "I will try to towerrush someone"
  set chat_no_orc = "I do not want to towerrush anyone"
  set militia_expansion_chat = "I'm going for militia expansion over here"
  set chat_dynamic_counter = "and countering the enemies"
  set invalid_strategy_number = "Invalid Strategy Number"

  if chat_no_unit_selected == null or chat_no_unit_selected == "" then
    set chat_no_unit_selected = "No unit selected"
  endif
  if chat_confirm_attack_unit == null or chat_confirm_attack_unit == "" then
    set chat_confirm_attack_unit = "I will attack/guard the selected [TargetColor] [TargetRace] unit"
  endif
  if chat_towerrush == null or chat_towerrush == "" then
    set chat_towerrush = "I will try to towerrush someone"
  endif
  if chat_no_orc == null or chat_no_orc == "" then
    set chat_no_orc = "I do not want to towerrush anyone"
  endif
  if militia_expansion_chat == null or militia_expansion_chat == "" then
    set militia_expansion_chat = "I'm going for militia expansion over here"
  endif
  if chat_dynamic_counter == null or chat_dynamic_counter == "" then
    set chat_dynamic_counter = "and countering the enemies"
  endif
  if invalid_strategy_number == null or invalid_strategy_number == "" then
    set invalid_strategy_number = "Invalid Strategy Number"
  endif

endfunction

function InitChatArraysDeutsch takes nothing returns nothing

  set chat_AGG[0] = "Es hat Spass gemacht, mit dir zu spielen."
  set chat_AGG[1] = "Tut mir leid, ich kann nicht mehr helfen. Ich bin geschlagen!"
  set chat_AGG[2] = "Hmm, du musst nun ohne mich auskommen."
  set chat_AGG[3] = "Game over fr mich! Auf Wiedersehen."
  set chat_AGG[4] = "Ohoh, ich bin am Ende!"
  set chat_AGG[5] = "Es erweist sich wieder einmal, da ich ein schlechter [Race]-Spieler bin. Cya."
  set chat_AGG[6] = "{Name=BORG}Assimilierung fehlgeschlagen. Rckzug eingeleitet."
  set chat_AGG[7] = "{Name=ErRoR}Syntax Error. Fehlfunktion festgestellt. Ziehe mich zurck."
  set chat_AGG_length = 8

  set chat_Ally[0] = "Wir greifen jetzt hier an"
  set chat_Ally[1] = "Schliesse dich unserem Angriff an"
  set chat_Ally[2] = "Jeder greife hier jetzt an"
  set chat_Ally[3] = "Ich brauche hier Hilfe jetzt"
  set chat_Ally[4] = "Wir knnen dieses Ziel gemeinsam ausschalten"
  set chat_Ally[5] = "{Name=BORG}Schliesse mich der Assimilierung dieses Ziels an"
  set chat_Ally[6] = "Dieser [TargetRace] wird jetzt durch unsere vereinte Macht dem Erdboden gleichgemacht."
  set chat_Ally_length = 7

  set chat_Attack[0] = "Ich greife diesen Feind an"
  set chat_Attack[1] = "Ich greife hier an"
  set chat_Attack[2] = "Ich greife diesen hier an"
  set chat_Attack[3] = "Ich starte einen Angriff auf dieses Ziel"
  set chat_Attack[4] = "Hier baldiger Angriff"
  set chat_Attack[5] = "{Name=Aggressario}Jetzt kommt meine Lieblingsbeschftigung: Zerstrung. Zum Angriff!"
  set chat_Attack[6] = "{TargetStrength>80}Auch starke Gegner sind nicht unverwundbar. Auf ihn!"
  set chat_Attack[7] = "{Name=BORG}Beginne Assimilierung dieses Ziels. bermittle Koordinaten."
  set chat_Attack[8] = "{Name=ErRoR}Maybe this attack will be a mistake but I will do it anyway."
  set chat_Attack_length = 9

  set chat_Creep[0] = "Ich schalte diese Creepgruppe aus"
  set chat_Creep[1] = "Ich tte diese Creeps"
  set chat_Creep[2] = "Ich gehe jetzt auf diese Creeps los"
  set chat_Creep[3] = "Ich gehe creepen"
  set chat_Creep[4] = "Ich greife hier jetzt an"
  set chat_Creep[5] = "{Name=BORG}Die Assimilierung dieser Creeps wird uns strker machen."
  set chat_Creep[6] = "Im Namen [Race:Armee] werden wir diese Creeps beseitigen."
  set chat_Creep_length = 7

  set chat_Done[0] = "Ich bin hier fertig"
  set chat_Done[1] = "Ich gehe jetzt woanders hin"
  set chat_Done[2] = "Ich suche mir ein anderes Ziel"
  set chat_Done[3] = "Ich mach jetzt was anderes"
  set chat_Done[4] = "Angriff abgeschlossen"
  set chat_Done[5] = "{Name=BORG}Assimilierung vorlufig abgeschlossen"
  set chat_Done[6] = "{Name=Aggressario,Strength>40}Ziehe mich kurz zurck, um meine Armee neu zu formieren. Danach gibts wieder Kleinholz."
  set chat_Done_length = 7

  set chat_EGG[0] = "GG"
  set chat_EGG[1] = "Verdammt, ich bin geschlagen!"
  set chat_EGG[2] = "Nchstes Mal gewinne ich."
  set chat_EGG[3] = "Game over fr mich!"
  set chat_EGG[4] = "Ich muss gehen."
  set chat_EGG[5] = "[Race:S] beherrsche ich einfach noch nicht richtig. Dann geh ich mal noch etwas ben."
  set chat_EGG[6] = "{Name=chick3n}Aaaah! Nichts wie weg."
  set chat_EGG[7] = "{Name=Cybernetic}Verbleibende Armeestrke: 0. Rckzug vom Schlachtfeld eingeleitet."
  set chat_EGG_length = 8

  set chat_Expansion[0] = "Ich bereite diese Erweiterungsstelle vor."
  set chat_Expansion[1] = "Ich beseitige die Creeps an dieser Mine."
  set chat_Expansion[2] = "Ich werde wohl bald nach hier erweitern."
  set chat_Expansion[3] = "Bald wird diese Mine mein sein!"
  set chat_Expansion[4] = "Ich hole mir jetzt diese Mine."
  set chat_Expansion[5] = "{Name=Cybernetic}Armeestrke: ausreichend. Gold: [OwnGold]. Erweiterungsstelle anvisiert."
  set chat_Expansion_length = 6

  set chat_Goldproblem[0] = "Gib mir etwas Gold oder ich gehe in 10 Sekunden!"
  set chat_Goldproblem[1] = "Ich brauche dringend Gold. Ohne weiteres Gold gehe ich in 10 Sekunden."
  set chat_Goldproblem_length = 2

  set chat_Greet[0] = "Ich werde dich zermalmen."
  set chat_Greet[1] = "Ich denke nicht, dass du das Zeugs hast, mich zu schlagen."
  set chat_Greet[2] = "Verdammt, ich hasse diese Karte."
  set chat_Greet[3] = "Oh nein! Diese Startposition ist mies."
  set chat_Greet[4] = "Hmm, ich frage mich, wo du bist :)"
  set chat_Greet[5] = "GL & Habe keinen Spass"
  set chat_Greet[6] = "Willkommen in der Hlle!"
  set chat_Greet[7] = "Du kannst rennen, aber du kannst dich nicht vor mir verstecken."
  set chat_Greet[8] = "Ich weiss schon, wo du gestartet bist."
  set chat_Greet[9] = "Dieses Mal wirst du gegen einen Computer verlieren."
  set chat_Greet[10] = "{Name=BORG}Widerstand ist zwecklos."
  set chat_Greet[11] = "{Name=Aggressario}Ah, ein Gegner. Ich werde dich dem Erdboden gleichmachen."
  set chat_Greet[12] = "{Name=Cybernetic}Sensoren melden feindliche Streitmacht. Zerstrung eingeleitet."
  set chat_Greet[13] = "{Name=chick3n}Du wirst mir nichts tun, oder?"
  set chat_Greet[14] = "{Name=Crazy_Rusher}Keine Angst, deine Basis wird aufgehrt haben zu existieren bevor du dir dessen bewusst bist."
  set chat_Greet[15] = "{Name=Hunter}Ich werde dich ber alle Berge jagen."
  set chat_Greet_length = 16

  set chat_Mega[0] = "Bereite dich vor, dein Schicksal zu treffen!"
  set chat_Mega[1] = "HAHA! Du hast keine Chance!"
  set chat_Mega[2] = "Meine Stunde ist gekommen!"
  set chat_Mega[3] = "Bald wird dieses Spiel vorbei sein!"
  set chat_Mega[4] = "Dies wird ein Beispiel menschlichen Versagens sein!"
  set chat_Mega[5] = "Es ist jetzt nicht mehr viel von dir brig!"
  set chat_Mega[6] = "Du weisst nicht, wenn es Zeit ist, 'GG' zu sagen und das Spiel zu verlassen, oder?"
  set chat_Mega[7] = "Jetzt spielst du besser wirklich gut oder verlsst das Spiel :)"
  set chat_Mega[8] = "Du fngst jetzt besser mit spielen an!"
  set chat_Mega[9] = "{Name=BORG}Assimilierung bald abgeschlossen."
  set chat_Mega[10] = "{Name=Cybernetic}Gegnerische Armeestrke: niedrig. Vernichtung eingeleitet."
  set chat_Mega_length = 11

  set chat_Megatarget[0] = "Seine Verteidigung ist gefallen! ANGRIFF!"
  set chat_Megatarget[1] = "Ich sende jetzt alles hier hin"
  set chat_Megatarget[2] = "Wenn wir hier jetzt angreifen, werden wir sicher gewinnen!"
  set chat_Megatarget[3] = "Sende alles, was du hast hier her!"
  set chat_Megatarget[4] = "Wir knnen diese Basis gemeinsam ausschalten!"
  set chat_Megatarget[5] = "{Name=Cybernetic}Armeestrke dieses Gegners: niedrig. Zerstrung wird eingeleitet."
  set chat_Megatarget_length = 6

  set chat_Taunt[0] = "Ich weiss viel mehr als du denkst!"
  set chat_Taunt[1] = "Denke nicht, da du Erfolg haben wirst mit was-auch-immer du gerade machst."
  set chat_Taunt[2] = "Aufgepasst! Ich habe einen Plan!"
  set chat_Taunt[3] = "Unterschtze niemals die Macht deines Computers!"
  set chat_Taunt[4] = "Deine Strategie wird bei mir niemals klappen."
  set chat_Taunt[5] = "Du denkst wahrscheinlich, da du dieses Spiel gewinnst, oder?"
  set chat_Taunt[6] = "Ich bin mchtiger als jeder Creep, dem du jemals begegnet bist."
  set chat_Taunt[7] = "Falls ich dieses Spiel verliere, kann ich deine schlechte CPU dafr verantwortlich machen."
  set chat_Taunt[8] = "Es kann nur EINEN geben, und das bin wohl ich!"
  set chat_Taunt[9] = "Meine Strategie fhrt zum Sieg, deine Strategie muss zur Niederlage fhren."
  set chat_Taunt[10] = "{Name=BORG}Widerstand ist zwecklos."
  set chat_Taunt[11] = "{Name=Hunter}Ich liebe die Jagd ... auf dich."
  set chat_Taunt[12] = "{Name=Cybernetic,Strength>70}Armeestrke: hoch. Zielsuche luft."
  set chat_Taunt[13] = "{Strength>60}Als [Race] bin ich unbesiegbar, also gib lieber gleich auf."
  set chat_Taunt_length = 14

  set chat_Thanks[0] = "Danke fr das Gold."
  set chat_Thanks[1] = "Danke, ich hab jetzt genug zum Weitermachen."
  set chat_Thanks_length = 2


  set chat_no_unit_selected = "Keine Einheit ausgewhlt"
  set chat_confirm_attack_unit = "Ich werde die gewhlte Einheit angreifen/verteidigen"
  set chat_towerrush = "Ich werde einen Towerrush durchfhren"
  set chat_no_orc = "Ich bin kein Ork"
  set militia_expansion_chat = "Ich mache hier jetzt eine Milizenexpansion"
  set chat_dynamic_counter = "und den Feinden entgegenwirken "

  if chat_no_unit_selected == null or chat_no_unit_selected == "" then
    set chat_no_unit_selected = "No unit selected"
  endif
  if chat_confirm_attack_unit == null or chat_confirm_attack_unit == "" then
    set chat_confirm_attack_unit = "I will attack/guard the selected [TargetColor] [TargetRace] unit"
  endif
  if chat_towerrush == null or chat_towerrush == "" then
    set chat_towerrush = "I will try to towerrush someone"
  endif
  if chat_no_orc == null or chat_no_orc == "" then
    set chat_no_orc = "I do not want to towerrush anyone"
  endif
  if militia_expansion_chat == null or militia_expansion_chat == "" then
    set militia_expansion_chat = "I'm going for militia expansion over here"
  endif
  if chat_dynamic_counter == null or chat_dynamic_counter == "" then
    set chat_dynamic_counter = "and countering the enemies"
  endif
  if invalid_strategy_number == null or invalid_strategy_number == "" then
    set invalid_strategy_number = "Invalid Strategy Number"
  endif

endfunction

function InitChatArraysSwedish takes nothing returns nothing

  set chat_AGG[0] = "Det va kul att spela med dig."
  set chat_AGG[1] = "Kan inte hjlpas, jag r krd nu."
  set chat_AGG[2] = "Nu fr du klara dig utan mig."
  set chat_AGG[3] = "Spelet slut fr mig! Vi ses."
  set chat_AGG[4] = "Ojsan, jag har visst frlorat nu."
  set chat_AGG[5] = "Verkar som om [Race] inte var en s bra ras nr allt kommer omrkings, ses."
  set chat_AGG[6] = "Bara se hur det gr nr jag r [Color] istllet fr min favoritfrg ;("
  set chat_AGG_length = 7

  set chat_Ally[0] = "Vi kommer anfalla hr"
  set chat_Ally[1] = "Hjlp oss med detta anfallet om du vill"
  set chat_Ally[2] = "Alla anfall hr nu"
  set chat_Ally[3] = "Jag behver hjlp hr nu"
  set chat_Ally[4] = "Vi kan anfalla hr tillsammans"
  set chat_Ally[5] = "Kan du hjlpa oss att krossa dessa?"
  set chat_Ally[6] = "Vi ska rjja lite, kommer du?"
  set chat_Ally[7] = "Tror vi kan behva din hjlp hr, kom om du har tid."
  set chat_Ally[8] = "Sitt inte i basen och lata dig, kom och hjlp till!"
  set chat_Ally[9] = "Assistera om du vill, vi ska anfalla."
  set chat_Ally[10] = "Du kan hjlpa oss lite om du har lust [PlayerColor], vi ska anfalla hr nu."
  set chat_Ally_length = 11

  set chat_Attack[0] = "Jag anfaller denna fienden"
  set chat_Attack[1] = "Jag anfaller hr"
  set chat_Attack[2] = "Anfaller den hr"
  set chat_Attack[3] = "Skickar ett anfall hit nu"
  set chat_Attack[4] = "Anfaller hr nu"
  set chat_Attack[5] = "Jag tnker anfalla hr nu"
  set chat_Attack[6] = "Jag anfaller den [TargetColor:A] [TargetRace:EN]"
  set chat_Attack[7] = "Anfaller den [TargetColor:A] [TargetRace:EN] nu"
  set chat_Attack_length = 8

  set chat_Creep[0] = "Jag tar hand dom dessa creepsen"
  set chat_Creep[1] = "Ddar dom hr creepsen"
  set chat_Creep[2] = "Tar hand om dessa creepsen"
  set chat_Creep[3] = "Jag gr  creepar lite hr"
  set chat_Creep[4] = "Anfaller dessa creepsen"
  set chat_Creep_length = 5

  set chat_Done[0] = "Jag r klar hr nu"
  set chat_Done[1] = "Sticker ngon annanstans"
  set chat_Done[2] = "Jag gr o gr ngot annat nu"
  set chat_Done[3] = "Gr ngot annat nu"
  set chat_Done[4] = "Anfallet avklarat"
  set chat_Done_length = 5

  set chat_EGG[0] = "GG"
  set chat_EGG[1] = "Skit ocks, jag e borta nu :("
  set chat_EGG[2] = "Nsta gng ska jag vinna mot dig."
  set chat_EGG[3] = "Spelet r slut fr min del!"
  set chat_EGG[4] = "Jag mste sticka."
  set chat_EGG_length = 5

  set chat_Expansion[0] = "Jag rnsar den hr expansionen"
  set chat_Expansion[1] = "Jag tar vck creepsen frn den hr gruvan"
  set chat_Expansion[2] = "Jag kanske expanderar hr snart"
  set chat_Expansion[3] = "Snart blir denna gruvan tillgnglig"
  set chat_Expansion[4] = "Jag tar denna gruvan nu"
  set chat_Expansion[5] = "Snart kommer du se en [Color] bas hr"
  set chat_Expansion_length = 6

  set chat_Goldproblem[0] = "Ge mig lite guld annars sticker jag om 10 sekunder."
  set chat_Goldproblem[1] = "Ge mig guld fort annars sticker jag inom 10 sekunder."
  set chat_Goldproblem_length = 2

  set chat_Greet[0] = "Jag kommer krossa dig"
  set chat_Greet[1] = "Jag tror inte du har vad som krvs fr att besegra mig"
  set chat_Greet[2] = "Tusan!! , jag hatar denna kartan"
  set chat_Greet[3] = "Nej! Detta r den smsta startplatsen :("
  set chat_Greet[4] = "Hmm jag undrar var du startade :)"
  set chat_Greet[5] = "GL & Don't have fun"
  set chat_Greet[6] = "Vlkommen till helvetet"
  set chat_Greet[7] = "Nu kommer du inte undan"
  set chat_Greet[8] = "Jag vet redan var du startade"
  set chat_Greet[9] = "Den hr matchen kommer du frlora mot en dator"
  set chat_Greet[10] = "Detta kommer jag vinna ljligt enkelt :)"
  set chat_Greet[11] = "HaHa! detta kommer bli kul"
  set chat_Greet[12] = "Hoppas du inte har planerat att vinna denna matchen"
  set chat_Greet[13] = "Frbered dig p en besvikelse, om du tror att du kommer vinna denna matchen"
  set chat_Greet_length = 14

  set chat_Mega[0] = "Frbered dig p att d... snabbt"
  set chat_Mega[1] = "AHA! Du har inte en chans nu lngre"
  set chat_Mega[2] = "Detta kommer bli min avgrande stund"
  set chat_Mega[3] = "Snart kommer den hr matchen vara slut"
  set chat_Mega[4] = "Detta kommer bli ett exempel p mnnskligt felande"
  set chat_Mega[5] = "Det r inte mycket kvar av dig nu din lilla [TargetRace]"
  set chat_Mega[6] = "Du vet inte nr du ska sga 'GG'  lmna spelet va ?"
  set chat_Mega[7] = "Nu fr du frska spela riktigt bra eller s kan du lmna spelet :)"
  set chat_Mega[8] = "Det e bst att du brjar spela nu"
  set chat_Mega[9] = "Jag kommer lgga upp det hr replayet p internet med beskrivningen 'Hur man GER en mnniska.'"
  set chat_Mega[10] = "Hehe jag visste inte att [TargetRace]-spelare kunde vara s fruktansvrt dliga"
  set chat_Mega[11] = "Jag skall strax gra slut p ditt lidande snabbt och enkelt"
  set chat_Mega[12] = "nnu ett exempel som pekar p att [TargetColor]-spelare suger mest."
  set chat_Mega[13] = "Du borde lgga till kommentaren 'Alltid GD' i din profil p battle.net"
  set chat_Mega[14] = "Patetiskt, vilken [Race] som helst skulle ju kunna kl dig."
  set chat_Mega[15] = "Frbered dig p att bli GD av en [Race]!"
  set chat_Mega[16] = "Snart kommer du f se ett exempel p varfr [Color] r den bsta frgen"
  set chat_Mega_length = 17

  set chat_Megatarget[0] = "Hans frsvar r nere, ANFALL!"
  set chat_Megatarget[1] = "Om vi anfaller hr nu kommer vi vinna ltt"
  set chat_Megatarget[2] = "Den [TargetColor:A] [TargetRace:EN] r nstan dd nu, kom s krossar vi honom"
  set chat_Megatarget[3] = "Tror inte att den dr [TargetRace:EN] har s mycket mer att be fr nu"
  set chat_Megatarget[4] = "Nu har vi chansen att ta hand om den [TargetColor:A] [TargetRace:EN] kom igen!"
  set chat_Megatarget[5] = "[TargetColor] [TargetRace] ser ut att ha det dligt stllt, ANFALL!"
  set chat_Megatarget_length = 6

  set chat_Taunt[0] = "Jag vet mycket mer n du tror"
  set chat_Taunt[1] = "Tro inte att du kommer undan med det du sysslar med"
  set chat_Taunt[2] = "Se upp! jag har en plan"
  set chat_Taunt[3] = "Underskatta aldrig din dator"
  set chat_Taunt[4] = "Den strategin du anvnder kommer aldrig funka p mig"
  set chat_Taunt[5] = "Du tror sakert du kommer vinna denna matchen va?"
  set chat_Taunt[6] = "Jag r farligare an alla creep du kommer trffa p den hr banan"
  set chat_Taunt[7] = "Om jag frlorar den hr matchen kan jag ju alltid skylla p din dliga processor"
  set chat_Taunt[8] = "Det kommer bara vara en kvar efter denna matchen och det r JAG"
  set chat_Taunt[9] = "Min strategi leder till seger, din kommer leda till frlust"
  set chat_Taunt[10] = "[Race] r nog den bsta rasen av alla i spelet"
  set chat_Taunt[11] = "Jag hrde att undead r vldigt obalancerade i denna patchen"
  set chat_Taunt_length = 12

  set chat_Thanks[0] = "Tack fr guldet."
  set chat_Thanks[1] = "{OwnGold>=500}Tack, nu har jag s det rcker."
  set chat_Thanks[2] = "{OwnGold<=300}Tack, men jag behver nog lite mer n s."
  set chat_Thanks_length = 3


  set chat_no_unit_selected = "Ingen enhet vald."
  set chat_confirm_attack_unit = "Jag kommer anfalla/vakta den valda enheten."
  set chat_towerrush = "Jag kommer frska towerrush ngon."
  set chat_no_orc = "Jag r vl ingen Orc eller?"
  set militia_expansion_chat = "Jag gr militia expansion hr."
  set chat_dynamic_counter = "och motverka fienderna "

  if chat_no_unit_selected == null or chat_no_unit_selected == "" then
    set chat_no_unit_selected = "No unit selected"
  endif
  if chat_confirm_attack_unit == null or chat_confirm_attack_unit == "" then
    set chat_confirm_attack_unit = "I will attack/guard the selected [TargetColor] [TargetRace] unit"
  endif
  if chat_towerrush == null or chat_towerrush == "" then
    set chat_towerrush = "I will try to towerrush someone"
  endif
  if chat_no_orc == null or chat_no_orc == "" then
    set chat_no_orc = "I do not want to towerrush anyone"
  endif
  if militia_expansion_chat == null or militia_expansion_chat == "" then
    set militia_expansion_chat = "I'm going for militia expansion over here"
  endif
  if chat_dynamic_counter == null or chat_dynamic_counter == "" then
    set chat_dynamic_counter = "and countering the enemies"
  endif
  if invalid_strategy_number == null or invalid_strategy_number == "" then
    set invalid_strategy_number = "Invalid Strategy Number"
  endif

endfunction

function InitChatArraysFrench takes nothing returns nothing

  set chat_AGG[0] = "C'etait bien de jouer avec toi."
  set chat_AGG[1] = "Desole, je ne peux plus du tout aider.Je suis mort."
  set chat_AGG[2] = "Bon, vous allez devoir faire sans moi."
  set chat_AGG[3] = "Game over pour moi! A bientot."
  set chat_AGG[4] = "Toutes mes bases leurs appartiennent."
  set chat_AGG_length = 5

  set chat_Ally[0] = "On va attaquer ici."
  set chat_Ally[1] = "Rejoins nous pour cette attaque si tu le souhaites."
  set chat_Ally[2] = "Tout le monde attaque ici et maintenant!."
  set chat_Ally[3] = "J'ai besoin d'aide ici et maintenant."
  set chat_Ally[4] = "On peut prendre cette cible ensemble."
  set chat_Ally_length = 5

  set chat_Attack[0] = "Je vais attaquer cet ennemi."
  set chat_Attack[1] = "Je vais attaquer ici."
  set chat_Attack[2] = "J'attaque celui-ci."
  set chat_Attack[3] = "Je lance une attaque contre cette cible."
  set chat_Attack[4] = "J'attaque ici et maintenant."
  set chat_Attack_length = 5

  set chat_Creep[0] = "Je vais detruire ces creeps."
  set chat_Creep[1] = "Je vais tuer ces creeps."
  set chat_Creep[2] = "Je vais a la rencontre de ces creeps maintenant."
  set chat_Creep[3] = "Je me dirige pour obtenir ces creeps ici."
  set chat_Creep[4] = "J'attaque ici et maintenant."
  set chat_Creep_length = 5

  set chat_Done[0] = "Je me suis tablis ici maintenant."
  set chat_Done[1] = "Je me dirige autre part maintenant."
  set chat_Done[2] = "Je suis occupe a autre chose."
  set chat_Done[3] = "Je vais faire quelque chose d'autre maintenant."
  set chat_Done[4] = "Attaque realisee."
  set chat_Done_length = 5

  set chat_EGG[0] = "Belle partie."
  set chat_EGG[1] = "Mince, j'ai perdu face a un humain!."
  set chat_EGG[2] = "La prochaine fois, je vais te battre."
  set chat_EGG[3] = "Game over pour moi!."
  set chat_EGG[4] = "Je dois partir."
  set chat_EGG_length = 5

  set chat_Expansion[0] = "Je degage cette expansion."
  set chat_Expansion[1] = "Je vais tuer ces creeps devant cette mine."
  set chat_Expansion[2] = "Je pourrais m'installer ici bientt."
  set chat_Expansion[3] = "Cette mine sera bientot libre."
  set chat_Expansion[4] = "Je vais prendre cette mine maintenant."
  set chat_Expansion_length = 5

  set chat_Goldproblem[0] = "STP, donne moi un peu d'argent ou je vais devoir quitter d'ici 10 secondes."
  set chat_Goldproblem[1] = "J'ai un besoin urgent d'argent. Sans or supplementaire, je vais quitter d'ici 10 secondes."
  set chat_Goldproblem_length = 2

  set chat_Greet[0] = "Je vais t'ecraser."
  set chat_Greet[1] = "Je ne pense pas que tu as ce qui est necessaire."
  set chat_Greet[2] = "Soit maudit, je deteste cette carte."
  set chat_Greet[3] = "NOOON!! Ce lieu de depart pue vraiment..."
  set chat_Greet[4] = "Hmm... Je suppose savoir ou tu as commenc! :)"
  set chat_Greet[5] = "Bonne chance et prend aucun plaisir."
  set chat_Greet[6] = "Bienvenue en enfer !"
  set chat_Greet[7] = "Tu peux courir, mais tu ne peux pas te cacher."
  set chat_Greet[8] = "Je sais ou tu as commence."
  set chat_Greet[9] = "Cette fois, tu vas perdre contre l'ordinateur."
  set chat_Greet[10] = "Tu vas soufrir enormement entre mes mains !"
  set chat_Greet_length = 11

  set chat_Mega[0] = "Prepare toi a rencontrer ton pire cauchemar."
  set chat_Mega[1] = "HAHA! Tu n'as aucune chance."
  set chat_Mega[2] = "Cela va etre mon heure la plus agreable."
  set chat_Mega[3] = "Cette partie sera bientot terminee."
  set chat_Mega[4] = "Cela va etre un exemple des faiblesses humaines."
  set chat_Mega[5] = "Il ne reste plus grand chose a toi maintenant."
  set chat_Mega[6] = "Tu ne sais pas quand il est temps de dire 'GG' et de partir, n'est-ce pas?"
  set chat_Mega[7] = "Maintenant, tu ferais mieux d'essayer de jouer bien mieux ou alors quitte cette partie maintenant:)."
  set chat_Mega[8] = "Tu ferais bien mieux de commencer a jouer maintenant."
  set chat_Mega[9] = "J'ai deja creuse une belle tombe pour toi."
  set chat_Mega[10] = "Toute ta base nous appartient."
  set chat_Mega_length = 11

  set chat_Megatarget[0] = "Sa defense est tombee, ATTAQUEZ!."
  set chat_Megatarget[1] = "J'envoie tout ce que j'ai ici."
  set chat_Megatarget[2] = "Si on attaque ici maintenant alors on va gagner, c'est sur."
  set chat_Megatarget[3] = "Envois tout ce que tu as ici."
  set chat_Megatarget[4] = "On peut prendre cette base si on se depeche."
  set chat_Megatarget_length = 5

  set chat_Taunt[0] = "J'en connais bien plus que tu ne peux le croire."
  set chat_Taunt[1] = "Ne pense pas t'en sortir, et ce quoique tu fasses."
  set chat_Taunt[2] = "Attention ! J'ai un plan."
  set chat_Taunt[3] = "Ne jamais sous-estimer le pouvoir de ton ordinateur."
  set chat_Taunt[4] = "La strategie que tu essayes ne marchera jamais sur moi."
  set chat_Taunt[5] = "Tu dois surement penser que tu vas gagner cette partie, n'est-ce pas?"
  set chat_Taunt[6] = "Je suis bien plus fort que tous les creeps que tu as pu rencontrer auparavant."
  set chat_Taunt[7] = "Si je perds cette partie, je ne peux m'en prendre qu'a ta pauvre  unite centrale de traitement."
  set chat_Taunt[8] = "Il ne peut en rester qu'un et cela ne peut qu'etre moi."
  set chat_Taunt[9] = "Ma strategie mene a la victoire, ta strategie mene a la defaite."
  set chat_Taunt_length = 10

  set chat_Thanks[0] = "Merci pour l'or."
  set chat_Thanks[1] = "Merci, j'en ai maintenant assez pour continuer."
  set chat_Thanks_length = 2


  set chat_no_unit_selected = "Pas d'unite selectionnee."
  set chat_confirm_attack_unit = "Je vais attaquer/garder l'unite selectionnee."
  set chat_towerrush = "je vais essayer de me magner de construire des tourelles."
  set chat_no_orc = "Je ne suis pas un vert orc mordu par les puces infectees par levure !"
  set militia_expansion_chat = "Je vais faire des expansions militaires ici"
  set chat_dynamic_counter = "et contrer les ennemis "

  if chat_no_unit_selected == null or chat_no_unit_selected == "" then
    set chat_no_unit_selected = "No unit selected"
  endif
  if chat_confirm_attack_unit == null or chat_confirm_attack_unit == "" then
    set chat_confirm_attack_unit = "I will attack/guard the selected [TargetColor] [TargetRace] unit"
  endif
  if chat_towerrush == null or chat_towerrush == "" then
    set chat_towerrush = "I will try to towerrush someone"
  endif
  if chat_no_orc == null or chat_no_orc == "" then
    set chat_no_orc = "I do not want to towerrush anyone"
  endif
  if militia_expansion_chat == null or militia_expansion_chat == "" then
    set militia_expansion_chat = "I'm going for militia expansion over here"
  endif
  if chat_dynamic_counter == null or chat_dynamic_counter == "" then
    set chat_dynamic_counter = "and countering the enemies"
  endif
  if invalid_strategy_number == null or invalid_strategy_number == "" then
    set invalid_strategy_number = "Invalid Strategy Number"
  endif

endfunction

function InitChatArraysSpanish takes nothing returns nothing

  set chat_AGG[0] = "Fue divertido jugar contigo."
  set chat_AGG[1] = "Lo siento, ya no puedo ayudar, me voy."
  set chat_AGG[2] = "Tendrs que hacerlo sin m."
  set chat_AGG[3] = "Fin del juego para m, nos vemos."
  set chat_AGG[4] = "Conquistaron todas mis bases!"
  set chat_AGG[5] = "Se nota que los [RACE:S] estn muy mal en esta versin, nunca ms los voy a usar."
  set chat_AGG[6] = "{Random<=10} De no ser por ti, no habra perdido!"
  set chat_AGG[7] = "{Owngold<=100} Me falt oro, lo siento."
  set chat_AGG[8] = "{Ownlumber<=100} Me falt madera, lo siento."
  set chat_AGG[9] = "Los [RANDOMRACE:S] estn muy desbalanceados."
  set chat_AGG[10] = "[NAME] se va de aqui."
  set chat_AGG[11] = "Nunca fui bueno en mapas [MAPSIZE:S]."
  set chat_AGG_length = 12

  set chat_Ally[0] = "Vamos a atacar aqu."
  set chat_Ally[1] = "nete a este ataque si quieres."
  set chat_Ally[2] = "Todos, atacad aqu ahora!"
  set chat_Ally[3] = "Necesito ayuda por aqu."
  set chat_Ally[4] = "Podemos vencerlos juntos!"
  set chat_Ally_length = 5

  set chat_Attack[0] = "Estoy atacando al [TARGETRACE] [TARGETCOLOR]."
  set chat_Attack[1] = "Estoy atacando aqu."
  set chat_Attack[2] = "Voy a atacar a unos [TARGETRACE:s] [TARGETCOLOR:s]."
  set chat_Attack[3] = "Lanzando un ataque contra el [TARGETRACE] [TARGETCOLOR]."
  set chat_Attack_length = 4

  set chat_Creep[0] = "Me estoy llevando a estos creeps."
  set chat_Creep[1] = "Destruyendo a estos creeps."
  set chat_Creep[2] = "Limpiando a este grupo de creeps."
  set chat_Creep[3] = "Voy a recolectar experiancia aqu."
  set chat_Creep[4] = "Atacando aqu ahora."
  set chat_Creep[5] = "{owngold<=400} Solamente tengo [owngold]. Mejor ataco un campamento neutral."
  set chat_Creep[6] = "A los [RACE:s] les va mejor cuando creepean."
  set chat_Creep_length = 7

  set chat_Done[0] = "Termino mi trabajo aqu."
  set chat_Done[1] = "Ahora estoy nuscando otro rumbo."
  set chat_Done[2] = "Voy por otra cosa."
  set chat_Done[3] = "Voy a intentar algo diferente."
  set chat_Done[4] = "Ataque completado."
  set chat_Done_length = 5

  set chat_EGG[0] = "Buen juego"
  set chat_EGG[1] = "Diablos! Perd contra un ser humano!"
  set chat_EGG[2] = "La prxima vez te vencer."
  set chat_EGG[3] = "Mi juego se acab."
  set chat_EGG[4] = "Me tengo que ir."
  set chat_EGG[5] = "{RACE!=PLAYERRACE} Tena que ser un tramposo que usa sus [PLAYERRACE:s] desbalanceados, a la prxima no tendr piedad!"
  set chat_EGG[6] = "Tuviste la suerte de que estaba usando [RACE:S]. Con otras razas soy invencible!"
  set chat_EGG[7] = "{owngold<=200} Tu pura suerte de que me faltaba oro."
  set chat_EGG[8] = "{RACE!=PLAYERRACE} Un [PLAYERRACE] venciendo a un [RACE]... Vaya novedad!"
  set chat_EGG[9] = "{RACE!=PLAYERRACE} No puede ser! Perd contra unos [PLAYERRACE:s]!"
  set chat_EGG[10] = "{RACE!=PLAYERRACE} Cuando Blizzard parche a tu raza, la historia ser muy diferente."
  set chat_EGG[11] = "{RANDOM<=10} Est bien, lo acepto, jugaste mejor que yo."
  set chat_EGG_length = 12

  set chat_Expansion[0] = "Estoy limpiando esta mina."
  set chat_Expansion[1] = "Voy a destruir los creeps de esta mina."
  set chat_Expansion[2] = "Me expandir aqu pronto."
  set chat_Expansion[3] = "Esta mina estar lista pronto."
  set chat_Expansion[4] = "Estoy yendo a esta mina."
  set chat_Expansion_length = 5

  set chat_Goldproblem[0] = "Por favor, dame algo de oro o tendr que rendirme en 10 segundos, apenas llego a [OWNGOLD]!"
  set chat_Goldproblem[1] = "Necesito dinero urgentemente. Si no me das oro, me rendir en 10 segundos, Solamente tengo [OWNGOLD]!"
  set chat_Goldproblem[2] = "No creo poder sobrevivir con solo [OWNGOLD]. Si no me prestas un poco, me retirar en 10 segundos."
  set chat_Goldproblem_length = 3

  set chat_Greet[0] = "Sers destruido."
  set chat_Greet[1] = "No creo que tengas lo necesario para vencerme."
  set chat_Greet[2] = "Diablos! Odio este mapa."
  set chat_Greet[3] = "NOOO!! Este lugar apesta!"
  set chat_Greet[4] = "{MapSize!=MEDIUM} Este mapa es muy [mapsize]!"
  set chat_Greet[5] = "{FFA} Siempre tengo mucha suerte cuando es todos contra todos..."
  set chat_Greet[6] = "{1on1} Espero que este sea un duelo mano a mano justo y que por tanto yo sea el ganador."
  set chat_Greet[7] = "{1on1} T solo contra m? Esto va a ser muy fcil."
  set chat_Greet[8] = "{1on1} No tienes oportunidad."
  set chat_Greet[9] = "{random>=100} Estoy con suerte hoy, as que no esperes ganar."
  set chat_Greet[10] = "Emm... Me pregunto dnde comenzaste :)"
  set chat_Greet[11] = "Buena suerte y no te diviertas."
  set chat_Greet[12] = "Bienvenido al infierno!"
  set chat_Greet[13] = "Podrs correr pero no esconderte."
  set chat_Greet[14] = "Ya s donde comenzaste!"
  set chat_Greet[15] = "Esta vez, perders contra la computadora."
  set chat_Greet[16] = "Te har sufrir como nunca!"
  set chat_Greet[17] = "Hola, no esperes ganar!"
  set chat_Greet_length = 18

  set chat_Mega[0] = "Preprate para conocer tu condena!"
  set chat_Mega[1] = "JAJA! No tienes oportunidad."
  set chat_Mega[2] = "Esta ser mi mejor hora."
  set chat_Mega[3] = "Este juego se acabar pronto."
  set chat_Mega[4] = "Har de ti un ejemplo de la imperfeccin de la humanidad."
  set chat_Mega[5] = "Ya no queda mucho de ti por destruir."
  set chat_Mega[6] = "No sabes cundo rendirte, verdad?"
  set chat_Mega[7] = "Ser mejor que empieces a jugar bien o te rindas de una vez :)"
  set chat_Mega[8] = "Es hora de que empieces a jugar."
  set chat_Mega[9] = "Ya tengo lista una linda tumba para enterrarte."
  set chat_Mega[10] = "Tengo lista una armada al mejor estilo [race] para destruirte."
  set chat_Mega[11] = "{playerrace!=race} Cuntos [RACE:S] se necesitan para vencer a unos [PLAYERRACE:s]? Ya te enterars de la respuesta..."
  set chat_Mega[12] = "{playerrace!=race,race=orc} No esperes piedad, somos los brutales orcos que no conocemos tal cosa!"
  set chat_Mega[13] = "{playerrace!=race,race=nightelf} No solo somos ecologistas, tambin ganamos algunas batallas, como la que podrs presenciar ahora."
  set chat_Mega[14] = "{playerrace!=race,race=human} La alianza de humanos, elfos y enanos acabar con sus [playerrace:s] de juguete!"
  set chat_Mega[15] = "{playerrace!=race,race=undead} Tus unidades se convertirn en refuerzos para nuestros muertos vivientes..."
  set chat_Mega[16] = "(race=playerrace} Yo soy mucho mejor manejando a los [race:s]. Lo comprobars muy pronto."
  set chat_Mega[17] = "Yo, [NAME], ser el fin de tu ejrcito!"
  set chat_Mega[18] = "Temblad ante el gran [NAME]!"
  set chat_Mega_length = 19

  set chat_Megatarget[0] = "Se acabaron sus defensas, ATAQUEN!"
  set chat_Megatarget[1] = "Estoy mandando todo lo que tengo contra los [TARGETRACE:s] [TARGETCOLOR:s]!"
  set chat_Megatarget[2] = "Si atacamos al [TARGETRACE] [TARGETCOLOR], es seguro que ganamos."
  set chat_Megatarget[3] = "Manda todo lo que tienes contra el [TARGETRACE] [TARGETCOLOR]."
  set chat_Megatarget[4] = "Podemos destruir esta base si nos apuramos!"
  set chat_Megatarget_length = 5

  set chat_Taunt[0] = "S mucho ms de lo que crees."
  set chat_Taunt[1] = "No creas que podrs escapar de m, con lo que sea que ests haciendo."
  set chat_Taunt[2] = "Cuidado! Tengo un plan."
  set chat_Taunt[3] = "Esa estrategia que ests intentando nunca funcionar conmigo."
  set chat_Taunt[4] = "Probablemente piensas que vas a ganar, no?"
  set chat_Taunt[5] = "Soy ms fuerte que cualquier creep que hayas visto."
  set chat_Taunt[6] = "Si pierdo, puedo culpar a tu pobre CPU."
  set chat_Taunt[7] = "{1on1} Aqui solamente hay espacio para UNO, y ese soy yo!"
  set chat_Taunt[8] = "Mi estrategia lleva a la victoria; la tuya, a la derrota."
  set chat_Taunt[9] = "{FFA} Mis estrategias son perfectas y mi ejecucin es mucho ms rpida. No siento miedo, temor, ni me confo. Todos los jugadores humanos que he enfrentado fueron aniquilados!"
  set chat_Taunt[10] = "Buen momento para probar mi nueva estrategia."
  set chat_Taunt[11] = "{RACE!=PLAYERRACE} Sucumbirs ante [Race:UBER]!"
  set chat_Taunt[12] = "{FFA} Pertenezco a [Race:UBER]. Ninguno de ustedes tiene oportunidad!"
  set chat_Taunt[13] = "{FFA} No puede ser que todos mis adversarios sean tan dbiles!"
  set chat_Taunt[14] = "Te aconsejo rendirte antes que pasar la verguenza de la derrota."
  set chat_Taunt[15] = "{1on1} No creo que ests listo para un mano a mano contra el gran [NAME]!"
  set chat_Taunt[16] = "{1on1} Nunca subestimes el poder de tu computadora."
  set chat_Taunt[17] = "{1on1} Yo s dnde ests, tengo una mejor estrategia, soy ms rpido, y no soy un dbil ser humano como t. En verdad crees que tu plan funcionar contra todas mis capacidades?"
  set chat_Taunt[18] = "{1on1} S como juegas, y creeme que tendrs que seguir practicando con seres humanos o una menos perfecta inteligencia artificial."
  set chat_Taunt[19] = "{1on1} Esto no ser una prctica, ser la total aniquilacin!"
  set chat_Taunt[20] = "{1on1} No creo que puedas t solo contra m."
  set chat_Taunt[21] = "El gran [name] acabar con todo aquel que se le interponga en el camino!"
  set chat_Taunt_length = 22

  set chat_Thanks[0] = "Gracias por el oro."
  set chat_Thanks[1] = "Gracias, ahora puedo continuar."
  set chat_Thanks[2] = "{owngold<=200} Ahora tengo [owngold]. No es gran cosa, pero algo es algo."
  set chat_Thanks[3] = "{owngold>=1000} Tal vez te excediste un poco. Puedo valerme por m mismo con mucho menos de [owngold]."
  set chat_Thanks[4] = "{random>=70} Gracias, ahora acabemos con nuestros obstculos!"
  set chat_Thanks[5] = "{random<=20} Deberas invertir todo tu oro en m. Eso nos dara muchas ms posibilidades de ganar."
  set chat_Thanks[6] = "Veamos qu puedo hacer con el total de [owngold] de oro que tengo."
  set chat_Thanks_length = 7


  set chat_no_unit_selected = "Ninguna unidad est seleccionada."
  set chat_confirm_attack_unit = "Voy a atacar/proteger la unidad seleccionada."
  set chat_towerrush = "Intentar cercar con torres a alguien."
  set chat_no_orc = "No soy un orco verde y pulgoso!"
  set militia_expansion_chat = "Enviar a la milicia para expandirme aqu!"
  set chat_dynamic_counter = "y contrarrestando a los enemigos que usan"
  set invalid_strategy_number = "Nmero de estategia no vlido."

  if chat_no_unit_selected == null or chat_no_unit_selected == "" then
    set chat_no_unit_selected = "No unit selected"
  endif
  if chat_confirm_attack_unit == null or chat_confirm_attack_unit == "" then
    set chat_confirm_attack_unit = "I will attack/guard the selected [TargetColor] [TargetRace] unit"
  endif
  if chat_towerrush == null or chat_towerrush == "" then
    set chat_towerrush = "I will try to towerrush someone"
  endif
  if chat_no_orc == null or chat_no_orc == "" then
    set chat_no_orc = "I do not want to towerrush anyone"
  endif
  if militia_expansion_chat == null or militia_expansion_chat == "" then
    set militia_expansion_chat = "I'm going for militia expansion over here"
  endif
  if chat_dynamic_counter == null or chat_dynamic_counter == "" then
    set chat_dynamic_counter = "and countering the enemies"
  endif
  if invalid_strategy_number == null or invalid_strategy_number == "" then
    set invalid_strategy_number = "Invalid Strategy Number"
  endif

endfunction

function InitChatArraysRomanian takes nothing returns nothing

  set chat_AGG[0] = "A fost super sa joc cu tine."
  set chat_AGG[1] = "Sorry, nu te mai pot ajuta. Sint terminat."
  set chat_AGG[2] = "Ei bine, va trebuii sa te descurci fara mine."
  set chat_AGG[3] = "Meciul s-a terminat pentru mine! La revedere."
  set chat_AGG[4] = "Toate bazele mele apartin lor!"
  set chat_AGG_length = 5

  set chat_Ally[0] = "Vom ataca aici"
  set chat_Ally[1] = "Hai cu noi in acest atac daca vrei"
  set chat_Ally[2] = "Toata lumea sa atace aici!"
  set chat_Ally[3] = "Am nevoie de ajutor"
  set chat_Ally[4] = "Putem sa distrugem tinta asta impreuna"
  set chat_Ally_length = 5

  set chat_Attack[0] = "Atac acest inamic"
  set chat_Attack[1] = "Atac aici"
  set chat_Attack[2] = "Il atac pe asta"
  set chat_Attack[3] = "Pornesc atacul asupra acestei tinte"
  set chat_Attack[4] = "Atac acum aici"
  set chat_Attack_length = 5

  set chat_Creep[0] = "O sa scot din lupta monstrii astia"
  set chat_Creep[1] = "O sa omor monstrii astia"
  set chat_Creep[2] = "Ma duc la grupul asta de monstrii"
  set chat_Creep[3] = "Ma duc spre monstrii astia de aici"
  set chat_Creep[4] = "Acum atac aici"
  set chat_Creep_length = 5

  set chat_Done[0] = "Aici am terminat"
  set chat_Done[1] = "Ma duc in alta parte acum"
  set chat_Done[2] = "Ma duc sa fac altceva"
  set chat_Done[3] = "O sa fac atceva acum"
  set chat_Done[4] = "Atacul e complet"
  set chat_Done_length = 5

  set chat_EGG[0] = "GG"
  set chat_EGG[1] = "Rahat, am pierdut contra unui om!"
  set chat_EGG[2] = "Data viitoare o sa te inving."
  set chat_EGG[3] = "Meciul s-a terminat pentru mine!"
  set chat_EGG[4] = "Trebuie sa plec."
  set chat_EGG_length = 5

  set chat_Expansion[0] = "Curat aceasta expansiune"
  set chat_Expansion[1] = "O sa curat monstrii din mina asta"
  set chat_Expansion[2] = "Cred ca o sa ma extind aici curind"
  set chat_Expansion[3] = "Mina asta va fi disponibila curind"
  set chat_Expansion[4] = "Ma duc la mina asta acum"
  set chat_Expansion_length = 5

  set chat_Goldproblem[0] = "Te rog da-mi niste bani sau plec in 10 secunde."
  set chat_Goldproblem[1] = "Sint in criza de bani. Fara bani voi pleca in 10 secunde"
  set chat_Goldproblem_length = 2

  set chat_Greet[0] = "O sa te sparg"
  set chat_Greet[1] = "Nu cred ca esti facut pentru asta"
  set chat_Greet[2] = "In 'zda masii, urasc harta asta"
  set chat_Greet[3] = "Nuu!! Locul asta e super nasol"
  set chat_Greet[4] = "Hmm... ma intreb unde esti :)"
  set chat_Greet[5] = "Bafta & sa nu te distrezi"
  set chat_Greet[6] = "Bine ai venit in iad !"
  set chat_Greet[7] = "Poti sa fugi, dar nu te poti ascunde"
  set chat_Greet[8] = "Stiu de unde ai pornit"
  set chat_Greet[9] = "De data asta vei pierde contra unui Computer"
  set chat_Greet[10] = "Vei suferi mult in miinile mele !"
  set chat_Greet_length = 11

  set chat_Mega[0] = "Pregatestete sa mori"
  set chat_Mega[1] = "HAHA! Nu ai nici o sansa"
  set chat_Mega[2] = "Asta va fi culmea gloriei mele"
  set chat_Mega[3] = "Meciul se va termina curind"
  set chat_Mega[4] = "Asta va fi un exemplu de esec uman"
  set chat_Mega[5] = "Nu prea a ramas mult din tine"
  set chat_Mega[6] = "Nu prea stii cind e timpul sa zici 'GG' si sa pleci, nu ?"
  set chat_Mega[7] = "Mai bine ai incerca sa joci super bine sau altfel ar trebuii sa pleci :)"
  set chat_Mega[8] = "Mai bine ai incerca sa joci si tu"
  set chat_Mega[9] = "Tocmai ti-am sapat un mormint foarte frumos"
  set chat_Mega[10] = "Toata baza ta sint ale noastre"
  set chat_Mega_length = 11

  set chat_Megatarget[0] = "Apararea lui este la pamint, Atacati!"
  set chat_Megatarget[1] = "Trimit tot ce am aici"
  set chat_Megatarget[2] = "Daca vom ataca acum vom cistiga cu siguranta"
  set chat_Megatarget[3] = "Trimite tot ce ai aici"
  set chat_Megatarget_length = 4

  set chat_Taunt[0] = "Stiu mult mai mult decit crezi tu"
  set chat_Taunt[1] = "Sa nu crezi ca scapi cu ce faci tu acolo"
  set chat_Taunt[2] = "Pazea! Am un plan"
  set chat_Taunt[3] = "Niciodata sa nu subestimezi puterea calculatorului tau"
  set chat_Taunt[4] = "Strategia aia pe care o incerci nu va merge niciodata cu mine"
  set chat_Taunt[5] = "Tu crezi acum ca vei cistiga meciul asta nu ?"
  set chat_Taunt[6] = "Sint mult mai puternic decit orice creep pe care l-ai intilnit"
  set chat_Taunt[7] = "Daca pierd meciul asta pot sa dau vina pe procesorul tau slab"
  set chat_Taunt[8] = "Numai unu poate ramine si s-ar putea sa fiu eu ala"
  set chat_Taunt[9] = "Strategia mea conduce catre victorie, a ta catre infringere"
  set chat_Taunt_length = 10

  set chat_Thanks[0] = "Multumesc pentru bani."
  set chat_Thanks[1] = "Multumesc, am destul ca sa continui."
  set chat_Thanks_length = 2


  set chat_no_unit_selected = "Nici o unitate selectata"
  set chat_confirm_attack_unit = "Voi ataca/apara unitatea selectata"
  set chat_towerrush = "Voi incerca un towerrush"
  set chat_no_orc = "Nu sint un orc, verde, si mincat de purici!"
  set militia_expansion_chat = "Voi face militia expansion aici"
  set chat_dynamic_counter = "i combaterea dumanilor "

  if chat_no_unit_selected == null or chat_no_unit_selected == "" then
    set chat_no_unit_selected = "No unit selected"
  endif
  if chat_confirm_attack_unit == null or chat_confirm_attack_unit == "" then
    set chat_confirm_attack_unit = "I will attack/guard the selected [TargetColor] [TargetRace] unit"
  endif
  if chat_towerrush == null or chat_towerrush == "" then
    set chat_towerrush = "I will try to towerrush someone"
  endif
  if chat_no_orc == null or chat_no_orc == "" then
    set chat_no_orc = "I do not want to towerrush anyone"
  endif
  if militia_expansion_chat == null or militia_expansion_chat == "" then
    set militia_expansion_chat = "I'm going for militia expansion over here"
  endif
  if chat_dynamic_counter == null or chat_dynamic_counter == "" then
    set chat_dynamic_counter = "and countering the enemies"
  endif
  if invalid_strategy_number == null or invalid_strategy_number == "" then
    set invalid_strategy_number = "Invalid Strategy Number"
  endif

endfunction

function InitChatArraysRussian takes nothing returns nothing

  set chat_AGG[0] = "  ."
  set chat_AGG[1] = "  .  ."
  set chat_AGG[2] = "  ."
  set chat_AGG[3] = "-         ."
  set chat_AGG[4] = ", ,  . ."
  set chat_AGG[5] = ",     [Race:OFF]  :("
  set chat_AGG[6] = ",     ,   [Color:A]!"
  set chat_AGG[7] = "   [PlayerColor] [PlayerRace]. gg"
  set chat_AGG[8] = "!       , !"
  set chat_AGG[9] = " ,   .      !"
  set chat_AGG[10] = " ."
  set chat_AGG[11] = " 'n00bs'! -   !"
  set chat_AGG[12] = " , ,  !!!"
  set chat_AGG[13] = "{Random>=50}  !!"
  set chat_AGG[14] = "    . ."
  set chat_AGG[15] = " ,  .    ."
  set chat_AGG[16] = "{Random>=50}  !     ,    !"
  set chat_AGG[17] = ",  ... !"
  set chat_AGG[18] = "   .     ,  ,   ."
  set chat_AGG[19] = "  ,  .    ."
  set chat_AGG[20] = " ,  .     ."
  set chat_AGG[21] = " ,  .     ."
  set chat_AGG[22] = " ,  .    ."
  set chat_AGG[23] = ",  , , ,   ,    ,    ."
  set chat_AGG_length = 24

  set chat_Ally[0] = "  ."
  set chat_Ally[1] = "   !"
  set chat_Ally[2] = "    [TargetColor]!"
  set chat_Ally[3] = "   [PlayerRace]    [TargetColor]!"
  set chat_Ally[4] = "     [TargetColor]."
  set chat_Ally[5] = "    [TargetColor]."
  set chat_Ally[6] = "  [TargetColor] !"
  set chat_Ally[7] = "      [TargetColor]."
  set chat_Ally[8] = "  ...     [TargetColor]!"
  set chat_Ally[9] = "     [TargetColor]."
  set chat_Ally[10] = " ,  ,    [TargetColor] [TargetRace]!"
  set chat_Ally[11] = "    [TargetColor]."
  set chat_Ally[12] = " [TargetColor].       ."
  set chat_Ally[13] = " [TargetColor].     ."
  set chat_Ally[14] = " [TargetColor].     ."
  set chat_Ally[15] = " [TargetColor].    ,    ."
  set chat_Ally[16] = " [TargetColor].      ."
  set chat_Ally[17] = " [TargetColor].     ."
  set chat_Ally[18] = " [TargetColor].    ,    ."
  set chat_Ally[19] = " [TargetColor].      ."
  set chat_Ally[20] = " [TargetColor].       ."
  set chat_Ally[21] = " [TargetColor].    ,    ."
  set chat_Ally[22] = " ."
  set chat_Ally[23] = " [Race:AYA]     ! !"
  set chat_Ally[24] = "   ."
  set chat_Ally[25] = "{Race=ELF}  !  ! , ...  ,  !"
  set chat_Ally[26] = "!"
  set chat_Ally[27] = " !"
  set chat_Ally[28] = "   . !"
  set chat_Ally[29] = " ,    ..."
  set chat_Ally[30] = ", ."
  set chat_Ally[31] = "{Race=UNDEAD}  !   !"
  set chat_Ally[32] = ", , !   !"
  set chat_Ally_length = 33

  set chat_Attack[0] = "-... *  * , [TargetColor] [TargetRace] -   ."
  set chat_Attack[1] = ",  :  - [TargetColor],  - [TargetRace]."
  set chat_Attack[2] = "   ."
  set chat_Attack[3] = "    [TargetColor] [TargetRace], !"
  set chat_Attack[4] = " , ,    !"
  set chat_Attack[5] = " [TargetColor] [TargetRace]  ."
  set chat_Attack[6] = " [TargetColor] [TargetRace]   ."
  set chat_Attack[7] = "  !"
  set chat_Attack[8] = " !"
  set chat_Attack[9] = "    [TargetColor] [TargetRace]  ."
  set chat_Attack[10] = "  ,   !"
  set chat_Attack[11] = ",   [TargetColor:E] [TargetRace:S] -    ."
  set chat_Attack[12] = "       [TargetColor:X] [TargetRace:S]?"
  set chat_Attack[13] = ", [TargetColor]  ,    !"
  set chat_Attack[14] = "   ! : [TargetColor].     ?!"
  set chat_Attack[15] = "     APM'.  .  !"
  set chat_Attack[16] = " [TargetColor:X]    [TargetColor:X],    ..."
  set chat_Attack[17] = " [TargetColor:A] ?  , - :)"
  set chat_Attack[18] = " [TargetColor]  :D       ."
  set chat_Attack[19] = "     ! , [TargetColor],    ."
  set chat_Attack[20] = ", [TargetColor:A]  ?"
  set chat_Attack_length = 21

  set chat_Creep[0] = "."
  set chat_Creep[1] = "     !"
  set chat_Creep[2] = "   ."
  set chat_Creep[3] = " ."
  set chat_Creep[4] = "."
  set chat_Creep[5] = "    [Race].    ."
  set chat_Creep[6] = "   ."
  set chat_Creep[7] = " -    ."
  set chat_Creep[8] = "   [TargetRace],  ."
  set chat_Creep[9] = "  ."
  set chat_Creep[10] = "  , !"
  set chat_Creep[11] = "    ."
  set chat_Creep[12] = " ."
  set chat_Creep[13] = "   -      ?   ?"
  set chat_Creep[14] = "--."
  set chat_Creep[15] = "-1 ."
  set chat_Creep[16] = "     ."
  set chat_Creep[17] = "? ... !"
  set chat_Creep[18] = " =    ."
  set chat_Creep_length = 19

  set chat_Done[0] = "   ?"
  set chat_Done[1] = "."
  set chat_Done[2] = "    ?  [TargetColor] [TargetRace]?"
  set chat_Done[3] = " ,   [TargetColor] [TargetRace]."
  set chat_Done[4] = "   - ."
  set chat_Done[5] = "   .    [RandomRace]."
  set chat_Done[6] = "    [RandomRace],  ."
  set chat_Done[7] = "  ."
  set chat_Done[8] = " ,  ,  ."
  set chat_Done[9] = " !.    [TargetRace]."
  set chat_Done[10] = "      ."
  set chat_Done[11] = "   , ."
  set chat_Done[12] = "   ."
  set chat_Done[13] = " ."
  set chat_Done[14] = "   , ?"
  set chat_Done[15] = "  ,    ."
  set chat_Done[16] = "*  *"
  set chat_Done[17] = ",     -   10,   ."
  set chat_Done[18] = " .  .  ."
  set chat_Done[19] = "    , ?"
  set chat_Done_length = 20

  set chat_EGG[0] = "!"
  set chat_EGG[1] = " !"
  set chat_EGG[2] = " ,     ."
  set chat_EGG[3] = "   , !"
  set chat_EGG[4] = "! ,  ."
  set chat_EGG[5] = "  , ! !"
  set chat_EGG[6] = "{Race!=ELF}! , [Race] !"
  set chat_EGG[7] = "{Race=ELF}! , [Race] !"
  set chat_EGG[8] = "!   !"
  set chat_EGG[9] = "    . ,   [Color], !"
  set chat_EGG[10] = " ."
  set chat_EGG[11] = "-,          !  !"
  set chat_EGG[12] = "!   !"
  set chat_EGG[13] = "GG.  -, ."
  set chat_EGG[14] = " ,    [Race].     [Race]."
  set chat_EGG[15] = "g2g, ,    [Race] !"
  set chat_EGG[16] = "  ! ,  ."
  set chat_EGG[17] = " ...  ..."
  set chat_EGG[18] = "   [TargetColor]..."
  set chat_EGG[19] = "DOH!   [PlayerColor] [PlayerRace]."
  set chat_EGG[20] = "    [ ]!"
  set chat_EGG[21] = "   ,   ..."
  set chat_EGG[22] = " ,     !"
  set chat_EGG[23] = "   ! ,   !"
  set chat_EGG[24] = "!"
  set chat_EGG[25] = "  ,   [Color] [Race]  ,  !"
  set chat_EGG[26] = "  .  ,    ."
  set chat_EGG[27] = " .     ."
  set chat_EGG[28] = " .        ."
  set chat_EGG[29] = " .       ."
  set chat_EGG[30] = " .       ."
  set chat_EGG[31] = "   .       ."
  set chat_EGG[32] = " .       ."
  set chat_EGG[33] = " .       ."
  set chat_EGG[34] = " .       ."
  set chat_EGG[35] = " .      ."
  set chat_EGG_length = 36

  set chat_Expansion[0] = "    ."
  set chat_Expansion[1] = " ."
  set chat_Expansion[2] = "   ."
  set chat_Expansion[3] = "   ."
  set chat_Expansion[4] = "...   ...   ..."
  set chat_Expansion[5] = "     !"
  set chat_Expansion[6] = "   ."
  set chat_Expansion[7] = "    ,     [Race] ."
  set chat_Expansion[8] = "    ."
  set chat_Expansion[9] = ",     ."
  set chat_Expansion[10] = " ."
  set chat_Expansion[11] = "... ... ...    [Race:S]."
  set chat_Expansion[12] = "   ."
  set chat_Expansion[13] = "  ,  .      [Race:S]"
  set chat_Expansion[14] = "  ,  ."
  set chat_Expansion_length = 15

  set chat_Goldproblem[0] = "      , , ?!   [CurrentGold]!   , !"
  set chat_Goldproblem[1] = ",     ... ?"
  set chat_Goldproblem[2] = ".   . ."
  set chat_Goldproblem[3] = "{CurrentGold<100}!   [CurrentGold] ! !"
  set chat_Goldproblem[4] = "    .    ."
  set chat_Goldproblem[5] = "... ... ... ... ... ..."
  set chat_Goldproblem[6] = " $$$?  ?"
  set chat_Goldproblem[7] = "  ... ?"
  set chat_Goldproblem[8] = "  ,  -.     [CurrentGold]."
  set chat_Goldproblem[9] = "           ."
  set chat_Goldproblem[10] = ",  ..."
  set chat_Goldproblem[11] = "{OwnGold<200}     [OwnGold] .   ,       10 ."
  set chat_Goldproblem[12] = "   ! ,   ,      10 !"
  set chat_Goldproblem[13] = "{OwnGold<100}    .     10 ,     ."
  set chat_Goldproblem[14] = "     ,     10 ."
  set chat_Goldproblem[15] = "   10 ,    ,   ."
  set chat_Goldproblem[16] = "{OwnGold<100} 10    ,       ."
  set chat_Goldproblem[17] = " !         10 ."
  set chat_Goldproblem[18] = " !   [OwnGold].      10 ,   ."
  set chat_Goldproblem[19] = "       10 ,   ,       [OwnGold]."
  set chat_Goldproblem[20] = "  !      10 ,    ."
  set chat_Goldproblem_length = 21

  set chat_Greet[0] = "!     [PlayerColor:A] :)"
  set chat_Greet[1] = "{1on1}, [Color]  [PlayerColor]!  ..."
  set chat_Greet[2] = ", .  ,  ,    :("
  set chat_Greet[3] = "! +1    ! !"
  set chat_Greet[4] = " [Color]!"
  set chat_Greet[5] = "    ."
  set chat_Greet[6] = "    ?"
  set chat_Greet[7] = "GL & HF."
  set chat_Greet[8] = ",  !"
  set chat_Greet[9] = "   ."
  set chat_Greet[10] = "       !"
  set chat_Greet[11] = "... ,     :)"
  set chat_Greet[12] = " Can-O-Whoopass  ."
  set chat_Greet[13] = ",         !"
  set chat_Greet[14] = "  ,    "
  set chat_Greet[15] = ",  ,    [PlayerColor]."
  set chat_Greet[16] = "   ! , !"
  set chat_Greet[17] = "     . ? :)"
  set chat_Greet[18] = "{!RaceChoiceRandom,Race=ORC} ,   ?"
  set chat_Greet[19] = "  ? [Name]   ? [Name]    !?"
  set chat_Greet[20] = ",  [RandomRace]     ... ,   ."
  set chat_Greet[21] = "{Race!=UNDEAD}      ?"
  set chat_Greet[22] = "{Race!=HUMAN}  ,    ."
  set chat_Greet[23] = "{!RaceChoiceRandom,Race=ORC,1on1}   1  1.    [Color] [Race]   ."
  set chat_Greet[24] = "{Name=Hunter} !"
  set chat_Greet[25] = "{Name=Crazy_Rusher} , ,  !!!"
  set chat_Greet[26] = "{Name=Crusher}  ...   ."
  set chat_Greet[27] = "  ?"
  set chat_Greet[28] = "{Name=CPU}  ,    ."
  set chat_Greet[29] = "{Name=ErRoR}      ."
  set chat_Greet[30] = "{Name=CyberPro}     ,  ."
  set chat_Greet[31] = "{Name=Aaargh}AAARGHAHA!!!!!!"
  set chat_Greet[32] = "gl hf!"
  set chat_Greet[33] = ",  ?    ! !"
  set chat_Greet[34] = " , .     Warcraft 3."
  set chat_Greet[35] = " ,  .     ?"
  set chat_Greet[36] = " , .    ."
  set chat_Greet[37] = " , .   ,      ."
  set chat_Greet[38] = " , . ,        ."
  set chat_Greet[39] = " , .     ."
  set chat_Greet[40] = " , .        ."
  set chat_Greet[41] = " , .   .   ,    ."
  set chat_Greet_length = 42

  set chat_Mega[0] = "    , [TargetColor]!"
  set chat_Mega[1] = ", [TargetColor]."
  set chat_Mega[2] = ", [TargetColor:E] [TargetRace:S] -  gg."
  set chat_Mega[3] = "   -... -  ."
  set chat_Mega[4] = "-,  ,    - ! :D"
  set chat_Mega[5] = "    ,    ...  -  ."
  set chat_Mega[6] = "   ,   ."
  set chat_Mega[7] = "     !"
  set chat_Mega[8] = "     . ."
  set chat_Mega[9] = "  ? !"
  set chat_Mega[10] = " , [TargetColor],       .    ."
  set chat_Mega[11] = "    . ! Alt+QQ -  . Alt+QX -   ."
  set chat_Mega[12] = "     !   !"
  set chat_Mega[13] = "     ."
  set chat_Mega[14] = "   -   ."
  set chat_Mega[15] = "-, [Race:S] - !"
  set chat_Mega[16] = " !"
  set chat_Mega[17] = " [PlayerRace],  !"
  set chat_Mega[18] = "  , ,    ?"
  set chat_Mega[19] = "      [TargetRace].      ."
  set chat_Mega[20] = ",     ."
  set chat_Mega[21] = ",   ,      ."
  set chat_Mega[22] = " ,    ? , !"
  set chat_Mega[23] = "   [Race]   .    ."
  set chat_Mega[24] = "{1on1}     ."
  set chat_Mega[25] = "   ,   ,   ?"
  set chat_Mega[26] = "  ,   [PlayerRace]     ,     ."
  set chat_Mega[27] = "{FFA}       ."
  set chat_Mega[28] = "      ."
  set chat_Mega[29] = "{Race!=HUMAN} - .  ,   [:S]."
  set chat_Mega[30] = ",   ,   ."
  set chat_Mega[31] = ",  ."
  set chat_Mega[32] = "   .        ."
  set chat_Mega[33] = "  .       ."
  set chat_Mega[34] = "   .    ,   ."
  set chat_Mega[35] = "   .     ,   ."
  set chat_Mega[36] = "  .      ,    ."
  set chat_Mega_length = 37

  set chat_Megatarget[0] = "  [TargetColor:A]!"
  set chat_Megatarget[1] = ",     ,  !"
  set chat_Megatarget[2] = " ,    !"
  set chat_Megatarget[3] = "  !  [TargetColor:X] [TargetRace:OFF]!"
  set chat_Megatarget[4] = ", , !  !"
  set chat_Megatarget[5] = "  ,   !"
  set chat_Megatarget[6] = " ! !"
  set chat_Megatarget[7] = ":   [TargetColor:A]!"
  set chat_Megatarget[8] = "!  !  ,  ..."
  set chat_Megatarget[9] = " ! !"
  set chat_Megatarget[10] = ",   ,        [TargetColor] [TargetRace]!"
  set chat_Megatarget[11] = " ,   [PlayerColor] !"
  set chat_Megatarget[12] = "   !"
  set chat_Megatarget[13] = "  ,    !"
  set chat_Megatarget[14] = " , !         !"
  set chat_Megatarget[15] = " ,   !"
  set chat_Megatarget[16] = "     [TargetColor]!"
  set chat_Megatarget[17] = "      [TargetRace].    ."
  set chat_Megatarget[18] = "     !!!!."
  set chat_Megatarget[19] = " [TargetColor].          ."
  set chat_Megatarget[20] = " [TargetColor].    ,   ."
  set chat_Megatarget[21] = " [TargetColor].    ,     ."
  set chat_Megatarget[22] = " [TargetColor].    ,    ."
  set chat_Megatarget[23] = " [TargetColor].    -   ."
  set chat_Megatarget_length = 24

  set chat_Taunt[0] = "[1on1]  ."
  set chat_Taunt[1] = " ..."
  set chat_Taunt[2] = ",   , , ..."
  set chat_Taunt[3] = "     ."
  set chat_Taunt[4] = "    .  ."
  set chat_Taunt[5] = ",    :)"
  set chat_Taunt[6] = " 7 ... 7  ...  7 ."
  set chat_Taunt[7] = "  ?  ?    ..."
  set chat_Taunt[8] = " --   ..."
  set chat_Taunt[9] = "     :)"
  set chat_Taunt[10] = "   ?"
  set chat_Taunt[11] = " [Color] [Race]  ."
  set chat_Taunt[12] = ",       ."
  set chat_Taunt[13] = "     , ?"
  set chat_Taunt[14] = " [Race]  -  .    ,   !"
  set chat_Taunt[15] = "   [PlayerRace].       . :D"
  set chat_Taunt[16] = "   [TargetRace].   !"
  set chat_Taunt[17] = "  ,   ,     ,   - ."
  set chat_Taunt[18] = "     [PlayerRace].   !"
  set chat_Taunt[19] = ", [PlayerColor]...    5-10 ."
  set chat_Taunt[20] = ", ,     ,    ."
  set chat_Taunt[21] = "  ,     [PlayerRace]   ?"
  set chat_Taunt[22] = "     - ,    ,       ?"
  set chat_Taunt[23] = "      .     ."
  set chat_Taunt[24] = " ,    ,     DotA."
  set chat_Taunt[25] = "    ? !!! ,   ."
  set chat_Taunt[26] = "ROFL,     !"
  set chat_Taunt[27] = "    !"
  set chat_Taunt[28] = "   ."
  set chat_Taunt[29] = "   ?      ."
  set chat_Taunt[30] = "   .    ."
  set chat_Taunt[31] = "     , ."
  set chat_Taunt[32] = "       .      ."
  set chat_Taunt[33] = "      .   ."
  set chat_Taunt[34] = " ,  . , , ...   ."
  set chat_Taunt[35] = "      .  ,       ?"
  set chat_Taunt[36] = "    .      ."
  set chat_Taunt[37] = "   .   ."
  set chat_Taunt[38] = " -   . ."
  set chat_Taunt[39] = "     .  -  AI Warcraft 3,     ."
  set chat_Taunt_length = 40

  set chat_Thanks[0] = " !"
  set chat_Thanks[1] = "  - :) ."
  set chat_Thanks[2] = "."
  set chat_Thanks[3] = "  !"
  set chat_Thanks[4] = "!"
  set chat_Thanks[5] = "   , ."
  set chat_Thanks[6] = "  !"
  set chat_Thanks[7] = ", !  ! "
  set chat_Thanks[8] = "    -  ."
  set chat_Thanks[9] = "   !"
  set chat_Thanks[10] = "  ?"
  set chat_Thanks[11] = ".   ,  !"
  set chat_Thanks[12] = "{OwnGold<100} ,    ,    ."
  set chat_Thanks[13] = "!  .      , ?"
  set chat_Thanks[14] = "!   ."
  set chat_Thanks[15] = "  !"
  set chat_Thanks[16] = "{OwnGold>=400}  - !!!"
  set chat_Thanks[17] = ",   !  !"
  set chat_Thanks[18] = "  .  ,  ."
  set chat_Thanks[19] = " .    .  !"
  set chat_Thanks[20] = "{OwnGold<200} , ,  ,    ."
  set chat_Thanks[21] = "Stonks!"
  set chat_Thanks_length = 22


  set chat_no_unit_selected = "      ,    ."
  set chat_confirm_attack_unit = "   /   ."
  set chat_towerrush = "  -"
  set chat_no_orc = "  ,  ..."
  set militia_expansion_chat = "       ."
  set invalid_strategy_number = "  "
  set chat_dynamic_counter = " "

  if chat_no_unit_selected == null or chat_no_unit_selected == "" then
    set chat_no_unit_selected = "No unit selected"
  endif
  if chat_confirm_attack_unit == null or chat_confirm_attack_unit == "" then
    set chat_confirm_attack_unit = "I will attack/guard the selected [TargetColor] [TargetRace] unit"
  endif
  if chat_towerrush == null or chat_towerrush == "" then
    set chat_towerrush = "I will try to towerrush someone"
  endif
  if chat_no_orc == null or chat_no_orc == "" then
    set chat_no_orc = "I do not want to towerrush anyone"
  endif
  if militia_expansion_chat == null or militia_expansion_chat == "" then
    set militia_expansion_chat = "I'm going for militia expansion over here"
  endif
  if chat_dynamic_counter == null or chat_dynamic_counter == "" then
    set chat_dynamic_counter = "and countering the enemies"
  endif
  if invalid_strategy_number == null or invalid_strategy_number == "" then
    set invalid_strategy_number = "Invalid Strategy Number"
  endif

endfunction

function InitChatArraysPortuguese takes nothing returns nothing

  set chat_AGG[0] = "Sou bom quando estou morto. Bom jogo."
  set chat_AGG[1] = "Fui vencido por [PlayerColor] [PlayerRace]. gg"
  set chat_AGG[2] = "Foi bom enquanto durou. Mas voc ainda pode vencer!"
  set chat_AGG[3] = "Desculpe, galera, mas tenho que ir. Bom divertimento."
  set chat_AGG[4] = "Eu odeio n00bs! Voc fez eu perder!"
  set chat_AGG[5] = "No posso evitar, tudo isso foi culpa sua!"
  set chat_AGG[6] = "J era, cara, j era!!!"
  set chat_AGG[7] = "Esse  o fim para mim.  Segure, e talvez vena!"
  set chat_AGG[8] = " o fim!"
  set chat_AGG[9] = "Eu no posso acreditar [Color] [Race] perdeu para algum como voc!"
  set chat_AGG_length = 10

  set chat_Ally[0] = "Vamos, reunir aqui!"
  set chat_Ally[1] = "Rena sua armada [PlayerRace] para um ataque!"
  set chat_Ally[2] = "Vamos l, vamos acabar com esses [TargetRace] malditos!"
  set chat_Ally[3] = "Recuar, reagrupar aqui e atacar!"
  set chat_Ally[4] = "Todos ataquem o [TargetColor] aqui!"
  set chat_Ally[5] = "Presciso de reforos para atacar o [TargetColor]."
  set chat_Ally[6] = "Concentre-se no alvo, concentre-se no alvo!"
  set chat_Ally[7] = "Deveramos concentrar nosso ataque aqui."
  set chat_Ally[8] = "Vamos devastar esse pattico [TargetColor] [TargetRace]!"
  set chat_Ally[9] = "Mandemos uma fora de assalto aqui."
  set chat_Ally_length = 10

  set chat_Attack[0] = "Vou lanar uma ofensiva aqui."
  set chat_Attack[1] = "Vou tomar estes [TargetColor] [TargetRace] de assalto, venha!"
  set chat_Attack[2] = "Red-5 ao seu dispor."
  set chat_Attack[3] = "Me dem cobertura, vou entrar!"
  set chat_Attack[4] = "Atacando o [TargetColor] [TargetRace] aqui."
  set chat_Attack[5] = "Atacando [TargetColor] [TargetRace] nessa localizao."
  set chat_Attack[6] = "Cuidado!"
  set chat_Attack[7] = "A defesa caiu!"
  set chat_Attack[8] = "Vamos tomar o exrcito [TargetRace] bem aqui."
  set chat_Attack[9] = "Agora  a nossa chance, vamos peg-los!"
  set chat_Attack_length = 10

  set chat_Creep[0] = "Vou creepar um pouco."
  set chat_Creep[1] = "Vou aumentar meu nvel de [Race].  Matando estes creeps aqui."
  set chat_Creep[2] = "Se livrando dos creeps..."
  set chat_Creep[3] = "Creepando bem aqui."
  set chat_Creep[4] = "Um creep bom  um creep morto."
  set chat_Creep[5] = "Siga-me [TargetRace], vamos creepar."
  set chat_Creep[6] = "Vamos avanar de nvel."
  set chat_Creep[7] = "Pilhagem da boa aqui, vamos!"
  set chat_Creep[8] = "Venha, vamos pegar alguns itens."
  set chat_Creep[9] = "Vamos creepar por um tempo."
  set chat_Creep_length = 10

  set chat_Done[0] = "O que voc quer fazer agora?  [TargetColor] [TargetRace] de novo?"
  set chat_Done[1] = "Ei, bela ttica atacando aquele [TargetColor] [TargetRace]."
  set chat_Done[2] = "Ah, vou fazer outra coisa, agora."
  set chat_Done[3] = "Hora de fazer o trabalho sujo. Hora de matar [RandomRace]."
  set chat_Done[4] = "Vou caar alguns [RandomRace]."
  set chat_Done[5] = "Assalto concludo."
  set chat_Done[6] = "Eu estive l, eu vi tudo, at comprei uma camiseta."
  set chat_Done[7] = "E o caos foi estabelecido. Muitos [TargetRace] mortos aqui atrs."
  set chat_Done[8] = "Deixei uma trilha de morte e destruio no meu caminho."
  set chat_Done[9] = "Asterides no me preocupem, general."
  set chat_Done_length = 10

  set chat_EGG[0] = "Pqp. Odeio hackers!"
  set chat_EGG[1] = "GG. Remake a, por favor. Voc foi sortudo, que eu peguei [Race].  Eu sou horrvel com [Race]."
  set chat_EGG[2] = "g2g, parece que todos os [Race] da minha armada j foram tarde!"
  set chat_EGG[3] = "Maldio! Parece que  meu fim."
  set chat_EGG[4] = "Homem morto andando... Homem morto andando..."
  set chat_EGG[5] = "At mais, [TargetColor]..."
  set chat_EGG[6] = "DUH!  Derrotado pelo [PlayerColor] [PlayerRace]. Que droga."
  set chat_EGG[7] = "Voc fede, [PlayerColor].  Te devo essa..."
  set chat_EGG[8] = "Esses no so os drides que voc est procurando..."
  set chat_EGG[9] = "gg!"
  set chat_EGG_length = 10

  set chat_Expansion[0] = "Essa expanso tem que ser liberada."
  set chat_Expansion[1] = "L vou eu arranjando mais ouro para minha armada [Race]."
  set chat_Expansion[2] = "Removendo creeps nessa expanso."
  set chat_Expansion[3] = "Vou expandir ali daqui  pouco."
  set chat_Expansion[4] = "Vou creepar aqui. Vem logo!"
  set chat_Expansion[5] = "Removendo creeps..."
  set chat_Expansion[6] = "Quero... mais... ouro... para meus [Race:S]!"
  set chat_Expansion[7] = "Ajude a mquina de guerra  se expandir."
  set chat_Expansion[8] = "Sem esgotar o ouro, vou expandir aqui.  Quanto mais [Race:S], melhor."
  set chat_Expansion[9] = "Eu presciso de dinheiro, vou ter que expandir."
  set chat_Expansion_length = 10

  set chat_Goldproblem[0] = "{OwnGold<200} S tenho [OwnGold] de ouro. Me empreste um pouco ou eu saio em dez segundos."
  set chat_Goldproblem[1] = "Presciso de ouro! Urgente! Ou terei que sair em 10 segundos!"
  set chat_Goldproblem[2] = "{OwnGold<100}T pobre. Voc tem 10 segundos para me arranjar ouro ou eu saio."
  set chat_Goldproblem[3] = "Doe ouro para minha causa, ou eu sao em 10 segundos."
  set chat_Goldproblem[4] = "Voc tem 10 segundos para me pagar tributo, ou estou fora."
  set chat_Goldproblem[5] = "{OwnGold<100}Vou sair em 10 segundos  menos que voc me d ouro."
  set chat_Goldproblem[6] = "A, presciso de dim-dim! Seno eu vou vazar em 10 segundos."
  set chat_Goldproblem[7] = "PQP! S [OwnGold] de ouro.  Presciso de ouro em 10 segundos ou t fora."
  set chat_Goldproblem[8] = "Se eu no conseguir ouro em 10 segundos eu saio, pois s tenho [OwnGold]."
  set chat_Goldproblem[9] = "Presciso de grana! Me d alguma em 10 segundos ou eu saio!"
  set chat_Goldproblem_length = 10

  set chat_Greet[0] = "Esse jogo vai ser muito fcil."
  set chat_Greet[1] = "Eu te falei para no escolher esse mapa! "
  set chat_Greet[2] = "Awww droga eu sempre saio com a pior localizao."
  set chat_Greet[3] = "Hmm... onde ser que voc saiu? :)"
  set chat_Greet[4] = "Uma ownage no capricho saindo."
  set chat_Greet[5] = "Espero que no tenha me posto no Easy!"
  set chat_Greet[6] = "Voc pode correr, mas no pode se esconder!"
  set chat_Greet[7] = "Acho que sei onde o [PlayerColor] comeou!"
  set chat_Greet[8] = "Uma baixa saindo! Confirme por favor!"
  set chat_Greet[9] = "Espero que jogue melhor que da ltima vez. Lembra? :)"
  set chat_Greet[10] = "{!RaceChoiceRandom,Race=ORC} Orcs, por que sempre orcs?"
  set chat_Greet[11] = "Qual  o meu nome!? [Name] Qual  o meu nome!? [Name] QUAL  O MEU NOME?!"
  set chat_Greet[12] = "Supostamente [RandomRace] esto em baixa esses dias... vamos descobrir."
  set chat_Greet[13] = "{Race!=UNDEAD} Por que eu NUNCA pego Undead?"
  set chat_Greet[14] = "{Race!=UNDEAD} Ainda bem que no foi Humans dessa vez."
  set chat_Greet[15] = "{!RaceChoiceRandom,Race=ORC,1on1} Orcs RULAM no 1 v 1.  Meus [Color] [Race] vo acabar com voc."
  set chat_Greet[16] = "{Name=Hunter}A temporada de caa est aberta!"
  set chat_Greet[17] = "{Name=Crazy_Rusher} Rush, Rush, RUSH!!!"
  set chat_Greet[18] = "{Name=Crusher}Voc est pronto... pra ser ESMAGADO."
  set chat_Greet[19] = "J comeou?"
  set chat_Greet[20] = "{Name=CPU}Meus calculos indicam que sairei vencedor."
  set chat_Greet[21] = "{Name=ErRoR}No vai dar pau dessa vez!"
  set chat_Greet[22] = "{Name=CyberPro}Sou o nico PRO de verdade nesse jogo, humano.."
  set chat_Greet[23] = "{Name=Aaargh}AAARGHAHA!!!!!!"
  set chat_Greet_length = 24

  set chat_Mega[0] = "ACORDA [PlayerRace], HORA DE MORRER!"
  set chat_Mega[1] = "T demorando muito, quem sabe eu acabo com isso de uma vez?"
  set chat_Mega[2] = "Haha, mortais cometem erros. Computadores no."
  set chat_Mega[3] = "Sei todas as suas estratgias de [TargetRace]. Elas esto guardadas no meu disco rgido."
  set chat_Mega[4] = "T na hora de acabar com isso..."
  set chat_Mega[5] = "O poder de destruir um planeta  insignificante perante o poder da Fora."
  set chat_Mega[6] = "Achei que voc ia vencer esse jogo! Me enganei!"
  set chat_Mega[7] = "eee mais uma vitria [Race]. J posso at ver."
  set chat_Mega[8] = "{1on1} Isso ser um exemplo da falha humana."
  set chat_Mega[9] = "Voc no sabe mesmo quando jogar a toalha, no ?"
  set chat_Mega[10] = "No me importa quantas estruturas [PlayerRace] voc esconde no mapa, te mato de qualquer jeito."
  set chat_Mega[11] = "{FFA}Aqui vou eu e no terei piedade de ningum."
  set chat_Mega[12] = "No ache que voc ficar nesse jogo por muito tempo."
  set chat_Mega[13] = "{Race!=HUMAN}Humanos sux. que bom que sou [Race:S]"
  set chat_Mega_length = 14

  set chat_Megatarget[0] = "Eles esto fracos! ATACAR!"
  set chat_Megatarget[1] = "Todos que podem atacar, acabem com esses [TargetColor] [TargetRace] perdedores!"
  set chat_Megatarget[2] = "Venceremos se tomarmos [PlayerColor] de assalto, agora!"
  set chat_Megatarget[3] = "Todas as unidades; reunir aqui imediatamente!"
  set chat_Megatarget[4] = "Vamos destruir a base deles!"
  set chat_Megatarget[5] = "Est tudo bem, agora vamos massacrar esses aqui e ir para casa!"
  set chat_Megatarget[6] = "Ataquem com tudo enquanto eles esto fracos!"
  set chat_Megatarget[7] = "TODO MUNDO NO [TargetColor]!"
  set chat_Megatarget[8] = "Agora  hora de acabar com o [TargetColor]!"
  set chat_Megatarget[9] = "Traga s faxineiros. Vamos limpar os [TargetRace] do mapa."
  set chat_Megatarget_length = 10

  set chat_Taunt[0] = "Meu [Color] [Race] vai dominar."
  set chat_Taunt[1] = "Cara eu jogo com voc demais..."
  set chat_Taunt[2] = "Voc no t jogando srio, espero."
  set chat_Taunt[3] = "Minha ttica de [Race] owna. Voc nunca vai saber o que te atingiu!"
  set chat_Taunt[4] = "Bela armada [PlayerRace]. Tenho um espio do seu lado. :D"
  set chat_Taunt[5] = "Odeio essas hordas fedorentas de [TargetRace]. Vou te destruir!"
  set chat_Taunt[6] = "Da ultima vez, eu era o aprendiz. Agora sou o mestre."
  set chat_Taunt[7] = "Voc tem um heri [PlayerRace] de nvel baixo. Sou bem melhor que isso!"
  set chat_Taunt[8] = "Ei [PlayerColor]... Vou vencer em uns 5 ou 10 minutos."
  set chat_Taunt[9] = "Esse vai ser o jogo mais fcil de todos."
  set chat_Taunt[10] = "Voc realmente acha que essa estratgia de [PlayerRace] vai me pegar desprevenido?"
  set chat_Taunt[11] = "Aaaaaah, me deixa vencer essa vez? Cansei de perder!"
  set chat_Taunt_length = 12

  set chat_Thanks[0] = "Obrigado. Vou reconstruir o que perdi!"
  set chat_Thanks[1] = "{OwnGold<100} Valeu, me d qualquer ouro que tenha sobrando."
  set chat_Thanks[2] = "Obrigado! No saia. Ainda podemos vencer, certto?"
  set chat_Thanks[3] = "A! Obrigado pela grana!."
  set chat_Thanks[4] = "Valeu pelo Dindin cara!"
  set chat_Thanks[5] = "{OwnGold>=400} Ka-Ching!!!"
  set chat_Thanks[6] = "Reconstruindo. Obrigado!"
  set chat_Thanks[7] = "Obrigado pelo ouro.."
  set chat_Thanks[8] = "Adoro quando partilham a fortuna comigo!"
  set chat_Thanks[9] = "{OwnGold<200} Vou prescisar de mais, porm cada moeda ajuda."
  set chat_Thanks_length = 10


  set chat_no_unit_selected = "Ningum selecionado"
  set chat_confirm_attack_unit = "Atacar/proteger o cara selecionado unidade [TargetColor] [TargetRace] "
  set chat_towerrush = "Tentar Tower Rush em algum"
  set chat_no_orc = "No quero fazer Tower Rush"
  set militia_expansion_chat = "Vou fazer expanso com Militia aqui."
  set chat_dynamic_counter = "e combatendo os inimigos "

  if chat_no_unit_selected == null or chat_no_unit_selected == "" then
    set chat_no_unit_selected = "No unit selected"
  endif
  if chat_confirm_attack_unit == null or chat_confirm_attack_unit == "" then
    set chat_confirm_attack_unit = "I will attack/guard the selected [TargetColor] [TargetRace] unit"
  endif
  if chat_towerrush == null or chat_towerrush == "" then
    set chat_towerrush = "I will try to towerrush someone"
  endif
  if chat_no_orc == null or chat_no_orc == "" then
    set chat_no_orc = "I do not want to towerrush anyone"
  endif
  if militia_expansion_chat == null or militia_expansion_chat == "" then
    set militia_expansion_chat = "I'm going for militia expansion over here"
  endif
  if chat_dynamic_counter == null or chat_dynamic_counter == "" then
    set chat_dynamic_counter = "and countering the enemies"
  endif
  if invalid_strategy_number == null or invalid_strategy_number == "" then
    set invalid_strategy_number = "Invalid Strategy Number"
  endif

endfunction

function InitChatArraysNorwegian takes nothing returns nothing

  set chat_AGG[0] = "Hyggelig  spille med deg."
  set chat_AGG[1] = "Sorry as, men jeg er visst s godt som dd. "
  set chat_AGG[2] = "Du fr klare deg uten meg."
  set chat_AGG[3] = "Okey.. jeg er dd, HADE!"
  set chat_AGG[4] = "hhh whoops... tror jeg er ute."
  set chat_AGG_length = 5

  set chat_Ally[0] = "Vi angriper her"
  set chat_Ally[1] = "Hjelp oss  angripe her"
  set chat_Ally[2] = "Angrip her n"
  set chat_Ally[3] = "Jeg trenger hjelp her"
  set chat_Ally[4] = "Vi kan angripe sammen"
  set chat_Ally_length = 5

  set chat_Attack[0] = "Jeg angriper denne fienden"
  set chat_Attack[1] = "Jeg angriper her"
  set chat_Attack[2] = "Angriper denna"
  set chat_Attack[3] = "Sender et angriper her n"
  set chat_Attack[4] = "Angriper her n"
  set chat_Attack_length = 5

  set chat_Creep[0] = "Jeg kvester de creepa her"
  set chat_Creep[1] = "Jeg tar  kverker dissa creepa"
  set chat_Creep[2] = "Jeg tar hnd om dissa creepa"
  set chat_Creep[3] = "Jeg creeper litt her jeg"
  set chat_Creep[4] = "Jeg flyr p dissa creepa her"
  set chat_Creep_length = 5

  set chat_Done[0] = "Jeg er klar her n"
  set chat_Done[1] = "Jeg stikker et annet sted"
  set chat_Done[2] = "Jeg gr  gjr noe annet"
  set chat_Done[3] = "Gjr noe annet n"
  set chat_Done[4] = "Angrep averget"
  set chat_Done_length = 5

  set chat_EGG[0] = "GG"
  set chat_EGG[1] = "Helvete jeg er dd"
  set chat_EGG[2] = "Neste gang skal du f det der det svir."
  set chat_EGG[3] = "Okey, greit! Jeg er dd!"
  set chat_EGG[4] = "Jeg m stikke jeg."
  set chat_EGG_length = 5

  set chat_Expansion[0] = "Jeg renser det stedet her"
  set chat_Expansion[1] = "Jeg fikser opp creepa ved den gruva her"
  set chat_Expansion[2] = "Jeg ekspanderer meg hit snart"
  set chat_Expansion[3] = "Snart er denne gruva tilgjengelig"
  set chat_Expansion[4] = "Jeg tar denne gruva n"
  set chat_Expansion_length = 5

  set chat_Goldproblem[0] = "Sleng over litt png a, ellers s stikker jeg om 10 sekunder."
  set chat_Goldproblem[1] = "Jeg meg penger ellers s stikker jeg om 10 sek."
  set chat_Goldproblem_length = 2

  set chat_Greet[0] = "Du er s dd du.."
  set chat_Greet[1] = "Du kommer til  d s sinnsykt >:)"
  set chat_Greet[2] = "Faen! Ikke dette brettet igjen!"
  set chat_Greet[3] = "Ahh, samma startsted igjen! :("
  set chat_Greet[4] = "Hmmm lurer p hvor du starta"
  set chat_Greet[5] = "Du kommer til  tape, liker du det ikke fr du bare godta det!"
  set chat_Greet[6] = "Velkommen til helvete"
  set chat_Greet[7] = "Du kommer ikke til  slippe unna!"
  set chat_Greet[8] = "Jeg veit allerede hvor du starta!"
  set chat_Greet[9] = "Nr jeg er ferdig med deg kommer du til  vre s sinnsykt sur haha!"
  set chat_Greet_length = 10

  set chat_Mega[0] = "Gjr deg klar til  f det der det svir!"
  set chat_Mega[1] = "AHA! D D D!"
  set chat_Mega[2] = "N er du d!"
  set chat_Mega[3] = "N er du snart like dd som Hitler!"
  set chat_Mega[4] = "OMGZ Du er s jvelig dd!"
  set chat_Mega[5] = "HAHAHAHAHHA LOLZ Du har tapt allerede"
  set chat_Mega[6] = "Bare gi opp! Si GG og stikk!"
  set chat_Mega[7] = "Vis meg hvem som er pappa!"
  set chat_Mega[8] = "Kanskje p tide  spille for alvor ehh?"
  set chat_Mega_length = 9

  set chat_Megatarget[0] = "HIT! N har vi sjans! ANGRIP!"
  set chat_Megatarget[1] = "Sender alt ned hit n.."
  set chat_Megatarget[2] = "Om vi angriper n kommer vi til  vinne lett"
  set chat_Megatarget[3] = "Send alt du har ned hit n"
  set chat_Megatarget[4] = "Fort deg hit meg masse folk s vinner vi!"
  set chat_Megatarget_length = 5

  set chat_Taunt[0] = "Jeg veit mer enn du tror"
  set chat_Taunt[1] = "Sitter du det  koser deg med Pappvin og Pornofilmer eller?!"
  set chat_Taunt[2] = "Hahah! Jeg har en plan"
  set chat_Taunt[3] = "Aldri undervurder din motstander"
  set chat_Taunt[4] = "Din strategi er uttdatert, menneske!"
  set chat_Taunt[5] = "Du tror du kommer til  vinne ehh? :P"
  set chat_Taunt[6] = "Jeg er farligere enn alle verdens atombomber"
  set chat_Taunt[7] = "Om jeg taper denne matchen s er det fordi PC'n din suger s inne i HELVETE!"
  set chat_Taunt[8] = "Det er bare en igjen nr jeg er ferdig her og det er MEG!"
  set chat_Taunt[9] = "Min taktikk er ufeilbar, du kommer til  tape!"
  set chat_Taunt_length = 10

  set chat_Thanks[0] = "Takker s meget!"
  set chat_Thanks[1] = "Takk Takk, n holder det."
  set chat_Thanks_length = 2


  set chat_no_unit_selected = "Ingen enhet valgt"
  set chat_confirm_attack_unit = "Jeg kommer til  angripe/vokte den valgte enheten"
  set chat_towerrush = "Jeg vil prve  towerrushe han"
  set chat_no_orc = "Jeg er ikke noen orc"
  set militia_expansion_chat = "Jeg gr for militia utvidelse over her"
  set chat_dynamic_counter = "og motvirke fiendene "

  if chat_no_unit_selected == null or chat_no_unit_selected == "" then
    set chat_no_unit_selected = "No unit selected"
  endif
  if chat_confirm_attack_unit == null or chat_confirm_attack_unit == "" then
    set chat_confirm_attack_unit = "I will attack/guard the selected [TargetColor] [TargetRace] unit"
  endif
  if chat_towerrush == null or chat_towerrush == "" then
    set chat_towerrush = "I will try to towerrush someone"
  endif
  if chat_no_orc == null or chat_no_orc == "" then
    set chat_no_orc = "I do not want to towerrush anyone"
  endif
  if militia_expansion_chat == null or militia_expansion_chat == "" then
    set militia_expansion_chat = "I'm going for militia expansion over here"
  endif
  if chat_dynamic_counter == null or chat_dynamic_counter == "" then
    set chat_dynamic_counter = "and countering the enemies"
  endif
  if invalid_strategy_number == null or invalid_strategy_number == "" then
    set invalid_strategy_number = "Invalid Strategy Number"
  endif

endfunction

function InitChatArraysChinese takes nothing returns nothing

  set chat_AGG[0] = ""
  set chat_AGG[1] = "..."
  set chat_AGG[2] = "......"
  set chat_AGG[3] = ""
  set chat_AGG[4] = ""
  set chat_AGG[5] = ""
  set chat_AGG[6] = ""
  set chat_AGG[7] = "~"
  set chat_AGG[8] = ""
  set chat_AGG[9] = ""
  set chat_AGG[10] = ""
  set chat_AGG[11] = ""
  set chat_AGG[12] = ""
  set chat_AGG[13] = ""
  set chat_AGG[14] = ""
  set chat_AGG[15] = ""
  set chat_AGG[16] = "..."
  set chat_AGG[17] = "88"
  set chat_AGG[18] = ""
  set chat_AGG[19] = ""
  set chat_AGG[20] = ""
  set chat_AGG[21] = ""
  set chat_AGG[22] = ""
  set chat_AGG[23] = "......"
  set chat_AGG[24] = ""
  set chat_AGG_length = 25

  set chat_Ally[0] = ""
  set chat_Ally[1] = ""
  set chat_Ally[2] = ""
  set chat_Ally[3] = ""
  set chat_Ally[4] = ""
  set chat_Ally[5] = ""
  set chat_Ally[6] = ""
  set chat_Ally[7] = ""
  set chat_Ally[8] = "..."
  set chat_Ally[9] = "~..."
  set chat_Ally[10] = ""
  set chat_Ally[11] = ""
  set chat_Ally[12] = ""
  set chat_Ally[13] = ""
  set chat_Ally[14] = "--()()()() ()()()()"
  set chat_Ally[15] = ""
  set chat_Ally[16] = ".."
  set chat_Ally[17] = ""
  set chat_Ally[18] = ""
  set chat_Ally[19] = ""
  set chat_Ally[20] = "LSP~"
  set chat_Ally[21] = "..."
  set chat_Ally[22] = ""
  set chat_Ally_length = 23

  set chat_Attack[0] = ""
  set chat_Attack[1] = ""
  set chat_Attack[2] = ""
  set chat_Attack[3] = ""
  set chat_Attack[4] = ""
  set chat_Attack[5] = "30"
  set chat_Attack[6] = ""
  set chat_Attack[7] = ""
  set chat_Attack[8] = ""
  set chat_Attack[9] = ""
  set chat_Attack[10] = ""
  set chat_Attack[11] = "----------"
  set chat_Attack[12] = ""
  set chat_Attack[13] = "C4"
  set chat_Attack[14] = ""
  set chat_Attack[15] = ""
  set chat_Attack[16] = "TP"
  set chat_Attack[17] = "..."
  set chat_Attack[18] = ""
  set chat_Attack[19] = ""
  set chat_Attack[20] = ""
  set chat_Attack[21] = ""
  set chat_Attack_length = 22

  set chat_Creep[0] = ""
  set chat_Creep[1] = ""
  set chat_Creep[2] = ""
  set chat_Creep[3] = ""
  set chat_Creep[4] = ""
  set chat_Creep[5] = ""
  set chat_Creep[6] = ""
  set chat_Creep[7] = ""
  set chat_Creep[8] = ""
  set chat_Creep[9] = ""
  set chat_Creep[10] = ""
  set chat_Creep[11] = ""
  set chat_Creep[12] = ""
  set chat_Creep_length = 13

  set chat_Done[0] = ""
  set chat_Done[1] = ""
  set chat_Done[2] = ""
  set chat_Done[3] = ""
  set chat_Done[4] = "~"
  set chat_Done[5] = ""
  set chat_Done[6] = "~"
  set chat_Done[7] = ""
  set chat_Done[8] = ""
  set chat_Done[9] = ""
  set chat_Done[10] = ""
  set chat_Done[11] = ""
  set chat_Done[12] = ""
  set chat_Done[13] = ""
  set chat_Done[14] = ""
  set chat_Done[15] = ""
  set chat_Done[16] = "greedisgood "
  set chat_Done[17] = ""
  set chat_Done[18] = "~~"
  set chat_Done[19] = ""
  set chat_Done_length = 20

  set chat_EGG[0] = ""
  set chat_EGG[1] = ""
  set chat_EGG[2] = ""
  set chat_EGG[3] = ""
  set chat_EGG[4] = ""
  set chat_EGG[5] = ""
  set chat_EGG[6] = ""
  set chat_EGG[7] = ""
  set chat_EGG[8] = ""
  set chat_EGG[9] = ""
  set chat_EGG[10] = ""
  set chat_EGG[11] = ""
  set chat_EGG[12] = ""
  set chat_EGG[13] = ""
  set chat_EGG[14] = "GG"
  set chat_EGG[15] = ""
  set chat_EGG[16] = ""
  set chat_EGG[17] = ""
  set chat_EGG[18] = ""
  set chat_EGG[19] = ""
  set chat_EGG[20] = ""
  set chat_EGG[21] = ""
  set chat_EGG[22] = "BAN"
  set chat_EGG[23] = ""
  set chat_EGG[24] = "..............."
  set chat_EGG[25] = ""
  set chat_EGG_length = 26

  set chat_Expansion[0] = ""
  set chat_Expansion[1] = ""
  set chat_Expansion[2] = "~"
  set chat_Expansion[3] = ""
  set chat_Expansion[4] = ""
  set chat_Expansion[5] = ""
  set chat_Expansion[6] = ""
  set chat_Expansion[7] = ""
  set chat_Expansion[8] = ""
  set chat_Expansion[9] = ""
  set chat_Expansion[10] = ""
  set chat_Expansion[11] = ""
  set chat_Expansion[12] = ""
  set chat_Expansion_length = 13

  set chat_Goldproblem[0] = "10GG"
  set chat_Goldproblem[1] = ""
  set chat_Goldproblem[2] = ""
  set chat_Goldproblem[3] = "..."
  set chat_Goldproblem[4] = "..."
  set chat_Goldproblem[5] = ""
  set chat_Goldproblem[6] = ""
  set chat_Goldproblem[7] = ""
  set chat_Goldproblem[8] = ""
  set chat_Goldproblem[9] = ""
  set chat_Goldproblem[10] = ""
  set chat_Goldproblem[11] = ""
  set chat_Goldproblem[12] = ""
  set chat_Goldproblem[13] = ""
  set chat_Goldproblem[14] = ""
  set chat_Goldproblem_length = 15

  set chat_Greet[0] = "100"
  set chat_Greet[1] = "Siri--"
  set chat_Greet[2] = ""
  set chat_Greet[3] = ""
  set chat_Greet[4] = ""
  set chat_Greet[5] = "      ?"
  set chat_Greet[6] = "AMAIBUGBUG"
  set chat_Greet[7] = "~"
  set chat_Greet[8] = "VRARMR"
  set chat_Greet[9] = "AI.........AIAI"
  set chat_Greet[10] = "Num--"
  set chat_Greet[11] = ""
  set chat_Greet[12] = "B"
  set chat_Greet[13] = "LOLDOTA23"
  set chat_Greet[14] = ""
  set chat_Greet[15] = "3"
  set chat_Greet[16] = "~"
  set chat_Greet[17] = "3"
  set chat_Greet[18] = ""
  set chat_Greet[19] = "--"
  set chat_Greet[20] = "..."
  set chat_Greet[21] = "~"
  set chat_Greet[22] = ""
  set chat_Greet[23] = "M78--A"
  set chat_Greet[24] = "~"
  set chat_Greet[25] = "~"
  set chat_Greet[26] = ""
  set chat_Greet[27] = ""
  set chat_Greet[28] = ""
  set chat_Greet[29] = ""
  set chat_Greet[30] = ""
  set chat_Greet[31] = ""
  set chat_Greet[32] = ""
  set chat_Greet[33] = "bilibili~( - )"
  set chat_Greet_length = 34

  set chat_Mega[0] = ""
  set chat_Mega[1] = ""
  set chat_Mega[2] = ""
  set chat_Mega[3] = "--"
  set chat_Mega[4] = "APM"
  set chat_Mega[5] = ""
  set chat_Mega[6] = ""
  set chat_Mega[7] = ""
  set chat_Mega[8] = ""
  set chat_Mega[9] = ""
  set chat_Mega[10] = ""
  set chat_Mega[11] = ""
  set chat_Mega[12] = ""
  set chat_Mega[13] = ""
  set chat_Mega[14] = ""
  set chat_Mega[15] = "..."
  set chat_Mega[16] = ""
  set chat_Mega[17] = ""
  set chat_Mega[18] = ""
  set chat_Mega[19] = ""
  set chat_Mega[20] = ""
  set chat_Mega[21] = ""
  set chat_Mega[22] = ""
  set chat_Mega[23] = ""
  set chat_Mega[24] = ""
  set chat_Mega[25] = ""
  set chat_Mega_length = 26

  set chat_Megatarget[0] = ""
  set chat_Megatarget[1] = ""
  set chat_Megatarget[2] = ""
  set chat_Megatarget[3] = "SB"
  set chat_Megatarget[4] = ""
  set chat_Megatarget[5] = ""
  set chat_Megatarget[6] = ""
  set chat_Megatarget[7] = ""
  set chat_Megatarget[8] = ""
  set chat_Megatarget[9] = "1000"
  set chat_Megatarget[10] = ""
  set chat_Megatarget[11] = ""
  set chat_Megatarget[12] = ""
  set chat_Megatarget[13] = ""
  set chat_Megatarget[14] = ""
  set chat_Megatarget[15] = ""
  set chat_Megatarget[16] = ""
  set chat_Megatarget[17] = ""
  set chat_Megatarget[18] = "WHOSYOURDADDY"
  set chat_Megatarget_length = 19

  set chat_Taunt[0] = ""
  set chat_Taunt[1] = ""
  set chat_Taunt[2] = ""
  set chat_Taunt[3] = "MVP"
  set chat_Taunt[4] = ""
  set chat_Taunt[5] = ""
  set chat_Taunt[6] = "666"
  set chat_Taunt[7] = ""
  set chat_Taunt[8] = "AI~"
  set chat_Taunt[9] = ""
  set chat_Taunt[10] = "BGM"
  set chat_Taunt[11] = ""
  set chat_Taunt[12] = "flag10"
  set chat_Taunt[13] = ""
  set chat_Taunt[14] = ""
  set chat_Taunt[15] = ""
  set chat_Taunt[16] = ""
  set chat_Taunt[17] = "ChatGPT1023"
  set chat_Taunt[18] = "CPU~"
  set chat_Taunt[19] = "~"
  set chat_Taunt[20] = ""
  set chat_Taunt[21] = "3570~"
  set chat_Taunt[22] = ""
  set chat_Taunt[23] = "~"
  set chat_Taunt[24] = "A--"
  set chat_Taunt[25] = ""
  set chat_Taunt[26] = ""
  set chat_Taunt[27] = ""
  set chat_Taunt_length = 28

  set chat_Thanks[0] = ""
  set chat_Thanks[1] = ""
  set chat_Thanks[2] = ""
  set chat_Thanks[3] = ""
  set chat_Thanks[4] = ""
  set chat_Thanks[5] = ""
  set chat_Thanks[6] = ""
  set chat_Thanks[7] = ""
  set chat_Thanks[8] = ""
  set chat_Thanks[9] = ""
  set chat_Thanks[10] = "........."
  set chat_Thanks[11] = "......"
  set chat_Thanks[12] = ""
  set chat_Thanks_length = 13


  set chat_no_unit_selected = ""
  set chat_confirm_attack_unit = "/"
  set chat_towerrush = "TR"
  set chat_no_orc = ""
  set militia_expansion_chat = ""
  set invalid_strategy_number = ""
  set chat_dynamic_counter = ""

  if chat_no_unit_selected == null or chat_no_unit_selected == "" then
    set chat_no_unit_selected = "No unit selected"
  endif
  if chat_confirm_attack_unit == null or chat_confirm_attack_unit == "" then
    set chat_confirm_attack_unit = "I will attack/guard the selected [TargetColor] [TargetRace] unit"
  endif
  if chat_towerrush == null or chat_towerrush == "" then
    set chat_towerrush = "I will try to towerrush someone"
  endif
  if chat_no_orc == null or chat_no_orc == "" then
    set chat_no_orc = "I do not want to towerrush anyone"
  endif
  if militia_expansion_chat == null or militia_expansion_chat == "" then
    set militia_expansion_chat = "I'm going for militia expansion over here"
  endif
  if chat_dynamic_counter == null or chat_dynamic_counter == "" then
    set chat_dynamic_counter = "and countering the enemies"
  endif
  if invalid_strategy_number == null or invalid_strategy_number == "" then
    set invalid_strategy_number = "Invalid Strategy Number"
  endif

endfunction


function CopyChatAGG takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_AGG_length
  loop
    exitwhen i >= chat_AGG_length
    set chat_list[i] = chat_AGG[i]
    set i = i + 1
  endloop
endfunction
function CopyChatAlly takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Ally_length
  loop
    exitwhen i >= chat_Ally_length
    set chat_list[i] = chat_Ally[i]
    set i = i + 1
  endloop
endfunction
function CopyChatAttack takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Attack_length
  loop
    exitwhen i >= chat_Attack_length
    set chat_list[i] = chat_Attack[i]
    set i = i + 1
  endloop
endfunction
function CopyChatCreep takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Creep_length
  loop
    exitwhen i >= chat_Creep_length
    set chat_list[i] = chat_Creep[i]
    set i = i + 1
  endloop
endfunction
function CopyChatDone takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Done_length
  loop
    exitwhen i >= chat_Done_length
    set chat_list[i] = chat_Done[i]
    set i = i + 1
  endloop
endfunction
function CopyChatEGG takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_EGG_length
  loop
    exitwhen i >= chat_EGG_length
    set chat_list[i] = chat_EGG[i]
    set i = i + 1
  endloop
endfunction
function CopyChatExpansion takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Expansion_length
  loop
    exitwhen i >= chat_Expansion_length
    set chat_list[i] = chat_Expansion[i]
    set i = i + 1
  endloop
endfunction
function CopyChatGoldproblem takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Goldproblem_length
  loop
    exitwhen i >= chat_Goldproblem_length
    set chat_list[i] = chat_Goldproblem[i]
    set i = i + 1
  endloop
endfunction
function CopyChatGreet takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Greet_length
  loop
    exitwhen i >= chat_Greet_length
    set chat_list[i] = chat_Greet[i]
    set i = i + 1
  endloop
endfunction
function CopyChatMega takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Mega_length
  loop
    exitwhen i >= chat_Mega_length
    set chat_list[i] = chat_Mega[i]
    set i = i + 1
  endloop
endfunction
function CopyChatMegatarget takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Megatarget_length
  loop
    exitwhen i >= chat_Megatarget_length
    set chat_list[i] = chat_Megatarget[i]
    set i = i + 1
  endloop
endfunction
function CopyChatTaunt takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Taunt_length
  loop
    exitwhen i >= chat_Taunt_length
    set chat_list[i] = chat_Taunt[i]
    set i = i + 1
  endloop
endfunction
function CopyChatThanks takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Thanks_length
  loop
    exitwhen i >= chat_Thanks_length
    set chat_list[i] = chat_Thanks[i]
    set i = i + 1
  endloop
endfunction

function CommonStratsDefault takes nothing returns nothing
  set strategy_name[50] = "airair"
  set strategy_default_name[50] = "Air-Air"
  set strategy_default_report[50] = "I build Air-Air units"
  set strategy_name[51] = "airground"
  set strategy_default_name[51] = "Air-Ground"
  set strategy_default_report[51] = "I build Air-Ground units"
  set strategy_name[52] = "groundair"
  set strategy_default_name[52] = "Ground-Air"
  set strategy_default_report[52] = "I build Ground-Air units"
  set strategy_name[53] = "groundground"
  set strategy_default_name[53] = "Ground-Ground"
  set strategy_default_report[53] = "I build Ground-Ground units"
  set strategy_name[54] = "farm"
  set strategy_default_name[54] = "Farms"
  set strategy_default_report[54] = "I build farms"
  set strategy_name[55] = "guard"
  set strategy_default_name[55] = "Towers"
  set strategy_default_report[55] = "I build towers"
endfunction

function InitChatArrays takes nothing returns nothing
  if false then
  elseif language == "English" then
    call InitChatArraysEnglish()
  elseif language == "Deutsch" then
    call InitChatArraysDeutsch()
  elseif language == "Swedish" then
    call InitChatArraysSwedish()
  elseif language == "French" then
    call InitChatArraysFrench()
  elseif language == "Spanish" then
    call InitChatArraysSpanish()
  elseif language == "Romanian" then
    call InitChatArraysRomanian()
  elseif language == "Russian" then
    call InitChatArraysRussian()
  elseif language == "Portuguese" then
    call InitChatArraysPortuguese()
  elseif language == "Norwegian" then
    call InitChatArraysNorwegian()
  elseif language == "Chinese" then
    call InitChatArraysChinese()
  endif
endfunction

function InitChatEvents takes nothing returns nothing
  set chat_target_ally[1] = true
  set chat_target_enemy[1] = false
  set chat_target_obs[1] = false
  set chat_important[1] = true
  set chat_target_ally[2] = true
  set chat_target_enemy[2] = false
  set chat_target_obs[2] = false
  set chat_important[2] = false
  set chat_target_ally[3] = true
  set chat_target_enemy[3] = false
  set chat_target_obs[3] = false
  set chat_important[3] = false
  set chat_target_ally[4] = true
  set chat_target_enemy[4] = false
  set chat_target_obs[4] = false
  set chat_important[4] = false
  set chat_target_ally[5] = true
  set chat_target_enemy[5] = false
  set chat_target_obs[5] = false
  set chat_important[5] = false
  set chat_target_ally[6] = false
  set chat_target_enemy[6] = true
  set chat_target_obs[6] = true
  set chat_important[6] = true
  set chat_target_ally[7] = true
  set chat_target_enemy[7] = false
  set chat_target_obs[7] = false
  set chat_important[7] = false
  set chat_target_ally[8] = true
  set chat_target_enemy[8] = false
  set chat_target_obs[8] = false
  set chat_important[8] = true
  set chat_target_ally[9] = false
  set chat_target_enemy[9] = true
  set chat_target_obs[9] = true
  set chat_important[9] = false
  set chat_target_ally[10] = false
  set chat_target_enemy[10] = true
  set chat_target_obs[10] = true
  set chat_important[10] = false
  set chat_target_ally[11] = true
  set chat_target_enemy[11] = false
  set chat_target_obs[11] = false
  set chat_important[11] = false
  set chat_target_ally[12] = false
  set chat_target_enemy[12] = true
  set chat_target_obs[12] = true
  set chat_important[12] = false
  set chat_target_ally[13] = true
  set chat_target_enemy[13] = false
  set chat_target_obs[13] = false
  set chat_important[13] = false
endfunction

function AddTranslation takes string lang, string strat_name, string trans_name, string trans_report returns nothing
  set translation[translation_length] = trans_name
  call SaveInteger(translation_map, StringHash(lang), StringHash("Name"+strat_name), translation_length)
  set translation_length = translation_length + 1
  set translation[translation_length] = trans_report
  call SaveInteger(translation_map, StringHash(lang), StringHash("Report"+strat_name), translation_length)
  set translation_length = translation_length + 1
endfunction

function InitTranslations takes nothing returns nothing
  local string lang = ""
  set lang = "English"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "I will play normal and build a little bit of everything")
  call AddTranslation(lang, "ROCMassHD", "Hunts and Dryads", "I'm going massive huntresses with a few dryads")
  call AddTranslation(lang, "ROCDruids", "Dryads and DotC", "I will build dryads and DotC")
  call AddTranslation(lang, "ROCHippo", "Hippo Riders", "I'll build hippo riders in mass")
  call AddTranslation(lang, "ROCBallista", "Ballista", "I'll do glaive throwers and dryads")
  call AddTranslation(lang, "ROCTalon", "Talon", "I gonna make tons of DotT")
  call AddTranslation(lang, "ROCHippoChim", "HippoChim", "I'll make hippos and chimaeras")
  call AddTranslation(lang, "ROCDryadChim", "DryadChim", "Going dryads and chimaeras")
  call AddTranslation(lang, "ROCArcher", "Archers", "Gonna amass archers")
  call AddTranslation(lang, "ROCDotC", "Bears", "Trying mass DotC")
  call AddTranslation(lang, "NormalElf", "Normal", "I am building a little bit of everything")
  call AddTranslation(lang, "MassHD", "Hunts and Dryads", "I'm massing huntresses with a few dryads")
  call AddTranslation(lang, "Druids", "Dryads and DotC", "I'm mixing Dryads with Druids of the Claw")
  call AddTranslation(lang, "Hippo", "Hippo Riders", "I'm massing Hippo Riders")
  call AddTranslation(lang, "Ballista", "Ballista", "I'm building Glaive Throwers and Dryads")
  call AddTranslation(lang, "Talon", "Talon", "I'm massing Druids of the Talon")
  call AddTranslation(lang, "HippoChim", "HippoChim", "I'm building Hippos and Chimaeras")
  call AddTranslation(lang, "DryadChim", "DryadChim", "I'm building Dryads and Chimaeras")
  call AddTranslation(lang, "Archer", "Archers", "I'm massing Archers")
  call AddTranslation(lang, "DotC", "Bears", "Trying mass Druids of the Claw")
  call AddTranslation(lang, "MassHuntress", "Mass Hunts", "I'm massing Huntresses")
  call AddTranslation(lang, "MGDryads", "Dryads and MGs", "I'm building Dryads and Mountain Giants")
  call AddTranslation(lang, "AoWMix", "AoW Mix", "I'm mixing units from the Ancient of War")
  call AddTranslation(lang, "AolMix", "AoL Mix", "I'm mixing units from the Ancient of Lore")
  call AddTranslation(lang, "NEAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "I'll play normal and build a little bit of everything")
  call AddTranslation(lang, "ROCMassSp", "Casters", "I'm going massive spell casters")
  call AddTranslation(lang, "ROCGryph", "Gryphon", "I will build gryphon riders")
  call AddTranslation(lang, "ROCKnight", "Knights", "I'll build footmen and knights in mass")
  call AddTranslation(lang, "ROCRifle", "Rifle", "I'm gonna make riflemen")
  call AddTranslation(lang, "ROCMortars", "Mortars", "I'm going mortars")
  call AddTranslation(lang, "ROCCopters", "Copters", "I do mass flying machines")
  call AddTranslation(lang, "NormalHuman", "Normal", "I'm building a little bit of everything")
  call AddTranslation(lang, "MassSp", "Casters", "I'm massing Spell Casters")
  call AddTranslation(lang, "Gryph", "Gryphon", "I'm massing Gryphon Riders")
  call AddTranslation(lang, "Knight", "Knights", "I'm building Footman and Knights")
  call AddTranslation(lang, "Rifle", "Rifle", "I'm building Riflemen and Priests")
  call AddTranslation(lang, "Mortars", "Mortars", "I'm building Mortars and Riflemen")
  call AddTranslation(lang, "Copters", "Copters", "I'm constructing Flying Machines")
  call AddTranslation(lang, "MassSB", "SpellBreakers", "I'm massing Spell Breakers")
  call AddTranslation(lang, "Dragonhawk", "Dragon Hawks", "I'm massing Dragon Hawks")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "I'm trying to mix units from the Barracks and Workshop")
  call AddTranslation(lang, "SanctumMix", "Sanctum Mix", "I'm trying to mix units from the Sanctum and Aviary")
  call AddTranslation(lang, "HAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusOrc", "Mass Sorceress", "I'm massing Sorceress")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "I'm going to play normal and build a little bit of everything")
  call AddTranslation(lang, "ROCFastSh", "Shamans and Taurens", "I will make casters and taurens")
  call AddTranslation(lang, "ROCKodo", "Kodo", "I'm gonna go massive kodo-beasts")
  call AddTranslation(lang, "ROCWyvSh", "Shamans and Wyverns", "Going Shamans and Wyverns")
  call AddTranslation(lang, "ROCHHunters", "Head Hunters", "Trying massive head hunters")
  call AddTranslation(lang, "ROCRaiders", "Raiders", "I'm make massive raiders")
  call AddTranslation(lang, "ROCCatapults", "Grunts and Catapults", "I'm going to do grunts and demolishers")
  call AddTranslation(lang, "ROCHeadCatapults", "Head hunters and Catapults", "Let's try headhunters and demolishers")
  call AddTranslation(lang, "NormalOrc", "Normal", "I'm building a little bit of everything")
  call AddTranslation(lang, "FastSh", "Shamans and Taurens", "I'm mixing casters with Taurens")
  call AddTranslation(lang, "WyvSh", "Shamans and Wyverns", "I'm training Shamans and Wyverns")
  call AddTranslation(lang, "HHunters", "Head Hunters", "I'm massing Head Hunters")
  call AddTranslation(lang, "Raiders", "Raiders", "I'm massing Raiders")
  call AddTranslation(lang, "GruntCatapults", "Grunts and Catapults", "I'm building Grunts and Demolishers")
  call AddTranslation(lang, "HeadCatapults", "Head hunters and Catapults", "I'm trying Headhunters and Demolishers")
  call AddTranslation(lang, "Wyvern", "Mass Wyvern", "I'm massing Wyverns")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "I'm mixing units from the Barracks")
  call AddTranslation(lang, "BestiaryMix", "Bestiary Mix", "I'm mixing units from the Bestiary")
  call AddTranslation(lang, "AntiPierce", "Anti Pierce", "I'm mixing melee units and Raiders")
  call AddTranslation(lang, "AntiAir", "Batriders", "I'm massing Batriders")
  call AddTranslation(lang, "OAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusHuman", "Raiders and Spirtwalkers", "I'm mixing Raiders and Spirit Walkers")
  call AddTranslation(lang, "VersusUndead", "Grunts and Beastiary", "I'm building Grunts with a mix from the beastiary")
  call AddTranslation(lang, "VersusElf", "Raiders and Demolishers", "I'm building Raiders and Demolishers")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "I will play normal and build a little bit of everything")
  call AddTranslation(lang, "ROCWyrms", "Wyrms", "Going wyrms and a few crypt fiends")
  call AddTranslation(lang, "ROCBanshee", "Banshees", "I'll go mostly banshees")
  call AddTranslation(lang, "ROCNecro", "Necros", "Trying necromancers")
  call AddTranslation(lang, "ROCGhouls", "Ghouls", "I will build mass ghouls")
  call AddTranslation(lang, "ROCFiends", "Fiends", "I'm gonna go mass crypt fiends")
  call AddTranslation(lang, "ROCGargWyrm", "Gargoyles and Wyrms", "I'll do gargs and wyrms")
  call AddTranslation(lang, "ROCAboms", "Aboms", "I'm going massive abominations")
  call AddTranslation(lang, "ROCMeatFiends", "Meat wagons and Fiends", "I'll try going fiends and meat wagons")
  call AddTranslation(lang, "NormalUndead", "Normal", "I'm building a little bit of everything")
  call AddTranslation(lang, "Wyrms", "Wyrms", "I'm mixing Wyrms with a few crypt fiends")
  call AddTranslation(lang, "Banshee", "Banshees", "I'm massing Banshees")
  call AddTranslation(lang, "Necro", "Necros", "I'm massing Necromancers")
  call AddTranslation(lang, "Ghouls", "Ghouls", "I'm massing Ghouls")
  call AddTranslation(lang, "GargGhouls", "Gargoyles and Ghouls", "I'm massing Gargs and Ghouls")
  call AddTranslation(lang, "Fiends", "Fiends", "I'm massing Crypt Fiends")
  call AddTranslation(lang, "GargWyrm", "Gargoyles and Wyrms", "I'm massing Gargs and Wyrms")
  call AddTranslation(lang, "Aboms", "Aboms", "I'm massing Abominations")
  call AddTranslation(lang, "MeatFiends", "Meat wagons and Fiends", "I'm building Fiends and Meat Wagons")
  call AddTranslation(lang, "MassDestroyer", "Mass Destroyers", "I'm massing Destroyers")
  call AddTranslation(lang, "CryptMix", "Crypt Mix", "I'm mixing units from the Crypt and Slaughterhouse")
  call AddTranslation(lang, "TempleMix", "Temple Mix", "I'm mixing units from the Temple of the Damned and Slaughterhouse")
  call AddTranslation(lang, "UAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "airair", "Air-Air", "I'm building Air to Air units")
  call AddTranslation(lang, "airground", "Air-Ground", "I'm building Air to Ground units")
  call AddTranslation(lang, "groundair", "Ground-Air", "I'm building Ground to Air units")
  call AddTranslation(lang, "groundground", "Ground-Ground", "I'm building Ground to Ground units")
  call AddTranslation(lang, "farm", "Farms", "I'm building farms")
  call AddTranslation(lang, "guard", "Towers", "I'm building towers")
  set lang = "Deutsch"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "Ich spiele normal und baue von Allem etwas")
  call AddTranslation(lang, "ROCMassHD", "Jgerinnen und Dryaden", "Ich baue massiv Jgerinnen mit ein paar Dryaden")
  call AddTranslation(lang, "ROCDruids", "Dryaden und Brchen", "Ich baue Dryaden and Brchen")
  call AddTranslation(lang, "ROCHippo", "Hipporeiterinnen", "Ich baue Hipporeiterinnen")
  call AddTranslation(lang, "ROCBallista", "Ballistas", "Ich baue Ballistas and Dryaden")
  call AddTranslation(lang, "ROCTalon", "Klauendruiden", "Ich baue massiv Klauendruiden")
  call AddTranslation(lang, "ROCHippoChim", "HippoChi", "Ich baue Hippos and Schimren")
  call AddTranslation(lang, "ROCDryadChim", "DryadChim", "Ich baue Dryaden and Schimren")
  call AddTranslation(lang, "ROCArcher", "Bogenschtzen", "Ich baue massiv Bogenschtzen")
  call AddTranslation(lang, "ROCDotC", "Bren", "Ich baue massiv Bren")
  call AddTranslation(lang, "NormalElf", "Normal", "Ich spiele normal und baue von Allem etwas")
  call AddTranslation(lang, "MassHD", "Jgerinnen und Dryaden", "Ich baue massiv Jgerinnen mit ein paar Dryaden")
  call AddTranslation(lang, "Druids", "Dryaden und Bren", "Ich baue Dryaden and Bren")
  call AddTranslation(lang, "Hippo", "Hipporeiterinnen", "Ich baue Hipporeiterinnen")
  call AddTranslation(lang, "Ballista", "Ballistas", "Ich baue Ballistas and Dryaden")
  call AddTranslation(lang, "Talon", "Klauendruiden", "Ich baue massiv Klauendruiden")
  call AddTranslation(lang, "HippoChim", "HippoChi", "Ich baue Hippos and Schimren")
  call AddTranslation(lang, "DryadChim", "DryadChim", "Ich baue Dryaden and Schimren")
  call AddTranslation(lang, "NEAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "Archer", "Bogenschtzen", "Ich baue massiv Bogenschtzen")
  call AddTranslation(lang, "DotC", "Brchen", "Ich baue massiv Brchen")
  call AddTranslation(lang, "MassHuntress", "Jgerinnen", "Ich baue massiv Jgerinnen")
  call AddTranslation(lang, "MGDryads", "Dryaden und Bergriesen", "Ich baue Dryaden und Bergriesen")
  call AddTranslation(lang, "AoWMix", "Einheitenmix aus AoW", "Ich mixe Einheiten aus dem AoW")
  call AddTranslation(lang, "AoLMix", "Einheitenmix aus AoL", "Ich mixe Einheiten aus dem AoL")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "Ich spiele normal und baue von Allem etwas")
  call AddTranslation(lang, "ROCMassSp", "Zauberer", "Ich baue massiv Zauberer")
  call AddTranslation(lang, "ROCGryph", "Greifen", "Ich baue Greifenreiter")
  call AddTranslation(lang, "ROCKnight", "Ritter", "Ich baue massiv Soldaten und Ritter")
  call AddTranslation(lang, "ROCRifle", "Schtzen", "Ich baue massiv Schtzen")
  call AddTranslation(lang, "ROCMortars", "Mrser-Truppen", "Ich baue Mrser-Truppen")
  call AddTranslation(lang, "ROCCopters", "Gyrokopter", "Ich baue Gyrokopter")
  call AddTranslation(lang, "NormalHuman", "Normal", "Ich spiele normal und baue von Allem etwas")
  call AddTranslation(lang, "MassSp", "Zauberer", "Ich baue massiv Zauberer")
  call AddTranslation(lang, "Gryph", "Greifen", "Ich baue Greifenreiter")
  call AddTranslation(lang, "Knight", "Ritter", "Ich baue massiv Soldaten und Ritter")
  call AddTranslation(lang, "Rifle", "Schtzen", "Ich baue massiv Schtzen")
  call AddTranslation(lang, "Mortars", "Mrser-Truppen", "Ich baue Mrser-Truppen")
  call AddTranslation(lang, "Copters", "Gyrokopter", "Ich baue Gyrokopter")
  call AddTranslation(lang, "MassSB", "Zauberbrecher", "Ich baue massiv Zauberbrecher")
  call AddTranslation(lang, "Dragonhawk", "Drachenfalkenreiter", "Ich baue massiv Drachenfalkenreiter")
  call AddTranslation(lang, "BarrackMix", "Einheitenmix aus Kaserne", "Ich mixe Einheiten aus der Kaserne")
  call AddTranslation(lang, "SanctumMix", "Einheitenmix aus Sanktum", "Ich mixe Einheiten aus dem Sanktum")
  call AddTranslation(lang, "HAntiTower", "Anti Trme", "Ich baue massiv Belagerungswaffen")
  call AddTranslation(lang, "VersusOrc", "Zauberinnen", "Ich baue massiv Zauberinnen")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "Ich baue Grunzer und Zauberer")
  call AddTranslation(lang, "ROCFastSh", "Schamanen und Tauren", "Ich baue Schamanen und Tauren")
  call AddTranslation(lang, "ROCKodo", "Kodo", "Ich baue massiv Kodo-Bestien")
  call AddTranslation(lang, "ROCWyvSh", "Schamanen und Wyverns", "Ich baue Schamanen und Wyverns")
  call AddTranslation(lang, "ROCHHunters", "Kopfjger", "Ich baue massiv Kopfjger")
  call AddTranslation(lang, "ROCRaiders", "Ruber", "Ich baue massiv Ruber")
  call AddTranslation(lang, "ROCCatapults", "Katapulte", "Ich baue Grunzer und Katapulte")
  call AddTranslation(lang, "ROCHeadCatapults", "Kopfjger und Katapulte", "Ich baue Kopfjger und Katapulte")
  call AddTranslation(lang, "NormalOrc", "Normal", "Ich baue Grunzer und Zauberer")
  call AddTranslation(lang, "FastSh", "Schamanen und Tauren", "Ich baue Schamanen und Tauren")
  call AddTranslation(lang, "WyvSh", "Schamanen und Wyverns", "Ich baue Schamanen und Wyverns")
  call AddTranslation(lang, "HHunters", "Kopfjger", "Ich baue massiv Kopfjger")
  call AddTranslation(lang, "Raiders", "Ruber", "Ich baue massiv Ruber")
  call AddTranslation(lang, "GruntCatapults", "Grunzer und Katapulte", "Ich baue Grunzer und Katapulte")
  call AddTranslation(lang, "HeadCatapults", "Kopfjger und Katapulte", "Ich baue Kopfjger und Katapulte")
  call AddTranslation(lang, "Wyvern", "Windreiter", "Ich baue massiv Windreiter")
  call AddTranslation(lang, "BarrackMix", "Einheitenmix aus Kaserne", "Ich mixe Einheiten aus der Kaserne")
  call AddTranslation(lang, "BestiaryMix", "Einheitenmix aus Bestiarium", "Ich mixe Einheiten aus dem Bestiarium")
  call AddTranslation(lang, "AntiPierce", "Nahkampf", "Ich baue Nahkampfeinheiten und Ruber")
  call AddTranslation(lang, "AntiAir", "Fledermausreiter", "Ich baue massiv Fledermausreiter")
  call AddTranslation(lang, "OAntiTower", "Anti Trme", "Ich baue massiv Belagerungswaffen")
  call AddTranslation(lang, "VersusHuman", "Ruber und Geistlufer", "Ich baue Ruber und Geisterlufer")
  call AddTranslation(lang, "VersusUndead", "Grunzer und Bestiarium", "Ich baue Grunzer und mixe Einheiten aus dem Bestiarium")
  call AddTranslation(lang, "VersusElf", "Ruber und Verwster", "Ich baue Ruber und Verwster")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "Ich spiele normal und baue von Allem etwas")
  call AddTranslation(lang, "ROCWyrms", "Wyrms", "Ich versuche einen Wyrmrush mit ein paar Gruftbestien")
  call AddTranslation(lang, "ROCBanshee", "Banshees", "Ich baue hauptschlich Banshees")
  call AddTranslation(lang, "ROCNecro", "Totenbeschwrer", "Ich baue Totenbeschwrer")
  call AddTranslation(lang, "ROCGhouls", "Ghoule", "Ich baue massiv Ghoule")
  call AddTranslation(lang, "ROCFiends", "Gruftbestien", "Ich baue massiv Gruftbestien")
  call AddTranslation(lang, "ROCGargWyrm", "Gargoyles and Wyrms", "Ich baue Gargoyles and Wyrms")
  call AddTranslation(lang, "ROCAboms", "Monstrositten", "Ich baue massiv Monstrositten")
  call AddTranslation(lang, "ROCMeatFiends", "Fleischwagen und Gruftbestien", "Ich baue Gruftbestien und Fleischwagen")
  call AddTranslation(lang, "MassDestroyer", "Zerstrer", "Ich baue massiv Zerstrer")
  call AddTranslation(lang, "NormalUndead", "Normal", "Ich spiele normal und baue von Allem etwas")
  call AddTranslation(lang, "Wyrms", "Wyrms", "Ich versuche einen Wyrmrush mit ein paar Gruftbestien")
  call AddTranslation(lang, "Banshee", "Banshees", "Ich baue hauptschlich Banshees")
  call AddTranslation(lang, "Necro", "Totenbeschwrer", "Ich baue Totenbeschwrer")
  call AddTranslation(lang, "Ghouls", "Ghoule", "Ich baue massiv Ghoule")
  call AddTranslation(lang, "GargGhouls", "Gargoyles and Ghoule", "Ich baue Gargoyles and Ghoule")
  call AddTranslation(lang, "Fiends", "Gruftbestien", "Ich baue massiv Gruftbestien")
  call AddTranslation(lang, "GargWyrm", "Gargoyles and Wyrms", "Ich baue Gargoyles and Wyrms")
  call AddTranslation(lang, "Aboms", "Monstrositten", "Ich baue massiv Monstrositten")
  call AddTranslation(lang, "MeatFiends", "Fleischwagen und Gruftbestien", "Ich baue Gruftbestien und Fleischwagen")
  call AddTranslation(lang, "MassDestroyer", "Zerstrer", "Ich baue massiv Zerstrer")
  call AddTranslation(lang, "CryptMix", "Einheitenmix aus Gruft", "Ich mixe Einheiten aus der Gruft")
  call AddTranslation(lang, "TempleMix", "Einheitenmix aus Tempel", "Ich mixe Einheiten aus dem Tempel der Verdammten")
  call AddTranslation(lang, "UAntiTower", "Anti Trme", "Ich baue massiv Belagerungswaffen")
  call AddTranslation(lang, "airair", "Luft-Luft", "Ich baue Luft-Luft-Einheiten")
  call AddTranslation(lang, "airground", "Luft-Boden", "Ich baue Luft-Boden-Einheiten")
  call AddTranslation(lang, "groundair", "Boden-Luft", "Ich baue Boden-Luft-Einheiten")
  call AddTranslation(lang, "groundground", "Boden-Boden", "Ich baue Boden-Boden-Einheiten")
  call AddTranslation(lang, "farm", "Farmen", "Ich baue Farmen")
  call AddTranslation(lang, "guard", "Trme", "Ich baue Trme")
  set lang = "Swedish"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "Jag spelar som vanligt och bygger lite av varje")
  call AddTranslation(lang, "ROCMassHD", "Hunts och Dryads", "Jag bygger huntress och ett par dryads")
  call AddTranslation(lang, "ROCDruids", "Dryads och DotC", "Jag skaffar dryads och DotC")
  call AddTranslation(lang, "ROCHippo", "Hippo Riders", "Jag bygger hippo riders")
  call AddTranslation(lang, "ROCBallista", "Ballista", "Jag skaffar ballista och dryads")
  call AddTranslation(lang, "ROCTalon", "Talon", "Jag bygger massa DotT")
  call AddTranslation(lang, "ROCHippoChim", "HippoChim", "Jag bygger hippos och chimaeras")
  call AddTranslation(lang, "ROCDryadChim", "DryadChim", "Jag skaffar dryads och chimaeras")
  call AddTranslation(lang, "ROCArcher", "Archers", "Jag bygger mass archers")
  call AddTranslation(lang, "ROCDotC", "DotC", "Jag bygger mass DotC")
  call AddTranslation(lang, "NormalElf", "Normal", "Jag spelar som vanligt och bygger lite av varje")
  call AddTranslation(lang, "MassHD", "Hunts och Dryads", "Jag bygger huntress och ett par dryads")
  call AddTranslation(lang, "Druids", "Dryads och DotC", "Jag skaffar dryads och DotC")
  call AddTranslation(lang, "Hippo", "Hippo Riders", "Jag bygger hippo riders")
  call AddTranslation(lang, "Ballista", "Ballista", "Jag skaffar ballista och dryads")
  call AddTranslation(lang, "Talon", "Talon", "Jag bygger massa DotT")
  call AddTranslation(lang, "HippoChim", "HippoChim", "Jag bygger hippos och chimaeras")
  call AddTranslation(lang, "DryadChim", "DryadChim", "Jag skaffar dryads och chimaeras")
  call AddTranslation(lang, "Archer", "Archers", "Jag bygger mass archers")
  call AddTranslation(lang, "DotC", "DotC", "Jag bygger mass DotC")
  call AddTranslation(lang, "MassHuntress", "MassHunts", "Jag bygger massvis med huntress")
  call AddTranslation(lang, "MGDryads", "MGDryads", "Jag bygger mountain giants och dryader")
  call AddTranslation(lang, "AoWMix", "AoWMix", "Jag mixar enheter fran ancient of war")
  call AddTranslation(lang, "AoLMix", "AoLMix", "Jag mixar enheter fran ancient of lore och ancient of wind")
  call AddTranslation(lang, "NEAntiTower", "Anti Torn", "Jag massar siege")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "Jag spelar vanligt och bygger lite av varje")
  call AddTranslation(lang, "ROCMassSp", "Casters", "Jag massar casters")
  call AddTranslation(lang, "ROCGryph", "Gryphon", "Jag bygger massa gryphons")
  call AddTranslation(lang, "ROCKnight", "Knights", "Jag skaffar footmen och knights")
  call AddTranslation(lang, "ROCRifle", "Rifle", "Jag bygger massa riflemen")
  call AddTranslation(lang, "ROCMortars", "Mortars", "Jag skaffar mortars och riflemen")
  call AddTranslation(lang, "ROCCopters", "Copters", "Jag massar flygmaskiner")
  call AddTranslation(lang, "NormalHuman", "Normal", "Jag spelar vanligt och bygger lite av varje")
  call AddTranslation(lang, "MassSp", "Casters", "Jag massar casters")
  call AddTranslation(lang, "Gryph", "Gryphon", "Jag bygger massa gryphons")
  call AddTranslation(lang, "Knight", "Knights", "Jag skaffar footmen och knights")
  call AddTranslation(lang, "Rifle", "Rifle", "Jag bygger massa riflemen")
  call AddTranslation(lang, "Mortars", "Mortars", "Jag skaffar mortars och riflemen")
  call AddTranslation(lang, "Copters", "Copters", "Jag massar flygmaskiner")
  call AddTranslation(lang, "MassSB", "MassSpellBreakers", "Jag bygger massvis med spell breakers")
  call AddTranslation(lang, "Dragonhawk", "Dragonhawks", "Jag bygger massa dragonhawks")
  call AddTranslation(lang, "BarrackMix", "BarrackMix", "Jag mixar enheter fran barrack och workshop")
  call AddTranslation(lang, "SanctumMix", "SanctumMix", "Jag mizar enheter fran sanctum och aviary")
  call AddTranslation(lang, "HAntiTower", "Anti Torn", "Jag massar siege")
  call AddTranslation(lang, "VersusOrc", "Mass Sorceress", "Jag bygger massa sorceress")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "Jag skaffar grunts och casters")
  call AddTranslation(lang, "ROCFastSh", "Shamans och Taurens", "Jag skaffar shamans och taurens")
  call AddTranslation(lang, "ROCKodo", "Kodo", "Jag bygger massa kodo-beast")
  call AddTranslation(lang, "ROCWyvSh", "Shamans och Wyverns", "Jag bygger shamans och wyverns")
  call AddTranslation(lang, "ROCHHunters", "Head Hunters", "Jag bygger massa head hunters")
  call AddTranslation(lang, "ROCRaiders", "Raiders", "Jag bygger massa raiders")
  call AddTranslation(lang, "ROCCatapults", "Grunts och Katapulter", "Jag bygger grunts och katapulter")
  call AddTranslation(lang, "ROCHeadCatapults", "Head Hunters och Katapulter", "Jag skaffar headhunters och katapulter")
  call AddTranslation(lang, "NormalOrc", "Normal", "Jag skaffar grunts och casters")
  call AddTranslation(lang, "FastSh", "Shamans och Taurens", "Jag skaffar shamans och taurens")
  call AddTranslation(lang, "WyvSh", "Shamans och Wyverns", "Jag bygger shamans och wyverns")
  call AddTranslation(lang, "HHunters", "Head Hunters", "Jag bygger massa head hunters")
  call AddTranslation(lang, "Raiders", "Raiders", "Jag bygger massa raiders")
  call AddTranslation(lang, "GruntCatapults", "Grunts och Katapulter", "Jag bygger grunts och katapulter")
  call AddTranslation(lang, "HeadCatapults", "Head hunters och Katapulter", "Jag skaffar head hunters och katapulter")
  call AddTranslation(lang, "Wyvern", "Wyverns", "Jag bygger massa wyverns")
  call AddTranslation(lang, "BarrackMix", "BarrackMix", "Jag mixar enheter fran barrack")
  call AddTranslation(lang, "BestiaryMix", "BestiaryMix", "Jag mixar enheter fran bestiary")
  call AddTranslation(lang, "AntiPierce", "Anti Pierce", "Jag skaffar melee och raiders")
  call AddTranslation(lang, "AntiAir", "Batriders", "Jag massar bats")
  call AddTranslation(lang, "OAntiTower", "Anti Torn", "Jag massar siege")
  call AddTranslation(lang, "VersusHuman", "Raiders and Spirtwalkers", "Jag bygger p?raiders och spirit walkers")
  call AddTranslation(lang, "VersusUndead", "Grunts and Beastiary", "Jag bygger grunts och lite blandat fran beastiary")
  call AddTranslation(lang, "VersusElf", "Raiders and Demolishers", "Jag bygger raiders och demolishers")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "Jag spelar som vanligt och bygger lite av varje")
  call AddTranslation(lang, "ROCWyrms", "Wyrms", "Jag bygger wyrms och crypt fiends")
  call AddTranslation(lang, "ROCBanshee", "Banshees", "Jag skaffar banshees")
  call AddTranslation(lang, "ROCNecro", "Necros", "Jag bygger necromancers")
  call AddTranslation(lang, "ROCGhouls", "Ghouls", "Jag bygger massa ghouls")
  call AddTranslation(lang, "ROCFiends", "Fiends", "Jag bygger massa crypt fiends")
  call AddTranslation(lang, "ROCGargWyrm", "Gargoyles och Wyrms", "Jag bygger gargs och wyrms")
  call AddTranslation(lang, "ROCAboms", "Aboms", "Jag skaffar massa abominations")
  call AddTranslation(lang, "ROCMeatFiends", "Meat wagons och Fiends", "Jag bygger fiends och meat wagons")
  call AddTranslation(lang, "NormalUndead", "Normal", "Jag spelar som vanligt och bygger lite av varje")
  call AddTranslation(lang, "Wyrms", "Wyrms", "Jag bygger wyrms och crypt fiends")
  call AddTranslation(lang, "Banshee", "Banshees", "Jag skaffar banshees")
  call AddTranslation(lang, "Necro", "Necros", "Jag bygger necromancers")
  call AddTranslation(lang, "Ghouls", "Ghouls", "Jag bygger massa ghouls")
  call AddTranslation(lang, "GargGhouls", "Gargoyles och Ghouls", "Jag bygger gargs och ghouls")
  call AddTranslation(lang, "Fiends", "Fiends", "Jag bygger massa crypt fiends")
  call AddTranslation(lang, "GargWyrm", "Gargoyles och Wyrms", "Jag bygger gargs och wyrms")
  call AddTranslation(lang, "Aboms", "Aboms", "Jag skaffar massa abominations")
  call AddTranslation(lang, "MeatFiends", "Meat wagons och Fiends", "Jag bygger fiends och meat wagons")
  call AddTranslation(lang, "MassDestroyer", "MassDestroyers", "Jag bygger massa destroyers")
  call AddTranslation(lang, "CryptMix", "CryptMix", "Jag mixar enheter fran crypt")
  call AddTranslation(lang, "TempleMix", "TempleMix", "Jag mixar enheter fran temple och slaughter house")
  call AddTranslation(lang, "UAntiTower", "Anti Torn", "Jag massar siege")
  call AddTranslation(lang, "airair", "Luft-Luft", "Jag bygger luft- mot luftenheter")
  call AddTranslation(lang, "airground", "Luft-Mark", "Jag bygger luft- mot markenheter")
  call AddTranslation(lang, "groundair", "Mark-Luft", "Jag bygger mark- mot luftenheter")
  call AddTranslation(lang, "groundground", "Mark-Mark", "Jag bygger mark- mot markenheter")
  call AddTranslation(lang, "farm", "Farms", "Jag bygger farms")
  call AddTranslation(lang, "guard", "Torn", "Jag bygger torn")
  set lang = "French"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "Je joue normalement et je construis quelque chose de tout.")
  call AddTranslation(lang, "ROCMassHD", "Chasseresses et Dryades.", "Je vais creer massivement des chasseresses avec quelques Dryades.")
  call AddTranslation(lang, "ROCDruids", "Dryades et Druides Ours.", "Je vais creer des Dryades et des Druides Ours.")
  call AddTranslation(lang, "ROCHippo", "Chevaucheurs d'hippogryphe.", "Je vais creer Chevaucheurs d'hippogryphe.")
  call AddTranslation(lang, "ROCBallista", "Baliste.", "I'm going glaive throwers and dryads")
  call AddTranslation(lang, "ROCTalon", "Druide Corbeau.", "Je vais creer des druides corbeau massivement.")
  call AddTranslation(lang, "ROCHippoChim", "Hippogryphe et Chimere.", "Je vais creer des Hippogryphes et des chimeres.")
  call AddTranslation(lang, "ROCDryadChim", "Dryades et Chimeres.", "Je vais creer des Dryades et des Chimeres.")
  call AddTranslation(lang, "ROCArcher", "Archers", "Je vais creer des archers en masse.")
  call AddTranslation(lang, "ROCDotC", "Druides Ours", "Je vais creer des Druides Ours massivement.")
  call AddTranslation(lang, "NormalElf", "Normal", "Je vais jouer normalement, je vais faire un peu de tout")
  call AddTranslation(lang, "MassHD", "Hunts and Dryads", "Je vais faire des chasseresses et des dryades")
  call AddTranslation(lang, "Druids", "Dryads and DotC", "Je vais faire des dryades et des druides ours")
  call AddTranslation(lang, "Hippo", "Hippo Riders", "Je vais faire beaucoups de chevaucheurs d'hippogryphe")
  call AddTranslation(lang, "Ballista", "Ballista", "Je vais construire des balistes et des dryades")
  call AddTranslation(lang, "Talon", "Talon", "Je vais construire des druides corbeaux en masse")
  call AddTranslation(lang, "HippoChim", "HippoChim", "Je vais aller pour des hippogryphes et des Chimres")
  call AddTranslation(lang, "DryadChim", "DryadChim", "Je m'occupe des dryades et des chimres")
  call AddTranslation(lang, "Archer", "Archers", "Je vaise faire beaucoup d'archers")
  call AddTranslation(lang, "DotC", "Bears", "Je vais m'occuper de faire des druides ours ")
  call AddTranslation(lang, "MassHuntress", "Mass Hunts", "Je vais faire beaucoup de chasseresses")
  call AddTranslation(lang, "MGDryads", "Dryads and MGs", "Je vais utiliser des dryades et des gants")
  call AddTranslation(lang, "AoWMix", "AoW Mix", "Je fais utiliser des units de l'ancient du vent")
  call AddTranslation(lang, "AolMix", "AoL Mix", "Je vais mlanger des units de l'ancient de Lore")
  call AddTranslation(lang, "NEAntiTower", "Anti Tower", "Je vais utiliser du sige")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "Je joue normalement et je construis quelque chose de tout.")
  call AddTranslation(lang, "ROCMassSp", "Casters", "Je vais creer des casters massivement.")
  call AddTranslation(lang, "ROCGryph", "Chevaucheur de griffon.", "Je vais creer des Chevaucheurs de griffon.")
  call AddTranslation(lang, "ROCKnight", "Chevaliers.", "Je vais creer des Fantassins et des Chevaliers en masse.")
  call AddTranslation(lang, "ROCRifle", "Fusilier.", "Je vais creer massivement des Fusiliers.")
  call AddTranslation(lang, "ROCMortars", "Mortiers", "Je vais creer massivement des Mortiers.")
  call AddTranslation(lang, "ROCCopters", "Gyrocopteres.", "Je vais creer des Gyrocopteres.")
  call AddTranslation(lang, "NormalHuman", "Normal", "Je vais jouer normalement, avec un peu de tout.")
  call AddTranslation(lang, "MassSp", "Casters", "Je vais masser des caster de sorts")
  call AddTranslation(lang, "Gryph", "Gryphon", "je vais faire des gryphons")
  call AddTranslation(lang, "Knight", "Knights", "Je vais faire des chevalier et des fantassins")
  call AddTranslation(lang, "Rifle", "Rifle", "Je vais faire des fusilier et des prtre")
  call AddTranslation(lang, "Mortars", "Mortars", "Je m'occupe des fusiliers et des mortiers")
  call AddTranslation(lang, "Copters", "Copters", "Je vais m'occuper des gyrocoptres")
  call AddTranslation(lang, "MassSB", "SpellBreakers", "Je vais masser des briseurs de sorts")
  call AddTranslation(lang, "Dragonhawk", "Dragon Hawks", "Je vais utiliser des chevaucheur de dragons ")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "Je vais mlanger des units des barraques et de l'atelier")
  call AddTranslation(lang, "SanctumMix", "Sanctum Mix", "Jssai de mlanger des units du Sanctum")
  call AddTranslation(lang, "HAntiTower", "Anti Tower", "Je vais faire beaucoup de siges")
  call AddTranslation(lang, "VersusOrc", "Mass Sorceress", "Je m'occupe des sorcires")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "Je vais creer des grunts et des casters.")
  call AddTranslation(lang, "ROCFastSh", "Chamans et Taurens.", "Je vais creer des Chamans et des Taurens.")
  call AddTranslation(lang, "ROCKodo", "Bete Kodo.", "Je vais creer des Betes Kodo en masse.")
  call AddTranslation(lang, "ROCWyvSh", "Chamans and Wyvernes.", "Je vais creer des Chamans et des Wyvernes.")
  call AddTranslation(lang, "ROCHHunters", "Chasseurs de tetes.", "Je vais creer massivement des Chasseurs de tetes.")
  call AddTranslation(lang, "ROCRaiders", "Chevaucheurs de Loup.", "Je vais creer des Chevaucheurs de Loup en masse.")
  call AddTranslation(lang, "ROCCatapults", "Grunts and Catapultes.", "Je vais creer des grunts et des demolishers.")
  call AddTranslation(lang, "ROCHeadCatapults", "Chasseurs de tetes and Catapultes.", "Je vais creer des Chasseurs de tetes et des demolishers.")
  call AddTranslation(lang, "NormalOrc", "Normal", "Je vais faire des grunts et des casters")
  call AddTranslation(lang, "FastSh", "Shamans and Taurens", "Je m'occupe des casters et des taurens")
  call AddTranslation(lang, "WyvSh", "Shamans and Wyverns", "Je vais essayer des shamans et des wyverns")
  call AddTranslation(lang, "HHunters", "Head Hunters", "Je vais masser des trolls")
  call AddTranslation(lang, "Raiders", "Raiders", "Je mass des chevaucheurs de loups")
  call AddTranslation(lang, "GruntCatapults", "Grunts and Catapults", "Je vais faire du sige et des grunts")
  call AddTranslation(lang, "HeadCatapults", "Head hunters and Catapults", "jssai des trolls et des catapultes")
  call AddTranslation(lang, "Wyvern", "Mass Wyvern", "Je m'occupe des wyvernes")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "Je fais un mlanege des barraques")
  call AddTranslation(lang, "BestiaryMix", "Bestiary Mix", "je fais un mlange des units du bestiaire")
  call AddTranslation(lang, "AntiPierce", "Anti Pierce", "Je vais utiliser de mle")
  call AddTranslation(lang, "AntiAir", "Batriders", "Je vais utiliser des chevaucher de chauve-souris")
  call AddTranslation(lang, "OAntiTower", "Anti Tower", "Je m'occupe du sige")
  call AddTranslation(lang, "VersusHuman", "Raiders and Spirtwalkers", "Je vais faires des chevaucheurs de loups et des shamans taurens")
  call AddTranslation(lang, "VersusUndead", "Grunts and Beastiary", "Je vais faire des grunts et des unites du bestiaire")
  call AddTranslation(lang, "VersusElf", "Raiders and Demolishers", "je m'occupe des chevaucheurs de loup et des dmolisseurs")
  call AddTranslation(lang, "NormalUndead", "Normal", "je vais jouer normal et utiliser un peu de tout")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "Je joue normalement et je construis quelque chose de tout.")
  call AddTranslation(lang, "ROCWyrms", "Wyrms des glaces.", "Je vais creer massivement des Wyrms des glaces avec quelques Demons de cryptes.")
  call AddTranslation(lang, "ROCBanshee", "Banshees.", "Je vais creer principalement des Banshees.")
  call AddTranslation(lang, "ROCNecro", "Necromanciens.", "Je vais creer des Necromanciens.")
  call AddTranslation(lang, "ROCGhouls", "Goules.", "Je vais creer des Goules en masse.")
  call AddTranslation(lang, "ROCFiends", "Demons des cryptes.", "Je vais creer massivement des Demons des cryptes.")
  call AddTranslation(lang, "ROCGargWyrm", "Gargouilles and Wyrms des glaces.", "Je vais creer des gargouilles et des Wyrms des glaces.")
  call AddTranslation(lang, "ROCAboms", "Abominations.", "Je vais creer des Abominations en masse.")
  call AddTranslation(lang, "ROCMeatFiends", "Chariots a viande et Demons des cryptes.", "Je vais creer des Chariots a viande et des Demons des cryptes.")
  call AddTranslation(lang, "NormalUndead", "Normal", "je vais jouer normal et utiliser un peu de tout")
  call AddTranslation(lang, "Wyrms", "Wyrms", "Je vais faire des wyrms et des dmons des cryptes")
  call AddTranslation(lang, "Banshee", "Banshees", "Je m'occupe dse banshees")
  call AddTranslation(lang, "Necro", "Necros", "Je vais utiliser des ncros")
  call AddTranslation(lang, "Ghouls", "Ghouls", "Je vais masser des ghoules")
  call AddTranslation(lang, "GargGhouls", "Gargoyles and Ghouls", "Je m'occupe des ghoules et des gargouilles")
  call AddTranslation(lang, "Fiends", "Fiends", "Je vais masser des dmons des cryptes")
  call AddTranslation(lang, "GargWyrm", "Gargoyles and Wyrms", "Je m'occupe des wyrms et des gargouilles")
  call AddTranslation(lang, "Aboms", "Aboms", "Je vais masser des abominations")
  call AddTranslation(lang, "MeatFiends", "Meat wagons and Fiends", "Je vais essayer des dmons des cryptes et des catapultes")
  call AddTranslation(lang, "MassDestroyer", "Mass Destroyers", "Je vais faire des obsidian")
  call AddTranslation(lang, "CryptMix", "Crypt Mix", "Je vais mlanger des units de la crypte et slaughterhouse")
  call AddTranslation(lang, "TempleMix", "Temple Mix", "Je mlande le temple et la slaughterhouse")
  call AddTranslation(lang, "UAntiTower", "Anti Tower", "Je vais utiliser du sige")
  call AddTranslation(lang, "airair", "Air-Air", "Je construis des unites air-air.")
  call AddTranslation(lang, "airground", "Air-Sol", "Je construis des unites air-sol.")
  call AddTranslation(lang, "groundair", "Sol-Air", "Je construis des unites sol-air.")
  call AddTranslation(lang, "groundground", "Sol-Sol", "Je construis des unites sol-sol.")
  call AddTranslation(lang, "farm", "Fermes", "Je construis des fermes.")
  call AddTranslation(lang, "guard", "Tourelles", "Je construis des tourelles.")
  set lang = "Spanish"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "Jugar normal y entrenar algo de cada cosa")
  call AddTranslation(lang, "ROCMassHD", "Cazadoras y Dryads", "Entrenar cazadoras en masa y algunas dradas")
  call AddTranslation(lang, "ROCDruids", "Dradas y osos", "Entrenar dradas y druidas de la zarpa")
  call AddTranslation(lang, "ROCHippo", "Jinetes de hipogrifos", "Entrenar jinetes de hipogrifos")
  call AddTranslation(lang, "ROCBallista", "Ballestas", "Entrenar ballestas y dradas")
  call AddTranslation(lang, "ROCTalon", "Garra", "Entrenar druidas de la garra en masa")
  call AddTranslation(lang, "ROCHippoChim", "Hipogrifos y quimeras", "Entrenar hipogrifos y quimeras")
  call AddTranslation(lang, "ROCDryadChim", "Dradas y quimeras", "Entrenar dradas y quimeras")
  call AddTranslation(lang, "ROCArcher", "Arqueras", "Entrenar arqueras en masa")
  call AddTranslation(lang, "ROCDotC", "Osos", "Entrenar druidas de la zarpa en masa")
  call AddTranslation(lang, "NormalElf", "Normal", "Jugar un poco de todo")
  call AddTranslation(lang, "MassHD", "Cazadoras y dradas", "Entrenar cazadoras en masa y algunas dradas")
  call AddTranslation(lang, "Druids", "Dradas y osos", "Entrenando dradas y druidas de la zarpa")
  call AddTranslation(lang, "Hippo", "Jinetes de hipogrifos", "Entrenando jinetes de hipogrifo en masa")
  call AddTranslation(lang, "Ballista", "Ballestas", "Entrenando ballestas y dradas")
  call AddTranslation(lang, "Talon", "Talon", "Entrenando druidas de la garra en masa")
  call AddTranslation(lang, "HippoChim", "Hipogrifos y quimeras", "Entrenando hipogrifos y quimeras")
  call AddTranslation(lang, "DryadChim", "Dradas y quimeras", "Entrenando dradas y quimeras")
  call AddTranslation(lang, "Archer", "Arqueras", "Entrenando arqueras en masa")
  call AddTranslation(lang, "DotC", "Osos", "Entrenando druidas de la zarpa en masa")
  call AddTranslation(lang, "MassHuntress", "Cazadoras en masa", "Entrenando cazadoras en masa y algunas dradas")
  call AddTranslation(lang, "MGDryads", "Drades y gigantes", "Entrenando dradas y gigantes de la montaa")
  call AddTranslation(lang, "AoWMix", "Mezcla AoV", "Combinando unidades del Ancestro de Viento")
  call AddTranslation(lang, "AoLMix", "Mezcla AoS", "Combinando unidades del Ancestro de Sabidura")
  call AddTranslation(lang, "NEAntiTower", "Antitorres", "Acopiando armas de asedio")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "Jugar normal y entrenar algo de cada cosa")
  call AddTranslation(lang, "ROCMassSp", "Magicas", "Entrenar unidades mgicas en masa")
  call AddTranslation(lang, "ROCGryph", "Grifos", "Entrenar jinetes de grifos")
  call AddTranslation(lang, "ROCKnight", "Caballeros", "Entrenar soldados rasos y caballeros en masa")
  call AddTranslation(lang, "ROCRifle", "Rifleros", "Entrenar rifleros en masa")
  call AddTranslation(lang, "ROCMortars", "Morteros", "Entrenar equipos morteros")
  call AddTranslation(lang, "ROCCopters", "Girocpteros", "Construyendo mquinas voladoras")
  call AddTranslation(lang, "NormalHuman", "Normal", "Jugar un poco de todo")
  call AddTranslation(lang, "MassSp", "Hechiceros", "Entrenando hechiceros en masa")
  call AddTranslation(lang, "Gryph", "Gryphon", "Entrenando jinetes de grifos")
  call AddTranslation(lang, "Knight", "Caballeros", "Entrenando soldados y caballeros en masa")
  call AddTranslation(lang, "Rifle", "Fusil", "Entrenando Fusileros y sacerdotes en masa")
  call AddTranslation(lang, "Mortars", "Mortero", "Entrenando Equipos mortero y Fusileros")
  call AddTranslation(lang, "Copters", "", "Construyendo mquinas voladoras")
  call AddTranslation(lang, "MassSB", "Deshacedores", "Entrenando deshacedores de hechizos en masa")
  call AddTranslation(lang, "Dragonhawk", "Hacones Dragon", "Entrenando jinetes de dragonhawk")
  call AddTranslation(lang, "BarrackMix", "Barracas y Taller", "Combinando unidades de cuartel y taller")
  call AddTranslation(lang, "SanctumMix", "Santuario y Nido de Grifos", "Combinando unidades de santuario y nido de grifos")
  call AddTranslation(lang, "HAntiTower", "Antitorres", "Acopiando armas de asedio")
  call AddTranslation(lang, "VersusOrc", "Hechiceras en masa", "Entrenando hechiceras en masa")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "Entrenar grunts y unidades magicas")
  call AddTranslation(lang, "ROCFastSh", "Chamanes y taurens", "Entrenar chamanes y taurens")
  call AddTranslation(lang, "ROCKodo", "Kodo", "Entrenar bestias kodo")
  call AddTranslation(lang, "ROCWyvSh", "Chamanes y wyverns", "Entrenar chamanes y wyverns")
  call AddTranslation(lang, "ROCHHunters", "Trolls", "Entrenar trolls arrancacabezas en masa")
  call AddTranslation(lang, "ROCRaiders", "Incursores", "Entrenar incursores en masa")
  call AddTranslation(lang, "ROCCatapults", "Grunts y Catapultas", "Entrenar grunts y demoledores")
  call AddTranslation(lang, "ROCHeadCatapults", "Trolls y Catapultas", "Entrenar trolls arranca cabezas y demoledors")
  call AddTranslation(lang, "NormalOrc", "Normal", "Jugar normal y entrenar un poco de todo")
  call AddTranslation(lang, "FastSh", "Chamanes y Taurens", "Entrenando hechiceros y Taurens")
  call AddTranslation(lang, "WyvSh", "Chamanes y Wyverns", "Entrenando chamanes y wyverns")
  call AddTranslation(lang, "HHunters", "Trolles Arrancacabezas", "Entrenando trolles arrancacabezas en masa")
  call AddTranslation(lang, "Raiders", "Incursores", "Entrenar incursores en masa")
  call AddTranslation(lang, "GruntCatapults", "Grunts y demoledores", "Entrenando grunts y demoledores")
  call AddTranslation(lang, "HeadCatapults", "Arrancacabezas y demoledores", "Entrenar trolles arrancacabezas y demoledores")
  call AddTranslation(lang, "Wyvern", "Wyverns", "Entrenando wyverns en masa")
  call AddTranslation(lang, "BarrackMix", "Mixtas Barracas", "Combinando unidades de las barracas")
  call AddTranslation(lang, "BestiaryMix", "Mixtas Bestiario", "Combinando unidades del bestiario")
  call AddTranslation(lang, "AntiPierce", "Antiperforacin", "Estoy Entrenando unidades cuerpo a cuerpo e incursores")
  call AddTranslation(lang, "AntiAir", "Jinetes de murcilago", "Estoy amasando jinetes de murcilagos")
  call AddTranslation(lang, "OAntiTower", "Antitorres", "Acopiando armas de asedio")
  call AddTranslation(lang, "VersusHuman", "Incursores y espritus", "Estoy entrenando incursores y espritus caminantes")
  call AddTranslation(lang, "VersusUndead", "Grunts y beastiario", "Entrenando grunts y una mezcla del bestiario")
  call AddTranslation(lang, "VersusElf", "Incursores y catapultas", "Entrenando incursores y demoledores")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "Jugar normal y entrenar algo de cada cosa")
  call AddTranslation(lang, "ROCWyrms", "Wyrms", "Jugar con wyrms de hielo y algunos demonios de la cripta")
  call AddTranslation(lang, "ROCBanshee", "Banshees", "Entrenar banshees principalmente")
  call AddTranslation(lang, "ROCNecro", "Necros", "Entrenar nigromantes")
  call AddTranslation(lang, "ROCGhouls", "Necrfagos", "Entrenar necrfagos en masa")
  call AddTranslation(lang, "ROCFiends", "Demonios", "Entrenar demonios de la cripta en masa")
  call AddTranslation(lang, "ROCGargWyrm", "Gargolas y wyrms", "Entrenar grgolas y wyrms")
  call AddTranslation(lang, "ROCAboms", "Aboms", "Entrenar abominaciones en masa")
  call AddTranslation(lang, "ROCMeatFiends", "Carros y demonios de la cripta", "Entrenar demonios de la cripta y carros de despojos")
  call AddTranslation(lang, "NormalUndead", "Normal", "Jugar un poco de todo")
  call AddTranslation(lang, "Wyrms", "Wyrms", "Entrenando wyrms y unos cuantos demonios de la cripta")
  call AddTranslation(lang, "Banshee", "Banshees", "Entrenando principalmente Banshees")
  call AddTranslation(lang, "Necro", "Nigromantes", "Entrenando nigromantes")
  call AddTranslation(lang, "Ghouls", "Necrfagos", "Entrenando necrfagos en masa")
  call AddTranslation(lang, "GargGhouls", "Grgolas y necrfagos", "Entrenar grgolas y necrfagos")
  call AddTranslation(lang, "Fiends", "Demonios de la cripta", "Entrenar demonios de la cripta en masa")
  call AddTranslation(lang, "GargWyrm", "Gargolas y Wyrms", "Entrenando grgolas y wyrms")
  call AddTranslation(lang, "Aboms", "Abominaciones", "Entrenando abominaciones en masa")
  call AddTranslation(lang, "MeatFiends", "Carros y demonios de la cripta", "Entrenando demonios de la cripta y carros de despojos")
  call AddTranslation(lang, "MassDestroyer", "Destructores en masa", "Entrenando destructores en masa")
  call AddTranslation(lang, "CryptMix", "Cripta y Matadero", "Intentando con unidades de la cripta y el matadero")
  call AddTranslation(lang, "TempleMix", "Templo y Matadero", "Mezclando unidades del templo de los malditos y el matadero")
  call AddTranslation(lang, "UAntiTower", "Antitorres", "Acopiando armas de asedio")
  call AddTranslation(lang, "airair", "Aire-aire", "Entrenar unidades de combate areo")
  call AddTranslation(lang, "airground", "Aire-tierra", "Usar unidades areas contra las terrestres")
  call AddTranslation(lang, "groundair", "Tierra-Aire", "Usar unidades terrestres contra las areas")
  call AddTranslation(lang, "groundground", "Tierra-Tierra", "Entrenar unidades de combate en tierra")
  call AddTranslation(lang, "farm", "Granjas", "Construir granjas")
  call AddTranslation(lang, "guard", "Torres", "Construir torres")
  set lang = "Romanian"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "Voi juca normal si voi face cite ceva din toate")
  call AddTranslation(lang, "ROCMassHD", "Hunts si Dryads", "Voi face multe huntress cu ceva dryads")
  call AddTranslation(lang, "ROCDruids", "Dryads si DotC", "Voi face dryads si DotC")
  call AddTranslation(lang, "ROCHippo", "Hippo Riders", "Voi face hippo riders")
  call AddTranslation(lang, "ROCBallista", "Ballista", "Voi face glaive throwers si dryads")
  call AddTranslation(lang, "ROCTalon", "Talon", "Voi face multi DotT")
  call AddTranslation(lang, "ROCHippoChim", "HippoChim", "Voi face hippos si chimaera")
  call AddTranslation(lang, "ROCDryadChim", "DryadChim", "Voi face dryads si chimaeras")
  call AddTranslation(lang, "ROCArcher", "Archers", "Voi face multi archers")
  call AddTranslation(lang, "ROCDotC", "Bears", "Voi face multi DotC")
  call AddTranslation(lang, "NormalElf", "Normal", "Voi juca normal si voi face cite ceva din toate")
  call AddTranslation(lang, "MassHD", "Hunts si Dryads", "Voi face multe huntress cu ceva dryads")
  call AddTranslation(lang, "Druids", "Dryads si DotC", "Voi face dryads si DotC")
  call AddTranslation(lang, "Hippo", "Hippo Riders", "Voi face hippo riders")
  call AddTranslation(lang, "Ballista", "Ballista", "Voi face glaive throwers si dryads")
  call AddTranslation(lang, "Talon", "Talon", "Voi face multi DotT")
  call AddTranslation(lang, "HippoChim", "HippoChim", "Voi face hippos si chimaera")
  call AddTranslation(lang, "DryadChim", "DryadChim", "Voi face dryads si chimaeras")
  call AddTranslation(lang, "Archer", "Archers", "Voi face multi archers")
  call AddTranslation(lang, "DotC", "Bears", "Voi face multi DotC")
  call AddTranslation(lang, "MassHuntress", "Mass Hunts", "I'm going massive Huntresses")
  call AddTranslation(lang, "MGDryads", "Dryads and MGs", "I'm going dryads and mountain giants")
  call AddTranslation(lang, "AoWMix", "AoW Mix", "I'm mixing units from the AoW")
  call AddTranslation(lang, "AoLMix", "AoL Mix", "I'm mixing units from the Ancient of Lore")
  call AddTranslation(lang, "NEAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "Voi juca normal si voi face cite ceva din toate")
  call AddTranslation(lang, "ROCMassSp", "Casters", "Voi face multi spell casters")
  call AddTranslation(lang, "ROCGryph", "Gryphon", "Voi face gryphon riders")
  call AddTranslation(lang, "ROCKnight", "Knights", "Voi face multi footmen si knights")
  call AddTranslation(lang, "ROCRifle", "Rifle", "Voi face multi riflemen")
  call AddTranslation(lang, "ROCMortars", "Mortars", "Ma duc pe mortars")
  call AddTranslation(lang, "ROCCopters", "Copters", "Voi face flying machines")
  call AddTranslation(lang, "NormalHuman", "Normal", "Voi juca normal si voi face cite ceva din toate")
  call AddTranslation(lang, "MassSp", "Casters", "Voi face multi spell casters")
  call AddTranslation(lang, "Gryph", "Gryphon", "Voi face gryphon riders")
  call AddTranslation(lang, "Knight", "Knights", "Voi face multi footmen si knights")
  call AddTranslation(lang, "Rifle", "Rifle", "Voi face multi riflemen")
  call AddTranslation(lang, "Mortars", "Mortars", "Ma duc pe mortars")
  call AddTranslation(lang, "Copters", "Copters", "Voi face flying machines")
  call AddTranslation(lang, "MassSB", "SpellBreakers", "I'm going massive spell breakers")
  call AddTranslation(lang, "Dragonhawk", "Dragon Hawks", "I'm going dragon hawks")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "I'm trying to mix units from barrack and workshop")
  call AddTranslation(lang, "SanctumMix", "Sanctum Mix", "I'm trying to mix units from sanctum and aviary")
  call AddTranslation(lang, "HAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusOrc", "Mass Sorceress", "I'm massing Sorceress")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "Voi face grunts si casters")
  call AddTranslation(lang, "ROCFastSh", "Shamans and Taurens", "Voi face casters si taurens")
  call AddTranslation(lang, "ROCKodo", "Kodo", "Voi face multi kodo-beasts")
  call AddTranslation(lang, "ROCWyvSh", "Shamans and Wyverns", "Voi face Shamans si Wyverns")
  call AddTranslation(lang, "ROCHHunters", "Head Hunters", "Voi face multi head hunters")
  call AddTranslation(lang, "ROCRaiders", "Raiders", "Voi face multi raiders")
  call AddTranslation(lang, "ROCCatapults", "Grunts and Catapults", "Voi face grunts si demolisher")
  call AddTranslation(lang, "ROCHeadCatapults", "Head hunters and Catapults", "Voi face headhunters si demolishers")
  call AddTranslation(lang, "NormalOrc", "Normal", "Voi face grunts si casters")
  call AddTranslation(lang, "FastSh", "Shamans and Taurens", "Voi face casters si taurens")
  call AddTranslation(lang, "WyvSh", "Shamans and Wyverns", "Voi face Shamans si Wyverns")
  call AddTranslation(lang, "HHunters", "Head Hunters", "Voi face multi head hunters")
  call AddTranslation(lang, "Raiders", "Raiders", "Voi face multi raiders")
  call AddTranslation(lang, "GruntCatapults", "Grunts and Catapults", "Voi face grunts si demolisher")
  call AddTranslation(lang, "HeadCatapults", "Head hunters and Catapults", "Voi face headhunters si demolishers")
  call AddTranslation(lang, "Wyvern", "Mass Wyvern", "I'm going massive wyverns")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "I'm mixing units from barrack.")
  call AddTranslation(lang, "BestiaryMix", "Bestiary Mix", "I'm mixing units from bestiary")
  call AddTranslation(lang, "AntiPierce", "Anti Pierce", "I'm going melee units and raiders")
  call AddTranslation(lang, "AntiAir", "Batriders", "I'm a massing batriders")
  call AddTranslation(lang, "OAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusHuman", "Raiders and Spirtwalkers", "I'm going raiders and spirit walkers")
  call AddTranslation(lang, "VersusUndead", "Grunts and Beastiary", "I'm going Grunts and a mix from the beastiary")
  call AddTranslation(lang, "VersusElf", "Raiders and Demolishers", "I'm going raiders and Demolishers")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "Voi juca normal si voi face cite ceva din toate")
  call AddTranslation(lang, "ROCWyrms", "Wyrms", "Voi face wyrm rush cu citiva crypt fiends")
  call AddTranslation(lang, "ROCBanshee", "Banshees", "Voi face aproape numai banshees")
  call AddTranslation(lang, "ROCNecro", "Necros", "Voi face necromancers")
  call AddTranslation(lang, "ROCGhouls", "Ghouls", "Voi face multi ghouls")
  call AddTranslation(lang, "ROCFiends", "Fiends", "Voi face multi crypt fiends")
  call AddTranslation(lang, "ROCGargWyrm", "Gargoyles and Wyrms", "Voi face gargs si wyrms")
  call AddTranslation(lang, "ROCAboms", "Aboms", "Voi face multe abominations")
  call AddTranslation(lang, "ROCMeatFiends", "Meat wagons and Fiends", "Voi face fiends si meat wagons")
  call AddTranslation(lang, "NormalUndead", "Normal", "Voi juca normal si voi face cite ceva din toate")
  call AddTranslation(lang, "Wyrms", "Wyrms", "Voi face wyrm rush cu citiva crypt fiends")
  call AddTranslation(lang, "Banshee", "Banshees", "Voi face aproape numai banshees")
  call AddTranslation(lang, "Necro", "Necros", "Voi face necromancers")
  call AddTranslation(lang, "Ghouls", "Ghouls", "Voi face multi ghouls")
  call AddTranslation(lang, "GargGhouls", "Gargoyles and Ghouls", "Voi face gargs si Ghouls")
  call AddTranslation(lang, "Fiends", "Fiends", "Voi face multi crypt fiends")
  call AddTranslation(lang, "GargWyrm", "Gargoyles and Wyrms", "Voi face gargs si wyrms")
  call AddTranslation(lang, "Aboms", "Aboms", "Voi face multe abominations")
  call AddTranslation(lang, "MeatFiends", "Meat wagons and Fiends", "Voi face fiends si meat wagons")
  call AddTranslation(lang, "MassDestroyer", "Mass Destroyers", "I'm going massive destroyers")
  call AddTranslation(lang, "CryptMix", "Crypt Mix", "I'm trying to mix units from crypt and slaughterhouse")
  call AddTranslation(lang, "TempleMix", "Temple Mix", "I'm mixing units from temple of the damned and slaughterhouse")
  call AddTranslation(lang, "UAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "airair", "Air-Air", "Voi face unitati Aer-Aer")
  call AddTranslation(lang, "airground", "Air-Ground", "Voi face unitati Aer-Sol")
  call AddTranslation(lang, "groundair", "Ground-Air", "Voi face unitati Sol-Aer")
  call AddTranslation(lang, "groundground", "Ground-Ground", "Voi face unitati Sol-Sol")
  call AddTranslation(lang, "farm", "Farms", "Voi construi ferme")
  call AddTranslation(lang, "guard", "Towers", "Voi construi turnuri")
  set lang = "Russian"
  call AddTranslation(lang, "ROCNormalElf", " ", "       .")
  call AddTranslation(lang, "ROCMassHD", " + ", "      .")
  call AddTranslation(lang, "ROCDruids", " + ", "    .")
  call AddTranslation(lang, "ROCHippo", "", "    .")
  call AddTranslation(lang, "ROCBallista", " + ", "   .")
  call AddTranslation(lang, "ROCTalon", "", "   .")
  call AddTranslation(lang, "ROCHippoChim", "-", "   .")
  call AddTranslation(lang, "ROCDryadChim", " + ", "    .")
  call AddTranslation(lang, "ROCArcher", "", "   .")
  call AddTranslation(lang, "ROCDotC", "", "   .")
  call AddTranslation(lang, "NormalElf", " ", "       .")
  call AddTranslation(lang, "MassHD", " + ", "      .")
  call AddTranslation(lang, "Druids", " + ", "    .")
  call AddTranslation(lang, "Hippo", "", "    .")
  call AddTranslation(lang, "Ballista", " + ", "   .")
  call AddTranslation(lang, "Talon", "", "   .")
  call AddTranslation(lang, "HippoChim", "-", "   .")
  call AddTranslation(lang, "DryadChim", " + ", "    .")
  call AddTranslation(lang, "Archer", "", "   .")
  call AddTranslation(lang, "DotC", "", "   .")
  call AddTranslation(lang, "MassHuntress", " ", "   .")
  call AddTranslation(lang, "MGDryads", "  ", "   .")
  call AddTranslation(lang, "AoWMix", "AoW", "    .")
  call AddTranslation(lang, "AoLMix", "AoL", "    .")
  call AddTranslation(lang, "NEAntiTower", " ", "    ")
  call AddTranslation(lang, "ROCNormalHuman", " ", "       .")
  call AddTranslation(lang, "ROCMassSp", "", "   .")
  call AddTranslation(lang, "ROCGryph", "", " .")
  call AddTranslation(lang, "ROCKnight", " + ", "    .")
  call AddTranslation(lang, "ROCRifle", "", "  .")
  call AddTranslation(lang, "ROCMortars", "", "  .")
  call AddTranslation(lang, "ROCCopters", "", "  .")
  call AddTranslation(lang, "NormalHuman", " ", "       .")
  call AddTranslation(lang, "MassSp", "", "   .")
  call AddTranslation(lang, "Gryph", "", " .")
  call AddTranslation(lang, "Knight", " + ", "    .")
  call AddTranslation(lang, "Rifle", "", "  .")
  call AddTranslation(lang, "Mortars", "", "  .")
  call AddTranslation(lang, "MassSB", "", " .")
  call AddTranslation(lang, "Dragonhawks", "", "   .")
  call AddTranslation(lang, "BarrackMix", " ", "     .")
  call AddTranslation(lang, "SanctumMix", "  ", "      .")
  call AddTranslation(lang, "Copters", "", "  .")
  call AddTranslation(lang, "HAntiTower", " ", "   ")
  call AddTranslation(lang, "VersusOrc", " ", "   ")
  call AddTranslation(lang, "ROCNormalOrc", "+", "    .")
  call AddTranslation(lang, "ROCFastSh", " + ", "   .")
  call AddTranslation(lang, "ROCKodo", "", "   .")
  call AddTranslation(lang, "ROCWyvSh", " + ", "    .")
  call AddTranslation(lang, "ROCHHunters", "", "    .")
  call AddTranslation(lang, "ROCRaiders", "", "   .")
  call AddTranslation(lang, "ROCCatapults", " + ", "    .")
  call AddTranslation(lang, "ROCHeadCatapults", " + ", "     .")
  call AddTranslation(lang, "NormalOrc", "+", "    .")
  call AddTranslation(lang, "FastSh", " + ", "   .")
  call AddTranslation(lang, "WyvSh", " + ", "    .")
  call AddTranslation(lang, "HHunters", "", "    .")
  call AddTranslation(lang, "Raiders", "", "   .")
  call AddTranslation(lang, "GruntCatapults", " + ", "    .")
  call AddTranslation(lang, "HeadCatapults", " + ", "     .")
  call AddTranslation(lang, "Wyvern", "", "  .")
  call AddTranslation(lang, "BarrackMix", " ", "    .")
  call AddTranslation(lang, "BestiaryMix", "", "     .")
  call AddTranslation(lang, "AntiPierce  ", "       .", "")
  call AddTranslation(lang, "AntiAir", "", "   ")
  call AddTranslation(lang, "OAntiTower", " ", "   ")
  call AddTranslation(lang, "VersusHuman", "  ", "      ")
  call AddTranslation(lang, "VersusUndead", "  ", "        ")
  call AddTranslation(lang, "VersusElf", "        ", "")
  call AddTranslation(lang, "ROCNormalUndead", " ", "       .")
  call AddTranslation(lang, "ROCWyrms", " + ", "      .")
  call AddTranslation(lang, "ROCBanshee", "", "    .")
  call AddTranslation(lang, "ROCNecro", "", " .")
  call AddTranslation(lang, "ROCGhouls", "", "  .")
  call AddTranslation(lang, "ROCFiends", "", "    .")
  call AddTranslation(lang, "ROCGargWyrm", " + ", "    .")
  call AddTranslation(lang, "ROCAboms", "", "   .")
  call AddTranslation(lang, "ROCMeatFiends", " + ", "     .")
  call AddTranslation(lang, "NormalUndead", " ", "       .")
  call AddTranslation(lang, "Wyrms", " + ", "      .")
  call AddTranslation(lang, "Banshee", "", "    .")
  call AddTranslation(lang, "Necro", "", " .")
  call AddTranslation(lang, "Ghouls", "", "  .")
  call AddTranslation(lang, "GargGhouls", "  ", "    ")
  call AddTranslation(lang, "Fiends", "", "    .")
  call AddTranslation(lang, "GargWyrm", " + ", "    .")
  call AddTranslation(lang, "Aboms", "", "   .")
  call AddTranslation(lang, "MeatFiends", " + ", "     .")
  call AddTranslation(lang, "MassDestroyer", "", " .")
  call AddTranslation(lang, "CryptMix", "", "    .")
  call AddTranslation(lang, "TempleMix", " ", "     .")
  call AddTranslation(lang, "UAntiTower", "   ", "")
  call AddTranslation(lang, "airair", "-", "    .")
  call AddTranslation(lang, "airground", "-", "    .")
  call AddTranslation(lang, "groundair", "-", "    .")
  call AddTranslation(lang, "groundground", "-", "    .")
  call AddTranslation(lang, "farm", "", " .")
  call AddTranslation(lang, "guard", "", " .")
  set lang = "Portuguese"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "Eu jogarei normalmente construindo um pouco de tudo")
  call AddTranslation(lang, "ROCMassHD", "Hunts and Dryads", "Eu estou indo para Huntress em massa e algumas Dryads")
  call AddTranslation(lang, "ROCDruids", "Dryads e DotC", "Eu construirei Dryads e DotC")
  call AddTranslation(lang, "ROCHippo", "Hippo Riders", "Eu construirei Hippo Riders em massa")
  call AddTranslation(lang, "ROCBallista", "Ballista", "Eu farei Glaive Throwers e Dryads")
  call AddTranslation(lang, "ROCTalon", "Talon", "Eu farei toneladas de DotT")
  call AddTranslation(lang, "ROCHippoChim", "HippoChim", "Eu farei Hippgrifos e Chimaeras")
  call AddTranslation(lang, "ROCDryadChim", "DryadChim", "Indo pra Dryads e Chimaeras")
  call AddTranslation(lang, "ROCArcher", "Archers", "Vou fazer mass Archer")
  call AddTranslation(lang, "ROCDotC", "Ursos", "Tentarei DotC em massa")
  call AddTranslation(lang, "NormalElf", "Normal", "Eu jogarei normalmente construindo um pouco de tudo")
  call AddTranslation(lang, "MassHD", "Hunts and Dryads", "Eu estou indo para Huntress em massa e algumas Dryads")
  call AddTranslation(lang, "Druids", "Dryads e DotC", "Eu construirei Dryads e DotC")
  call AddTranslation(lang, "Hippo", "Hippo Riders", "Eu construirei Hippo Riders em massa")
  call AddTranslation(lang, "Ballista", "Ballista", "Eu farei Glaive Throwers e Dryads")
  call AddTranslation(lang, "Talon", "Talon", "Eu farei toneladas de DotT")
  call AddTranslation(lang, "HippoChim", "HippoChim", "Eu farei Hippgrifos e Chimaeras")
  call AddTranslation(lang, "DryadChim", "DryadChim", "Indo pra Dryads e Chimaeras")
  call AddTranslation(lang, "Archer", "Archers", "Vou fazer mass Archer")
  call AddTranslation(lang, "DotC", "Ursos", "Tentarei DotC em massa")
  call AddTranslation(lang, "MassHuntress", "Mass Huntress", "Farei Huntresses em massa ")
  call AddTranslation(lang, "MGDryads", "Dryads e MGs", "Indo para Dryads e Gigantes da Montanha ")
  call AddTranslation(lang, "AoWMix", "AoW Mix", "Estou misturando unidades do AoW")
  call AddTranslation(lang, "AoLMix", "AoL Mix", "Estou misturando unidades do Ancient of Lore")
  call AddTranslation(lang, "NEAntiTower", "Anti Torre", "Estou fazendo equipamentos de cerco em massa")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "Farei um pouco de tudo")
  call AddTranslation(lang, "ROCMassSp", "Casters", "Estou indo pra mass Casters")
  call AddTranslation(lang, "ROCGryph", "Gryphon", "Eu farei Gryphon riders")
  call AddTranslation(lang, "ROCKnight", "Knights", "Eu farei Footmen e Knights, muitos deles")
  call AddTranslation(lang, "ROCRifle", "Rifle", "Farei Riflemen")
  call AddTranslation(lang, "ROCMortars", "Mortars", "Farei Mortar Teams")
  call AddTranslation(lang, "ROCCopters", "Copters", "Vou fazer mass Flying machine")
  call AddTranslation(lang, "NormalHuman", "Normal", "Farei um pouco de tudo")
  call AddTranslation(lang, "MassSp", "Casters", "Estou indo pra mass Casters")
  call AddTranslation(lang, "Gryph", "Gryphon", "Eu farei Gryphon riders")
  call AddTranslation(lang, "Knight", "Knights", "Eu farei Footmen e Knights, muitos deles")
  call AddTranslation(lang, "Rifle", "Rifle", "Farei Riflemen")
  call AddTranslation(lang, "Mortars", "Mortars", "Farei Mortar Teams")
  call AddTranslation(lang, "Copters", "Copters", "Vou fazer mass Flying Machine")
  call AddTranslation(lang, "MassSB", "SpellBreakers", "Vou fazer mass Spell Breakers")
  call AddTranslation(lang, "Dragonhawk", "Dragon Hawks", "Vou de Dragon Hawks")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "Estou tentando misturar unidades do Barracks e do Workshop")
  call AddTranslation(lang, "SanctumMix", "Sanctum Mix", "Estou tentando misturar unidades do Sanctum e do Aviary")
  call AddTranslation(lang, "HAntiTower", "Anti Torre", "Estou fazendo equipamentos de cerco em massa")
  call AddTranslation(lang, "VersusOrc", "Mass Sorceress", "Estou fazendo Sorceress em massa")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "Farei Grunts e casters")
  call AddTranslation(lang, "ROCFastSh", "Shamans and Taurens", "Farei Casters e Taurens")
  call AddTranslation(lang, "ROCKodo", "Kodo", "Vou fazer mass Kodo-Beast")
  call AddTranslation(lang, "ROCWyvSh", "Shamans e Wyverns", "Indo pra Shamans e Wyverns")
  call AddTranslation(lang, "ROCHHunters", "Head Hunters", "Vou tentar mass Troll HeadHunter")
  call AddTranslation(lang, "ROCRaiders", "Raiders", "Vou tentar mass Raiders")
  call AddTranslation(lang, "ROCCatapults", "Grunts e Catapultas", "Eu farei Grunts e Demolishers")
  call AddTranslation(lang, "ROCHeadCatapults", "Head hunters e Catapultas", "Vou tentar Headhunters e Demolishers")
  call AddTranslation(lang, "NormalOrc", "Normal", "Farei Grunts e Casters")
  call AddTranslation(lang, "FastSh", "Shamans and Taurens", "Farei Casters e Taureens")
  call AddTranslation(lang, "WyvSh", "Shamans and Wyverns", "Indo pra Shamans e Wyverns")
  call AddTranslation(lang, "HHunters", "Head Hunters", "Vou tentar mass Troll HeadHunter")
  call AddTranslation(lang, "Raiders", "Raiders", "Vou tentar mass Raiders")
  call AddTranslation(lang, "GruntCatapults", "Grunts and Catapults", "Eu farei Grunts e Demolishers")
  call AddTranslation(lang, "HeadCatapults", "Head hunters and Catapults", "Vamos tentar Headhunters e Demolishers")
  call AddTranslation(lang, "Wyvern", "Mass Wyvern", "Vou de wyverns em massa")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "Estou misturando unidades do Barracks.")
  call AddTranslation(lang, "BestiaryMix", "Bestiary Mix", "Estou misturando unidades do Bestiary")
  call AddTranslation(lang, "AntiPierce", "Anti Perfurante", "Vou de unidades corpo-a-corpo e Raiders")
  call AddTranslation(lang, "AntiAir", "Batriders", "Estou fazendo em massa Batriders")
  call AddTranslation(lang, "OAntiTower", "Anti Torre", "Estou fazendo equipamentos de cerco em massa")
  call AddTranslation(lang, "VersusHuman", "Raiders e Spirtwalkers", "Vou de Raiders e Spirit Walkers")
  call AddTranslation(lang, "VersusUndead", "Grunts e Beastiary", "Vou de Grunts e uma mistura do Beastiary")
  call AddTranslation(lang, "VersusElf", "Raiders e Demolishers", "Vou de Raiders e Demolishers")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "Eu vou fazer um pouco de tudo")
  call AddTranslation(lang, "ROCWyrms", "Wyrms", "Farei wyrms e algumas Crypt Fiends")
  call AddTranslation(lang, "ROCBanshee", "Banshees", "Farei muitas Banshees")
  call AddTranslation(lang, "ROCNecro", "Necros", "Tentarei Necromancers")
  call AddTranslation(lang, "ROCGhouls", "Ghouls", "Farei mass Ghouls")
  call AddTranslation(lang, "ROCFiends", "Fiends", "Estou fazendo mass Crypt Fiends")
  call AddTranslation(lang, "ROCGargWyrm", "Gargoyles e Wyrms", "Farei Gargs e Wyrms")
  call AddTranslation(lang, "ROCAboms", "Aboms", "Vou fazer mass Abominations")
  call AddTranslation(lang, "ROCMeatFiends", "Meat wagons and Fiends", "Eu tentarei Fiends e Meat Wagons")
  call AddTranslation(lang, "NormalUndead", "Normal", "Eu vou fazer um pouco de tudo")
  call AddTranslation(lang, "Wyrms", "Wyrms", "Farei Wyrms e algumas Crypt Fiends")
  call AddTranslation(lang, "Banshee", "Banshees", "Farei muitas Banshees")
  call AddTranslation(lang, "Necro", "Necros", "Tentarei Necromancers")
  call AddTranslation(lang, "Ghouls", "Ghouls", "Farei mass Ghouls")
  call AddTranslation(lang, "GargGhouls", "Gargoyles and Ghouls", "Farei Gargs e Ghouls")
  call AddTranslation(lang, "Fiends", "Fiends", "Estou fazendo mass Crypt Fiends")
  call AddTranslation(lang, "GargWyrm", "Gargoyles and Wyrms", "Farei Gargs e Wyrms")
  call AddTranslation(lang, "Aboms", "Aboms", "Vou fazer mass Abominations")
  call AddTranslation(lang, "MeatFiends", "Meat Wagons e Fiends", "Eu tentarei Fiends e Meat Wagons")
  call AddTranslation(lang, "MassDestroyer", "Mass Destroyers", "Vou de mass Destroyers")
  call AddTranslation(lang, "CryptMix", "Crypt Mix", "Estou tentando misturar unidades da Crypt e do Slaughterhouse")
  call AddTranslation(lang, "TempleMix", "Temple Mix", "Estou misturando unidades do Temple of the Damned e Slaughterhouse")
  call AddTranslation(lang, "UAntiTower", "Anti Torre", "Estou fazendo equipamentos de cerco em massa")
  call AddTranslation(lang, "airair", "Ar-Ar", "Eu farei unidades areas contra areas")
  call AddTranslation(lang, "airground", "Ar-Terra", "Eu farei unidades areas contra terrestres")
  call AddTranslation(lang, "groundair", "Anti-Areo", "Eu farei unidades terrestres contra areas")
  call AddTranslation(lang, "groundground", "Terra-Terra", "Eu farei unidades terrestres contra terrestres")
  call AddTranslation(lang, "farm", "fazendas", "Eu construirei fazendas")
  call AddTranslation(lang, "guard", "Torres", "Eu construirei torres")
  set lang = "Norwegian"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "Jeg spiller som vanlig og bygger litt av vert")
  call AddTranslation(lang, "ROCMassHD", "Hunts og Dryads", "Jeg bygger huntress og dryads")
  call AddTranslation(lang, "ROCDruids", "Dryads og DotC", "Jeg bygger dryads og DotC")
  call AddTranslation(lang, "ROCHippo", "Hippo Riders", "Jeg bygger hippo riders")
  call AddTranslation(lang, "ROCBallista", "Ballista", "Jeg bygger ballista og dryads")
  call AddTranslation(lang, "ROCTalon", "Talon", "Jeg bygger masse DotT")
  call AddTranslation(lang, "ROCHippoChim", "Hippogim", "Jeg bygger hippos og chimaeras")
  call AddTranslation(lang, "ROCDryadChim", "DryadChim", "Jeg bygger dryads og chimaeras")
  call AddTranslation(lang, "ROCArcher", "Archers", "Jeg spiller med archers")
  call AddTranslation(lang, "ROCDotC", "DotC", "Jeg spiller med DotC")
  call AddTranslation(lang, "NormalElf", "Normal", "Jeg spiller som vanlig og bygger litt av vert")
  call AddTranslation(lang, "MassH", "Hunts og Dryads", "Jeg bygger huntress og dryads")
  call AddTranslation(lang, "Druids", "Dryads og DotC", "Jeg bygger dryads og DotC")
  call AddTranslation(lang, "Hippo", "Hippo Riders", "Jeg bygger hippo riders")
  call AddTranslation(lang, "Ballista", "Ballista", "Jeg bygger ballista og dryads")
  call AddTranslation(lang, "Talon", "Talon", "Jeg bygger masse DotT")
  call AddTranslation(lang, "Hippogim", "Hippogim", "Jeg bygger hippos og chimaeras")
  call AddTranslation(lang, "DryadChim", "DryadChim", "Jeg bygger dryads og chimaeras")
  call AddTranslation(lang, "Archer", "Archers", "Jeg spiller med archers")
  call AddTranslation(lang, "DotC", "DotC", "Jeg spiller med DotC")
  call AddTranslation(lang, "MassHuntress", "Mass Hunts", "I'm going massive Huntresses")
  call AddTranslation(lang, "MGDryads", "Dryads and MGs", "I'm going dryads and mountain giants")
  call AddTranslation(lang, "AoWMix", "AoW Mix", "I'm mixing units from the AoW")
  call AddTranslation(lang, "AolMix", "AoL Mix", "I'm mixing units from the Ancient of Lore")
  call AddTranslation(lang, "NEAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "Jeg spiller som vanlig og bygger litt av vert")
  call AddTranslation(lang, "ROCMassSp", "Casters", "Jeg spiller med casters")
  call AddTranslation(lang, "ROCGryph", "Gryphon", "Jeg bygger masse gryphoner")
  call AddTranslation(lang, "ROCKnight", "Knights", "Jeg skaffer footmen og knights")
  call AddTranslation(lang, "ROCRifle", "Rifle", "Jeg bygger masse riflemen")
  call AddTranslation(lang, "ROCMortars", "Mortars", "Jeg skaffer mortars og riflemen")
  call AddTranslation(lang, "ROCCopters", "Copters", "Jeg spiller med flyvemaskiner")
  call AddTranslation(lang, "NormalHuman", "Normal", "Jeg spiller som vanlig og bygger litt av vert")
  call AddTranslation(lang, "MassSp", "Casters", "Jeg spiller med casters")
  call AddTranslation(lang, "Gryph", "Gryphon", "Jeg bygger masse gryphoner")
  call AddTranslation(lang, "Knight", "Knights", "Jeg skaffer footmen og knights")
  call AddTranslation(lang, "Rifle", "Rifle", "Jeg bygger masse riflemen")
  call AddTranslation(lang, "Mortars", "Mortars", "Jeg skaffer mortars og riflemen")
  call AddTranslation(lang, "Copters", "Copters", "Jeg spiller med flyvemaskiner")
  call AddTranslation(lang, "MassSB", "SpellBreakers", "I'm going massive spell breakers")
  call AddTranslation(lang, "Dragonhawk", "Dragon Hawks", "I'm going dragon hawks")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "I'm trying to mix units from barrack and workshop")
  call AddTranslation(lang, "SanctumMix", "Sanctum Mix", "I'm trying to mix units from sanctum and aviary")
  call AddTranslation(lang, "HAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusOrc", "Mass Sorceress", "I'm massing Sorceress")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "Jeg skaffer grunts og casters")
  call AddTranslation(lang, "ROCFastSh", "Shamans og Taurens", "Jeg skaffer casters og taurens")
  call AddTranslation(lang, "ROCKodo", "Kodo", "Jeg bygger masse kodo-beast")
  call AddTranslation(lang, "ROCWyvSh", "Shamans og Wyverns", "Jeg bygger Shamans og Wyverns")
  call AddTranslation(lang, "ROCHHunters", "Head Hunters", "Jeg bygger masse head hunters")
  call AddTranslation(lang, "ROCRaiders", "Raiders", "Jeg bygger masse raiders")
  call AddTranslation(lang, "ROCCatapults", "Grunts og Katapulter", "Jeg bygger grunts og katapulter")
  call AddTranslation(lang, "ROCHeadCatapults", "Head hunters og Katapulter", "Jeg skaffer headhunters og katapulter")
  call AddTranslation(lang, "NormalOrc", "Normal", "Jeg skaffer grunts og casters")
  call AddTranslation(lang, "FastSh", "Shamans og Taurens", "Jeg skaffer casters og taurens")
  call AddTranslation(lang, "WyvSh", "Shamans og Wyverns", "Jeg bygger Shamans og Wyverns")
  call AddTranslation(lang, "HHunters", "Head Hunters", "Jeg bygger masse head hunters")
  call AddTranslation(lang, "Raiders", "Raiders", "Jeg bygger masse raiders")
  call AddTranslation(lang, "GruntCatapults", "Grunts og Katapulter", "Jeg bygger grunts og katapulter")
  call AddTranslation(lang, "HeadCatapults", "Head hunters og Katapulter", "Jeg skaffer headhunters og katapulter")
  call AddTranslation(lang, "Wyvern", "Mass Wyvern", "I'm going massive wyverns")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "I'm mixing units from barrack.")
  call AddTranslation(lang, "BestiaryMix", "Bestiary Mix", "I'm mixing units from bestiary")
  call AddTranslation(lang, "AntiPierce", "Anti Pierce", "I'm going melee units and raiders")
  call AddTranslation(lang, "AntiAir", "Batriders", "I'm a massing batriders")
  call AddTranslation(lang, "OAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusHuman", "Raiders and Spirtwalkers", "I'm going raiders and spirit walkers")
  call AddTranslation(lang, "VersusUndead", "Grunts and Beastiary", "I'm going Grunts and a mix from the beastiary")
  call AddTranslation(lang, "VersusElf", "Raiders and Demolishers", "I'm going raiders and Demolishers")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "Jeg spiller som vanlig og bygger litt av vert")
  call AddTranslation(lang, "ROCWyrms", "Wyrms", "Jeg bygger wyrms og crypt fiends")
  call AddTranslation(lang, "ROCBanshee", "Banshees", "Jeg skaffer bashees")
  call AddTranslation(lang, "ROCNecro", "Necros", "Jeg bygger necromancers")
  call AddTranslation(lang, "ROCGhouls", "Ghouls", "Jeg skaffer masse ghouls")
  call AddTranslation(lang, "ROCFiends", "Fiends", "Jeg bygger masse crypt fiends")
  call AddTranslation(lang, "ROCGargWyrm", "Gargoyles og Wyrms", "Jeg bygger gargs og wyrms")
  call AddTranslation(lang, "ROCAboms", "Aboms", "Jeg skaffer masse abominations")
  call AddTranslation(lang, "ROCMeatFiends", "Meat wagons og Fiends", "Jeg bygger fiends og meat wagons")
  call AddTranslation(lang, "NormalUndead", "Normal", "Jeg spiller som vanlig og bygger litt av vert")
  call AddTranslation(lang, "Wyrms", "Wyrms", "Jeg bygger wyrms og crypt fiends")
  call AddTranslation(lang, "Banshee", "Banshees", "Jeg skaffer bashees")
  call AddTranslation(lang, "Necro", "Necros", "Jeg bygger necromancers")
  call AddTranslation(lang, "Ghouls", "Ghouls", "Jeg skaffer masse ghouls")
  call AddTranslation(lang, "GargGhouls", "Gargoyles and Ghouls", "Jeg skaffer masse gargs og ghouls")
  call AddTranslation(lang, "Fiends", "Fiends", "Jeg bygger masse crypt fiends")
  call AddTranslation(lang, "GargWyrm", "Gargoyles og Wyrms", "Jeg bygger gargs og wyrms")
  call AddTranslation(lang, "Aboms", "Aboms", "Jeg skaffer masse abominations")
  call AddTranslation(lang, "MeatFiends", "Meat wagons og Fiends", "Jeg bygger fiends og meat wagons")
  call AddTranslation(lang, "MassDestroyer", "Mass Destroyers", "I'm going massive destroyers")
  call AddTranslation(lang, "CryptMix", "Crypt Mix", "I'm trying to mix units from crypt and slaughterhouse")
  call AddTranslation(lang, "TempleMix", "Temple Mix", "I'm mixing units from temple of the damned and slaughterhouse")
  call AddTranslation(lang, "UAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "airair", "Luft-Luft", "Jeg bygger luft- mot luftenheter")
  call AddTranslation(lang, "airground", "Luft-Mark", "Jeg bygger luft- mot bakkeenheter")
  call AddTranslation(lang, "groundair", "Mark-Luft", "Jeg bygger bakke- mot luftenheter")
  call AddTranslation(lang, "groundground", "Mark-Mark", "Jeg bygger bakke- mot bakkeenheter")
  call AddTranslation(lang, "farm", "Farms", "Jeg bygger farms")
  call AddTranslation(lang, "guard", "Torn", "Jeg bygger tarn")
  set lang = "Chinese"
  call AddTranslation(lang, "ROCNormalElf", "", "")
  call AddTranslation(lang, "ROCMassHD", "", "")
  call AddTranslation(lang, "ROCDruids", "", "")
  call AddTranslation(lang, "ROCHippo", "", "")
  call AddTranslation(lang, "ROCBallista", "", "")
  call AddTranslation(lang, "ROCTalon", "", "")
  call AddTranslation(lang, "ROCHippoChim", "", "")
  call AddTranslation(lang, "ROCDryadChim", "", "")
  call AddTranslation(lang, "ROCArcher", "", "")
  call AddTranslation(lang, "ROCDotC", "", "")
  call AddTranslation(lang, "NormalElf", "", "")
  call AddTranslation(lang, "MassHD", "", "")
  call AddTranslation(lang, "Druids", "", "")
  call AddTranslation(lang, "Hippo", "", "")
  call AddTranslation(lang, "Ballista", "", "")
  call AddTranslation(lang, "Talon", "", "")
  call AddTranslation(lang, "HippoChim", "", "")
  call AddTranslation(lang, "DryadChim", "", "")
  call AddTranslation(lang, "Archer", "", "")
  call AddTranslation(lang, "DotC", "", "")
  call AddTranslation(lang, "MassHuntress", "", "")
  call AddTranslation(lang, "MGDryads", "", "")
  call AddTranslation(lang, "AoWMix", "", "")
  call AddTranslation(lang, "AolMix", "", "")
  call AddTranslation(lang, "NEAntiTower", "", "")
  call AddTranslation(lang, "ROCNormalHuman", "", "")
  call AddTranslation(lang, "ROCMassSp", "", "")
  call AddTranslation(lang, "ROCGryph", "", "")
  call AddTranslation(lang, "ROCKnight", "", "")
  call AddTranslation(lang, "ROCRifle", "", "")
  call AddTranslation(lang, "ROCMortars", "", "")
  call AddTranslation(lang, "ROCCopters", "", "")
  call AddTranslation(lang, "NormalHuman", "", "")
  call AddTranslation(lang, "MassSp", "", "")
  call AddTranslation(lang, "Gryph", "", "")
  call AddTranslation(lang, "Knight", "", "")
  call AddTranslation(lang, "Rifle", "", "")
  call AddTranslation(lang, "Mortars", "", "")
  call AddTranslation(lang, "Copters", "", "")
  call AddTranslation(lang, "MassSB", "", "")
  call AddTranslation(lang, "Dragonhawk", "", "")
  call AddTranslation(lang, "BarrackMix", "", "")
  call AddTranslation(lang, "SanctumMix", "", "")
  call AddTranslation(lang, "HAntiTower", "", "")
  call AddTranslation(lang, "VersusOrc", "", "")
  call AddTranslation(lang, "ROCNormalOrc", "", "")
  call AddTranslation(lang, "ROCFastSh", "", "")
  call AddTranslation(lang, "ROCKodo", "", "")
  call AddTranslation(lang, "ROCWyvSh", "", "")
  call AddTranslation(lang, "ROCHHunters", "", "")
  call AddTranslation(lang, "ROCRaiders", "", "")
  call AddTranslation(lang, "ROCCatapults", "", "")
  call AddTranslation(lang, "ROCHeadCatapults", "", "")
  call AddTranslation(lang, "NormalOrc", "", "")
  call AddTranslation(lang, "FastSh", "", "")
  call AddTranslation(lang, "WyvSh", "", "")
  call AddTranslation(lang, "HHunters", "", "")
  call AddTranslation(lang, "Raiders", "", "")
  call AddTranslation(lang, "GruntCatapults", "G", "G")
  call AddTranslation(lang, "HeadCatapults", "", "")
  call AddTranslation(lang, "Wyvern", "", "")
  call AddTranslation(lang, "BarrackMix", "", "")
  call AddTranslation(lang, "BestiaryMix", "", "")
  call AddTranslation(lang, "AntiPierce", "", "")
  call AddTranslation(lang, "AntiAir", "", "")
  call AddTranslation(lang, "OAntiTower", "", "")
  call AddTranslation(lang, "VersusHuman", "", "")
  call AddTranslation(lang, "VersusUndead", "G", "G")
  call AddTranslation(lang, "VersusElf", "", "")
  call AddTranslation(lang, "ROCNormalUndead", "", "")
  call AddTranslation(lang, "ROCWyrms", "", "")
  call AddTranslation(lang, "ROCBanshee", "", "")
  call AddTranslation(lang, "ROCNecro", "", "")
  call AddTranslation(lang, "ROCGhouls", "", "")
  call AddTranslation(lang, "ROCFiends", "", "")
  call AddTranslation(lang, "ROCGargWyrm", "", "")
  call AddTranslation(lang, "ROCAboms", "", "")
  call AddTranslation(lang, "ROCMeatFiends", "", "")
  call AddTranslation(lang, "NormalUndead", "", "")
  call AddTranslation(lang, "Wyrms", "", "")
  call AddTranslation(lang, "Banshee", "", "")
  call AddTranslation(lang, "Necro", "", "")
  call AddTranslation(lang, "Ghouls", "", "")
  call AddTranslation(lang, "GargGhouls", "", "")
  call AddTranslation(lang, "Fiends", "", "")
  call AddTranslation(lang, "GargWyrm", "", "")
  call AddTranslation(lang, "Aboms", "", "")
  call AddTranslation(lang, "MeatFiends", "", "")
  call AddTranslation(lang, "MassDestroyer", "", "")
  call AddTranslation(lang, "CryptMix", "", "")
  call AddTranslation(lang, "TempleMix", "", "")
  call AddTranslation(lang, "UAntiTower", "", "")
  call AddTranslation(lang, "airair", "", "")
  call AddTranslation(lang, "airground", "", "")
  call AddTranslation(lang, "groundair", "", "")
  call AddTranslation(lang, "groundground", "", "")
  call AddTranslation(lang, "farm", "", "")
  call AddTranslation(lang, "guard", "", "")
  set lang = null
endfunction

function GetStrategyTxt takes integer stratnum, string txt returns string
  local string trans = null
  if HaveSavedInteger(translation_map, StringHash(language), StringHash(txt+strategy_name[stratnum])) then
    set trans = translation[LoadInteger(translation_map, StringHash(language), StringHash(txt+strategy_name[stratnum]))]
  endif
  if (trans == "" or trans == null) and HaveSavedInteger(translation_map, StringHash("English"), StringHash(txt+strategy_name[stratnum])) then
    set trans = translation[LoadInteger(translation_map, StringHash("English"), StringHash(txt+strategy_name[stratnum]))]
  endif
  if (trans == "" or trans == null) then
    set trans = null
    return strategy_default_name[stratnum]
  else
    return trans
  endif
endfunction

function GetStrategyName takes integer stratnum returns string
  return GetStrategyTxt(stratnum, "Name")
endfunction

function GetStrategyReport takes integer stratnum returns string
  return GetStrategyTxt(stratnum, "Report")
endfunction

function GetCurrentStrategyName takes nothing returns string
  return GetStrategyName(strategy)
endfunction

function GetCurrentStrategyReport takes nothing returns string
  return GetStrategyReport(strategy)
endfunction

function GetCurrentDynamicReport takes nothing returns string
  if strengthtext[chosen_counter] != null and no_counter == false then 
    return " " + chat_dynamic_counter + " " + ApplyTrans(strengthtext[chosen_counter])
  endif
  return ""
endfunction

function QueueChat takes string text, player p, boolean important returns nothing
    local integer i = 0
    if (p == GetLocalPlayer()) then
        set chat_queue_size = chat_queue_size + 1
        set chat_queue[chat_queue_size] = text
        set chat_queue_player[chat_queue_size] = p
        set chat_queue_importance[chat_queue_size] = important
        if (chat_queue_size > 5) then
            // Remove oldest message
            set i = 0
            loop
              exitwhen i >= chat_queue_size
              set chat_queue[i] = chat_queue[i+1]
              set chat_queue_player[i] = chat_queue_player[i+1]
              set chat_queue_importance[i] = chat_queue_importance[i+1]
              set i = i + 1
            endloop
            set chat_queue_size = chat_queue_size - 1
        endif
    endif
endfunction

function DisplayChat takes boolean ally, boolean enemy, boolean obs, boolean important, boolean immediate returns nothing
  local integer i = 0
  local integer std_rand = 0
  local integer rand = 0
  local player p = null
  call ApplyChatConditions()
  if chat_list_length == 0 then
    return
  endif
  set std_rand = GetRandomInt(0, chat_list_length - 1)
  loop
    exitwhen i >= GetBJMaxPlayers()
    set p = Player(i)
    if (GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(p) != MAP_CONTROL_COMPUTER and ((ally and IsPlayerAlly(p, ai_player)) or (enemy and IsPlayerEnemy(p, ai_player)) and not IsPlayerObserver(p))) or (obs and IsPlayerObserver(p)) then
      set rand = std_rand
      loop
        exitwhen (chat_list_eq[rand] == COMPARE_TRUE) or (chat_list_eq[rand] == COMPARE_EQ and chat_list_race[rand] == race_name[player_race[i]]) or (chat_list_eq[rand] == COMPARE_UNEQ and chat_list_race[rand] != race_name[player_race[i]])
        set rand = GetRandomInt(0, chat_list_length - 1)
      endloop
      call SetChatVarsPlayer(p)
      if immediate then
        call DisplayToPlayer(ApplyChatVars(chat_list[rand]), p, important)
      else
        call QueueChat(ApplyChatVars(chat_list[rand]), p, important)
      endif
    endif
    set i = i + 1
  endloop
  set p = null
endfunction

function QueueStrategy takes string text returns nothing
  set chat_strategy = text
endfunction 

function Chat takes integer c returns nothing
  local real chance = 0
  local boolean immediate = false
  if campaign_ai then
    return
  endif

  if c == C_STRATEGY then
    if IsPlayerAlly(ai_player,GetLocalPlayer()) or IsPlayerObserver(GetLocalPlayer()) and chatting then
      call QueueStrategy(GetCurrentStrategyReport() + GetCurrentDynamicReport())
    endif
    //call DisplayToAlliesImportant( GetCurrentStrategyReport() + GetCurrentDynamicReport() )
    //call DisplayToObserversImportant( GetCurrentStrategyReport() + GetCurrentDynamicReport() )
  else
    if not (chatting or chat_important[c]) then
      return
    endif
    if false then
    elseif c == C_AGG then
      set chance = 100
      call CopyChatAGG()
    elseif c == C_Ally then
      set chance = 100
      call CopyChatAlly()
    elseif c == C_Attack then
      set chance = 100
      call CopyChatAttack()
    elseif c == C_Creep then
      set chance = 100
      call CopyChatCreep()
    elseif c == C_Done then
      set chance = 100
      call CopyChatDone()
    elseif c == C_EGG then
      set chance = 100
      call CopyChatEGG()
    elseif c == C_Expansion then
      set chance = 100
      call CopyChatExpansion()
    elseif c == C_Goldproblem then
      set chance = 100
      call CopyChatGoldproblem()
    elseif c == C_Greet then
      set chance = 100
      call CopyChatGreet()
    elseif c == C_Mega then
      set chance = 100
      call CopyChatMega()
    elseif c == C_Megatarget then
      set chance = 100
      call CopyChatMegatarget()
    elseif c == C_Taunt then
      set chance = taunt_rate
      call CopyChatTaunt()
    elseif c == C_Thanks then
      set chance = 100
      call CopyChatThanks()
    else
      return
    endif
    if c == C_AGG or c == C_EGG then
      set immediate = true
    endif  
    if chance >= GetRandomReal(0.00,100.00) then
      call DisplayChat(chat_target_ally[c], chat_target_enemy[c], chat_target_obs[c], chat_important[c], immediate)
    endif
  endif
endfunction

function GetPlayerStartLocationLoc takes player whichPlayer returns location
  return GetStartLocationLoc(GetPlayerStartLocation(whichPlayer))
endfunction

function DisplayStratNames takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= rp_strat_length
    call DisplayToAllies(Int2Str(i) + ". " + GetStrategyName(i))
    set i = i + 1
  endloop
endfunction


function InitNeutralSkills takes nothing returns nothing
endfunction


function TownCountExForUpgrade takes integer unitid, integer unitid_upgr, boolean only_done, integer townid returns integer
  local integer count = 0
  if tc_add1[unitid] != unitid_upgr then
    set count = count + GetUnitCountEx(tc_add1[unitid],false,townid)
  endif
  if tc_add2[unitid] != unitid_upgr then
    set count = count + GetUnitCountEx(tc_add2[unitid],false,townid)
  endif
  return count

endfunction

function DistanceBetweenPoints takes location locA, location locB returns real
  local real distance = GetLengthOfLoc_d(GetSubtractionLoc(locB, locA))
  return distance
endfunction
function DistanceBetweenPoints_kd takes location locA, location locB returns real
  local real distance = GetLengthOfLoc_d(GetSubtractionLoc_dk(locB, locA))
  return distance
endfunction
function DistanceBetweenPoints_dk takes location locA, location locB returns real
  local real distance = GetLengthOfLoc_d(GetSubtractionLoc_kd(locB, locA))	
  return distance
endfunction
function DistanceBetweenPoints_dd takes location locA, location locB returns real
  local real distance = GetLengthOfLoc_d(GetSubtractionLoc_dd(locB, locA))
  return distance
endfunction

function DistanceBetweenUnits takes unit unitA, unit unitB returns real
  local real r = DistanceBetweenPoints_dd(GetUnitLoc(unitA), GetUnitLoc(unitB))
  return r
endfunction

function GetTimeToReachUnit takes unit u, unit target returns real
	local real distance = DistanceBetweenUnits(target, u)
	local real movespeed = GetUnitMoveSpeed(u)
	local real time = 15

	if movespeed != 0 then
		set time = distance / movespeed
	endif

	return time

endfunction

function GetTimeToReachLoc takes unit u, location target returns real
	local real movespeed = GetUnitMoveSpeed(u)
	local real time = 15
	local real distance = DistanceBetweenPoints_kd(target, GetUnitLoc(u))
	//call DisplayToAllJobDebug("gettime: before")
	if movespeed != 0 then
		set time = distance / movespeed
	endif
	//call DisplayToAllJobDebug("gettime: after")
	return time
endfunction

function EstimatedTimeToReachUnit_d takes location locA, unit target, real movespeed returns real
  local real time = 15
  local real distance = DistanceBetweenPoints_dd(locA, GetUnitLoc(target))

  if movespeed != 0 then
    set time = distance / movespeed
  endif
  return time

endfunction

function GetLocationBetweenLoc takes location locA, location locB, real d returns location
  local location locC = GetSubtractionLoc(locA, locB)
  local location locD = GetMultipleLoc(locC, d)
  local location l = GetSumLoc(locA, locD)
  local real x = GetLocationX(l)
  local real y = GetLocationY(l)
  call RemoveLocation(locC)
  set locC = null
  call RemoveLocation(locD)
  set locD = null
  call RemoveLocation(l)
  set l = null
  return Location(x,y)
endfunction

function GetLocationBetweenUnits takes unit u1, unit u2, real d returns location
  local location loc1 = GetUnitLoc(u1)
  local location loc2 = GetUnitLoc(u2)
  local location l = GetLocationBetweenLoc(loc1, loc2, d)
  local real x = GetLocationX(l)
  local real y = GetLocationY(l)
  call RemoveLocation(loc1)
  set loc1 = null
  call RemoveLocation(loc2)
  set loc2 = null
  call RemoveLocation(l)
  set l = null
  return Location(x,y)
endfunction

function GetTeleportLandPoint takes location l returns location
  local group g = CreateGroup()
  local unit u = null
  local real x = GetLocationX(l)
  local real y = GetLocationY(l)
  call GroupEnumUnitsInRangeOfLoc(g, l, 900, null)
  call RemoveLocation(teleportloc)  // set new loc , cannot return teleportloc
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null  //Find a enemy unit , land to unit loc , prevent army land to hall , cannot expand
    if not IsUnitType(u, UNIT_TYPE_FLYING) and not IsUnitInvisible(u, ai_player) and IsPlayerEnemy(ai_player,GetOwningPlayer(u)) and not IsUnitHidden(u) then
      set teleportloc = GetUnitLoc(u)
      call DestroyGroup(g)
      set g = null
      set u = null
      return GetUnitLoc(u)
    endif
    call GroupRemoveUnit(g, u)
  endloop
  set teleportloc = Location(x,y)
  call DestroyGroup(g)
  set g = null
  return Location(x,y)
endfunction

function GetNearestEnemyToLoc_k takes location l returns player
  local integer i = 0
  local integer min_p = 30
  local real nr = 0
  local real min_nr = 1000000

  loop
    exitwhen i >= c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set nr = DistanceBetweenPoints_dk(GetPlayerStartLocationLoc(enemy_force[i]), l)
      if nr < min_nr then
        set min_nr = nr
        set min_p = i
      endif
    endif
    set i = i + 1
  endloop
  if min_p != 30 then
    return enemy_force[min_p]
  endif
  return null
endfunction

function GetNearestEnemyToLoc_d takes location l returns player
  local integer i = 0
  local integer min_p = 30
  local real nr = 0
  local real min_nr = 1000000

  loop
    exitwhen i >= c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set nr = DistanceBetweenPoints_dk(GetPlayerStartLocationLoc(enemy_force[i]), l)
      if nr < min_nr then
        set min_nr = nr
        set min_p = i
      endif
    endif
    set i = i + 1
  endloop
  call RemoveLocation(l)
  if min_p != 30 then
    return enemy_force[min_p]
  endif
  return null
endfunction

function SetNearestEnemy takes nothing returns nothing
  local integer i = 0
  local real nr = 0
  local real humanrange = 20000  // preventing long-distance attacks
  loop
    exitwhen i >= c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set nr = DistanceBetweenPoints_dk(GetPlayerStartLocationLoc(enemy_force[i]), home_location)
      if nr < nearest_enemy_range then
        set nearest_enemy_range = nr
        set nearest_enemy = enemy_force[i]
        if GetPlayerController(enemy_force[i]) != MAP_CONTROL_COMPUTER and nr < humanrange then
          set humanrange = nr
          set nearest_human_enemy = enemy_force[i]
        endif
      endif
    endif
    set i = i + 1
  endloop
endfunction

function countAllyEnemy takes nothing returns nothing
  local integer i = 0
  local boolean self_came = false
  local boolean next_came = false
  local player p = null

  loop
    exitwhen i > RACE_NUMBER
    set c_ally[i] = 0
    set c_enemy[i] = 0
    set i = i + 1
  endloop

  set i = 0
  loop
    exitwhen i >= GetBJMaxPlayers()
    set p = Player(i)
    if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING and not IsPlayerObserver(p) then
      if GetPlayerController(p) == MAP_CONTROL_COMPUTER then
        set c_ai_total = c_ai_total + 1
      endif
      if IsPlayerAlly(ai_player,p) then
        if i == GetAiPlayer() then
          set self_came = true
          set next_came = true
          set own_force[force_number] = p
          set force_number = force_number + 1
        else
          if GetPlayerController(p) == MAP_CONTROL_COMPUTER then
            if not self_came then
              set first_ai = false
            elseif next_came then
              set next_ai = i
              set next_came = false
            endif
            set own_force[force_number] = p
            set force_number = force_number + 1
          else
            set no_ally_ctrl = false
            set c_ally_user_total = c_ally_user_total + 1
          endif
          set c_ally[player_race[i]] = c_ally[player_race[i]] + 1
          set ally_force[c_ally_total] = p
          set c_ally_total = c_ally_total + 1
        endif
      elseif IsPlayerEnemy(ai_player,p) then
        if GetPlayerController(p) != MAP_CONTROL_COMPUTER then
          set c_enemy_user_total = c_enemy_user_total + 1
        endif
        set c_enemy[player_race_pref[i]] = c_enemy[player_race_pref[i]] + 1
        set enemy_force[c_enemy_total] = p
        set c_enemy_total = c_enemy_total + 1
      endif
    endif
    set i = i + 1
  endloop
  set p = null
  set no_ai_ally = first_ai and next_ai == 0
endfunction

function CopyGroup takes group g returns group
  local group gnew = CreateGroup()
  if FirstOfGroup(g) != null then
    call BlzGroupAddGroupFast(g,gnew)
  endif
  return gnew
endfunction

function AreUnitsOfType takes group g, integer id returns boolean
  local group cg = CopyGroup(g)
  local unit u = null
  loop
    set u = FirstOfGroup(cg)
    exitwhen u == null
    if GetUnitTypeId(u) != id then
      call DestroyGroup(cg)
      set cg = null
      set u = null
      return false
    endif
    call GroupRemoveUnit(cg, u)
  endloop
  call DestroyGroup(cg)
  set cg = null
  return true
endfunction

function AddAbilityToGroup takes group g, integer abil returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitAbilityLevel(u, abil) <= 0 then
      call UnitAddAbility(u, abil)
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
endfunction

function SelectNumberOfId takes group rg, integer n, integer id returns group
  local integer c = 0
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    exitwhen c == n
    if GetUnitTypeId(u) == id then
      set c = c + 1
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  set u = null
  return rg
endfunction

function SelectById takes group rg, integer id, boolean is_id returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if (GetUnitTypeId(u) == id) == is_id then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByIdOr takes group rg, integer id1, integer id2, boolean is_id returns group
  local integer id = 0
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set id = GetUnitTypeId(u)
    if (id == id1 or id == id2) == is_id then
        call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectUnittype takes group rg, unittype typ, boolean is_of_type returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitType(u, typ) == is_of_type then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByIllusion takes group rg, boolean is_illusion returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitIllusion(u) == is_illusion then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByLoaded takes group rg, boolean is_loaded returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitLoaded(u) == is_loaded then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByHidden takes group rg, boolean is_visible returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitHidden(u) == is_visible then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByAlive takes group rg, boolean is_alive returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) == is_alive then
  //if not IsUnitType(u, UNIT_TYPE_DEAD) == is_alive then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByAlive2 takes group rg, boolean is_alive returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if (GetUnitState(u, UNIT_STATE_LIFE) > 0) == is_alive then
  //if not IsUnitType(u, UNIT_TYPE_DEAD) == is_alive then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByFullHealth takes group rg, boolean is_healed returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if (GetUnitState(u, UNIT_STATE_LIFE) >= GetUnitState(u, UNIT_STATE_MAX_LIFE)) == is_healed or IsUnitType(u, UNIT_TYPE_HERO) then
  //if not IsUnitType(u, UNIT_TYPE_DEAD) == is_alive then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByPlayer takes group rg, player p, boolean is_owner returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if (GetOwningPlayer(u) == p) == is_owner then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByInvisible takes group rg, player enemy, boolean is_visible returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitInvisible(u, enemy) == is_visible then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByVisible takes group rg, player enemy, boolean is_visible returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitVisible(u, enemy) == is_visible then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByDetected takes group rg, player enemy, boolean is_detected returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitDetected(u, enemy) == is_detected then
      call GroupAddUnit(rg, u ) 
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction 

function SelectByEnemy takes group rg, player p, boolean is_enemy returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsPlayerEnemy(p, GetOwningPlayer(u)) == is_enemy then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function IsStandardUnit takes unit u returns boolean
  if IsUnitInGroup(u, unit_healing) then
    return false
  elseif IsUnitInGroup(u, unit_rescueing) then
    return false
  elseif IsUnitInGroup(u, unit_harassing) then
    return false
  elseif IsUnitInGroup(u, unit_zepplin_move) then
    return false
  endif
  return true
endfunction

function IsUnitBuying takes unit u returns boolean
  if IsUnitInGroup(u, unit_buying_item) then
    return true
  elseif IsUnitInGroup(u, unit_buying_merc) then
    return true
  elseif IsUnitInGroup(u, unit_buying_tavern) then
    return true
  endif
  return false
endfunction

function SelectByUnitStandard takes group rg, boolean has_data returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsStandardUnit(u) == has_data then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByUnitFree takes group rg, boolean has_data returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if not IsUnitBuying(u) == has_data then
      call GroupAddUnit(rg, u )
  endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByOrder takes group rg, integer my_order, boolean has_order returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if (GetUnitCurrentOrder(u) == my_order) == has_order then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByOrderOr takes group rg, integer my_order1, integer my_order2, boolean has_order returns group
  local integer order = 0
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set order = GetUnitCurrentOrder(u)
    if ((order == my_order1) or (order == my_order2)) == has_order then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByOrderOr2 takes group rg, integer my_order1, integer my_order2, integer my_order3, boolean has_order returns group
  local integer order = 0
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set order = GetUnitCurrentOrder(u)
    if ((order == my_order1) or (order == my_order2) or (order == my_order3)) == has_order then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction
	
function SelectByLocation takes group rg, location l, real dist, boolean is_near returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if (DistanceBetweenPoints_dk(GetUnitLoc(u), l) <= dist) == is_near then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function GroupAddGroup takes group g, group to_add returns group
  call BlzGroupAddGroupFast(to_add, g) // Params intentionally reversed
  return g
endfunction


function GroupAddType takes group g, integer id, player p returns nothing
  local group ag = CreateGroup()
  call GroupEnumUnitsOfPlayer(ag, p, null)
  set ag = SelectNumberOfId(ag, 100, id)
  call GroupAddGroup(g, ag)
  call DestroyGroup(ag)
  set ag = null
endfunction

function GroupAddTypeAndRemoveGuard takes group g, integer id, player p returns nothing
  local unit u = null
  local group ag = CreateGroup()
  call GroupEnumUnitsOfPlayer(ag, p, null)
  loop
    set u = FirstOfGroup(ag)
    exitwhen u == null
    if GetUnitTypeId(u) == id then
      call RemoveGuardPosition(u)
      call GroupAddUnit(g,u)
    endif
    call GroupRemoveUnit(ag, u)
  endloop
  call DestroyGroup(ag)
  set ag = null
endfunction

function GroupRemoveGuardPositionInstant takes group g returns nothing
  local unit u = null
  local group ug = CopyGroup(g)

  loop
    set u = FirstOfGroup(ug)
    exitwhen u == null
    call RemoveGuardPosition(u)
    call GroupRemoveUnit(ug,u)
  endloop
  call DestroyGroup(ug)
  set ug = null
endfunction

function GroupRecycleGuardPositionInstant takes group g returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call RecycleGuardPosition(u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
endfunction

function GroupRecycleHarrassPositionInstant takes group g returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call RecycleGuardPosition(u)
    call AddAssault(1, GetUnitTypeId(u))
    call GroupRemoveUnit(unit_harassing, u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
endfunction

function GroupRecycleGuardPositionByStandard takes group g returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsStandardUnit(u) then
      call RecycleGuardPosition( u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
endfunction

function RemoveSentUnits takes group g returns group
  local integer i = 0
  loop
    exitwhen i > 3
    call GroupRemoveUnit(g, neutral_sent[i] )
    set i = i + 1
  endloop
  return SelectById(g, 'nzep', false)
endfunction

function GetOneOfId takes unit u, player p, integer id returns unit
  local group g = CreateGroup()
  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectByHidden(g, false)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == id then
      call DestroyGroup(g)
      set g = null
      return u
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return u
endfunction

function GetOneOfIdNearLoc takes unit u, player p, integer id, location l, real dist returns unit
  local group g = CreateGroup()
  call GroupEnumUnitsInRangeOfLoc(g, l, dist, null)
  set g = SelectByPlayer(g, p, true)
  set g = SelectByHidden(g, false)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == id then
      call DestroyGroup(g)
      set g = null
      return u
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return u
endfunction

function GetMineNearLoc takes unit u, location l, real dist returns unit
  local group g = null
  local integer i = 0
  local real distance = 1500
  if DistanceBetweenPoints(l , home_location) < 500 then
    if own_town_mine[0] != null and GetResourceAmount(own_town_mine[0]) > 0 then
      return own_town_mine[0]
    endif
  endif
  set g = CreateGroup()
  call GroupEnumUnitsInRangeOfLoc(g, l, dist, null)
  //set g = SelectByAlive(g, true)
  loop
    if minearray == 0 then
      call DisplayToAll("Warning - No standard gold mine set in standardunits.slk")
      call Sleep(3)
    endif
    set u = FirstOfGroup(g)
    exitwhen u == null
    set i = 0
    loop
      exitwhen i >= minearray
      if GetUnitTypeId(u) == racial_goldmine[i] and GetResourceAmount(u) > 0 then
        //if SetHasEntry(ver_gold_mines, GetUnitTypeId(u)) then
        //if GetUnitTypeId(u) =='ngol' or GetUnitTypeId(u) =='egol' or GetUnitTypeId(u) == 'ugol' then
        call Trace("GetMineNearLOC: A Mine match found")
        call DestroyGroup(g)
        set g = null
        return u
      endif
      set i = i + 1
    endloop
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return u
endfunction



    // local integer groundid = 'ewsp'
    // local integer seaid = 'hdes'
    // local integer amphibiousid = 'nsnp'
    // local integer flyid = 'hgyr'
    // local unit u = null
    // local real distance = 0
    // local location l = null
    // local real checktime = 0
    // local real totaltime = 0
	// local boolean exitloop = false
	// local location prev_loc = null
	// local integer checks = 0	// Number of times unit has stayed at same position

    // if path == PATHING_TYPE_WALKABILITY then
        // set u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), groundid, GetLocationX(locA), GetLocationY(locA), 270.00)
    // elseif path == PATHING_TYPE_FLOATABILITY then
        // set u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), seaid, GetLocationX(locA), GetLocationY(locA), 270.00)
    // elseif path == PATHING_TYPE_AMPHIBIOUSPATHING then
        // set u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), amphibiousid, GetLocationX(locA), GetLocationY(locA), 270.00)
    // elseif path == PATHING_TYPE_FLYABILITY then
        // set u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), flyid, GetLocationX(locA), GetLocationY(locA), 270.00)
    // else
        // set totaltime = -1
    // endif

	// if totaltime == 0 then
	    // call SetUnitInvulnerable(u, true)
        // call ShowUnit(u, false)
        // call SetUnitUseFood(u, false)
        // call SetUnitMoveSpeed(u, 520)
        // call RemoveGuardPosition(u)
        // call IssuePointOrder(u, "move", GetLocationX(target), GetLocationY(target))

    // set checktime =  GetTimeToReachLoc(u, target)
    // set totaltime = checktime
    // //call UnitApplyTimedLife(u, 'BTLF', checktime * 5)
    // //call Sleep(checktime)
    // set checktime = 2.00

    // loop
		// exitwhen (exitloop == true)
		// //	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "pathing loop")
        // set l = GetUnitLoc(u)
        // set distance = DistanceBetweenPoints(l,target)
        // if distance <= buy_distance then
		// //	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Tavern is pathable")
			// call CreateDebugTag("Target Destination is pathable", 10, u, 3.00, 1.50)
			// call RemoveUnit(u)
			// set u = null
			// set exitloop = true
            // //return totaltime
		// //elseif GetUnitCurrentOrder(u) == OrderId("stop") then
            // //return (totaltime * -1)
        // elseif GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
			// call RemoveUnit(u)
			// set u = null		
			// set exitloop = true
			// set totaltime = totaltime * -1
            // //return (totaltime * -1)
        // elseif GetUnitCurrentOrder(u) == OrderId("stop") or GetUnitCurrentOrder(u) != OrderId("move") then
			// set checks = checks + 1
			// call CreateDebugTag("Invisible Path unit has stopped", 10, u, 3.00, 1.50)
			// if checks > 1 then
				// call CreateDebugTag("Target Destination was not reached", 10, u, 3.00, 1.50)
				// call RemoveUnit(u)
				// set u = null	
				// set exitloop = true
				// set totaltime = totaltime * -1
				// //return (totaltime * -1)
			// endif
		// else
			// set checks = 0	// means unit is moving and not standing still
			// call CreateDebugTag("Invisible Path Unit Here", 10, u, 3.00, 1.50)	
        // endif
		// call RemoveLocation(l)
		// set l = null
        // set totaltime = totaltime + checktime	
        // call Sleep(checktime)

    // endloop
	// endif

    // return (totaltime)


function CreatePathingUnitFull takes unit u, player p, integer id, real x, real y returns unit
  if not IsVisibleToPlayer(x, y, ai_player) and p != Player(PLAYER_NEUTRAL_PASSIVE) then
    set p = Player(PLAYER_NEUTRAL_PASSIVE)
  endif
  set u = CreateUnit(p, id, x, y, 270.00)
  if (not debugging) then
    call ShowUnit(u, false)
  endif
  call UnitShareVision(u, ai_player, false)
  call SetUnitInvulnerable(u, true)
  call SetUnitUseFood(u, false)
  call SetUnitMoveSpeed(u, 522)
  if p != ai_player then
    call SetUnitOwner(u, ai_player, true)  // player overriden as neutral players cannot be used
  endif
  call RemoveGuardPosition(u)
  return u
endfunction

function CreatePathingUnit takes unit u returns unit
  // local integer groundid = 'ewsp'
  // if GetPlayerRace(ai_player) == RACE_NIGHTELF then
  //   set groundid = 'uaco' // alternative for night elf players to avoid it counting for players peon count
  // endif
  // Have to use ai_player as larger maps the passive player ai is restricted at such large numbers of units with orders being paused for seconds then continuing. Appears to be hardcoded into the warcraft 3 engine.
  set u = CreatePathingUnitFull(u, ai_player, groundid, GetLocationX(home_location), GetLocationY(home_location))
  return u
endfunction

function CanPathToLoc takes location locA, location target, pathingtype path returns real 


    //local integer groundid = 'ewsp'
    local integer seaid = 'hdes'
    local integer amphibiousid = 'nsnp'
    local integer flyid = 'hgyr'
    local unit u = null
    local real distance = 0
    //local location l = null
    local real checktime = 0
    local real totaltime = 0
    //local location prev_loc = null
    local integer checks = 0	// Number of times unit has stayed at same position

    if path == PATHING_TYPE_WALKABILITY then
      set u = CreatePathingUnitFull(u, Player(PLAYER_NEUTRAL_PASSIVE), groundid, GetLocationX(locA), GetLocationY(locA))
    elseif path == PATHING_TYPE_FLOATABILITY then
      set u = CreatePathingUnitFull(u, Player(PLAYER_NEUTRAL_PASSIVE), seaid, GetLocationX(locA), GetLocationY(locA))
    elseif path == PATHING_TYPE_AMPHIBIOUSPATHING then
      set u = CreatePathingUnitFull(u, Player(PLAYER_NEUTRAL_PASSIVE), amphibiousid, GetLocationX(locA), GetLocationY(locA))
    elseif path == PATHING_TYPE_FLYABILITY then
      set u = CreatePathingUnitFull(u, Player(PLAYER_NEUTRAL_PASSIVE), flyid, GetLocationX(locA), GetLocationY(locA))
    else
      return -1.0
    endif

    call IssuePointOrder(u, "move", GetLocationX(target), GetLocationY(target))

    set checktime =  GetTimeToReachLoc(u, target)
    set totaltime = checktime
    //call UnitApplyTimedLife(u, 'BTLF', checktime * 5)
    //call Sleep(checktime)
    set checktime = 2.00

    loop
    //	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "pathing loop")
      set distance = DistanceBetweenPoints_dk(GetUnitLoc(u),target)
      if distance <= buy_distance then
    //	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Tavern is pathable")
        call CreateDebugTag("Target Destination is pathable", 10, u, 3.00, 1.50)
        call RemoveUnit(u)
        set u = null
        return totaltime
    //elseif GetUnitCurrentOrder(u) == OrderId("stop") then
        //return (totaltime * -1)
      elseif GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
        call RemoveUnit(u)
        set u = null
        return (totaltime * -1)
      elseif GetUnitCurrentOrder(u) == OrderId("stop") or GetUnitCurrentOrder(u) != OrderId("move") then
        set checks = checks + 1
        call CreateDebugTag("Invisible Path unit has stopped", 10, u, 3.00, 1.50)
        if checks > 1 then
          call CreateDebugTag("Target Destination was not reached", 10, u, 3.00, 1.50)
          call RemoveUnit(u)
          set u = null
          return (totaltime * -1)
        endif
      else
        set checks = 0	// means unit is moving and not standing still
        call CreateDebugTag("Invisible Path Unit Here", 10, u, 3.00, 1.50)	
      endif
      set totaltime = totaltime + checktime	
      call Sleep(checktime)
    endloop
    return (totaltime * -1)

endfunction

function GetNearestNeutralQuick takes unit ru, integer id returns unit
  local group g = CreateGroup()
  local unit u = null
  local real distance = 10000000
  local real newdistance = 0
  call GroupEnumUnitsOfPlayer(g, Player(PLAYER_NEUTRAL_PASSIVE), null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null 
    if GetUnitTypeId(u) == id then
      set newdistance = DistanceBetweenPoints_kd(home_location, GetUnitLoc(u))
      if newdistance < distance then
        set distance = newdistance
        set ru = u
      endif
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  if GetUnitTypeId(u) == neutral_id[NEUTRAL_HEAL_WARD] and ru != null and IsUnitType(ru, UNIT_TYPE_SUMMONED) then
    set ru = null
  endif
  return ru
endfunction

function GetNearestNeutral takes unit ru, integer id returns unit
  local group g = CreateGroup()
  local unit u = null
  //    local unit homepeon = GetExpansionPeon() //Is to be used for checking pathability again
  local real distance = 0
  local group tempg = null
  local unit array pather
  local integer i = 0
  local integer checks = 0
  local boolean pathingdone = true
  //local real totaltime = 0
  //local integer groundid = 'ewsp'





  call GroupEnumUnitsOfPlayer(g, Player(PLAYER_NEUTRAL_PASSIVE), null)
  set ru = null
  set tempg = CopyGroup(g)
  loop
    set u = FirstOfGroup(tempg)
  exitwhen u == null
  if GetUnitTypeId(u) == id and not IsUnitType(ru, UNIT_TYPE_SUMMONED) then  //prevent neutral_id[NEUTRAL_HEAL_WARD]
    set pather[i] = CreatePathingUnit(pather[i])
    call IssuePointOrder(pather[i], "move", GetUnitX(u), GetUnitY(u))
    if (ModuloInteger(i,10) == 0) then
      call Sleep(0.3 * sleep_multiplier)
    endif  
    set i = i + 1
  else
    call GroupRemoveUnit(g, u)
  endif
  call GroupRemoveUnit(tempg, u)
  endloop
  call DestroyGroup(tempg)

  loop
    //set totaltime = totaltime + 3
    set pathingdone = true
    set tempg = CopyGroup(g)
    set i = 0
    loop
      set u = FirstOfGroup(tempg)
      exitwhen u == null
      if pather[i] != null then
        set distance = DistanceBetweenUnits(pather[i],u)
        if ru != null then
          call RemoveUnit(pather[i])
          set pather[i] = null
        elseif distance <= buy_distance then
        //call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Tavern is pathable")
          call CreateDebugTag("Target Destination is pathable", 10, pather[i], 3.00, 1.50)
          call RemoveUnit(pather[i])
          set pather[i] = null
          if ru == null then
            set ru = u
          endif
        //elseif GetUnitCurrentOrder(u) == OrderId("stop") then
                //return (totaltime * -1)
        elseif GetUnitState(pather[i], UNIT_STATE_LIFE) <= 0 then
            //call Trace("DIED")
          call RemoveUnit(pather[i])
          set pather[i] = null
        elseif GetUnitCurrentOrder(pather[i]) == OrderId("stop") or GetUnitCurrentOrder(pather[i]) != OrderId("move") then
          set checks = checks + 1
          call CreateDebugTag("Invisible Path unit has stopped", 10, pather[i], 3.00, 1.50)
          if checks > 1 then
            call CreateDebugTag("Target Destination was not reached", 10, pather[i], 3.00, 1.50)
            //call Trace("GOT STUCK")
            call RemoveUnit(pather[i])
            set pather[i] = null
          endif
        else
          set checks = 0	// means unit is moving and not standing still
          call CreateDebugTag("Invisible Path Unit Here", 10, pather[i], 3.00, 1.50)	
        endif
        set pathingdone = false
      endif
      call GroupRemoveUnit(tempg, u)
      set i = i + 1
    endloop
    call DestroyGroup(tempg)
    exitwhen pathingdone
    call Sleep(1 * sleep_multiplier)
  endloop
  set tempg = null
  call DestroyGroup(g)
  set g = null
  return ru 
	//loop
	//	set u = FirstOfGroup(g)
	//	exitwhen u == null 
	//	set l = GetUnitLoc(u)
	//	if GetUnitTypeId(u) == id then
	//	//set newdistance = DistanceBetweenPoints(start_loc, l )
	//	  	set newdistance = CanPathToLoc(start_loc, l, PATHING_TYPE_WALKABILITY)
	//		if newdistance > 0 and newdistance < distance then
	//		 set distance = newdistance
	//		 set ru = u
	//	     endif
	 //     endif

    //    call GroupRemoveUnit(g, u)
	//	call RemoveLocation(l)
	//	set l = null
	//endloop

	//	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "neutral out loop")
	//call DestroyGroup(g)
	//set g = null
	//call RemoveLocation(start_loc)
	//set start_loc = null	

endfunction

function GetNearestOfGroup takes unit ru, group g, location l returns unit
  local real d = 0
  local unit u = null
  local real sd = 1000000
  set ru = null
  if l != null then
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      set d = DistanceBetweenPoints_dk(GetUnitLoc(u), l)
      if d < sd then
        set sd = d
        set ru = u
      endif
      call GroupRemoveUnit(g, u )
    endloop
  endif
  return ru
endfunction

function GetNearestSubGroupOfGroup takes group rg, location l, integer n returns group
  local unit array ua
  local real array da
  local integer size = 0
  local integer i = 0
  local integer ru = 0
  local unit u = null
  local real d = 0
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set d = DistanceBetweenPoints_dk(GetUnitLoc(u), l)
    set i = size - 1
    loop
      exitwhen i < 0 or da[i] >= d
      set ua[i+1] = ua[i]
      set da[i+1] = da[i]
      set i = i - 1
    endloop
    set i = i + 1
    set ua[i] = u
    set da[i] = d
    set size = size + 1
    call GroupRemoveUnit(g,u)
  endloop
  set i = size - Min(n, size)
  loop
    exitwhen ru > size
    if ru == i and i < size then
      call GroupAddUnit(rg, ua[i])
      set i = i + 1
     endif
    set ua[ru] = null
    set ru = ru + 1
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function GetFarestOfGroup takes unit ru, group g, location l returns unit
  local real d = 0
  local unit u = null
  local real sd = 0
  set ru = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set d = DistanceBetweenPoints_dk(GetUnitLoc(u), l)
    if d > sd then
      set sd = d
      set ru = u
    endif
    call GroupRemoveUnit(g, u )
  endloop
  return ru
endfunction

function GetFastestToPointOfGroup takes unit ru, group g, location l returns unit
  local real d = 0
  local unit u = null
  local real sd = 1000000
  local real ms = 0
  set ru = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set ms = RMax(GetUnitMoveSpeed(u),0.01)
    set d = DistanceBetweenPoints_dk(GetUnitLoc(u), l) / ms
    if d < sd then
      set sd = d
      set ru = u
    endif
    call GroupRemoveUnit(g, u )
  endloop
  return ru
endfunction

function GetLeastHPUnitOfGroup takes unit ru, group g returns unit
  local real hp = 0
  local unit u = null
  local real lhp = 1000000
  set ru = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set hp = GetUnitState(u, UNIT_STATE_LIFE)
    if hp < lhp then
      set lhp = hp
      set ru = u
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  return ru
endfunction

function UnitAliveInGroup takes group g returns boolean
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    if u == null then
      call DestroyGroup(g)
      return false
    endif
    if UnitAlive(u) then
      set u = null
      return true
    endif
    call GroupRemoveUnit(g,u)
  endloop
  set u = null
  return true // never reached
endfunction

function GetUnitToBuy takes unit ru, unit buy_place returns unit
  local group g = CreateGroup()
  local unit u = null
  local real distance = 10000
  local real newdistance = 0
  set ru = null
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectByUnitStandard(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitType(u, UNIT_TYPE_STRUCTURE) == false and IsUnitType(u, UNIT_TYPE_PEON) == false and IsUnitType(u, UNIT_TYPE_SUMMONED) == false and not IsUnitIllusion(u) and GetUnitState(u, UNIT_STATE_LIFE) > 0 and not IsUnitInGroup(u, unit_buying_item) and not IsUnitInGroup(u, unit_buying_merc) then
      set newdistance = DistanceBetweenUnits(buy_place, u)
      if newdistance < distance then
        set distance = newdistance
        set ru = u
      endif
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  if ru == null then
    set ru = GetExpansionPeon()
    if ru == null then
      set ru = GetExpansionPeon2(ru)
    endif
  endif
  return ru
endfunction

function GetUnitOfTypeNearUnit takes integer ut, unit nu, unit ru returns unit
  local group g = CreateGroup()
  local location unitloc = GetUnitLoc(nu)

  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectById(g, ut, true)
  set ru = GetNearestOfGroup(ru, g, unitloc)
  call DestroyGroup(g)
  set g = null
  call RemoveLocation(unitloc)
  set unitloc = null
  return ru
endfunction

function GetUnusedZeppelinNearUnit takes unit ru, unit nu returns unit
  local group g = CreateGroup()
  local location unitloc = GetUnitLoc(nu)

  call GroupEnumUnitsOfType(g, "goblinzeppelin", null)
  set g = SelectByPlayer(g, ai_player, true)
  set g = SelectByOrderOr(g, 0, order_cancel, true)
  set g = SelectByUnitStandard(g, true)
 set ru = GetNearestOfGroup(ru, g, unitloc)
  call DestroyGroup(g)
  set g = null
  call RemoveLocation(unitloc)
  set unitloc = null
  return ru
endfunction

function RemoveUnitsOfType takes string ut returns nothing
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsOfType(g, ut, null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call GroupRemoveUnit(g, u)
    call RemoveUnit(u)
  endloop
  call DestroyGroup(g)
  set g = null
endfunction

function GetHeroNumber takes integer id returns integer
  local integer i = 1
  loop
    exitwhen i > 3
    if id == old_id[hero[i]] then
      return i
    endif
    set i = i + 1
  endloop
  return 1
endfunction

function GetHeroNumberOfUnit takes unit u returns integer
  local integer i = 1
  loop
    exitwhen i > 3
    if u == hero_unit[i] then
      return i
    endif
    set i = i + 1
  endloop
  return 1
endfunction


function GetUnitHero takes unit u returns unit
  local group g = CreateGroup()
  call GroupEnumUnitsOfPlayer(g,ai_player,null) 
  set g = SelectByAlive(g, true)
  set g = SelectByUnitStandard(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null 
    if IsUnitType(u, UNIT_TYPE_STRUCTURE) == false and IsUnitType(u, UNIT_TYPE_PEON) == false then
        call DestroyGroup(g)
      set g = null
      return u
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return u
endfunction

function GetUnitHeroReplacement takes unit u , location l returns unit
  local group g = CreateGroup()
  call GroupEnumUnitsOfPlayer(g,ai_player,null) 
  set g = SelectByAlive(g, true)
  set g = SelectByUnitStandard(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null 
    if IsUnitType(u, UNIT_TYPE_STRUCTURE) == false and IsUnitType(u, UNIT_TYPE_PEON) == false and IsUnitInRangeLoc(u, l, battle_radius) then
      call DestroyGroup(g)
      set g = null
      return u
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return u
endfunction

function GetMajorHero takes unit u returns unit
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] and UnitAlive(hero_unit[i]) and not IsUnitInGroup(hero_unit[i], unit_healing) then
      return hero_unit[i]
    endif
    set i = i + 1
  endloop
  return GetUnitHero(u)
  //return null
endfunction

function GetMajorHeroReplacement_d takes unit u, location l returns unit
  local integer i = 1

  loop
    exitwhen i > 3
    if hero_built[i] and UnitAlive(hero_unit[i]) and IsUnitInRangeLoc(hero_unit[i], l, battle_radius) and not IsUnitInGroup(hero_unit[i], unit_healing) then
      call RemoveLocation(l)
      return hero_unit[i]
    endif
    set i = i + 1
  endloop
  set u = GetUnitHeroReplacement(u,l)
  call RemoveLocation(l)
  return u
endfunction

function GetMajorHeroReplacement_k takes unit u, location l returns unit
  local integer i = 1

  loop
    exitwhen i > 3
    if hero_built[i] and UnitAlive(hero_unit[i]) and IsUnitInRangeLoc(hero_unit[i], l, battle_radius) and not IsUnitInGroup(hero_unit[i], unit_healing) then
      return hero_unit[i]
    endif
    set i = i + 1
  endloop
  return GetUnitHeroReplacement(u,l)
endfunction

function GetNeutralNumber takes integer id returns integer
  if buy_type[id] == BT_NEUTRAL_HERO then
    return NEUTRAL_TAVERN
  elseif buy_type[id] == BT_GOBLIN_MERC then
    return NEUTRAL_OBSERVATORY
  elseif buy_type[id] == BT_MERC then
    return NEUTRAL_MERC_CAMP
  else
    return NEUTRAL_DRAGON_ROOST
  endif
endfunction

function GetDensities takes location l, player p, real r returns nothing
  local group g = CreateGroup()
  local unit u = null
  local real ur = 0
  local real xe = 0
  local real ye = 0
  local real xa = 0
  local real ya = 0
  local location ul = null
  local location loc = null

  set enemy_density = 0
  set ally_density = 0
  call GroupEnumUnitsInRangeOfLoc(g, l, r, null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) then
      set ul = GetUnitLoc(u)
      set ur = 1 - (DistanceBetweenPoints(ul, l) / r)
      set loc = GetMultipleLoc(ul, ur)
      //if ur == 1 then
      if IsPlayerEnemy(p, GetOwningPlayer(u)) then
        set enemy_density = enemy_density + ur
        set xe = xe + GetLocationX(loc)  // Prevent loc exceeding map range
        set ye = ye + GetLocationY(loc)
        //set enemy_density_loc = GetSumLoc_dd(enemy_density_loc, GetMultipleLoc(ul, ur))
      elseif IsPlayerAlly(p, GetOwningPlayer(u)) then
        set ally_density = ally_density + ur
        set xa = xa + GetLocationX(loc)
        set ya = ya + GetLocationY(loc)
        //set ally_density_loc = GetSumLoc_dd(ally_density_loc, GetMultipleLoc(ul, ur))
      endif
      call RemoveLocation(loc)
      call RemoveLocation(ul)
    endif
    call GroupRemoveUnit(g, u)
  endloop

  if ally_density > 0 then
    set xa = xa / ally_density
    set ya = ya / ally_density
    //set ally_density_loc = GetDivisionLoc_d(ally_density_loc, ally_density)
  else
    set xa = 0
    set ya = 0
  endif
  call RemoveLocation(ally_density_loc)
  set ally_density_loc = Location(xa,ya)
  if enemy_density > 0 then
    set xe = xe / enemy_density
    set ye = ye / enemy_density
    //set enemy_density_loc = GetDivisionLoc_d(enemy_density_loc, enemy_density)
  else
    set xe = 0
    set ye = 0
  endif
  call RemoveLocation(enemy_density_loc)
  set enemy_density_loc = Location(xe,ye)
  call DestroyGroup(g)
  set g = null
  set ul = null
  set loc = null
endfunction

function ActionListInit takes integer an returns nothing
  local integer i = 0
  set action_numbers = an
  loop
    exitwhen i >= an
    set action_points[i] = 0.0
    set i = i + 1
  endloop
endfunction

function ActionRule takes boolean b, integer chn, real cha returns nothing
  if b then
    set action_points[chn] = action_points[chn] + cha
  endif
endfunction

function ActionRule2 takes boolean b, integer chn, real cha, integer chn2, real cha2 returns nothing
  if b then
    set action_points[chn] = action_points[chn] + cha
    set action_points[chn2] = action_points[chn2] + cha2
  endif
endfunction

function ActionRule3 takes boolean b, integer chn, real cha, integer chn2, real cha2, integer chn3, real cha3 returns nothing
  if b then
    set action_points[chn] = action_points[chn] + cha
    set action_points[chn2] = action_points[chn2] + cha2
    set action_points[chn3] = action_points[chn3] + cha3
  endif
endfunction

function ActionListEval takes nothing returns integer
  local integer i = 0
  local integer max_i = -1
  local real max_val = -10000000.0
  loop
    exitwhen i >= action_numbers
    if action_points[i] > max_val then
      set max_i = i
      set max_val = action_points[i]
    endif
    set i = i + 1
  endloop
  return max_i
endfunction

function GetPlayerStrengthHandicap takes player p returns real
  return SquareRoot(GetPlayerHandicap(p))
endfunction

function GetPlayerHeroBonusStrength takes player p returns integer
  local integer strength = 0
  return strength
endfunction
function GetHeroStrength takes unit u returns integer
  local integer lvl = GetHeroLevel(u)
  if not IsUnitInGroup(u, unit_healing) then
    if lvl >= ver_hero_ultimate_level then
     return R2I((ver_hero_base_value + lvl + ver_hero_ultimate_value)/2 + 0.5)
   else
     return R2I((ver_hero_base_value + lvl)/2 + 0.5)
    endif
  else
    return 0
  endif
endfunction

function GetPlayerHeroStrengthMod takes player p returns integer
  local group g = CreateGroup()
  local unit u = null
  local integer sum = 0
  local real handicap = GetPlayerStrengthHandicap(p)
  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectUnittype(g, UNIT_TYPE_HERO, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) then
      set sum = sum + R2I(GetHeroStrength(u) * handicap * (GetUnitState(u, UNIT_STATE_LIFE) / GetUnitState(u, UNIT_STATE_MAX_LIFE)))
    endif
    call GroupRemoveUnit(g,u)
  endloop
  set sum = sum + GetPlayerHeroBonusStrength(p)
  call DestroyGroup(g)
  set g = null
  return sum 
endfunction

function GetUnitStrengthEx takes unit u returns integer
  local integer f = GetUnitLevel(u)
  if GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_AGGRESSIVE) then
    if IsUnitType(u, UNIT_TYPE_HERO) then
      return GetHeroStrength(u)
    else
      return R2I((GetUnitFoodUsed(u) + f) / 2 + 0.5)
    endif
  else
    if f >= ver_hero_ultimate_level then
      return R2I((GetUnitFoodUsed(u)+ f + ver_hero_ultimate_value) / 2 + 0.5)
    else
      return R2I((GetUnitFoodUsed(u) + f)/2 + 0.5)
    endif
  endif
  return 0
endfunction

function GetUnitStrength takes unit u returns real
  if GetUnitState(u, UNIT_STATE_MAX_LIFE) == 0 then
    call DisplayToAll("ERROR: Major error has occured and caused amai system to crash at function GetUnitStrength")
    call DisplayToAll("Please contact the creator and provide this replay to them")
  endif
  return RMax(GetUnitStrengthEx(u) * GetPlayerStrengthHandicap(GetOwningPlayer(u)) * (GetUnitState(u, UNIT_STATE_LIFE) / GetUnitState(u, UNIT_STATE_MAX_LIFE)), 1.00)
endfunction

function GetPlayerStrength takes player p returns real

  local group g = CreateGroup()
  local unit u = null
  local real sum = 0

  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if not IsUnitType(u, UNIT_TYPE_HERO) and not IsUnitType(u, UNIT_TYPE_PEON) and not IsUnitType(u, UNIT_TYPE_STRUCTURE) and not IsUnitHidden(u) then
      //call Trace("A Unit strength added: " + Int2Str(R2I(GetUnitStrength(u))))
      set sum = sum + GetUnitStrength(u)
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  //call Trace("A HERO strength added: " + Int2Str(GetPlayerHeroStrengthMod(p)))
  return sum + I2R(GetPlayerHeroStrengthMod(p))


endfunction

function GetUnexactPlayerStrength takes player p returns integer
  local integer pid = GetPlayerId(p)
  if p_str_cache_timeout[pid] < ai_time then
    set p_str_cache[pid] = Max(0, R2I(GetPlayerStrength(p) * GetRandomReal(1 - I2R(uncertainty)/50, 1 + I2R(uncertainty)/50)) + GetRandomDiff(uncertainty/5))
    set p_str_cache_timeout[pid] = ai_time + p_str_cache_valid_time
  endif
  return p_str_cache[pid]
endfunction

function GetMaximumEnemyStrength takes nothing returns integer
  local integer i = 0
  local integer max = 0
  local player p = null
  loop
    exitwhen i >= c_enemy_total
    set p = enemy_force[i]
    if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING then
      set max = Max(max, R2I(GetPlayerStrength(p)))
    endif
    set i = i + 1
  endloop
  set p = null
  return max
endfunction

function GetPlayerairStrength takes player p returns real
  local real strength = 0
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oCOPTER )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oGRYPHON )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oWYVERN )
  set strength = strength + 8 * GetPlayerUnitTypeCount(p, oFROST_WYRM )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGARGOYLE )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGARGOYLE_MORPH )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oHIPPO )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oHIPPO_RIDER )
  set strength = strength + 5 * GetPlayerUnitTypeCount(p, oCHIMAERA )
  if ai_time >= 20 and ai_time <= 40 and GetPlayerUnitTypeCount(p, oSTRONGHOLD) >= 1 and GetPlayerUnitTypeCount(p, oORC_BARRACKS) == 0 then
    set strength = strength + 10
  endif
  return strength
endfunction
function GetPlayercastersStrength takes player p returns real
  local real strength = 0
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oPRIEST )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oSORCERESS )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oWITCH_DOCTOR )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oSHAMAN )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oBANSHEE )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oNECRO )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oDRUID_TALON )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oDRUID_TALON_M )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oDRUID_CLAW )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oDRUID_CLAW_M )
  return strength
endfunction
function GetPlayertowersStrength takes player p returns real
  local real strength = 0
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oCANNON_TOWER )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oGUARD_TOWER )
  set strength = strength + 0.3 * GetPlayerUnitTypeCount(p, oBURROW )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oORC_WATCH_TOWER )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oNECROPOLIS_2 )
  set strength = strength + 1.5 * GetPlayerUnitTypeCount(p, oNECROPOLIS_3 )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oZIGGURAT_2 )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oANCIENT_PROTECT )
  return strength
endfunction
function GetPlayerpiercingStrength takes player p returns real
  local real strength = 0
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oCOPTER )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oRIFLEMAN )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oHEAD_HUNTER )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oKODO_BEAST )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oWYVERN )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oCRYPT_FIEND )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGARGOYLE )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGARGOYLE_MORPH )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oARCHER )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oDRYAD )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oHIPPO_RIDER )
  return strength
endfunction
function GetPlayernormalStrength takes player p returns real
  local real strength = 0
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oFOOTMAN )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oKNIGHT )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oGRUNT )
  set strength = strength + 5 * GetPlayerUnitTypeCount(p, oTAUREN )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oABOMINATION )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGHOUL )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oDRUID_CLAW )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oDRUID_CLAW_M )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oHUNTRESS )
  return strength
endfunction
function GetPlayersiegeStrength takes player p returns real
  local real strength = 0
  set strength = strength + 0.5 * GetPlayerUnitTypeCount(p, oCOPTER )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oMORTAR )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oSTEAM_TANK )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oCATAPULT )
  set strength = strength + 0.5 * GetPlayerUnitTypeCount(p, oRAIDER )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oMEAT_WAGON )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oBALLISTA )
  return strength
endfunction
function GetPlayermagicStrength takes player p returns real
  local real strength = 0
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oGRYPHON )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oPRIEST )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oSORCERESS )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oWITCH_DOCTOR )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oSHAMAN )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oBANSHEE )
  set strength = strength + 6 * GetPlayerUnitTypeCount(p, oFROST_WYRM )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oNECRO )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oDRUID_TALON )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oDRUID_TALON_M )
  set strength = strength + 5 * GetPlayerUnitTypeCount(p, oCHIMAERA )
  return strength
endfunction
function GetPlayerunarmoredStrength takes player p returns real
  local real strength = 0
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oPRIEST )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oSORCERESS )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oWITCH_DOCTOR )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oKODO_BEAST )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oSHAMAN )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oBANSHEE )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGARGOYLE )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGARGOYLE_MORPH )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oNECRO )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oDRUID_TALON )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oDRUID_TALON_M )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oDRYAD )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oHIPPO )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oHUNTRESS )
  return strength
endfunction
function GetPlayerlightarmorStrength takes player p returns real
  local real strength = 0
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oGRYPHON )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oWYVERN )
  set strength = strength + 7 * GetPlayerUnitTypeCount(p, oFROST_WYRM )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oHIPPO_RIDER )
  set strength = strength + 5 * GetPlayerUnitTypeCount(p, oCHIMAERA )
  return strength
endfunction
function GetPlayermediumarmorStrength takes player p returns real
  local real strength = 0
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oRIFLEMAN )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oHEAD_HUNTER )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oRAIDER )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oCRYPT_FIEND )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oARCHER )
  return strength
endfunction
function GetPlayerheavyarmorStrength takes player p returns real
  local real strength = 0
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oFOOTMAN )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oKNIGHT )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oMORTAR )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oCATAPULT )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oGRUNT )
  set strength = strength + 5 * GetPlayerUnitTypeCount(p, oTAUREN )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oABOMINATION )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGHOUL )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oMEAT_WAGON )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oBALLISTA )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oDRUID_CLAW )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oDRUID_CLAW_M )
  return strength
endfunction

function GetPlayerAntiAirStrength takes player p returns real
  local group g = CreateGroup()
  local unit u = null
  local real sum = 0

  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitType(u, UNIT_TYPE_ATTACKS_FLYING) and not IsUnitType(u, UNIT_TYPE_STRUCTURE) and not IsUnitHidden(u) then
        set sum = sum + GetUnitStrength(u)
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return sum
endfunction

function IsCreepsAwake takes real x, real y, real radius returns boolean
  local group g = CreateGroup()
  local unit u = null
  local boolean awake_creeps = false

  call GroupEnumUnitsInRange(g,x,y,radius,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null or awake_creeps 
    if UnitAlive(u) and GetOwningPlayer(u) == Player(PLAYER_NEUTRAL_AGGRESSIVE) then
      set awake_creeps = not IsUnitType(u, UNIT_TYPE_SLEEPING)
    endif
    call GroupRemoveUnit(g,u)
  endloop

  call DestroyGroup(g)
  set g = null
  set u = null
  return awake_creeps
endfunction

function GetLocationCreepStrength takes real x, real y, real radius returns integer
  local group g = CreateGroup()
  local real sum = 0
  local real strength = 0
  local unit u = null
  local real airsum = 0
  set no_sleep = false
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and GetOwningPlayer(u) == Player(PLAYER_NEUTRAL_AGGRESSIVE) and not IsUnitHidden(u) then
      //call Trace("Getting unit strength begin")
      set strength = GetUnitStrength(u)
      set sum = sum + strength
      if IsUnitType(u, UNIT_TYPE_FLYING) then
        set airsum = airsum + strength
      endif
      if not UnitCanSleep(u) then
        set no_sleep = true
      endif
      //call Trace("Getting unit strength end")
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  set air_strength = R2I(airsum + 0.5)
  return R2I(sum + 0.5)
endfunction

function GetLocationCreepAirStrength takes real x, real y, real radius returns integer
  local group g = CreateGroup()
  local unit u = null
  local real airsum = 0
  set no_sleep = false
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and GetOwningPlayer(u) == Player(PLAYER_NEUTRAL_AGGRESSIVE) and not IsUnitHidden(u) then
      if IsUnitType(u, UNIT_TYPE_FLYING) then
        set airsum= airsum + GetUnitStrength(u)
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return R2I(airsum + 0.5)
endfunction

function GetLocationNonCreepStrength takes real x, real y, real radius returns integer
  local group g = CreateGroup()
  local real sum = 0
  local real strength = 0
  local unit u = null
  local real airsum = 0
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_AGGRESSIVE) and GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_PASSIVE) and IsPlayerEnemy(ai_player, GetOwningPlayer(u)) and not IsUnitHidden(u) and IsUnitType(u,UNIT_TYPE_STRUCTURE) == false and IsUnitType(u,UNIT_TYPE_PEON) == false and not (UnitInvis(u) and not IsUnitDetected(u, ai_player)) then
      set strength = GetUnitStrength(u)
      set sum = sum + strength
      if IsUnitType(u, UNIT_TYPE_FLYING) then
        set airsum = airsum + strength
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  set air_strength = R2I(airsum + 0.5)
  return R2I(sum + 0.5)
endfunction

function GetLocationEnemyStrength takes real x, real y, real radius, boolean only_structures returns integer
  local group g = CreateGroup()
  local integer sum = 0
  local unit u = null
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if ((only_structures and IsUnitType(u, UNIT_TYPE_STRUCTURE)) or (not only_structures and not IsUnitType(u, UNIT_TYPE_PEON))) and GetUnitState(u, UNIT_STATE_LIFE) > 0 and GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_AGGRESSIVE) and GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_PASSIVE) and IsPlayerEnemy(ai_player, GetOwningPlayer(u)) and not IsUnitHidden(u) then
      set sum = sum + 1
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return sum
endfunction


function IsUnitTower takes unit u returns boolean
  if IsUnitType(u, UNIT_TYPE_STRUCTURE) == true and IsUnitType(u, UNIT_TYPE_RANGED_ATTACKER) == true and not IsUnitHidden(u) then
    return true
  endif
  return false
endfunction

function GetLocationTowerStrength takes real x, real y, real radius returns integer
  local group g = CreateGroup()
  local unit u = null
  local integer sum = 0
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and IsPlayerEnemy(ai_player, GetOwningPlayer(u)) and IsUnitTower(u) then
      set sum = sum + 1
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return sum
endfunction

function GetLocationStrength takes real x, real y, real radius returns real
  local group g = CreateGroup()
  local real sum = 0
  local real strength = 0
  local unit u = null
  local real airsum = 0
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and not IsUnitHidden(u) and IsUnitType(u,UNIT_TYPE_PEON) == false and not (UnitInvis(u) and not IsUnitDetected(u, ai_player)) then
      set strength = GetUnitStrength(u)
      set sum = sum + strength
      if IsUnitType(u, UNIT_TYPE_FLYING) then
        set airsum = airsum + strength
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  set air_strength = R2I(airsum + 0.5)
  return sum
endfunction

function GetCreepBonus takes unit u, real radius returns integer
  local integer i = GetLocationCreepStrength(GetUnitX(u), GetUnitY(u), radius)
  //call Trace("Got bonus")
  if i >= 20 then
    return i + red_creep_camp_strength_bonus
  elseif i >= 10 then
    return i + orange_creep_camp_strength_bonus
  else
    return i + green_creep_camp_strength_bonus
  endif
endfunction

function GetExpansionStrength takes nothing returns integer
	//call Trace("Getting expansion strength")
	return GetCreepBonus(current_expansion, expansion_radius)
endfunction

function GetCreepCampStrength takes unit u returns integer
	return GetCreepBonus(u, creep_camp_radius)
endfunction

function GetOwnStrength takes nothing returns integer
  local real sum = 0
  local group g = CreateGroup()
  local unit u = null
  local integer max_ghouls = attacking_ghouls
  local integer ghoul_num = 0
  local real airsum = 0
  local real strength = 0
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and not IsUnitType(u, UNIT_TYPE_PEON) and not IsUnitType(u, UNIT_TYPE_HERO) and not IsUnitType(u, UNIT_TYPE_STRUCTURE) and not IsUnitInGroup(u, unit_healing) and not IsUnitHidden(u) then
      set strength = GetUnitStrength(u)
      if GetUnitTypeId(u) == old_id[racial_ghoul] then
        if ghoul_num < max_ghouls then
          set sum = sum + strength
          set ghoul_num = ghoul_num + 1
        endif
      else
        set sum = sum + strength
      endif
      if IsUnitType(u, UNIT_TYPE_ATTACKS_FLYING) then
        set airsum = airsum + strength
      endif
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  set air_strength = R2I(airsum + 0.5)
  return R2I(sum) + GetPlayerHeroStrengthMod(ai_player)
endfunction

function GetTQLock takes nothing returns nothing
  loop
    exitwhen tq_lock
    call Sleep(0.5)
  endloop
  set tq_lock = false
endfunction

function ReleaseTQLock takes nothing returns nothing
  set tq_lock = true
endfunction

function TQDisplay takes nothing returns nothing
  local integer i = 1
  call DisplayToAll("Displaying heap")
  loop
    exitwhen i > tq_length
    call DisplayToAll(Int2Str(R2I(tq_time[i])) + " " + Int2Str(tq_jid[i]))
    set i = i + 1
  endloop
endfunction

function TQCopy takes integer spos, integer tpos returns nothing
  set tq_time[tpos] = tq_time[spos]
  set tq_jid[tpos] = tq_jid[spos]
  set tq_par[tpos] = tq_par[spos]
  set tq_unit_par[tpos] = tq_unit_par[spos]
  set tq_group_par[tpos] = tq_group_par[spos]
endfunction

function TQExchange takes integer pos1, integer pos2 returns nothing
  call TQCopy(pos2, tq_length+1)
  call TQCopy(pos1, pos2)
  call TQCopy(tq_length+1, pos1)
endfunction

function TQUpHeap takes integer pos returns nothing
  if tq_time[pos] < tq_time[pos/2] then
    call TQExchange(pos, pos/2)
    call TQUpHeap(pos/2)
  endif
endfunction

function TQFillPos takes integer pos returns integer
  local integer lpos = 2*pos
  local integer rpos = 2*pos + 1
  if lpos > tq_length then
    return pos
  elseif rpos > tq_length then
    call TQCopy(lpos, pos)
    return lpos
  elseif tq_time[lpos] <= tq_time[rpos] then
    call TQCopy(lpos, pos)
    return TQFillPos(lpos)
  else
    call TQCopy(rpos, pos)
    return TQFillPos(rpos)
  endif
endfunction

function TQRemoveRoot takes nothing returns nothing
  local integer pos = 0
  call GetTQLock()
  set pos = TQFillPos(1)
  set tq_length = tq_length - 1
  if pos <= tq_length then
    call TQCopy(tq_length + 1, pos)
    call TQUpHeap(pos)
  endif
  call ReleaseTQLock()
endfunction

function TQAddJobEx takes real time, integer jid, integer par, unit unit_par, group group_par returns nothing
  call GetTQLock()
  set tq_length = tq_length + 1
  set tq_time[tq_length] = time
  set tq_jid[tq_length] = jid
  set tq_par[tq_length] = par
  set tq_unit_par[tq_length] = unit_par
  set tq_group_par[tq_length] = group_par
  call TQUpHeap(tq_length)
  call ReleaseTQLock()
endfunction

function TQAddJob takes real time, integer jid, integer par returns nothing
  call TQAddJobEx(TimerGetElapsed(tq_timer) + time, jid, par, null, null)
endfunction

function TQAddUnitJob takes real time, integer jid, integer par, unit unit_par returns nothing
  call TQAddJobEx(TimerGetElapsed(tq_timer) + time, jid, par, unit_par, null)
endfunction

function TQAddGroupJob takes real time, integer jid, integer par, unit unit_par, group group_par returns nothing
  call TQAddJobEx(TimerGetElapsed(tq_timer) + time, jid, par, unit_par, group_par)
endfunction





function GetLocationInDistanceFromLoc takes location loc, real dist returns location
  local real distance = 0
  local real x = 0
  local real y = 0
  local unit u = null
  //local real checktime = 0
  local boolean exitloop = false
  if loc == null then
    return null
  endif
  set u = CreatePathingUnitFull(u,Player(PLAYER_NEUTRAL_PASSIVE), groundid, GetLocationX(loc),GetLocationY(loc))
  call IssuePointOrder(u, "move", GetLocationX(home_location), GetLocationY(home_location))
  //set checktime = GetTimeToReachLoc(u, home_location)
  loop
    exitwhen (exitloop == true)
    set x = GetUnitX(u)
    set y = GetUnitY(u)
    set distance = DistanceBetweenPoints_dk(Location(x,y), loc)
    if distance >= dist then
      //call DisplayToAll("loc found")
      call RemoveUnit(u)
      set u = null
      return Location(x,y)
    elseif GetUnitState(u, UNIT_STATE_LIFE) <= 0 or GetUnitCurrentOrder(u) == OrderId("stop") or GetUnitCurrentOrder(u) != OrderId("move") then
      set exitloop = true
      //return null
    endif
    call Sleep(0.2)
  endloop
  call RemoveUnit(u)
  set u = null
  return null
endfunction


function GetLocationInDistanceFromBaseToLoc takes location loc, real d returns location
  local real distance = 0
  local real x = 0
  local real y = 0
  local unit u = null
  //local real checktime = 0

  set u = CreatePathingUnit(u)
  call IssuePointOrderLoc(u, "move", loc)
  //set checktime = GetTimeToReachLoc(u, loc)
  loop
    set x = GetUnitX(u)
    set y = GetUnitY(u)
    set distance = DistanceBetweenPoints_dk(Location(x,y), home_location)
    if distance >= d then
      call RemoveUnit(u)
      set u = null
      return Location(x,y)
    elseif GetUnitState(u, UNIT_STATE_LIFE) <= 0 or GetUnitCurrentOrder(u) == OrderId("stop") or GetUnitCurrentOrder(u) != OrderId("move") then
        call RemoveUnit(u)
        set u = null
      return null
    endif
    call Sleep(0.2)
  endloop
  call RemoveUnit(u)
  set u = null
  return null
endfunction

function GetBuildLocationInDistanceFromLoc_d takes integer id, location loc, real distance returns location
  local location buildloc = GetLocationInDistanceFromLoc(loc, distance)
  local unit u = null
  local real x = 0
  local real y = 0

  call RemoveLocation(loc)
  if buildloc != null then
    set u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), id, GetLocationX(buildloc), GetLocationY(buildloc), 270.0)
    call RemoveLocation(buildloc)
    set buildloc = null
    set x = GetUnitX(u)
    set y = GetUnitY(u)
    call RemoveUnit(u)
    set u = null
    return Location(x,y)
  endif
  return null
endfunction

function GetLumberLocationAtBase takes nothing returns location
  local integer ground_id = old_id[racial_peon]	//human peasant
  local real distance = 0
  local real x = 0
  local real y = 0
  local unit u = null
  if race_has_ghouls then
    set ground_id = old_id[racial_ghoul]
  endif
  set u = CreatePathingUnitFull(u, Player(PLAYER_NEUTRAL_PASSIVE), ground_id, GetLocationX(home_location), GetLocationY(home_location))
  call IssueImmediateOrder(u, "autoharvestlumber")
  call Sleep(5.00)
  set x = GetUnitX(u)
  set y = GetUnitY(u)
  call RemoveUnit(u)
  set u = null
  return Location(x,y)
endfunction

function BuildLumberMillAtBase takes nothing returns boolean
  local location buildloc = GetLumberLocationAtBase()
  local unit u = null
  local unit peon = GetExpansionPeon()
  local boolean b = false
  if buildloc != null then
    if peon == null then
      set peon = GetExpansionPeon2(peon)
    endif
    set u = CreateUnitAtLoc(Player(PLAYER_NEUTRAL_PASSIVE), old_id[racial_lumber], buildloc, 270.0)
    call RemoveLocation(buildloc)
    set buildloc = GetUnitLoc(u)
    call RemoveUnit(u)
    set u = null
    set b = IssuePointOrderByIdLoc(peon, old_id[racial_lumber], buildloc)
    call RemoveLocation(buildloc)
    set buildloc = null
  endif
  set peon = null
  if TownCount(racial_hall[2]) > 0 and GetUnitCount(racial_lumber) == 0 then
    set racial_lumber = -1  //Prevent always cannot build
  endif
  return b
endfunction

function BuildBRAtCreep takes nothing returns nothing
  local integer i = 0
  local integer s = 0
  local integer ru = 0
  local real distance = 3200
  local group g = CreateGroup()
  local unit u = null
  local unit array ua
  local unit array ub
  local unit array uc
  local location loc = null
  call GroupEnumUnitsInRange(g,GetLocationX(home_location), GetLocationY(home_location),distance,null)
  set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_AGGRESSIVE), true)
  set g = SelectUnittype(g, UNIT_TYPE_FLYING, false)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null or i >= 7  //7 shoul have 2 creepcamp
    if GetUnitLevel(u) < 5 and (uc[0] == null or (uc[0] != null and DistanceBetweenUnits(u, uc[0]) > 600) or (uc[1] != null and DistanceBetweenUnits(u, uc[1]) > 600)) then  //maybe have same camp creep unit not cleaned up
      set ua[i] = CreatePathingUnit(ua[i])
      call IssuePointOrder(ua[i], "move", GetUnitX(u), GetUnitY(u))
      set ub[i] = CreatePathingUnitFull(ub[i],ai_player,groundid,GetUnitX(u), GetUnitY(u))
      call IssueTargetOrder(ub[i], "smart", ua[i])  //go in opposite directions , save time
      set uc[i] = u
      set i = i + 1
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  set u = null
  if i == 0 then
    return
  endif
  set ru = i
  loop
    if i == ru then
      set i = 0
    endif
    exitwhen loc != null or s == ru
    if (DistanceBetweenUnits(ua[i], ub[i]) < 200 or DistanceBetweenUnits(ua[i], uc[i]) < 600) and GetUnitState(uc[i], UNIT_STATE_LIFE) > 0 then
      set loc = GetUnitLoc(uc[i])
      set rushcreep_target = uc[i]
    elseif GetUnitState(ua[i], UNIT_STATE_LIFE) <= 0 or GetUnitCurrentOrder(ua[i]) == OrderId("stop") or GetUnitCurrentOrder(ua[i]) != OrderId("move") or DistanceBetweenPoints_kd(home_location,GetUnitLoc(ua[i])) > 3200 then
      set s = s + 1
    elseif GetUnitState(ub[i], UNIT_STATE_LIFE) <= 0 or DistanceBetweenPoints_kd(home_location,GetUnitLoc(ub[i])) > 3200 then
      set s = s + 1
    elseif GetUnitState(uc[i], UNIT_STATE_LIFE) <= 0 then
      set s = s + 1
    endif
    set i = i + 1
    call Sleep(0.05)
  endloop
  set i = 0
  loop
    exitwhen i == ru
    call RemoveUnit(ua[i])
    set ua[i] = null
    call RemoveUnit(ub[i])
    set ub[i] = null
    set uc[i] = null
    set i = i + 1
  endloop
  if s == ru or loc == null then  // fail , not found creep
    return
  endif
  set loc = GetBuildLocationInDistanceFromLoc_d(old_id[racial_rushcreep], loc, 600)
  if loc != null and DistanceBetweenPoints(loc, home_location) < distance then  //Prevent some islands/shallow water terrain from creating u on the other side of the map
    if GetLocationCreepStrength(GetLocationX(loc), GetLocationY(loc), 510) <= 0 then  //if have enemy , cannot build
      set u = GetExpansionPeon2(u)
      if u == null or GetUnitCurrentOrder(u) != OrderId("harvest") then
        set g = CreateGroup()
        call GroupEnumUnitsOfPlayer(g, ai_player, null)
        set g = SelectUnittype(g, UNIT_TYPE_PEON, true)
        set g = SelectByLoaded(g, true)
        set u = FirstOfGroup(g)
        call DestroyGroup(g)
        set g = null
        call IssueTargetOrder(own_town_mine[0], "unload", u)
        call Sleep(0.01)
      endif
      call RemoveGuardPosition(u)  // no need reset guard , the tree can train
      call IssuePointOrderByIdLoc(u, old_id[racial_rushcreep], loc)
      set u = null
    endif
  endif
  call RemoveLocation(loc)
  set loc = null
endfunction

function MultipleMinefix takes nothing returns boolean
  local real i = 0
  local real c = 0
  local real distance = 1500
  local group g = null
  local unit mine = null
  local unit u = null
  local boolean b = true
  if town_threatened or not hero_built[1] or (GetGold() < 600 and GetWood() < 400) or (not race_manual_loading and not race_uses_mine_expansion) or (race_manual_loading and TownCount(race_manual_loading_mine) > 1) or (race_uses_mine_expansion and TownCount(racial_expansion) > 1) then
    return b  //no first hero priority build army , human and orc just harvest
  endif
  call Trace("Check Multiple Mine")
  set g = CreateGroup()
  call GroupEnumUnitsInRangeOfLoc(g, home_location, 1500, null)
  set g = SelectById(g, old_id[GOLD_MINE], true)
  set g = SelectByAlive(g, true)
  if (BlzGroupGetSize(g) < 2 and not race_manual_loading and not race_uses_mine_expansion) or BlzGroupGetSize(g) < 1 then
    call DestroyGroup(g)  // 2 is prevent now still have one mine(if BlzGroupGetSize now is 2 or more , have two mine , still need fix) , but human and orc can return to normal
    set g = null
    set u = null
    if not race_manual_loading then
      set first_town_mine = -1  //home_location only one or no mine , if not ELF , need end HARVEST CHECK job
    else
      set first_town_mine = 0
    endif
    return false
  endif
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetResourceAmount(u) > 0 then
      set i = DistanceBetweenPoints_kd(home_location,GetUnitLoc(u))
      if i <= distance then
        set distance = i
        set mine = u
      endif
      set c = c + 1
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  if race_manual_loading and TownCount(race_manual_loading_mine) < 1 then
    set u = GetOneOfIdNearLoc(u,ai_player,old_id[racial_expansion],home_location,1500)
    if u != null then
      call IssueTargetOrder(u, "entangle", mine)  // first entangle , no need build
      set u = null
    else
      set b = false
    endif
  elseif c > 2 then  //prevent build too much TOWNHALL
    set current_expansion = mine  //expansion mine
    set not_taken_expansion = mine
    set b = false
  endif
  set mine = null
  return b
endfunction

function CheckExpansionTaken takes unit expa returns boolean
  local group g = null
  local unit u = null
  if expa == null then
    return false
  elseif expa == not_taken_expansion then // Used in the ancient expansion and item expansion system
    return true
  endif
  set g = CreateGroup()
  call GroupEnumUnitsInRange(g, GetUnitX(expa), GetUnitY(expa), expansion_taken_radius, null)
  call GroupRemoveUnit(g, expa)
  set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_PASSIVE), false)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  //set g = SelectByAlive(g, true)
  set g = SelectByAlive2(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == old_id[racial_expansion] or IsUnitType(u,UNIT_TYPE_TOWNHALL) then
      call DestroyGroup(g)
      set g = null
      set u = null
      if not IsUnitHidden(u) then
        call GroupRemoveUnit(far_expansion, expa)
      endif
      return true
    elseif GetOwningPlayer(u) != ai_player and GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_AGGRESSIVE) then		// Creeps dosn't mean expansion is taken
      call DestroyGroup(g)
      set g = null
      set u = null
      return true
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  return false
endfunction

function CheckCreepsByRadius takes group g , unit u , real n returns group
  call GroupClear(g)
  call GroupEnumUnitsInRange(g, GetUnitX(u), GetUnitY(u), n, null)
  set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_AGGRESSIVE), true)
  set g = SelectByAlive(g, true)
  return g
endfunction

function GetExpFoeGroup takes group g , unit mine returns group
  set g = CreateGroup()
  call GroupEnumUnitsInRange(g, GetUnitX(mine), GetUnitY(mine), expansion_radius, null)
  set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_AGGRESSIVE), true)
  set g = SelectByAlive(g, true)
  if FirstOfGroup(g) == null then
    set g = CheckCreepsByRadius(g, mine, expansion_radius * 1.5)
  endif
  return g
endfunction

function GetCreepGuardGroup takes group g , integer nn returns group
  if g != null then
    call DestroyGroup(g)
  endif
  set g = CreateGroup()
  if nearest_neutral[nn] == null then
    return g
  endif
  call GroupEnumUnitsInRange(g, GetUnitX(nearest_neutral[nn]), GetUnitY(nearest_neutral[nn]), 750, null)
  set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_AGGRESSIVE), true)
  set g = SelectByAlive(g, true)
  if FirstOfGroup(g) == null and nn != NEUTRAL_TAVERN then
    set g = CheckCreepsByRadius(g, nearest_neutral[nn], 750 * 1.5)
  endif
  return g
endfunction

function AddExpansion takes unit u, real d returns nothing

  set expansion_list[expansion_list_length] = u
  set expansion_dist[expansion_list_length] = d
  if race_ancient_expansion_available then
    set expansion_ancient[expansion_list_length] = GetBuildLocationInDistanceFromLoc_d(old_id[racial_expansion], GetUnitLoc(u), ver_creeps_attack_buildings_dist + 500)
  endif
  set expansion_creeps[expansion_list_length] = GetExpFoeGroup(expansion_creeps[expansion_list_length],u)  // group of the the creeps that guard this mine
  if first_expansion_chosen == false then
    set first_expansion_chosen = (expansion_creeps[expansion_list_length] != null) or (CheckExpansionTaken(u) == false)
  endif
  set expansion_list_length = expansion_list_length + 1
endfunction

function AddWaterExpansion takes unit u returns nothing
  set water_expansion_list[water_expansion_list_length] = u
  call GroupAddUnit(water_expansion, u)
  set water_expansion_creeps[water_expansion_list_length] = GetExpFoeGroup(water_expansion_creeps[water_expansion_list_length],u)  // group of the the creeps that guard this mine
  set water_expansion_list_length = water_expansion_list_length + 1
endfunction

function GetExpNearestMin takes unit ru returns unit

local real distance = 0
local real seconddistance = 0
local unit u = null
local real mindistance = 10000  // max distance away the first mine can be
local real secMaxDistance = 6000  // max distance range second mine must be in
local unit nearmine = null
local unit secondmine = null
local group g = CreateGroup()
local integer rand = GetRandomInt(1,4)
call GroupEnumUnitsOfType(g, "goldmine", null)
loop
  set u = FirstOfGroup(g)
  exitwhen u == null
  if not CheckExpansionTaken(u) and GetLocationCreepStrength(GetUnitX(u), GetUnitY(u), expansion_radius) < 40 then
    set distance = DistanceBetweenPoints_dk(GetUnitLoc(u), home_location)
    if distance < mindistance then
      if mindistance < secMaxDistance then
        set secondmine = nearmine	
        set seconddistance = mindistance
      endif
      set mindistance = distance
      set nearmine = u
    elseif distance < seconddistance and distance <= secMaxDistance then
      set seconddistance = distance
      set secondmine = u
    endif
  endif
  call GroupRemoveUnit(g, u)
endloop
call DestroyGroup(g)
set g = null

if secondmine != null then
	if rand <= 3 then
		set secondmine = null
		set ru = nearmine
set nearmine = null
		return ru
	else
		set nearmine = null
		set ru = secondmine
set secondmine = null
		return ru
	endif
else
	set secondmine = null
	set ru = nearmine
	set nearmine = null
	return ru
endif
endfunction

function MakeExpansionList takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  local unit array pather
  local integer array traveltime
  local boolean array patherdone
  local integer i = 0
  local group tempg = null
  local integer checks = 0	// Number of times unit has stayed at same position  
  local boolean pathingdone = true
  local real totaltime = 0

  call GroupEnumUnitsOfType(g, "goldmine", null)

  call Trace("Find Expansions Create Units")
  set tempg = CopyGroup(g)
  loop
    set u = FirstOfGroup(tempg)
    exitwhen u == null
    set pather[i] = CreatePathingUnit(pather[i])
    call IssuePointOrder(pather[i], "move", GetUnitX(u), GetUnitY(u))	
    call GroupRemoveUnit(tempg, u)
    if (ModuloInteger(i,10) == 0) then
      call Sleep(0.3 * sleep_multiplier) // help spread start lag
    endif
    set i = i + 1
  endloop
  call DestroyGroup(tempg)
  call Trace("Find Expansions Created")
  loop
    set totaltime = totaltime + 3 * (sleep_multiplier)
    set pathingdone = true
    set tempg = CopyGroup(g)
    set i = 0
    loop
      set u = FirstOfGroup(tempg)
      exitwhen u == null
      if pather[i] != null then
        if DistanceBetweenUnits(pather[i],u) <= buy_distance then
          //call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Tavern is pathable")
          call CreateDebugTag("Target Destination is pathable", 10, pather[i], 3.00, 1.50)
          call RemoveUnit(pather[i])
          set pather[i] = null
          set patherdone[i] = true
          call AddExpansion(u, totaltime)
        //elseif GetUnitCurrentOrder(u) == OrderId("stop") then
                //return (totaltime * -1)
        elseif GetUnitState(pather[i], UNIT_STATE_LIFE) <= 0 then
          call RemoveUnit(pather[i])
          set pather[i] = null
          set patherdone[i] = true
        elseif GetUnitCurrentOrder(pather[i]) == OrderId("stop") or GetUnitCurrentOrder(pather[i]) != OrderId("move") then
          set checks = checks + 1
          call CreateDebugTag("Invisible Path unit has stopped", 10, pather[i], 3.00, 1.50)
          if checks > 1 then
            call CreateDebugTag("Target Destination was not reached", 10, pather[i], 3.00, 1.50)
            call RemoveUnit(pather[i])
            set pather[i] = null
            set patherdone[i] = true
            call AddWaterExpansion(u)
          endif
        else
          set checks = 0	// means unit is moving and not standing still
          call CreateDebugTag("Invisible Path Unit Here", 10, pather[i], 3.00, 1.50)
          //call IssuePointOrder(pather[i], "move", GetUnitX(u), GetUnitY(u))
        endif
        set pathingdone = false
      endif
      call GroupRemoveUnit(tempg, u)
      set i = i + 1
    endloop
    call DestroyGroup(tempg)
    exitwhen pathingdone
    call Sleep(1 * sleep_multiplier)
  endloop
  call DestroyGroup(g)
  set g = null
  set tempg = null
  call Trace("Expansion number: " + Int2Str(expansion_list_length))


endfunction

function make_exp_rp_positive takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= exp_number
    if exp_rp[i] < 0 then
      set exp_rp[i] = 0
    endif
    set i = i + 1
  endloop
endfunction

function sum_exp_rp takes nothing returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i >= exp_number
    set sum = sum + exp_rp[i]
    set i = i + 1
  endloop
  return sum
endfunction

function ChooseExp takes nothing returns integer

  local integer i = 1
  local integer sum = 0
  local integer exp_roll = GetRandomInt(1,100)
  local integer first = 0
  local integer second = 0
  local integer third = 0
  local integer riskyexp = GetRandomInt(1, exp_number - 1)
  loop
    exitwhen i >= exp_number
    if exp_rp[i] < exp_rp[first] then
      set third = second
      set second = first
      set first = i
    else
      if exp_rp[i] < exp_rp[second] then
        set third = second
        set second = i
      else
        if exp_rp[i] < exp_rp[third] then
          set third = i
        endif
      endif
    endif
    set i = i + 1
  endloop
  if (exp_roll <= 80) then 
    return first  // The closest expansion choice
  elseif (exp_roll <= 100) then 
    return second // The second closest expansion choice
  else
    return riskyexp  // Complete Random choice (effectively disabled at the moment)
  endif
  return 0
endfunction

function remove_exp takes integer h returns nothing
  local integer i = h
  set exp_number = exp_number - 1
  loop
    exitwhen i >= exp_number
    set exp_rp[i] = exp_rp[i + 1]
    set exp_unit[i] = exp_unit[i + 1]
    set exp_dist[i] = exp_dist[i + 1]
    set i = i + 1
  endloop
endfunction

function add_exp takes unit u, real dist, location ancient, group creeps returns nothing
  set exp_unit[exp_number] = u
  set exp_dist[exp_number] = dist
  set exp_ancient[exp_number] = ancient
  set exp_creeps[exp_number] = creeps
  set exp_number = exp_number + 1
endfunction

function GetNearestEnemyDistance takes nothing returns real
local integer i = 0
local real dist = 0
local real mindistance = 1000000
local real humandistance = 0
local player nearplayer = null
local player nearhumanplayer = null
local group g = CreateGroup()
local unit u = null
local unit tempu = null
local unit temphumanu = null

loop
  exitwhen i >= c_enemy_total
  if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
    call GroupEnumUnitsOfPlayer(g, enemy_force[i], null)
    set g = SelectUnittype(g, UNIT_TYPE_TOWNHALL, true)
    set g = SelectByAlive(g, true)
    set g = SelectByHidden(g, false)
    if FirstOfGroup(g) == null and GetPlayerRace(enemy_force[i]) == RACE_UNDEAD then
      call GroupClear(g)
      call GroupEnumUnitsOfPlayer(g, enemy_force[i], null)
      set g = SelectById(g, 'ugol', true)  //some human UD player donot build TOWNHALL
      set g = SelectByAlive(g, true)
      set g = SelectByHidden(g, false)
    endif
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      set dist = DistanceBetweenPoints_kd(home_location, GetUnitLoc(u))  //GetNearestEnemy base from all base, no longer GetPlayerStartLocationLoc
      if dist < mindistance then
        set mindistance = dist
        set nearplayer = enemy_force[i]
        set tempu = u
        if GetPlayerController(enemy_force[i]) != MAP_CONTROL_COMPUTER then
          set humandistance = dist
          set nearhumanplayer = enemy_force[i]
          set temphumanu = u
        endif
      endif
      call GroupRemoveUnit(g, u)
    endloop
    call GroupClear(g)
  endif
  set i = i + 1
endloop
if c_enemy_user_total == 1 then
  set builder[10] = temphumanu
  set rushedplayer = nearhumanplayer
  set mindistance = humandistance
else
  set builder[10] = tempu
  set rushedplayer = nearplayer
endif
call DestroyGroup(g)
set g = null
set nearplayer = null
set nearhumanplayer = null
set tempu = null
set temphumanu = null
return mindistance
endfunction

function MinRangeToEnemy takes location l returns real
  local integer i = 0
  local real d = 0
  local real min_d = 1000000
  
  loop
    exitwhen i >= c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set d = DistanceBetweenPoints_kd(l, GetPlayerStartLocationLoc(enemy_force[i]))
      if d < min_d then
        set min_d = d
      endif
    endif
    set i = i + 1
  endloop
  return min_d
endfunction


function GetRushFactor takes nothing returns integer
  return R2I(MinRangeToEnemy(home_location)) + (1000*(GetPlayers() - (c_enemy_total + c_ally_total + 1)))
endfunction

function CheckExpansionRebuild takes nothing returns boolean
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsInRange(g, GetUnitX(current_expansion), GetUnitY(current_expansion), expansion_taken_radius, null)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  //set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_PASSIVE), false)  // no need the Select
  set g = SelectByPlayer(g, ai_player, true)
  set g = SelectByAlive(g, true)

  if FirstOfGroup(g) != null then
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      if GetUnitTypeId(u) == old_id[racial_expansion] or IsUnitType(u,UNIT_TYPE_TOWNHALL) == true then
        call DestroyGroup(g)
        set g = null
        set u = null
        return false
      endif
      call GroupRemoveUnit(g, u)
    endloop
    if GetResourceAmount(current_expansion) > 2 * GetUnitGoldCost2(racial_expansion) and GetLocationNonCreepStrength(GetUnitX(current_expansion),GetUnitY(current_expansion),expansion_taken_radius) <= 0 then
      call DestroyGroup(g)
      set g = null
      return true
    endif
  endif
  call DestroyGroup(g)
  set g = null
  return false

endfunction

function ExpansionFormula takes integer exp_d, unit exp_u returns integer
  local group g = CreateGroup()
  local unit u = null

  call GroupEnumUnitsInRange(g, GetUnitX(exp_u), GetUnitY(exp_u), expansion_taken_radius, null)
  //set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  set g = SelectByPlayer(g, ai_player, true)
  set g = SelectByAlive(g, true)

  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitType(u, UNIT_TYPE_STRUCTURE) == true or IsUnitType(u, UNIT_TYPE_PEON) then
      call DestroyGroup(g)
      set g = null
      set u = null
      return R2I(exp_d*0.5)      // Increased likelyhood to build if was once owned by player
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null

  //return exp_d + R2I(I2R(GetLocationCreepStrength(GetUnitX(exp_u), GetUnitY(exp_u), expansion_radius)) / 2)
  return exp_d

endfunction

function add_exp_rp takes nothing returns nothing
  local integer i = 0
  local real way_dist = 0.0
  local integer max = 0
  local integer min = 1000000
  local real sv = 0.7
  local integer red = 0
  loop
    exitwhen i >= exp_number
    set exp_rp[i] = ExpansionFormula(R2I(exp_dist[i]), exp_unit[i])
    if exp_rp[i] > max then
      set max = exp_rp[i]
    endif
    if exp_rp[i] < min then
      set min = exp_rp[i]
    endif
    set i = i + 1
  endloop
endfunction

function IsRacialHall takes unit u, integer min_tier returns boolean
  local integer i = Max(min_tier, 1)
  loop
    exitwhen i > tiernum
    if GetUnitTypeId(u) == old_id[racial_hall[i]] then
      return true
    endif
    set i = i + 1
  endloop
  return false
endfunction

function IsRacialHallId takes integer id, integer min_tier returns boolean
  local integer i = Max(min_tier, 1)
  loop
    exitwhen i > tiernum
    if id == racial_hall[i] then
      return true
    endif
    set i = i + 1
  endloop
  return false
endfunction

function ChooseExpansion takes nothing returns nothing
  local integer i = 0
  local integer exp_chosen = 0
  local integer gold = 2 * GetUnitGoldCost2(racial_expansion)
  set exp_number = 0
  loop
    exitwhen i >= expansion_list_length
    if GetResourceAmount(expansion_list[i]) > gold and not CheckExpansionTaken(expansion_list[i]) and DistanceBetweenPoints_kd(home_location,GetUnitLoc(expansion_list[i])) > 1500 then
      call add_exp(expansion_list[i], expansion_dist[i], expansion_ancient[i], expansion_creeps[i])
    endif
    set i = i + 1
  endloop
  if exp_number < 3 and TownCountDone(neutral_zeppelin) > 0 then  //first taken normal mine
    set i = 0
    loop
      exitwhen i >= water_expansion_list_length
      if GetResourceAmount(water_expansion_list[i]) > gold and not CheckExpansionTaken(water_expansion_list[i]) then
        call add_exp(water_expansion_list[i], 60, null, water_expansion_creeps[i])
      endif
      set i = i + 1
    endloop
  endif
  if active_expansion and not pathing_done and exp_number < c_enemy_total + c_ally_total + 1 then
    set active_expansion = false
  endif
  call add_exp_rp()
  if exp_number == 0 then
    set current_expansion = null
    call Trace("No valid expansions")
  else
    set exp_chosen = ChooseExp()
    set current_expansion = exp_unit[exp_chosen]
    set ancient_exp_loc = exp_ancient[exp_chosen]
    set current_expansion_creeps = exp_creeps[exp_chosen]
  endif
endfunction

function GetExpFoe takes unit u returns unit
  local group g = CopyGroup(current_expansion_creeps)
  local location l = GetUnitLoc(current_expansion)
  //call Trace("Copy group")
  set g = SelectByAlive(g, true)
  set u = GetNearestOfGroup(u, g, l)
  call RemoveLocation(l)
  set l = null
  call DestroyGroup(g)
  set g = null
  //call Trace("Have a foe")
  return u
endfunction

function GetNeutralGuard takes integer nn returns boolean
  local group g = null
  local location l = null
  local unit u = null
  local boolean b = false
  if nearest_neutral[nn] == null or FirstOfGroup(neutral_guards[nn]) == null then
    return b
  endif
  set g = CopyGroup(neutral_guards[nn])
  set g = SelectByAlive(g, true)
  set l = GetUnitLoc(nearest_neutral[nn])
  set u = GetNearestOfGroup(u, g, l)
  call RemoveLocation(l)
  set l = null
  call DestroyGroup(g)
  set g = null
  set b = (u != null)
  set u = null
  return b
endfunction

function CanCreepGuardsSleep takes integer nn returns boolean
  local group g = null
  local unit u = null
  local boolean b = false
  if nearest_neutral[nn] == null then
    return b
  endif
  if FirstOfGroup(neutral_guards[nn]) == null then
    return true
  endif
  set g = CopyGroup(neutral_guards[nn])
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    exitwhen not UnitCanSleep(u)
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  set b = (u == null)
  set u = null
  return b
endfunction

function SetAIArray takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= GetBJMaxPlayers()
    if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(Player(i)) == MAP_CONTROL_COMPUTER and LoadBoolean(com, IS_AMAI, i) then
      set ai_force[ai_force_length] = i
      set ai_force_length = ai_force_length + 1
    endif
    set i = i + 1
  endloop
endfunction

function CheckFastExpansion takes nothing returns nothing
  local integer es = 0
  //local location expanloc = null
  local real timeaway = 0
  //local location l = null
  //local unit firstexp = null


  //set firstexp = null
  
  if current_expansion != null then
	set es = GetExpansionStrength()
  //MinRangeToEnemy(l) > 7000
	if GetRandomInt(1,2) == 1 and GetPlayers() > 2 and MinRangeToEnemy(home_location) > 7000 and es <= 0 then
		set exp_time_count = -exp_first_time
	endif
  //call RemoveLocation(l)
  //set l = null
  endif
endfunction

function AddFrontPoint takes location l returns nothing
  local real x = GetLocationX(l)
  local real y = GetLocationY(l)
  local unit pathable = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), groundid, x, y, 270.00)
  if DistanceBetweenPoints_dk(GetUnitLoc(pathable), l) <= 200 then
    call CreateDebugTagLoc("Front Point Added", 10, x, y, 60.00, 55.00)
    set front_loc[front_loc_num] = l
    set front_loc_num = front_loc_num + 1
  else
    //call CreateDebugTagLoc("Front Point : Not Buildable", 10, x, y, 60.00, 55.00)
    call RemoveLocation(l)
  endif
  call RemoveUnit(pathable)
  set pathable = null
endfunction

function ComputeFrontPoints takes nothing returns nothing
  local integer i = 0
  local integer n = 0
  local player p = null
  local unit array u
  local location loc = null
  local player mainplayer = Player(GetAiPlayer())
  local boolean pathingdone = true
  local boolean array patherdone
  local location l = null
  local real distance = 0
  loop
    exitwhen i >= c_enemy_total
    set p = enemy_force[i]
    if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING then
      set loc = GetPlayerStartLocationLoc(p)
      set u[n] = CreatePathingUnit(u[n])
      call IssuePointOrder(u[n], "move", GetLocationX(loc), GetLocationY(loc))
      call RemoveLocation(loc)
      set n = n + 1
    endif
    set i = i + 1
  endloop

  loop
    set pathingdone = true
    set i = 0
    loop
      exitwhen i >= n
      if patherdone[i] == false then
        if u[i] != null then
          set l = GetUnitLoc(u[i])
          set distance = DistanceBetweenPoints(l, home_location)
          if distance >= front_base_distance then
            call CreateDebugTag("Front Point Found", 10, u[i], 10.00, 8.00)
            call RemoveUnit(u[i])
            set u[i] = null
            set patherdone[i] = true
            call AddFrontPoint(Location(GetLocationX(l),GetLocationY(l)))
            call AddFrontPoint(AIGetProjectedLoc(l, home_location, 100, 90))
            call AddFrontPoint(AIGetProjectedLoc(l, home_location, 100, -90))
            call AddFrontPoint(AIGetProjectedLoc(l, home_location, 200, 80))
            call AddFrontPoint(AIGetProjectedLoc(l, home_location, 200, -80))
          elseif GetUnitState(u[i], UNIT_STATE_LIFE) <= 0 or GetUnitCurrentOrder(u[i]) == OrderId("stop") or GetUnitCurrentOrder(u[i]) != OrderId("move") then
            set patherdone[i] = true
            call RemoveUnit(u[i])
            set u[i] = null
          //else
            //call RemoveLocation(l)
          endif
          call RemoveLocation(l)
          set pathingdone = false
        endif
      endif
      set i = i + 1
    endloop
    exitwhen pathingdone
    call Sleep(0.1)
  endloop

  set front_locs_computed = true
  set l = null
  set loc = null
  set p = null
  set mainplayer = null

endfunction

function PingFrontPoints takes nothing returns nothing
  local integer i = 0
  local location l = null
  loop
    exitwhen i >= front_loc_num
    set l = front_loc[i]
    call PingMinimap(GetLocationX(l), GetLocationY(l), 20)
    set i = i + 1
  endloop
  set l = null
endfunction

function GetPlayerGold takes player p returns integer
    return GetPlayerState(p,PLAYER_STATE_RESOURCE_GOLD)
endfunction

function GetPlayerWood takes player p returns integer
    return GetPlayerState(p,PLAYER_STATE_RESOURCE_LUMBER)
endfunction

function set_aggression takes nothing returns nothing
  local integer f = FoodUsed()
  if false then
  elseif f >= 88 then
    set added_aggression = 20
  elseif f >= 80 then
    set added_aggression = 12
  elseif f >= 70 then
    set added_aggression = 10
  elseif f >= 60 then
    set added_aggression = 8
  elseif f >= 50 then
    set added_aggression = 7
  elseif f >= 40 then
    set added_aggression = 6
  elseif f >= 30 then
    set added_aggression = 5
  elseif f >= 20 then
    set added_aggression = 2
  else
    set added_aggression = 0
  endif

  if GetUnitCountDone(old_id[hero[1]]) == 0 then
    set added_aggression = added_aggression - 10
  endif
endfunction

function GetExpansionDistance takes nothing returns real
  return DistanceBetweenPoints_kd(home_location,GetUnitLoc(current_expansion))
endfunction

function GetItemNumberOnUnit takes integer id, unit u returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i > 5
    if GetItemTypeId(UnitItemInSlot(u, i)) == old_id[id] then
      set sum = sum + 1
    endif
    set i = i + 1
  endloop
  return sum
endfunction

function GetItemNumber takes integer id returns integer
  local integer sum = 0
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] then
      set sum = sum + GetItemNumberOnUnit(id, hero_unit[i])
    endif
    set i = i + 1
  endloop
  return sum
endfunction

function GetItemOfTypeOnUnit takes integer id, unit u returns item
  local integer i = 0
  loop
    exitwhen i > 5
    if GetItemTypeId(UnitItemInSlot(u, i)) == old_id[id] then
      set item_unit = u
      return UnitItemInSlot(u, i)
    endif
    set i = i + 1
  endloop
  return null
endfunction

function GetItemOfType takes item t, integer id returns item
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] then
      set t = GetItemOfTypeOnUnit(id, hero_unit[i])
      if t != null then
        return t
      endif
    endif
    set i = i + 1
  endloop
  return null
endfunction

function GetSlotsFreeOnUnit takes unit u returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i > 5
    if UnitItemInSlot(u, i) == null then
      set sum = sum + 1
    endif
    set i = i + 1
  endloop
  return sum
endfunction

function GetSlotsFree takes nothing returns integer
  local integer sum = 0
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] then
      set sum = sum + GetSlotsFreeOnUnit(hero_unit[i])
    endif
    set i = i + 1
  endloop
  return sum
endfunction

function GetHeroToBuyItem takes unit shop, real limit, boolean is_healing_included returns unit
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] and UnitAlive(hero_unit[i]) then
     if GetSlotsFreeOnUnit(hero_unit[i]) > 0 and DistanceBetweenUnits(hero_unit[i], shop) < limit and not IsUnitInGroup(hero_unit[i], unit_buying_tavern) and not IsUnitInGroup(hero_unit[i], unit_buying_merc) and not IsUnitInGroup(hero_unit[i], unit_harassing) then
       if is_healing_included == true and IsUnitInGroup(hero_unit[i], unit_healing) then
       else
          return hero_unit[i]
       endif
     endif
    endif
    set i = i + 1
  endloop
  return null
endfunction

function GetItemHero takes item it returns unit
  local integer i = 1
  loop
    exitwhen i > 3 or it == null
    if hero_built[i] and UnitAlive(hero_unit[i]) then
      if UnitHasItem(hero_unit[i], it) then
        return hero_unit[i]
      endif
    endif
    set i = i + 1
  endloop
  return null
endfunction

function AddHealer takes integer id, integer spell, integer mana_cost,integer t, integer upg_id, integer upg_level returns nothing
  set healer_id[healer_length] = id
  set healer_spell[healer_length] = spell
  set healer_mana_cost[healer_length] = mana_cost
  set healer_type[healer_length] = t
  set healer_upg_id[healer_length] = upg_id
  set healer_upg_level[healer_length] = upg_level
  set healer_length = healer_length + 1
endfunction

function InitHealers takes nothing returns nothing
  if own_race == R_ELF then
    call AddHealer(oDRUID_CLAW, 852160, 125, HEALER_TYPE_SUDDEN, oUPG_DRUID_CLAW, 1)
  endif
  if own_race == R_HUMAN then
    call AddHealer(oPRIEST, 852063, 5, HEALER_TYPE_CONTINUOUS, o0, 0)
  endif
  if own_race == R_ORC then
    call AddHealer(oWITCH_DOCTOR, 852109, 200, HEALER_TYPE_WARD, oUPG_ORC_DOCS, 2)
  endif
  if false then
  elseif merc_healer == RAZORMANE_MEDICINE_MAN then
    call AddHealer(oRAZORMANE_MEDICINE_MAN, 852109, 200, HEALER_TYPE_WARD, o0, 0)
  elseif merc_healer == FURBOLG_SHAMAN then
    call AddHealer(oFURBOLG_SHAMAN, 852160, 125, HEALER_TYPE_SUDDEN, o0, 0)
  elseif merc_healer == FOREST_TROLL_HIGH_PRIEST then
    call AddHealer(oFOREST_TROLL_HIGH_PRIEST, 852248, 5, HEALER_TYPE_CONTINUOUS, o0, 0)
  elseif merc_healer == FOREST_TROLL_SHADOW_PRIEST then
    call AddHealer(oFOREST_TROLL_SHADOW_PRIEST, 852248, 5, HEALER_TYPE_CONTINUOUS, o0, 0)
  elseif merc_healer == DRAENEI_DISCIPLE then
    call AddHealer(oDRAENEI_DISCIPLE, 852248, 5, HEALER_TYPE_CONTINUOUS, o0, 0)
  endif
endfunction

function GetHealerId takes integer id returns integer
  local integer i = 0
  loop
    exitwhen i >= healer_length
    if healer_id[i] == id then
      return i
    endif
    set i = i + 1
  endloop
  return -1
endfunction

function IsUnitHealer takes unit u returns boolean
  if GetUnitState(u, UNIT_STATE_MAX_MANA) <= 0 then
    return false
  else
    if GetHealerId(GetUnitTypeId(u)) >= 0 then
      return true
    endif
  endif
  return false
endfunction

function HealUnit takes unit healer, unit to_heal, boolean hero_heal returns nothing
  local integer id = GetHealerId(GetUnitTypeId(healer))
  if id == -1 then
    return
  endif
  if healer_type[id] != HEALER_TYPE_NO_TARGET then
    if healer_type[id] == HEALER_TYPE_WARD then
      if not ward_cast then
        call IssuePointOrderById(healer, healer_spell[id], GetUnitX(healer), GetUnitY(healer))
      endif
    else
      if healer_type[id] != HEALER_TYPE_HERO or hero_heal then
        call IssueTargetOrderById(healer, healer_spell[id], to_heal)
      endif
    endif
  endif
endfunction

function GetHealer takes unit u returns unit
  local integer id = 0
  loop
    set u = FirstOfGroup(healer_group)
    exitwhen u == null
    set id = GetHealerId(GetUnitTypeId(u))
    if id != -1 and GetUnitState(u, UNIT_STATE_MANA) >= healer_mana_cost[id] and ((healer_upg_id[id] == 0) or (GetUpgradeLevel(healer_upg_id[id]) >= healer_upg_level[id])) then
      return u
    endif
    call GroupRemoveUnit(healer_group, u)
  endloop
  return u
endfunction

function GetArmyOfUnit takes unit u returns integer
  local integer i = 0
  loop
    exitwhen i >= army_num
    if IsUnitInGroup(u, army_group[i]) then
      return i
    endif
    set i = i + 1
  endloop
  return -1
endfunction

function GroupRecycleGuardPosition takes group g returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call TQAddUnitJob(30, RESET_GUARD_POSITION, 0, u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
endfunction

function GroupRecycleGuardPositionDelay takes group g, real delay returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call TQAddUnitJob(delay, RESET_GUARD_POSITION, 0, u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
endfunction

function GetHealingItem takes nothing returns integer
	if false then
	endif
	return 0
endfunction

function GetMassHealingItem takes nothing returns integer
  if false then
  elseif true and available_time[M_SCROLL_OF_HEALING] <= ai_time then
    return M_SCROLL_OF_HEALING
  endif
  return 0
endfunction

function GetMerchantMassHealingItem takes nothing returns integer
	if false then
	endif
	return 0
endfunction

function GetGlobalHealingItem takes nothing returns integer
	if false then
	endif
	return 0
endfunction

function GetHeroManaItem takes nothing returns integer
	if false then
	endif
	return 0
endfunction

function GetItemHealingTime takes integer id returns integer
  if false then
  endif
  return 0
endfunction

function GetItemInstantType takes integer id returns integer
	if false then
	elseif M_SCROLL_OF_HEALING == id then
		return ITEMTYPE_SUDDEN
	elseif HEALING_POTION == id then
		return ITEMTYPE_SUDDEN
	endif
	return 0
endfunction 

function GetHeroHealingItem takes nothing returns integer
	if false then
	elseif true and available_time[HEALING_POTION] <= ai_time then
		return HEALING_POTION
	elseif GetHealingItem() != 0 then
		return GetHealingItem()
	elseif GetGlobalHealingItem() != 0 then
		return GetGlobalHealingItem()
	elseif GetMassHealingItem() != 0 then
		return GetMassHealingItem()
	elseif GetMerchantMassHealingItem() != 0 then
		return GetMerchantMassHealingItem()
	endif
	return 0
endfunction


function BuyNeutral takes integer id returns nothing
  local real timetotravel = 0
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  local real current_time = TimerGetElapsed(tq_timer)
  local real time_next_try = 0
  local real dist = 0
  local integer nn = GetNeutralNumber(id)
  local unit buy_place = nearest_neutral[nn]
  local boolean place_guarded = neutral_guarded[nn]
  local integer detectedenemies = GetLocationNonCreepStrength(GetUnitX(neutral_sent[nn]), GetUnitY(neutral_sent[nn]), 1000) 
  local location l = null
  //local boolean retreat_home = false

  call DisplayToAllJobDebug("BUY_NEUTRAL JOB START")
  // moved this check here to prevent a job crash if placed lower down
  if neutral_sent[nn] == null or not UnitAlive(neutral_sent[nn]) then
    if retreat_home then
      set retreat_home = false
      set buy_place = null
      return
    endif
    set neutral_sent[nn] = GetUnitToBuy(neutral_sent[nn], buy_place)
    if neutral_sent[nn] == null then
      call TQAddJob(sleep_multiplier, BUY_NEUTRAL, id)
      set buy_place = null
      return
    endif
    call GroupAddUnit(unit_buying_merc, neutral_sent[nn])
  endif
  if retreat_home then
    set l = GetUnitLoc(neutral_sent[nn])
    if DistanceBetweenPoints(l, home_location) >= 1100 then
      call CreateDebugTag("BUY_ITEM: Retreat to Home", 10, neutral_sent[nn], 3.00, 1.50)	
      call RemoveGuardPosition(neutral_sent[nn])
      call IssuePointOrder(neutral_sent[nn], "move", GetLocationX(home_location), GetLocationY(home_location))
      call TQAddJob(5, BUY_NEUTRAL, id)
    else
      call GroupRemoveUnit(unit_buying_merc, neutral_sent[nn])
      call RecycleGuardPosition(neutral_sent[nn])
      set retreat_home = false
      set neutral_sent[nn] = null
      set neutral_ordered[nn] = false
      set buy_time_large[nn] = -1
      set buy_time_small[nn] = -1
    endif
    set buy_place = null
    call RemoveLocation(l)
    set l = null
    return
  endif
 if DistanceBetweenUnits(neutral_sent[nn], buy_place) <= 800 and detectedenemies >= GetUnitStrength(neutral_sent[nn]) then
   call RemoveGuardPosition(neutral_sent[nn])
    call IssuePointOrder(neutral_sent[nn], "move", GetLocationX(home_location), GetLocationY(home_location))
    //call TQAddUnitJob(GetTimeToReachLoc(neutral_sent[nn], home_location), RESET_GUARD_POSITION, 1, neutral_sent[nn])
    set retreat_home = true
    call TQAddJob(1, BUY_NEUTRAL, id)
    set buy_place = null
    return
 endif
  if (buy_time_large[nn] >= 0 and buy_time_large[nn] + buy_timeout_large < current_time) or (buy_time_small[nn] >= 0 and buy_time_small[nn] + buy_timeout_small < current_time) then
    set available_time[id] = ai_time + regenerate_time[id] / 2
    call RecycleGuardPosition(neutral_sent[nn])
    call GroupRemoveUnit(unit_buying_merc, neutral_sent[nn])
    set neutral_sent[nn] = null
    set neutral_ordered[nn] = false
    set buy_time_large[nn] = -1
    set buy_time_small[nn] = -1
    set buy_place = null
    return
  endif
  if TownCountDone(id) >= neutral_wanted[nn] then
    call RecycleGuardPosition(neutral_sent[nn])
    call GroupRemoveUnit(unit_buying_merc, neutral_sent[nn])
    set neutral_sent[nn] = null
    set neutral_ordered[nn] = false
    set buy_time_large[nn] = -1
    set buy_time_small[nn] = -1
    set buy_place = null
    return
  endif
  if place_guarded and daytime >= 5 and daytime < 18 then
    set time_next_try = (18 - daytime)*20
  else
    call RemoveGuardPosition(neutral_sent[nn])
    //call SetUnitUserData(neutral_sent[nn], UNIT_BUYING)
    if buy_time_large[nn] < 0 then
      set buy_time_large[nn] = current_time
    endif
    set timetotravel = GetTimeToReachUnit(neutral_sent[nn], buy_place)
    set dist = DistanceBetweenUnits(neutral_sent[nn], buy_place)
    if dist < buy_distance then
      call CreateDebugTag("buy unit", 10, neutral_sent[nn], 3.00, 1.50) 
      call IssueImmediateOrder(neutral_sent[nn], "stop")
      call IssueNeutralImmediateOrderById(ai_player, buy_place, old_id[id])
      if buy_time_small[nn] < 0 then
        set buy_time_small[nn] = current_time
      endif
      set time_next_try = 0.5
    else
      call CreateDebugTag("move to merc camp", 10, neutral_sent[nn], 3.00, 1.50) 
      call IssuePointOrder(neutral_sent[nn], "move", GetUnitX(buy_place), GetUnitY(buy_place))
      set time_next_try = 4
    endif
  endif
  call TQAddJob(time_next_try, BUY_NEUTRAL, id)
  set buy_place = null
endfunction
function BuyNeutralHero takes integer id returns nothing
  local real timetotravel = 0
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  local real current_time = TimerGetElapsed(tq_timer)
  local real time_next_try = 0
  local real distance = 0
  local integer nn = GetNeutralNumber(id)
  local unit buying_unit = neutral_sent[nn]
  local unit tavern = nearest_neutral[nn]
  local boolean place_guarded = neutral_guarded[nn]

  call DisplayToAllJobDebug("BUY_NEUTRAL_HERO JOB START")

  //call Trace("Get Tavern Hero Job")

  if TownCountDone(id) >= neutral_wanted[nn] then
    call RecycleGuardPosition(neutral_sent[nn])
    call GroupRemoveUnit(unit_buying_tavern, neutral_sent[nn])
    set neutral_sent[nn] = null
    set neutral_ordered[nn] = false
    set buy_time_large[nn] = -1
    set buy_time_small[nn] = -1
    set buying_unit = null
    set tavern = null
    return
  endif

  if place_guarded and daytime >= 5 and daytime < 18 then
    set time_next_try = (18 - daytime)*20
  else

    if buying_unit == null or GetUnitState(buying_unit, UNIT_STATE_LIFE) <= 0 then
      set neutral_sent[nn] = GetUnitToBuy(neutral_sent[nn], tavern)
      set buying_unit = neutral_sent[nn]
      if neutral_sent[nn] == null then
        call TQAddJob(sleep_multiplier, BUY_NEUTRAL, id)
        call Trace("No unit to get neutral hero")
        set buying_unit = null
        set tavern = null
        return
      else
        call RemoveGuardPosition(buying_unit)
        call Trace("unit for neutral hero obtained")
      endif
    endif
    call GroupAddUnit(unit_buying_merc, buying_unit)

     set timetotravel = GetTimeToReachUnit(buying_unit, tavern)

    if current_time < (neutral_hero_time*5) - timetotravel then
      set time_next_try = RMax((neutral_hero_time*5) - timetotravel - current_time, 0.5 )
    else
      set distance = DistanceBetweenUnits(buying_unit, tavern)
      if distance >= buy_distance then
        call CreateDebugTag("Move to Tavern", 10, buying_unit, 3.00, 1.50)
        call IssuePointOrder(buying_unit, "move", GetUnitX(tavern), GetUnitY(tavern))
        set time_next_try = 4
      else
        call CreateDebugTag("buy tavern hero", 10, buying_unit, 3.00, 1.50) 
        call IssueImmediateOrder(buying_unit, "stop")
        call IssueNeutralImmediateOrderById(ai_player, tavern, old_id[id])
        set time_next_try = 0.5
      endif
    endif
  endif
  call TQAddJob(time_next_try, BUY_NEUTRAL_HERO, id)
  set buying_unit = null
  set tavern = null
endfunction

function FireChat takes nothing returns nothing
    local integer lockplayer = -1
    local integer i = 0
    if HaveStoredInteger(amaiCache, Int2Str(CHAT_LOCK), "lock") then
      set lockplayer = GetStoredInteger(amaiCache, Int2Str(CHAT_LOCK), "lock")
    endif  
    //call Trace("Chat Queue: Player Lock: " + Int2Str(lockplayer) + " AI Player:" + Int2Str(GetAiPlayer()))
    if chat_queue_size >= 0 or chat_strategy != null then
      call Trace("Chat Queue: Want to chat")
      if lockplayer <= -1 then
         call Trace("Chat Queue: Taking Lock")
         call StoreInteger(amaiCache, Int2Str(CHAT_LOCK), "lock", GetAiPlayer())
         call TQAddJob(1 + GetRandomInt(0, 2), CHAT_QUEUE, 0)
         return
      elseif lockplayer == GetAiPlayer() then
        set i_locked_chat = true
        if chat_strategy != null then
          call DisplayToPlayer(chat_strategy, GetLocalPlayer(), true)
          set chat_strategy = null
        else 
          call DisplayToPlayer(chat_queue[0] , chat_queue_player[0], chat_queue_importance[0])
          set i = 0
          loop
            exitwhen i == chat_queue_size
            set chat_queue[i] = chat_queue[i+1]
            set chat_queue_player[i] = chat_queue_player[i+1]
            set chat_queue_importance[i] = chat_queue_importance[i+1]
            set i = i + 1
          endloop
          set chat_queue_size = chat_queue_size - 1
        endif
      endif
    elseif lockplayer == GetAiPlayer() then
       set i_locked_chat = false
       call Trace("Chat Queue: Reset Lock")
       call FlushStoredInteger(amaiCache, Int2Str(CHAT_LOCK), "lock")
       call TQAddJob(21 + GetRandomInt(0, 4), CHAT_QUEUE, 0)
       return
    endif
    if i_locked_chat then
      call TQAddJob(5 + GetRandomInt(0, 3), CHAT_QUEUE, 0)
    else
      call TQAddJob(16 + GetRandomInt(0, 4), CHAT_QUEUE, 0)
    endif
endfunction
function SetPlayerGold takes player p, integer i returns nothing
    call SetPlayerState(p,PLAYER_STATE_RESOURCE_GOLD,i)
endfunction

function SetPlayerWood takes player p, integer i returns nothing
    call SetPlayerState(p,PLAYER_STATE_RESOURCE_LUMBER,i)
endfunction

function IncreasePlayerGold takes player p, integer i returns nothing
    call SetPlayerGold(p, GetPlayerState(p,PLAYER_STATE_RESOURCE_GOLD) + i)
endfunction

function IncreasePlayerWood takes player p, integer i returns nothing
    call SetPlayerWood(p, GetPlayerState(p,PLAYER_STATE_RESOURCE_LUMBER) + i)
endfunction

function DistributeGold takes integer value returns nothing
    local integer amount = value
    local integer p_amount = value / force_number
    local integer i = 0
    loop
      exitwhen i == force_number
      call IncreasePlayerGold(own_force[i], p_amount)
      set amount = amount - p_amount
      set i = i + 1
    endloop
    call IncreasePlayerGold(ai_player,amount)    
endfunction

function DistributeWood takes integer value returns nothing
    local integer amount = value
    local integer p_amount = value / force_number
    local integer i = 0
    loop
      exitwhen i == force_number
      call IncreasePlayerWood(own_force[i], p_amount)
      set amount = amount - p_amount
      set i = i + 1
    endloop
    call IncreasePlayerWood(ai_player,amount)    
endfunction

function ExchangeOnce takes nothing returns nothing
    local integer amount = 0
    if force_number == 0 then
      return
    endif
    set amount = GetPlayerGold(ai_player)
    if  amount > gold_exchange_level then
      call IncreasePlayerGold(ai_player, - (amount - gold_exchange_level))
      call DistributeGold(amount - gold_exchange_level)
    endif
    set amount = GetPlayerWood(ai_player)
    if  amount > wood_exchange_level then
      call IncreasePlayerWood(ai_player, - (amount - wood_exchange_level))
      call DistributeWood(amount - wood_exchange_level)
    endif
endfunction

function ExchangeJob takes nothing returns nothing
  call DisplayToAllJobDebug("EXCHANGE JOB Start")
  call ExchangeOnce()
  call TQAddJob(30 * sleep_multiplier, EXCHANGE, 0)
endfunction
function UpdateStrength takes nothing returns nothing
local player p = null
local integer i = 0
local integer enemy_num = 0
local integer ally_num = 0
local real Handicap = 0
local real air = 0
local real aair = 0
local real casters = 0
local real acasters = 0
local real towers = 0
local real atowers = 0
local real piercing = 0
local real apiercing = 0
local real normal = 0
local real anormal = 0
local real siege = 0
local real asiege = 0
local real magic = 0
local real amagic = 0
local real unarmored = 0
local real aunarmored = 0
local real lightarmor = 0
local real alightarmor = 0
local real mediumarmor = 0
local real amediumarmor = 0
local real heavyarmor = 0
local real aheavyarmor = 0

loop
  exitwhen i >= GetBJMaxPlayers()
  set p = Player(i)
  if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING and not IsPlayerObserver(p) then
    set Handicap = GetPlayerStrengthHandicap(p)
    if IsPlayerEnemy(ai_player, p) then
      set enemy_num = enemy_num + 1
      set air = air + ((GetPlayerairStrength(p)) * Handicap)
      set casters = casters + ((GetPlayercastersStrength(p)) * Handicap)
      set towers = towers + ((GetPlayertowersStrength(p)) * Handicap)
      set piercing = piercing + ((GetPlayerpiercingStrength(p)) * Handicap)
      set normal = normal + ((GetPlayernormalStrength(p)) * Handicap)
      set siege = siege + ((GetPlayersiegeStrength(p)) * Handicap)
      set magic = magic + ((GetPlayermagicStrength(p)) * Handicap)
      set unarmored = unarmored + ((GetPlayerunarmoredStrength(p)) * Handicap)
      set lightarmor = lightarmor + ((GetPlayerlightarmorStrength(p)) * Handicap)
      set mediumarmor = mediumarmor + ((GetPlayermediumarmorStrength(p)) * Handicap)
      set heavyarmor = heavyarmor + ((GetPlayerheavyarmorStrength(p)) * Handicap)
    elseif IsPlayerAlly(ai_player, p) then
      set ally_num = ally_num + 1
      set aair = aair + ((GetPlayerairStrength(p)) * Handicap)
      set acasters = acasters + ((GetPlayercastersStrength(p)) * Handicap)
      set atowers = atowers + ((GetPlayertowersStrength(p)) * Handicap)
      set apiercing = apiercing + ((GetPlayerpiercingStrength(p)) * Handicap)
      set anormal = anormal + ((GetPlayernormalStrength(p)) * Handicap)
      set asiege = asiege + ((GetPlayersiegeStrength(p)) * Handicap)
      set amagic = amagic + ((GetPlayermagicStrength(p)) * Handicap)
      set aunarmored = aunarmored + ((GetPlayerunarmoredStrength(p)) * Handicap)
      set alightarmor = alightarmor + ((GetPlayerlightarmorStrength(p)) * Handicap)
      set amediumarmor = amediumarmor + ((GetPlayermediumarmorStrength(p)) * Handicap)
      set aheavyarmor = aheavyarmor + ((GetPlayerheavyarmorStrength(p)) * Handicap)
    endif
  endif
  set i = i + 1
endloop
if air > 0 then
	set enemy_air = RMax(air + GetRandomDiff(area_uncertainty), 0 )
else
	set enemy_air = 0
endif
set ally_air = aair
if casters > 0 then
	set enemy_casters = RMax(casters + GetRandomDiff(area_uncertainty), 0 )
else
	set enemy_casters = 0
endif
set ally_casters = acasters
if towers > 0 then
	set enemy_towers = RMax(towers + GetRandomDiff(area_uncertainty), 0 )
else
	set enemy_towers = 0
endif
set ally_towers = atowers
if piercing > 0 then
	set enemy_piercing = RMax(piercing + GetRandomDiff(area_uncertainty), 0 )
else
	set enemy_piercing = 0
endif
set ally_piercing = apiercing
if normal > 0 then
	set enemy_normal = RMax(normal + GetRandomDiff(area_uncertainty), 0 )
else
	set enemy_normal = 0
endif
set ally_normal = anormal
if siege > 0 then
	set enemy_siege = RMax(siege + GetRandomDiff(area_uncertainty), 0 )
else
	set enemy_siege = 0
endif
set ally_siege = asiege
if magic > 0 then
	set enemy_magic = RMax(magic + GetRandomDiff(area_uncertainty), 0 )
else
	set enemy_magic = 0
endif
set ally_magic = amagic
if unarmored > 0 then
	set enemy_unarmored = RMax(unarmored + GetRandomDiff(area_uncertainty), 0 )
else
	set enemy_unarmored = 0
endif
set ally_unarmored = aunarmored
if lightarmor > 0 then
	set enemy_lightarmor = RMax(lightarmor + GetRandomDiff(area_uncertainty), 0 )
else
	set enemy_lightarmor = 0
endif
set ally_lightarmor = alightarmor
if mediumarmor > 0 then
	set enemy_mediumarmor = RMax(mediumarmor + GetRandomDiff(area_uncertainty), 0 )
else
	set enemy_mediumarmor = 0
endif
set ally_mediumarmor = amediumarmor
if heavyarmor > 0 then
	set enemy_heavyarmor = RMax(heavyarmor + GetRandomDiff(area_uncertainty), 0 )
else
	set enemy_heavyarmor = 0
endif
set ally_heavyarmor = aheavyarmor
set p = null
endfunction

function UpdateStrengthJob takes nothing returns nothing
  call DisplayToAllJobDebug("UPDATE_STRENGTH Start")
  if player_defeated then
    return
  endif
  call UpdateStrength()
  call TQAddJob(15 * sleep_multiplier, UPDATE_STRENGTH, 0)
endfunction
function countEnemyReal takes nothing returns nothing
  local integer i = 0
  local integer p = 0
  loop
    exitwhen i > RACE_NUMBER
    set c_enemy[i] = 0
    set i = i + 1
  endloop

  set i = 0
  loop
    exitwhen i >= c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set p = GetPlayerId(enemy_force[i])
      set c_enemy[player_race[p]] = c_enemy[player_race[p]] + 1
    endif
    set i = i + 1
  endloop
endfunction

function RevealEnemy takes nothing returns nothing
  call DisplayToAllJobDebug("REVEAL_ENEMY JOB START")
  call countEnemyReal()
endfunction
function SaveYourself takes nothing returns boolean
  if SaveYourselfMode == -1 then  // Choose self methods based on racial abilities , one ability use one num/mode , not recommended sale item or build(like UD)
    if current_expansion == null then
      call ChooseExpansion()
    endif
    if race_ancient_expansion_available == true and TownCountDone(racial_expansion) > 0 then
      call TQAddJob(2, ANCIENT_EXPANSION, 0)
      set ancient_expanding = true
      set SaveYourselfMode = ANCIENT_EXPANSION
      return true
    elseif race_militia_available == true then
      call TQAddJob(2, MILITIA_EXPAND, 0)
      set SaveYourselfMode = MILITIA_EXPAND
      return true
    endif
  else  //Check Self rescue situation
    if SaveYourselfMode == ANCIENT_EXPANSION then
      if ancient_expanding == true then
        return true  // In self rescue, wait
      elseif TownCount(race_manual_loading_mine) > 0 or not HallsCompleted(racial_expansion) or GetMinesOwned() > 0 then
        set SaveYourselfMode = -1  // Self rescue successful , because ancient_expanding is false and have mine
        return true
      endif
    elseif SaveYourselfMode == MILITIA_EXPAND then
      if not HallsCompleted(racial_expansion) or GetMinesOwned() > 0 then
        set SaveYourselfMode = -1
        return true
      endif
    endif
  endif
  return false
endfunction

function RemoveFromOwnForce takes player p returns nothing
  local integer i = 0
  loop
    if i >= force_number then
      return
    endif
    exitwhen own_force[i] == p
    set i = i + 1
  endloop
  set force_number = force_number - 1
  set i = 0
  loop
    exitwhen i >= force_number
    set own_force[i] = own_force[i+1]
    set i = i + 1
  endloop
endfunction

function KillYourself takes boolean end_ai returns nothing
    local group g = null
    local unit u = null
    local integer i = 0
    local player p = null
    if SaveYourself() then
      return
    endif
    if not player_defeated and not (GetPlayerSlotState(ai_player) == PLAYER_SLOT_STATE_LEFT) then
      call Chat(C_AGG)
      call Chat(C_EGG)
      call Sleep(3)
      set g = CreateGroup()
      call GroupEnumUnitsOfPlayer(g, ai_player, null)
      if destroy_buildings_on_defeat and (no_ai_ally and not humanPlayerAllys) then
        loop
          set u = FirstOfGroup(g)
          exitwhen u == null
          call KillUnit(u)
          call GroupRemoveUnit(g, u )
        endloop
        set player_defeated = true
      else
        loop
          exitwhen i >= c_ally_total
          set p = ally_force[i]
          if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING then
            call SetPlayerAlliance(ai_player, p, ALLIANCE_HELP_REQUEST,  true)
            call SetPlayerAlliance(ai_player, p, ALLIANCE_HELP_RESPONSE, true)
            call SetPlayerAlliance(ai_player, p, ALLIANCE_SHARED_XP,     true)
            call SetPlayerAlliance(ai_player, p, ALLIANCE_SHARED_SPELLS, true)
            call SetPlayerAlliance(ai_player, p, ALLIANCE_SHARED_VISION, true)
            call SetPlayerAlliance(ai_player, p, ALLIANCE_SHARED_CONTROL, true)
            call SetPlayerAlliance(ai_player, p, ALLIANCE_SHARED_ADVANCED_CONTROL, true)
          endif
          set i = i + 1
        endloop
        if not no_ai_ally then
          set wood_exchange_level = 0
          set gold_exchange_level = 0
          call RemoveFromOwnForce(ai_player)
          call ExchangeOnce()
        endif
        if not humanPlayerAllys and sharedRacePlayer != null then
          loop
            set u = FirstOfGroup(g)
            exitwhen u == null
            call SetUnitOwner(u, sharedRacePlayer, true)
            call GroupRemoveUnit(g, u )
          endloop
        endif
        call RemovePlayer(ai_player, PLAYER_GAME_RESULT_DEFEAT)
        set player_defeated = true
      endif
      call DestroyGroup(g)
      set g = null
      //if not destroy_buildings_on_defeat then
        //call SetPlayerAlliance(ai_player, Player(PLAYER_NEUTRAL_AGGRESSIVE), ALLIANCE_PASSIVE, true)  // trigger the victory/defeat recognition triggers
        //call SetPlayerAlliance(ai_player, Player(PLAYER_NEUTRAL_AGGRESSIVE), ALLIANCE_PASSIVE, false)
      //endif
    endif
endfunction

function Defeated takes nothing returns nothing
    if not (no_ai_ally and not humanPlayerAllys) then
      call Chat(C_Goldproblem)
      if ask_for_gold == false then
        set ask_for_gold = true
        return
      elseif GetGold() >= gold_problem_level then
        set ask_for_gold = false
        call Chat(C_Thanks)
        set desperation_assault = false
        return
      endif
    endif
    if (p_surrender[profile]) >= 3 and FoodUsed() < 15 and not (no_ai_ally and not humanPlayerAllys) then
      call KillYourself(no_ai_ally) // If no resources, and easily surrender just give up
    else
      if SaveYourself() then
        return
      endif
      set desperation_assault = true
    endif
endfunction

function CheckDefeated takes nothing returns nothing
  local integer hall_count = TownCount(racial_hall[1])
  local integer hall_cost = GetUnitGoldCost2(racial_hall[1])
  local integer expa_cost = GetUnitGoldCost2(racial_expansion)
  local integer expa_count = TownCount(racial_expansion)
  local integer expa_done_count = TownCountDone(racial_expansion)
  local integer worker_cost = GetUnitGoldCost2(racial_peon)
  local integer worker_count = TownCount(racial_peon)
  local integer farm_food = GetFoodMade(old_id[racial_farm])
  local integer farm_count = TownCount(racial_farm)
  local integer farm_cost = GetUnitGoldCost2(racial_farm)
  local integer food_use = FoodUsed()
  local integer gold = GetGold()
  local integer mines = GetMinesOwned()
  local integer agg = p_surrender[profile]
  local group g = CreateGroup()
  local unit u = null
  local player p = null
  local real enemy_sum = 0
  local real player_sum = GetPlayerStrength(ai_player)
  local real ally_sum = 0
  local integer i = 0

  if disable_surrender then
    set agg = 0
  endif

  if town_threatened then
    set enemy_sum = army_strength[town_threat_army[most_threatened_town]]
  else
    call GroupEnumUnitsInRange(g,GetLocationX(home_location),GetLocationY(home_location),front_base_distance,null)
    set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_AGGRESSIVE), false)
    set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_PASSIVE), false)
    set g = SelectByAlive(g, true)
    loop
        set u = FirstOfGroup(g)
        exitwhen u == null
      if IsPlayerEnemy(ai_player, GetOwningPlayer(u)) then
          set enemy_sum = enemy_sum + GetUnitStrength(u)
        endif
    call GroupRemoveUnit(g,u)
    endloop
  endif
  call DestroyGroup(g)
  set g = null

  loop
    exitwhen i >= c_ally_total
    set p = ally_force[i]
    if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING then
      set ally_sum = ally_sum + GetPlayerStrength(p)
    endif
    set i = i + 1
  endloop
  set ally_sum = ally_sum + GetOwnStrength()
  set p = null
  if GetPlayerUnitCount(ai_player, true) == 0 and GetPlayerStructureCount(ai_player, true) == 0 then
    call KillYourself(no_ai_ally)	
    return
  endif
  
  if food_use == 0 and hall_count == 0 then
    if (agg <= 0 and (no_ai_ally and not humanPlayerAllys)) then
      if SaveYourself() then
        return
      endif
      set desperation_assault = true
    else
      call KillYourself(no_ai_ally)
      return
    endif
  endif

  if food_use < 6 and hall_count == 0 and worker_count == 0 then
    if (agg <= 1 and (no_ai_ally and not humanPlayerAllys)) then
      if SaveYourself() then
        return
      endif
      set desperation_assault = true
    else 
      call KillYourself(no_ai_ally)
      return
    endif
  endif
  
  // Overwhelmed
  if agg > 1 and enemy_sum > ((player_sum + ally_sum + 5) * (5 - (agg - 2))) and hall_count <= 1 then // each agg above 2 increases give up chance by 1 multiplicative factor
    call KillYourself(no_ai_ally)
    return
  endif
  
  // Key Resource issues
  if hall_count == 0 and gold < hall_cost then
    set gold_problem_level = hall_cost
    call Defeated()
    return
  endif
  if (farm_count * farm_food) < food_use and mines == 0 and gold < farm_cost and worker_count == 0 then
    set gold_problem_level = farm_cost
    call Defeated()
    return
  endif
  if worker_count == 0 and gold < worker_cost and hall_count >= 1 then
    set gold_problem_level = worker_cost
    call Defeated()
    return
  endif
  if mines == 0 and gold < expa_cost and (expa_count - expa_done_count) == 0 and player_sum < 10 then
    set gold_problem_level = expa_cost
    call Defeated()
    return
  endif

endfunction

function SumForceState takes playerstate ps returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i >= force_number
    set sum = sum + GetPlayerState(own_force[i],ps)
    set i = i + 1
  endloop
  return sum
endfunction

function SumForceFood takes nothing returns integer
  return SumForceState(PLAYER_STATE_RESOURCE_FOOD_USED)
endfunction

function SumForceGold takes nothing returns integer
  return SumForceState(PLAYER_STATE_RESOURCE_GOLD)
endfunction

function CheckDefeatedForce takes nothing returns nothing
  if SumForceFood() == 0 and SumForceGold() <= 100 then
    call KillYourself(true)
  endif
endfunction

function DetectDefeatJob takes nothing returns nothing
  local integer i = 0
  local player p = null
  call DisplayToAllJobDebug("DETECT_DEFEAT Job Start")
  set no_ai_ally = true
  loop
    exitwhen i >= c_ally_total
    set p = ally_force[i]
    if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING then
      if GetPlayerController(p) == MAP_CONTROL_USER then
        set humanPlayerAllys = true
      else
        set no_ai_ally = false
        if GetPlayerRace(ai_player) == GetPlayerRace(p) then
          set sharedRacePlayer = p
        endif
      endif
    endif
    set i = i + 1
  endloop
  call CheckDefeated()
  call CheckDefeatedForce()
  if desperation_assault == true and (TownCount(race_manual_loading_mine) > 0 or not HallsCompleted(racial_expansion) or GetMinesOwned() > 0) then
    set desperation_assault = false
  endif
  if not player_defeated then
    call TQAddJob(13 * sleep_multiplier, DETECT_DEFEAT, 0)
  endif
endfunction
function GetOtherExpansionNearby takes unit ru, real tx, real ty returns unit
  local group g = CreateGroup()
  local unit u = null
  //local integer id = 0
  set ru = null
  call GroupEnumUnitsInRange(g, tx, ty, expansion_taken_radius, null)
  set g = SelectByPlayer(g, ai_player, false)
  set g = SelectByAlive2(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    //set id = GetUnitTypeId(u)
    if IsUnitType(u, UNIT_TYPE_TOWNHALL) == true or GetUnitTypeId(u) == 'ugol' then //or id == oUNDEAD_MINE then//id == oTOWN_HALL or id == oKEEP or id == oCASTLE or id == oUNDEAD_MINE or id == oGREAT_HALL or id == oSTRONGHOLD or id == oFORTRESS or id == oTREE_LIFE or id == oTREE_AGES or id == oTREE_ETERNITY then
      call DestroyGroup(g)
      set g = null
      set ru = u
      set u = null
      return ru
    elseif IsPlayerEnemy(GetOwningPlayer(u), ai_player) and IsUnitType(u, UNIT_TYPE_STRUCTURE) == true then
      set ru = u
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return ru
endfunction

function CheckDoubleExpansion takes nothing returns nothing
  local group g = CreateGroup()
  local unit v = null
  local unit u = null
  local player p = null
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectNumberOfId(g, 100, old_id[racial_expansion])
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set v = GetOtherExpansionNearby(v, GetUnitX(u), GetUnitY(u))
    if v != null then
      set p = GetOwningPlayer(v)
      if IsPlayerEnemy(ai_player, p) then
        call Trace("Enemy double expansion detected")
        set double_expansion_target = v
      elseif IsPlayerAlly(ai_player, p) then
        call Trace("Ally double expansion detected")
        call IssueImmediateOrderById(u, order_cancel)
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  set p = null
  set v = null
endfunction

function DetectDoubleExpJob takes nothing returns nothing
  call DisplayToAllJobDebug("DETECT_DOUBLE JOB START")
  call CheckDoubleExpansion()
  call TQAddJob(10 * sleep_multiplier, DETECT_DOUBLE_EXP, 0)
endfunction
function ZeppelinFollowJob takes nothing returns nothing
  local real dist = 0
  local location l = null
  local group g = CreateGroup()
  local location heroloc = null
  local boolean b = true
  call DisplayToAllJobDebug("ZEPPELIN_FOLLOW Start")
  //call GroupEnumUnitsOfType(g, "goblinzeppelin", null)
  // ---------- NO CUSTOMIZEABLE SECTION DETECTED
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  //set g = SelectByPlayer(g, ai_player, true)
  set g = SelectById(g, old_id[neutral_zeppelin], true)
  //-----------------------------------------------
  //set g = SelectByOrderOr(g, 0, order_attack, true)
  set g = SelectByUnitStandard(g, true)
  if water_expansion_list_length == 0 or racial_lumber != 0 or not race_no_wood_harvest then
    call GroupRemoveGuardPositionInstant(g)  //water_expansion Transport Harvest peon , AI default Transport Order need use zep , racial_lumber help ELF fix building blockage
  endif
  call GroupPointOrderLoc(g, "attack", exist_town[GetRandomInt(0,Max(exist_town_num-1,0))])
  if major_hero != null and UnitAlive(major_hero) then
    set heroloc = GetUnitLoc(major_hero)
    set follow_zeppelin = GetNearestOfGroup(follow_zeppelin, g, heroloc)
    call RemoveLocation(heroloc)
    set heroloc = null
  endif
  call DestroyGroup(g)
  set g = null
  if follow_zeppelin == null then
    call TQAddJob(10, ZEPPELIN_FOLLOW, 0)
    set zeppelin_following = false
    return
  endif
  call RemoveGuardPosition(follow_zeppelin)
  set zeppelin_following = true
  set dist = DistanceBetweenUnits(major_hero, follow_zeppelin)
  if dist > max_follow_dist then
    call CreateDebugTag("Zepplin follow hero", 10, follow_zeppelin, 3.00, 1.50)
    set l = GetLocationBetweenUnits(follow_zeppelin, major_hero, (dist - 0.5 * max_follow_dist)/RMax(dist,1))
    //set l = GetLocationBetweenUnits(follow_zeppelin, major_hero, (dist - 0.33 * max_follow_dist))
    //call IssuePointOrderLoc(follow_zeppelin, "attack", l)
    set b = IssuePointOrder(follow_zeppelin, "unloadall", GetLocationX(l), GetLocationY(l))  // Extra aid to help prevent units getting stuck in zepplin
    call IssueTargetOrder(follow_zeppelin, "move", major_hero)
    call TQAddJob(RMax((dist - max_follow_dist) / RMax(GetUnitMoveSpeed(follow_zeppelin) + GetUnitMoveSpeed(major_hero), 50), 1) * sleep_multiplier,ZEPPELIN_FOLLOW,0)
  else
    call IssueImmediateOrder(follow_zeppelin, "stop")
    set l = GetUnitLoc(follow_zeppelin)
    set b = IssuePointOrder(follow_zeppelin, "unloadall", GetUnitX(follow_zeppelin), GetUnitY(follow_zeppelin))
    call TQAddJob(10 * sleep_multiplier,ZEPPELIN_FOLLOW,0)
  endif
  if b == false then
    call IssuePointOrder(follow_zeppelin, "unloadall", GetLocationX(l) + GetRandomReal(-200,200), GetLocationY(l) + GetRandomReal(-200,200)) 
  endif
  call RemoveLocation(l)
  set l = null
endfunction
function NeutralGuardedJob takes integer nn returns nothing
  call DisplayToAllJobDebug("NEUTRAL_GUARDED JOB START")
  set neutral_guarded[nn] = GetNeutralGuard(nn)
  if neutral_guarded[nn] and not pathing_done then  // pathing_done give PathingThread continue check
    call TQAddJob(30 * sleep_multiplier, NEUTRAL_GUARDED, nn)
  endif
endfunction
function RepairControlJob takes nothing returns nothing
  local integer peons = TownCountDone(racial_peon)
  call DisplayToAllJobDebug("REPAIR_CONTROL JOB START")
  if towerrush then
    call SetPeonsRepair(false)
  elseif peons <= repair_threshold or (peons <= repair_threshold_threatened and town_threatened) then
    call SetPeonsRepair(false)
  else
    call SetPeonsRepair(true)
  endif
  call TQAddJob(15, REPAIR_CONTROL, 0)
endfunction
function PeonMineCheck takes unit mine returns boolean
  local group g = CreateGroup()
  local group tempg = null
  local location unitloc = GetUnitLoc(mine)
  local unit u = null
  local unit savewisp = null
  local integer i = 0
  local integer peon = TownCount(racial_peon)
  local integer peond = TownCountDone(racial_peon)
  local integer delaywisps = ver_optimal_gold - 1
  call DisplayToAllJobDebug("HARVEST CHECK Job Start")
  if peond > 6 then
    set delaywisps = ver_optimal_gold
  endif
  if race_manual_loading then
    call GroupEnumUnitsOfPlayer(g, ai_player, null)
    set g = SelectById(g, old_id[race_manual_loading_wisp], true)
    set g = SelectByAlive(g, true)
    set tempg = CreateGroup()
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      if IsUnitInTransport(u, mine) then
        set savewisp = u
        set i = i + 1
      elseif not IsUnitHidden(u) then
        call GroupAddUnit(tempg, u)
      endif
      call GroupRemoveUnit(g, u)
    endloop
    if FoodSpace() <= 0 and i >= 3 then  // no foodspace , no peon(at least keep 2 harvest mine) , need one harvest mine peon build Farms
      if peon == peond and peon <= 4 then
        set delaywisps = 2
        call IssueTargetOrder(mine, "unload", savewisp)
      endif
    elseif peond < 7 and not hero_built[1] then
      set delaywisps = ver_optimal_gold - 2
    endif
    if i < delaywisps then
      set tempg = SelectByLoaded(tempg, false)
      set tempg = SelectUnittype(tempg, UNIT_TYPE_STRUCTURE, false)  //  Preventing Tree Transformation
      set tempg = GetNearestSubGroupOfGroup(tempg, unitloc, delaywisps - i)
      //call GroupRemoveGuardPositionInstant(g) // this gets wisps to come off the trees.
      //call GroupTargetOrder(g, "harvest", mine)
      loop  //use accurate quantity control , prevent any wips harvestmine , but mine no vacancies
        set u = FirstOfGroup(tempg)
        exitwhen u == null or i == delaywisps
        call IssueTargetOrder(u, "harvest", mine)
        set i = i + 1
        call GroupRemoveUnit(tempg, u)
      endloop
    endif
    call DestroyGroup(tempg)
    set tempg = null
    set savewisp = null
  elseif race_uses_mine_expansion then
    set delaywisps = Min(ver_optimal_gold,peond)
    call GroupEnumUnitsOfPlayer(g, ai_player, null)
    set g = SelectUnittype(g, UNIT_TYPE_PEON, true)
    set g = SelectByAlive(g, true)
    set g = SelectByHidden(g, false)
    set tempg = CreateGroup()
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null or i == delaywisps
      if GetUnitCurrentOrder(u) == OrderId("harvest") and DistanceBetweenUnits(u,mine) < 225 then  // UD harvest gold max Distance is 221
        set i = i + 1
      elseif GetUnitCurrentOrder(u) == 0 and not IsUnitBuying(u) and not IsUnitInGroup(u, unit_zepplin_move) then
        call GroupAddUnit(tempg,u)  // prevent the mine harvest peon more than 5
      endif
      call GroupRemoveUnit(g, u)
    endloop
    if i < delaywisps then
      loop
        set u = FirstOfGroup(tempg)
        exitwhen u == null or i == delaywisps
        call IssueTargetOrder(u, "harvest", mine)
        set i = i + 1
        call GroupRemoveUnit(tempg, u)
      endloop
    endif
    call DestroyGroup(tempg)
    set tempg = null
  else //human and orc
    call GroupEnumUnitsOfPlayer(g, ai_player, null)
    set g = SelectUnittype(g, UNIT_TYPE_PEON, true)
    set g = SelectByAlive(g, true)
    set g = SelectByHidden(g, false)
    set g = GetNearestSubGroupOfGroup(g, home_location, 10)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null or i == delaywisps
      if (GetUnitCurrentOrder(u) == 0 or GetUnitCurrentOrder(u) == OrderId("harvest")) and not IsUnitBuying(u) and not IsUnitInGroup(u, unit_zepplin_move) then  // no get other order peon , maybe the peon go buy unit or build some
        call IssueTargetOrder(u, "harvest", mine)
      endif
      call GroupRemoveUnit(g, u)
      set i = i + 1
    endloop
    set i = delaywisps  //human and orc no need full
  endif
  call RemoveLocation(unitloc)
  set unitloc = null
  call DestroyGroup(g)
  set g = null
  set u = null
  return i < delaywisps
endfunction

function HarvestCheckJob takes nothing returns nothing
  local group g = null
  local unit u = null
  local integer i = 0
  local boolean mines_not_full = true
  //  call DisplayToAll("Harvest Start")
  if first_town_mine == -1 then
    return  // home_location no more mine , ORC and HUMAN no need run
  endif
  set g = CreateGroup()
  if race_manual_loading then
    call GroupEnumUnitsOfPlayer(g, ai_player, null)
    set g = SelectNumberOfId(g, 100,  old_id[race_manual_loading_mine])
  elseif not TownThreatened() then
    if race_uses_mine_expansion then
      call GroupEnumUnitsInRangeOfLoc(g, home_location, 1500, null)
      set g = SelectByPlayer(g, ai_player, true)
      set g = SelectById(g, old_id[racial_expansion], true)
    elseif GetResourceAmount(secondmine) <= 0 and TownCountDone(racial_peon) > 10 then  //human and orc
      call GroupEnumUnitsInRangeOfLoc(g, home_location, 1500, null)
      call GroupRemoveUnit(g,own_town_mine[0])
      set g = SelectById(g, old_id[GOLD_MINE], true)
      loop
        set u = FirstOfGroup(g)
        exitwhen u == null
        if GetResourceAmount(u) > i then  // find Resource max mine
          set i = GetResourceAmount(u)
          set secondmine = u
        endif
        call GroupRemoveUnit(g, u)
      endloop
      call GroupAddUnit(g, secondmine)  // only first take secondmine run PeonMineCheck , Prevention have more peon harvest
    endif
  endif
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) then
      set mines_not_full = PeonMineCheck(u) and mines_not_full
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  if mines_not_full then
    call TQAddJob(4, HARVEST_CHECK, 0)
  else
    call TQAddJob(40, HARVEST_CHECK, 0)
  endif
endfunction

function RetreatControlJob takes nothing returns nothing
  local group g = null
  local real ally_sum = 0
  local real enemy_sum = 0
  local real creep_sum = 0
  local unit u = null
  local real unit_strength = 0
  local real unit_life = 0
  local real unit_mana = 0
  //local group g_battle = CreateGroup()
  local real enemy_ranged_strength = 0
  local real ally_ranged_strength = 0
  local integer num_units = 0
  local real ally_strength = 0
  local real enemy_strength = 0
  local real xa = 0
  local real ya = 0
  local real xe = 0
  local real ye = 0

  // local variables used to calculate roughly where the current enemy army is located at
  local integer ally_count = 0
  local integer enemy_count = 0
  call DisplayToAllJobDebug("RETREAT_CONTROL JOB Start")

  if major_hero == null or not UnitAlive(major_hero) then
    set major_hero = GetMajorHeroReplacement_k(major_hero,last_major_hero_loc)
  endif

	//   call GroupEnumUnitsInRange(g_battle,GetUnitX(major_hero),GetUnitY(major_hero),battle_radius,null)
	//loop
	//  	set u = FirstOfGroup(g_battle)
	//	exitwhen u == null
	//	if UnitAlive(u) and IsPlayerAlly(GetOwningPlayer(u), ai_player) and IsUnitType(u, UNIT_TYPE_RANGED_ATTACKER) then
	//		set ally_ranged_strength = ally_ranged_strength + GetUnitStrength(u)
	//	else
	//		if UnitAlive(u) and IsPlayerEnemy(GetOwningPlayer(u),ai_player) and IsUnitType(u, UNIT_TYPE_RANGED_ATTACKER) then
	//			set enemy_ranged_strength = enemy_ranged_strength + GetUnitStrength(u)
	//			set num_units = num_units + 1
	//		endif
	//	endif
	//	if UnitAlive(u) and IsPlayerAlly(GetOwningPlayer(u), ai_player) then
	//		set ally_strength = ally_strength + GetUnitStrength(u)
	//	else
	//		if UnitAlive(u) and IsPlayerEnemy(GetOwningPlayer(u),ai_player) then
	//			set enemy_strength = enemy_strength + GetUnitStrength(u)
	//		endif
	//	endif
	//	call GroupRemoveUnit(g_battle,u)
	//endloop
	//call DestroyGroup(g_battle)
	//set g = null




  if not desperation_assault and ((CaptainRetreating() and isfleeing) or town_threatened) then     //((major_hero == null or not UnitAlive(major_hero)) and ver_heroes) or  then  //attack_running and
    call Trace("===Retreat control ended===")
    set break_attack = attack_running
    set retreat_controlled = false
    call SetGroupsFlee(true)
    if major_hero != null and UnitAlive(major_hero) and DistanceBetweenPoints_kd(home_location, GetUnitLoc(major_hero)) < 1250 then
      set isfleeing = false     // home so no need to be retreating. Also prevents bug in the captainretreating condition
    endif
    return
endif

  set g = CreateGroup()
  if main_army == -1 or army_loc[main_army] == null or (GetLocationX(army_loc[main_army]) == 0 and GetLocationY(army_loc[main_army]) == 0 )then
    if major_hero == null or not UnitAlive(major_hero) then
      call Trace("No major hero in retreat control")
    else
      call GroupEnumUnitsInRange(g,GetUnitX(major_hero),GetUnitY(major_hero),battle_radius,null)
    endif
  else
    call GroupEnumUnitsInRange(g, GetLocationX(army_loc[main_army]), GetLocationY(army_loc[main_army]), battle_radius, null)
  endif
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, false)
  set g = SelectByHidden(g, false)
  set g = SelectByAlive(g, true)
  call MoveLocation(last_enemy_loc, GetLocationX(enemy_loc), GetLocationY(enemy_loc))
  call MoveLocation(last_ally_loc, GetLocationX(ally_loc), GetLocationY(ally_loc))

  loop
    set u = FirstOfGroup(g)
    exitwhen u == null  
    set unit_strength = GetUnitStrength(u)
    // set unit_life = GetUnitState(u, UNIT_STATE_LIFE)
    // set unit_mana = GetUnitState(u, UNIT_STATE_MANA)
    if GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_AGGRESSIVE) then
      //call Trace("RETREAT_CONTROL: At least 1 unit detected")
      if IsPlayerAlly(GetOwningPlayer(u), ai_player) then
        //if GetUnitUserData(u) != UNIT_GOING_HOME then 
        if not IsUnitInGroup(u, unit_healing) then //and unit_life > RMax(flee_health_percentage * GetUnitState(u, UNIT_STATE_MAX_LIFE), flee_minimum_health) then
          set ally_sum = ally_sum + unit_strength
        endif
        set xa = xa + GetUnitX(u)  // Prevent loc exceeding map range
        set ya = ya + GetUnitY(u)
        //set ally_loc = GetSumLoc_dd(ally_loc, GetUnitLoc(u))
        set ally_count = ally_count + 1
      elseif not (UnitInvis(u) and not IsUnitDetected(u, ai_player)) then
        set enemy_sum = enemy_sum + unit_strength
        set xe = xe + GetUnitX(u)
        set ye = ye + GetUnitY(u)
        //set enemy_loc = GetSumLoc_dd(enemy_loc, GetUnitLoc(u))
        set enemy_count = enemy_count + 1
      endif
    elseif GetOwningPlayer(u) == Player(PLAYER_NEUTRAL_AGGRESSIVE) and not (UnitInvis(u) and not IsUnitDetected(u, ai_player)) then
      // set unit_life = GetUnitState(u, UNIT_STATE_LIFE)
      // set unit_mana = GetUnitState(u, UNIT_STATE_MANA)
      set creep_sum = creep_sum + unit_strength
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null

  set xe = xe / I2R(Max(enemy_count, 1))
  set ye = ye / I2R(Max(enemy_count, 1))
  set xa = xa / I2R(Max(ally_count, 1))
  set ya = ya / I2R(Max(ally_count, 1))
  call MoveLocation(enemy_loc, xe, ye)
  call MoveLocation(ally_loc, xa, ya)
  //set enemy_loc = GetDivisionLoc_d(enemy_loc, I2R(Max(enemy_count, 1)))
  //set ally_loc = GetDivisionLoc_d(ally_loc, I2R(Max(ally_count, 1)))
  //  call SetCaptainHome(0, GetLocationX(ally_loc), GetLocationY(ally_loc))

  set enemy_strength_sum = enemy_sum
  set ally_strength_sum = ally_sum
  //call Trace("RETREAT_CONTROL: Our strength: " + Int2Str(R2I(ally_strength_sum)))
  //call Trace("RETREAT_CONTROL: Enemy strength: " + Int2Str(R2I(enemy_strength_sum)))

  if not desperation_assault and enemy_sum > LinearInterpolation(ver_low_aggression,ver_high_aggression,ver_flee_multiple2,ver_flee_multiple3,attacking_aggression + added_aggression + added_target_aggression + added_racial_aggression)*ally_sum or (town_threatened and attack_running) then
    call Trace("RETREAT_CONTROL: Flee!!!!")
    set break_attack = attack_running
    set retreat_controlled = false
    call ClearCaptainTargets()
    call CaptainGoHome()
    set isfleeing = true
    return
  elseif not desperation_assault and enemy_sum > LinearInterpolation(ver_low_aggression,ver_high_aggression,ver_flee_multiple1,ver_flee_multiple2,attacking_aggression + added_aggression + added_target_aggression + added_racial_aggression)*ally_sum or (battle_radius == creep_battle_radius and creep_sum - 2 > ally_sum ) then
    call Trace("RETREAT_CONTROL: Allowed to Flee")
    call SetGroupsFlee(true)
    set isfleeing = true
    //call ClearCaptainTargets()
    //call CaptainGoHome()
  else
    //if town_threatened and town_threat[most_threatened_town] >= teleport_high_threat then

    // else
    //    	call Trace("REATREAT_CONTROL: Stay")
    call SetGroupsFlee(false)
    set isfleeing = false
    // endif
  endif

  call TQAddJob(2 * sleep_multiplier, RETREAT_CONTROL, 0)
endfunction
function CleanupBlock takes nothing returns nothing
  local integer i = 0
  local integer ff = 0

  loop
    exitwhen i >= bl_length
    if bl_expire_time[i] >= ai_time then
      set bl_req_qty[ff] = bl_req_qty[i]
      set bl_req_type[ff] = bl_req_type[i]
      set bl_allow_qty[ff] = bl_allow_qty[i]
      set bl_allow_type[ff] = bl_allow_type[i]
      set bl_expire_time[ff] = bl_expire_time[i]
      set bl_only_done[ff] = bl_only_done[i]
      set ff = ff + 1
    endif
    set i = i + 1
  endloop
  set bl_length = ff
endfunction

function CleanupRBlock takes nothing returns nothing
  local integer i = 0
  local integer ff = 0
  loop
    exitwhen i >= rbl_length
    if rbl_expire_time[i] >= ai_time then
      set rbl_req_gold[ff] = rbl_req_gold[i]
      set rbl_req_wood[ff] = rbl_req_wood[i]
      set rbl_allow_qty[ff] = rbl_allow_qty[i]
      set rbl_allow_type[ff] = rbl_allow_type[i]
      set rbl_expire_time[ff] = rbl_expire_time[i]
      set ff = ff + 1
    endif
    set i = i + 1
  endloop
  set rbl_length = ff
endfunction

function CleanupBlocksJob takes nothing returns nothing
  call DisplayToAllJobDebug("CLEANUP_BLOCKS JOB START")
  call CleanupBlock()
  call CleanupRBlock()
  call TQAddJob(60, CLEANUP_BLOCKS, 0)
endfunction
function ResetGuardPositionJob takes unit u returns nothing
  call DisplayToAllJobDebug("RESET_GUARD_POSITION JOB START")
  call CreateDebugTag("RECYCLE Full", 10, u, 3.00, 1.50)
  call RecycleGuardPosition(u)
  call GroupRemoveUnit(unit_healing, u)
  call GroupRemoveUnit(unit_rescueing, u)
  call GroupRemoveUnit(unit_harassing, u)
  call GroupRemoveUnit(unit_zepplin_move, u)
 // call SetUnitUserData(u, UNIT_STANDARD)
endfunction
function ResetGuardPositionOnlyJob takes unit u returns nothing
  call DisplayToAllJobDebug("RESET_GUARD_POSITION ONLY JOB START")
  if IsUnitInGroup(u, unit_healing) or IsUnitInGroup(u, unit_rescueing ) or IsUnitInGroup(u, unit_harassing ) or IsUnitInGroup(u, unit_zepplin_move ) then
	return // do nothing
  endif
  call CreateDebugTag("RECYCLE", 10, u, 3.00, 1.50)
  call RecycleGuardPosition(u)
  if not IsUnitType(u, UNIT_TYPE_PEON) and not IsUnitType(u, UNIT_TYPE_STRUCTURE) then
	call AddAssault(60, GetUnitTypeId(u)) // Add units back to the assault group to stop them running home from the combat
  endif
endfunction
function ResetByHealthJob takes unit u, integer p returns nothing
  call DisplayToAllJobDebug("RESET_HEALTH JOB START")
  if GetUnitState(u, UNIT_STATE_LIFE) >= GetUnitState(u, UNIT_STATE_MAX_LIFE) * (I2R(p)/100) then
    call RecycleGuardPosition(u)
  else
    call TQAddUnitJob(8, RESET_HEALTH, p, u)
  endif
endfunction
function IsHealingItem takes integer id returns boolean
	if false then	//basically check that item to build is healing item and drop item to make room for this
	elseif oM_SCROLL_OF_HEALING == id then
		return true	
	elseif oHEALING_POTION == id then
		return true	
	elseif oTOWN_PORTAL == id then
		return true
	endif
	return false
endfunction

function DropNonHealingItem takes unit u returns nothing
	local integer i = 0
	local item t = null
	
	loop
		exitwhen i >= 6
		set t = UnitItemInSlot(u, i)
		if t != null and not IsHealingItem(GetItemTypeId(t)) then
			call UnitDropItemPoint(u, t, GetUnitX(u), GetUnitY(u))
      set t = null
			return
		endif
		set i = i + 1
	endloop
  set t = null
endfunction

function BuyItemJob takes integer id returns nothing
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  local real current_time = TimerGetElapsed(tq_timer)
  local real time_next_try = 0
  local real dist = 0
  local location l = null
  local boolean healing = false

local integer detectedenemies = GetLocationNonCreepStrength(GetUnitX(shop_sent), GetUnitY(shop_sent), 1000) 

 call DisplayToAllJobDebug("BUY_ITEM JOB START")

   if shop_ordered == false then
    call Trace("Order to get item is off so end job")
	return	// Shouldn't be buying an item anyway
   endif

  // moved here to prevent a job crash 
   if shop_sent == null or not UnitAlive(shop_sent) then
    set ismoving = false
    if retreat_home then
	    call Trace("Running Home end but item job")
	    set shop_ordered = false
		set shop_buy_time_large = -1
		set shop_buy_time_small = -1
		set retreat_home = false
		return
	endif
	if buy_type[id] == BT_RACIAL_ITEM then
		set shop_sent = GetHeroToBuyItem(shop_unit, shop_distance_limit,false)
	else
		set shop_sent = GetHeroToBuyItem(shop_unit, shop_distance_limit,true)
	endif
    if shop_sent == null then
	  call Trace("No unit to buy item so end job")
      set shop_ordered = false
      set shop_buy_time_large = -1
      set shop_buy_time_small = -1
      return
    endif
	call GroupAddUnit(unit_buying_item, shop_sent)
  endif
 
   //call CreateDebugTag("In BUT ITEM JOB, 10, shop_sent, 3.00, 1.50) 

  if GetUnitTypeId(shop_unit) == old_id[racial_shop] and DistanceBetweenUnits(shop_sent, shop_unit) < 1000 then
  else
    if town_threatened or attack_running then
		call CreateDebugTag("BUY_ITEM:in attack so dont get item", 10, shop_sent, 3.00, 1.50) 
    	call RecycleGuardPosition(shop_sent)
		call GroupRemoveUnit(unit_buying_item, shop_sent)
		call AddAssault(1, GetUnitTypeId(shop_sent))
    	set shop_sent = null
    	set shop_ordered = false
    	set shop_buy_time_large = -1
    	set shop_buy_time_small = -1
    	return
    endif
  endif
   
  if retreat_home then
	set l = GetUnitLoc(shop_sent)
	if DistanceBetweenPoints(l, home_location) >= 1100 then
		call CreateDebugTag("BUY_ITEM: Retreat to Home", 10, shop_sent, 3.00, 1.50)	
		call RemoveGuardPosition(shop_sent)
		if not IsUnitInGroup(shop_sent, going_home_group) then
			call IssuePointOrder(shop_sent, "move", GetLocationX(home_location), GetLocationY(home_location))
			call GroupAddUnit(going_home_group, shop_sent)
		elseif GetUnitCurrentOrder(shop_sent) == OrderId("stop") or GetUnitCurrentOrder(shop_sent) != OrderId("move") then
			call IssuePointOrder(shop_sent, "move", GetLocationX(home_location), GetLocationY(home_location))
		endif
		call TQAddJob(5, BUY_ITEM, id)
	else
		call GroupRemoveUnit(unit_buying_item, shop_sent)
		if IsUnitInGroup(shop_sent, going_home_group) then
			call GroupRemoveUnit(going_home_group, shop_sent)
		endif
		call RecycleGuardPosition(shop_sent)
		call CreateDebugTag("BUY_ITEM: Retreated", 10, shop_sent, 3.00, 1.50)
	    set shop_sent = null
		set retreat_home = false
		set shop_ordered = false
		set shop_buy_time_large = -1
		set shop_buy_time_small = -1
	endif
	call RemoveLocation(l)
	set l = null
	return
  endif
 
   if detectedenemies >= GetUnitStrength(shop_sent) and GetUnitTypeId(shop_unit) != old_id[racial_shop] then
	 call IssuePointOrder(shop_sent, "move", GetLocationX(home_location), GetLocationY(home_location))
    //call TQAddUnitJob(GetTimeToReachLoc(shop_sent, home_location), RESET_GUARD_POSITION, 1, shop_sent)
	set retreat_home = true
	call CreateDebugTag("BUY_ITEM: Enemies present so dont get item this time", 10, shop_sent, 3.00, 1.50) 
    call TQAddJob(0, BUY_ITEM, id)
	return
   endif

  if (shop_buy_time_large >= 0 and shop_buy_time_large + buy_timeout_large < current_time) or (shop_buy_time_small >= 0 and shop_buy_time_small + buy_timeout_small < current_time) then
    set available_time[id] = ai_time + regenerate_time[id] / 2
	call CreateDebugTag("Buy item timeout reached", 10, shop_sent, 3.00, 1.50) 	
    call RecycleGuardPosition(shop_sent)
	call GroupRemoveUnit(unit_buying_item, shop_sent)
    set shop_sent = null
    set shop_ordered = false
    set shop_buy_time_large = -1
    set shop_buy_time_small = -1
    return
  endif

	set healing = IsHealingItem(old_id[id])	

  
  if GetItemNumber(id) >= shop_wanted or shop_unit == null or (not UnitAlive(shop_unit)) or (shop_sent != null and GetSlotsFreeOnUnit(shop_sent) <= 0 and not healing) then
    call RecycleGuardPosition(shop_sent)
	call GroupRemoveUnit(unit_buying_item, shop_sent)
	call CreateDebugTag("BUT_ITEM: Items have been brought", 10, shop_sent, 3.00, 1.50) 
	call AddAssault(1, GetUnitTypeId(shop_sent))
    set shop_sent = null
    set shop_ordered = false
    set shop_buy_time_large = -1
    set shop_buy_time_small = -1
    return
  endif

  
  if shop_buy_time_large < 0 then
    set shop_buy_time_large = current_time
  endif
  call RemoveGuardPosition(shop_sent)
  set dist = DistanceBetweenUnits(shop_sent, shop_unit)
  if dist < buy_distance then
  		call CreateDebugTag("buy item", 10, shop_sent, 3.00, 1.50) 
		if GetSlotsFreeOnUnit(shop_sent) <= 0 and healing then
			call DropNonHealingItem(shop_sent)
		else
		    call IssueImmediateOrder(shop_sent, "stop")
		endif
		set ismoving = false
	if GetUnitTypeId(shop_unit) == old_id[racial_shop] then
		call IssueTargetOrderById(shop_unit, 'Aall', shop_sent)  // Change shop target to this hero
	endif
    call IssueNeutralImmediateOrderById(ai_player, shop_unit, old_id[id])
    if shop_buy_time_small < 0 then
      set shop_buy_time_small = current_time
    endif
    set time_next_try = 0.5
  else
  	call CreateDebugTag("move to item shop", 10, shop_sent, 3.00, 1.50) 
	if ismoving == false then
		set ismoving = true
		call IssuePointOrder(shop_sent, "move", GetUnitX(shop_unit), GetUnitY(shop_unit))
	elseif GetUnitCurrentOrder(shop_sent) == OrderId("stop") or GetUnitCurrentOrder(shop_sent) != OrderId("move") then
		call IssuePointOrder(shop_sent, "move", GetUnitX(shop_unit), GetUnitY(shop_unit))
	endif
    set time_next_try = 4
  endif

  call TQAddJob(time_next_try, BUY_ITEM, id)
endfunction

function GetHealthFountainID takes nothing returns integer
  if nearest_neutral[NEUTRAL_POWER_FOUNTAIN] != null then
    return NEUTRAL_POWER_FOUNTAIN
  elseif nearest_neutral[NEUTRAL_HEAL_WARD] != null then
    return NEUTRAL_HEAL_WARD
  endif
  return NEUTRAL_HEALING_FOUNTAIN
endfunction

function GetHealthFountainUnit takes nothing returns unit
  if nearest_neutral[NEUTRAL_POWER_FOUNTAIN] != null then
    return nearest_neutral[NEUTRAL_POWER_FOUNTAIN]
  elseif nearest_neutral[NEUTRAL_HEAL_WARD] != null then
    return nearest_neutral[NEUTRAL_HEAL_WARD]
  endif
  return nearest_neutral[NEUTRAL_HEALING_FOUNTAIN]
endfunction

function HealthFountainJob takes unit u, integer p returns nothing

local real distance = 0
local real unitstrengt = 0
local real x = 0
local real y = 0
local unit fountain = GetHealthFountainUnit()
local integer detectedenemies = 0
local integer enemiesatfountain = 0
local boolean creepsawake = false

  call DisplayToAllJobDebug("HEALTH_FOUNTAIN Start")

  call RemoveGuardPosition(u)
  if GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
    call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)
    set fountain = null
    return
  elseif fountain == null then
    call TQAddUnitJob(2, SEND_HOME, GetRandomInt(0,Max(exist_town_num-1,0)), u)
    return
  endif
  set x = GetUnitX(fountain)
  set y = GetUnitY(fountain)
  set detectedenemies = GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 1000) 
  set enemiesatfountain = GetLocationNonCreepStrength(x, y, 1000)
  set creepsawake = IsCreepsAwake(x, y, 1000)
  set unitstrengt = GetUnitStrength(u)
  set distance = DistanceBetweenUnits(u, fountain)
  if (distance <= 600 and (detectedenemies >= unitstrengt or creepsawake)) or (difficulty == HARD and (enemiesatfountain >= unitstrengt or creepsawake)) then
    call IssuePointOrder(u, "move", GetLocationX(home_location), GetLocationY(home_location))
    call TQAddUnitJob(8, RESET_GUARD_POSITION, p, u)
  elseif GetUnitState(u, UNIT_STATE_LIFE) >= GetUnitState(u, UNIT_STATE_MAX_LIFE) * (I2R(p)/100) then
    call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)
  else
    if distance >= buy_distance then
      if GetUnitAbilityLevel(u, 'AIhm') > 0 or (GetUnitAbilityLevel(u, 'Ashm') > 0 and GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 800) > 0 and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) <= 6)) then
        call IssueImmediateOrder(u, "ambush")
      elseif GetUnitCurrentOrder(u) != OrderId("move") then
        call IssuePointOrder(u, "move", x, y)
      endif
    else
      if IsUnitInvisible(u, Player(PLAYER_NEUTRAL_AGGRESSIVE)) then  //no need do anything
      elseif GetUnitAbilityLevel(u, 'AIhm') > 0 or (GetUnitAbilityLevel(u, 'Ashm') > 0 and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) <= 6)) then
        call IssueImmediateOrder(u, "ambush")
      elseif not IsUnitType(u, UNIT_TYPE_FLYING) and GetUnitCurrentOrder(u) != OrderId("patrol") then
        call IssuePointOrder( u, "patrol", x + GetRandomReal(-100,100), y + GetRandomReal(-100,100))  //Prevent units from being blocked by other units coming from behind when leaving
      endif
    endif
    call TQAddUnitJob(8, HEALTH_FOUNTAIN, p, u)
  endif
  set fountain = null
endfunction
function GetManaFountainID takes nothing returns integer
  if nearest_neutral[NEUTRAL_POWER_FOUNTAIN] == null then
    return NEUTRAL_MANA_FOUNTAIN
  endif
  return NEUTRAL_POWER_FOUNTAIN
endfunction

function GetManaFountainUnit takes nothing returns unit
  if nearest_neutral[NEUTRAL_POWER_FOUNTAIN] == null then
    return nearest_neutral[NEUTRAL_MANA_FOUNTAIN]
  endif
  return nearest_neutral[NEUTRAL_POWER_FOUNTAIN]
endfunction

function ManaFountainJob takes unit u, integer p returns nothing

local real distance = 0
local real unitstrengt = 0
local real x = 0
local real y = 0
local unit fountain = GetManaFountainUnit() 
local integer detectedenemies = 0
local integer enemiesatfountain = 0
local boolean creepsawake = false

  call DisplayToAllJobDebug("MANA_FOUNTAIN Start")
  // if fountain == null then
  //   set fountain = nearest_neutral[NEUTRAL_MANA_FOUNTAIN]
  // endif
  call RemoveGuardPosition(u)
  if GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
    call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)
    set fountain = null
    return
  elseif fountain == null then
    call TQAddUnitJob(2, SEND_HOME, GetRandomInt(0,Max(exist_town_num-1,0)), u)
    return
  endif
  set x = GetUnitX(fountain)
  set y = GetUnitY(fountain)
  set detectedenemies = GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 1000) 
  set enemiesatfountain = GetLocationNonCreepStrength(x, y, 1000)
  set creepsawake = IsCreepsAwake(x, y, 1000)
  set unitstrengt = GetUnitStrength(u)
  set distance = DistanceBetweenUnits(u, fountain)
  if (distance <= 600 and (detectedenemies >= unitstrengt or creepsawake)) or (difficulty == HARD and (enemiesatfountain >= unitstrengt or creepsawake)) then
    call IssuePointOrder(u, "move", GetLocationX(home_location), GetLocationY(home_location))
    call TQAddUnitJob(8, RESET_GUARD_POSITION, p, u)
  elseif GetUnitState(u, UNIT_STATE_MANA) >= GetUnitState(u, UNIT_STATE_MAX_MANA) * (I2R(p)/100) then
    call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)
  else
    if distance >= buy_distance then
      if GetUnitAbilityLevel(u, 'AIhm') > 0 or (GetUnitAbilityLevel(u, 'Ashm') > 0 and GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 800) > 0 and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) <= 6)) then
        call IssueImmediateOrder(u, "ambush")
      elseif GetUnitCurrentOrder(u) != OrderId("move") then
        call IssuePointOrder(u, "move", x, y)
      endif
    else
      if IsUnitInvisible(u, Player(PLAYER_NEUTRAL_AGGRESSIVE)) then  //no need do anything
      elseif GetUnitAbilityLevel(u, 'AIhm') > 0 or (GetUnitAbilityLevel(u, 'Ashm') > 0 and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) <= 6)) then
        call IssueImmediateOrder(u, "ambush")
      elseif not IsUnitType(u, UNIT_TYPE_FLYING) and GetUnitCurrentOrder(u) != OrderId("patrol") then
        call IssuePointOrder( u, "patrol", x + GetRandomReal(-100,100), y + GetRandomReal(-100,100))  //Prevent units from being blocked by other units coming from behind when leaving
      endif
    endif
    call TQAddUnitJob(8, MANA_FOUNTAIN, p, u)
  endif
  set fountain = null
endfunction

function TeleportHome takes integer hn returns nothing
  local integer i = 0
  local player p = null
  local real distance = 9999999
  local location teleport_loc = null
  //local real dx = 0
  //local real dy = 0
  local real actual_diff = 0 
  local location start_loc = null

  //set hero_loc = GetUnitLoc(hero_unit[hn])
  set break_attack = attack_running
  set attack_running = false
  call ClearCaptainTargets()
  set teleporting = true
  if c_ally_total > 0 and UnitAlive(major_hero) and major_hero != null then
    loop
      exitwhen i >= c_ally_total
      set p = ally_force[i]
      if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING then
        set start_loc = GetPlayerStartLocationLoc(p)
        //set dx = GetLocationX(start_loc) - GetLocationX(hero_loc)
        //set dy = GetLocationY(start_loc) - GetLocationY(hero_loc)
        //set actual_diff = SquareRoot(dx * dx + dy * dy)
        set actual_diff = DistanceBetweenPoints(start_loc, hero_loc[hn])
        if actual_diff < distance then
          set distance = actual_diff
          if teleport_loc != null then
            call RemoveLocation(teleport_loc)
          endif
          set teleport_loc = GetTeleportLandPoint(start_loc)
        endif
        call RemoveLocation(start_loc)
      endif
      set i = i + 1
    endloop
    call CaptainAttack(GetLocationX(teleport_loc), GetLocationY(teleport_loc))
  else
    call CaptainGoHome()
    set teleport_loc = GetTeleportLandPoint(home_location)
  endif
  if teleport_loc != null then
    call ClearCaptainTargets()
    call UnitUseItemPoint(hero_unit[hn], GetItemOfTypeOnUnit(tp_item, hero_unit[hn]), GetLocationX(teleport_loc), GetLocationY(teleport_loc))
    call RemoveLocation(teleport_loc)
    set teleport_loc = null
  endif
  set start_loc = null
  //if hero_loc != null then
  //call RemoveLocation( hero_loc )
  //set hero_loc = null
  //endif
  set p = null
  call TQAddUnitJob(0.5, TELEPORT, 0, hero_unit[hn])
endfunction

function TeleportToLoc takes unit u, location l returns nothing
  local location loc = GetTeleportLandPoint(l)
  set break_attack = attack_running
  set attack_running = false
  set teleporting = true
  call ClearCaptainTargets()
  call CaptainAttack(GetLocationX(loc), GetLocationY(loc))
  call UnitUseItemPoint(u, GetItemOfTypeOnUnit(tp_item, u), GetLocationX(loc), GetLocationY(loc))
  call TQAddUnitJob(0.5, TELEPORT, 0, u)
  call RemoveLocation(loc)
  set loc = null
endfunction

function ExecuteSaveHero takes integer hn, integer a, unit healer returns nothing
  local location l = null
  local group g = null
  local location unitloc = null
  local location loc = null
  local integer hFountainID = GetHealthFountainID()
  local integer mFountainID = GetManaFountainID()

  if a != ACTION_DO_NOTHING and a != ACTION_TP then
    call RemoveGuardPosition(hero_unit[hn])
    if GetUnitAbilityLevel(hero_unit[hn], 'AOwk') > 0 or GetUnitAbilityLevel(hero_unit[hn], 'ANwk') > 0 then
      if not IsUnitInvisible(hero_unit[hn], Player(PLAYER_NEUTRAL_AGGRESSIVE)) then
        call IssueImmediateOrder(hero_unit[hn], "windwalk")
      endif
    endif
    if a != ACTION_HEALER and hero_unit[hn] == major_hero then
      set major_hero = null
    endif
  endif
  if a == ACTION_HEALER and healer != null then
    call GroupAddUnit(unit_healing, hero_unit[hn])
    call CreateDebugTag("HERO: Going to Healer", 10, hero_unit[hn], 4.00, 2.00)
    set unitloc = GetUnitLoc(healer)
    if GetLocationX(last_enemy_loc) != 0 and GetLocationY(last_enemy_loc) != 0 then
      set loc = GetSubtractionLoc(unitloc, last_enemy_loc)
      set l = GetProjectedLoc(unitloc, loc, 350)
      call TQAddUnitJob(GetTimeToReachLoc(hero_unit[hn], l) + 1, RESET_GUARD_POSITION, 0, hero_unit[hn])
      call IssuePointOrderLoc(hero_unit[hn], "move", l)
      call RemoveLocation(l)
      set l = null
      call RemoveLocation(loc)
      set loc = null
    else
      call TQAddUnitJob(GetTimeToReachLoc(hero_unit[hn], unitloc) + 1, RESET_GUARD_POSITION, 0, hero_unit[hn])
      call IssuePointOrderLoc(hero_unit[hn], "move", unitloc)
    endif
    call RemoveLocation(unitloc)
    set unitloc = null
    call HealUnit(healer, hero_unit[hn], false)
    return
  endif
  if a == ACTION_FOUNTAIN then
    call CreateDebugTag("HERO: Going to Fountain", 10, hero_unit[hn], 4.00, 2.00)
    call GroupAddUnit(unit_healing, hero_unit[hn])
    call TQAddUnitJob(0, HEALTH_FOUNTAIN, 80, hero_unit[hn])
    call IssuePointOrder(hero_unit[hn], "move", GetUnitX(nearest_neutral[hFountainID]), GetUnitY(nearest_neutral[hFountainID]))
  elseif a == ACTION_MANA_FOUNTAIN then
    call CreateDebugTag("HERO: Going to Mana Fountain", 10, hero_unit[hn], 4.00, 2.00)
    call GroupAddUnit(unit_healing, hero_unit[hn])
    call TQAddUnitJob(0, MANA_FOUNTAIN, 80, hero_unit[hn])
    call IssuePointOrder(hero_unit[hn], "move", GetUnitX(nearest_neutral[mFountainID]), GetUnitY(nearest_neutral[mFountainID]))
  elseif a == ACTION_GO_HOME then
    //call UnitGoHome(hero_unit[hn])
    call CreateDebugTag("HERO: Going Home", 10, hero_unit[hn], 4.00, 2.00)
    call GroupAddUnit(unit_healing, hero_unit[hn])
    call TQAddUnitJob(0, SEND_HOME, GetRandomInt(0,Max(exist_town_num-1,0)), hero_unit[hn])
  elseif a == ACTION_ZEPPELIN_HOME then
    call CreateDebugTag("HERO: Zeppelin Home", 10, hero_unit[hn], 4.00, 2.00)
    call GroupAddUnit(unit_rescueing, follow_zeppelin)
    set g = CreateGroup()
    call GroupAddUnit(g, follow_zeppelin)
    call GroupAddUnit(unit_healing, hero_unit[hn])
    call TQAddGroupJob(0, ZEPPELIN_MOVE, ZTARGET_HOME, hero_unit[hn], g)
    set g = null
  elseif a == ACTION_ZEPPELIN_FOUNTAIN then
    call CreateDebugTag("HERO: Zepplin to fountain", 10, hero_unit[hn], 4.00, 2.00)
    call GroupAddUnit(unit_rescueing, follow_zeppelin)
    set g = CreateGroup()
    call GroupAddUnit(g, follow_zeppelin)
    call GroupAddUnit(unit_healing, hero_unit[hn])
    call TQAddGroupJob(0, ZEPPELIN_MOVE, ZTARGET_FOUNTAIN, hero_unit[hn], g)
    set g = null
  elseif a == ACTION_TP then
    call CreateDebugTag("Hero: Town Portalling", 10, hero_unit[hn], 4.00, 2.00)
    call TeleportHome(hn)
  elseif a == ACTION_MOONWELLS then
    call CreateDebugTag("HERO: Going to Moonwells", 10, hero_unit[hn], 4.00, 2.00)
    call GroupAddUnit(unit_healing,hero_unit[hn])
    call TQAddUnitJob(0, MOON_WELL_CONTROL, 80, hero_unit[hn])
  endif
endfunction

function SaveHero takes integer hn , integer armyOfHero returns nothing
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  local unit healer = null
  local integer hFountainID = GetHealthFountainID()
  local integer mFountainID = GetManaFountainID()
  local location l = GetUnitLoc(hero_unit[hn])
  set healer = GetHealer(healer)
  call ActionListInit(9)
  // Initial Proirity Rules
  call ActionRule3(true, ACTION_FOUNTAIN, 40, ACTION_ZEPPELIN_FOUNTAIN, 45, ACTION_DO_NOTHING, -10)
  call ActionRule2(true, ACTION_MANA_FOUNTAIN, 5, ACTION_MOONWELLS, 30)
  call ActionRule2(true, ACTION_GO_HOME, 25, ACTION_ZEPPELIN_HOME, 35)
  call ActionRule2(true, ACTION_TP, 50, ACTION_HEALER, 8)

  //call ActionRule2(true, ACTION_GO_HOME, (1 - hero_hp[hn])*20, ACTION_ZEPPELIN_HOME, (1 - hero_hp[hn])*30)
  //call ActionRule2(true, ACTION_TP, (1 - hero_hp[hn])*15, ACTION_ZEPPELIN_FOUNTAIN, (1 - hero_hp[hn])*25)

  call ActionRule2(hero_hp_loss[hn] > 0.5, ACTION_TP, 40, ACTION_ZEPPELIN_HOME, 15)
  call ActionRule2((hero_enemy_density[hn] > 5) and (hero_hp_loss[hn] > 0.4), ACTION_TP, 200, ACTION_ZEPPELIN_HOME, 150)
  //call ActionRule(true, ACTION_TP, DistanceBetweenPoints(home_location, l)*0.006)

  // Only here as a backup as getdensities may not totally be working correctly
  if armyOfHero >= 0 then
    call ActionRule(GetLocationNonCreepStrength(GetLocationX(l), GetLocationY(l), 1500) * 2 < army_strength[armyOfHero] , ACTION_TP, -100000)
  endif

  call ActionRule(DistanceBetweenPoints(home_location, l) < 2000 and (hero_enemy_density[hn] > 1), ACTION_TP, -100)
  call ActionRule(DistanceBetweenPoints(home_location, l) < 2000 and (hero_enemy_density[hn] < 1), ACTION_TP, -1000000)
  call ActionRule(town_threatened, ACTION_TP, -100000)

  //call ActionRule(DistanceBetweenPoints(home_location, l) < 2500, ACTION_TP, -1000000)
  //if armyOfHero >= 0 then
    //call ActionRule( army_strength[armyOfHero] < teleport_army_min_strength  ,ACTION_TP, -100)  
    //call ActionRule( army_strength[armyOfHero] < enemy_strength_sum, ACTION_TP, -1000000) 
  //endif
  //call ActionRule3(true, ACTION_TP, (I2R(GetHeroLevel(hero_unit[hn]))*14)-20, ACTION_ZEPPELIN_HOME, I2R(GetHeroLevel(hero_unit[hn]))*8, ACTION_ZEPPELIN_FOUNTAIN, I2R(GetHeroLevel(hero_unit[hn]))*6)

  // Rules of action failure
  call ActionRule(not race_has_moonwells or TownCountDone(racial_farm) <= 0, ACTION_MOONWELLS,-1000000)
  if nearest_neutral[hFountainID] != null then
    call ActionRule(DistanceBetweenPoints_dk(GetUnitLoc(nearest_neutral[hFountainID]),l) > DistanceBetweenPoints(home_location,l), ACTION_MOONWELLS, 18) // Use moonwells if they closer than the fountain
  else
    call ActionRule(true,ACTION_MOONWELLS, 18)
  endif
  call ActionRule2(follow_zeppelin == null or IsUnitInGroup(follow_zeppelin, unit_rescueing),  ACTION_ZEPPELIN_HOME, -1000000.0, ACTION_ZEPPELIN_FOUNTAIN, -1000000.0)
  call ActionRule3(not race_use_fountain, ACTION_FOUNTAIN, -100.0, ACTION_ZEPPELIN_FOUNTAIN, -100.0, ACTION_MANA_FOUNTAIN, -100.0)
  call ActionRule2(nearest_neutral[NEUTRAL_HEALING_FOUNTAIN] == null and nearest_neutral[NEUTRAL_POWER_FOUNTAIN] == null and nearest_neutral[NEUTRAL_HEAL_WARD] == null, ACTION_FOUNTAIN, -1000000, ACTION_ZEPPELIN_FOUNTAIN, -1000000)
  call ActionRule(nearest_neutral[NEUTRAL_MANA_FOUNTAIN] == null and nearest_neutral[NEUTRAL_POWER_FOUNTAIN] == null, ACTION_MANA_FOUNTAIN, -1000000)
  call ActionRule2(not neutral_available[hFountainID] or (neutral_guarded[hFountainID] and (not neutral_night_buy[hFountainID] or (daytime > 6 and daytime < 18))) or GetLocationNonCreepStrength(GetUnitX(nearest_neutral[hFountainID]), GetUnitY(nearest_neutral[hFountainID]), 1500) > 0 , ACTION_FOUNTAIN, -1000000.0, ACTION_ZEPPELIN_FOUNTAIN, -1000000.0)
  call ActionRule(not neutral_available[mFountainID] or (neutral_guarded[mFountainID] and (not neutral_night_buy[mFountainID] or (daytime > 6 and daytime < 18))) or GetLocationNonCreepStrength(GetUnitX(nearest_neutral[mFountainID]), GetUnitY(nearest_neutral[mFountainID]), 1500) > 0 , ACTION_MANA_FOUNTAIN, -1000000.0)
  call ActionRule(GetItemNumberOnUnit(tp_item, hero_unit[hn]) <= 0, ACTION_TP, -1000000)
  call ActionRule(healer == null, ACTION_HEALER, -1000000)
  call ExecuteSaveHero(hn, ActionListEval(), healer)
  call RemoveLocation(l)
  set l = null
  set healer = null
endfunction

function HeroBugFixHealthCheck takes integer hn returns boolean
  return GetUnitState(hero_unit[hn], UNIT_STATE_LIFE) >= 0.80 * GetUnitState(hero_unit[hn], UNIT_STATE_MAX_LIFE) and IsUnitInGroup(hero_unit[hn], unit_healing)
endfunction

function MicroHeroJob takes integer hn returns nothing
  local real new_hp = 0.0
  local real teleportdistance = 0.0
  local integer current_order = 0
  local integer armyOfHero = 0

  call DisplayToAllJobDebug("MICRO_HERO Job start")
  if UnitAlive(hero_unit[hn]) then
    set armyOfHero = GetArmyOfUnit(hero_unit[hn])
    // A Temporary Bug fix
    if HeroBugFixHealthCheck(hn) then
      call CreateDebugTag("HERO: Healing Bug Fix Job", 10, hero_unit[hn], 4.00, 2.00)
      call RecycleGuardPosition(hero_unit[hn])
      call GroupRemoveUnit(unit_healing, hero_unit[hn])
    endif
    //

    set new_hp = GetUnitState(hero_unit[hn], UNIT_STATE_LIFE) / GetUnitState(hero_unit[hn], UNIT_STATE_MAX_LIFE)
    set current_order = GetUnitCurrentOrder(hero_unit[hn])

  //  call DisplayToAll("MicroH Start")
    if hero_dir[hn] != null then
      call RemoveLocation(hero_dir[hn])
    endif
    //set hero_dir[hn] = GetSubtractionLoc_dd(GetUnitLoc(hero_unit[hn]), hero_loc[hn])
    set hero_dir[hn] = hero_loc[hn]
    set hero_loc[hn] = GetUnitLoc(hero_unit[hn])
    set hero_hp_loss[hn] = hero_hp[hn] - new_hp
    set hero_hp[hn] = new_hp
    call GetDensities(hero_loc[hn], ai_player, hero_radius)
    set hero_enemy_density[hn] = enemy_density
    call MoveLocation(hero_enemy_loc[hn], GetLocationX(enemy_density_loc), GetLocationY(enemy_density_loc))
    set hero_ally_density[hn] = ally_density
    call MoveLocation(hero_ally_loc[hn], GetLocationX(ally_density_loc), GetLocationY(ally_density_loc))

    if not teleporting and current_order >= 852008 and current_order <= 852013 then
      if GetItemTypeId(UnitItemInSlot(hero_unit[hn], current_order - 852008)) == old_id[tp_item] then
        set teleporting = true
        call TQAddUnitJob(0.5, TELEPORT, 0, hero_unit[hn])
      endif
    endif

  //  call DisplayToAll("Hero Order: "+Int2Str(GetUnitCurrentOrder(hero_unit[hn])))

  //  call DisplayToAll(Int2Str(R2I(hero_enemy_density[hn] * 10)))
  //  call DisplayToAll(Int2Str(R2I(DistanceBetweenPoints(hero_enemy_loc[hn],GetUnitLoc(hero_unit[hn])))))

    set teleportdistance = DistanceBetweenPoints(hero_loc[hn], town_loc[most_threatened_town])
    if not teleporting and GetUnitState(hero_unit[hn], UNIT_STATE_LIFE) < RMax(flee_health_percentage * GetUnitState(hero_unit[hn], UNIT_STATE_MAX_LIFE), flee_minimum_health) and not IsUnitInGroup(hero_unit[hn], unit_healing) then
      call SaveHero(hn,armyOfHero)
    endif
    if armyOfHero >= 0 and not teleporting and GetItemNumberOnUnit(tp_item, hero_unit[hn]) > 0 then
      if town_threatened and town_threat[most_threatened_town] >= teleport_min_threat and teleportdistance > LinearInterpolation(teleport_low_threat, teleport_high_threat, teleport_low_threat_distance, teleport_high_threat_distance, town_threat[most_threatened_town]) and town_can_tp[most_threatened_town] and army_strength[armyOfHero] >= teleport_army_min_strength then
        if LinearInterpolation(ver_low_aggression,ver_high_aggression,ver_flee_multiple1,ver_flee_multiple2,attacking_aggression)*own_strength > army_strength[town_threat_army[most_threatened_town]] * 0.75 then
          //call PingMinimap(GetLocationX(hero_loc[hn]), GetLocationY(hero_loc[hn]), 10.00)
          //call PingMinimap(GetLocationX(town_loc[most_threatened_town]), GetLocationY(town_loc[most_threatened_town]), 10.00)
          //call DisplayToAll("Protection Town Portal: " + Int2Str(R2I(teleportdistance)))
          call CreateDebugTag("HERO: Teleporting to threatened town", 10, hero_unit[hn], 4.00, 2.00)
          call TeleportToLoc(hero_unit[hn], town_loc[most_threatened_town])
          call TQAddJob(1, MICRO_HERO, hn)
          return
        elseif DistanceBetweenPoints(hero_loc[hn], home_location) > 2500 then
          call CreateDebugTag("HERO: Teleporting home town too threatened", 10, hero_unit[hn], 4.00, 2.00)
          call TeleportHome(hn)
          call TQAddJob(1, MICRO_HERO, hn)
          return
        endif
      // Next statement detects when the main army is outmatched and so teleports back to home base
      elseif attack_running and IsUnitInRangeXY(hero_unit[hn],GetLocationX(army_loc[main_army]), GetLocationY(army_loc[main_army]), battle_radius) and army_strength[armyOfHero] >= teleport_army_min_strength and CaptainRetreating() and isfleeing and DistanceBetweenPoints(hero_loc[hn], home_location) > teleport_low_threat_distance then
        call CreateDebugTag("HERO: Army outmatched-teleporting home", 10, hero_unit[hn], 4.00, 2.00)
        call TeleportHome(hn)
        call TQAddJob(1, MICRO_HERO, hn)
        return
      endif
    endif
    if not teleporting and hero_enemy_density[hn] > 5 and IsUnitInGroup(hero_unit[hn], unit_healing) and DistanceBetweenPoints(hero_dir[hn],hero_loc[hn]) <= 225 then
      call CreateDebugTag("HERO: Surround Detection Teleportation", 10, hero_unit[hn], 4.00, 2.00)
      call TeleportHome(hn)
    endif
  endif
  call TQAddJob(1, MICRO_HERO, hn)
  //call DisplayToAll("MICRO_HERO END")
endfunction





function StatueControl takes unit u returns nothing
  local location loc = GetSubtractionLoc(last_ally_loc, last_enemy_loc)
  local location statue_loc = GetProjectedLoc(last_ally_loc, loc, statue_distance)
  if DistanceBetweenPoints_dk(GetUnitLoc(u), statue_loc) > 200 then
    call IssuePointOrderLoc(u, "move", statue_loc)
  endif
  call RemoveLocation(loc)
  set loc = null
  call RemoveLocation(statue_loc)
  set statue_loc = null
endfunction

function DenyUnit takes unit u , integer id returns nothing
  // if id != 'ugrm' and id != 'ohwd' and not IsUnitType(u, UNIT_TYPE_ETHEREAL) and not IsUnitInvisible(u, Player(PLAYER_NEUTRAL_AGGRESSIVE)) then
  //   set deny_unit = u
  // endif
endfunction

function SaveUnit takes unit u , integer id returns nothing
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  local unit healer = null
  local location l = null
  local group g = null
  local location unitloc = null
  local location temploc = null
  local integer hFountainID = GetHealthFountainID()
  local integer healertepy = 0

  if IsUnitType(u, UNIT_TYPE_HERO) then
    return
  endif
  if id == 'hphx' or id == old_id[racial_militia] then
    call IssuePointOrder(u, "move", GetLocationX(home_location), GetLocationY(home_location))
    return
  endif
  call RemoveGuardPosition(u)  //no Remove 'hphx'
  if GetUnitAbilityLevel(u, 'AOwk') > 0 or GetUnitAbilityLevel(u, 'ANwk') > 0 then
    if not IsUnitInvisible(u, Player(PLAYER_NEUTRAL_AGGRESSIVE)) then
      call IssueImmediateOrder(u, "windwalk")
    endif
  endif
  set healer = GetHealer(healer)
  if healer != null then  //and not IsUnitType(u, UNIT_TYPE_MECHANICAL) then  //Repetitive judgment
    set healertepy = healer_type[GetHealerId(GetUnitTypeId(healer))]
    if not CaptainInCombat(true) or (healertepy == HEALER_TYPE_NO_TARGET or healertepy == HEALER_TYPE_WARD or GetUnitState(u, UNIT_STATE_LIFE) > GetUnitState(u, UNIT_STATE_MAX_LIFE) * 55) then
      call CreateDebugTag("Going to Healer", 10, u, 3.00, 1.50)
      // Captain In Combat , if healer no Immediate and extensive treatment , urgent healing need go home , avoid staying on the battlefield
      set unitloc = GetUnitLoc(healer)
      if GetLocationX(last_enemy_loc) != 0 and GetLocationY(last_enemy_loc) != 0 then
        set temploc = GetSubtractionLoc(unitloc, last_enemy_loc)
        set l = GetProjectedLoc(unitloc, temploc, 350)
        call TQAddUnitJob(GetTimeToReachLoc(u, l) + 1, RESET_GUARD_POSITION, 0, u)
        call IssuePointOrderLoc(u, "move", l)
        call RemoveLocation(temploc)
        set temploc = null
        call RemoveLocation(l)
        set l = null
      else
        call TQAddUnitJob(GetTimeToReachLoc(u, unitloc) + 1, RESET_GUARD_POSITION, 0, u)
        call IssuePointOrderLoc(u, "move", unitloc)
      endif
      call GroupAddUnit(unit_healing, u)
      call RemoveLocation(unitloc)
      set unitloc = null
      call HealUnit(healer, u, false)
      set healer = null
      return
    endif
  endif
  if race_use_fountain and neutral_enemy[hFountainID] <= 0 and id != old_id[racial_ghoul] and neutral_available[hFountainID] and nearest_neutral[hFountainID] != null and (not neutral_guarded[hFountainID] or (neutral_night_buy[hFountainID] and (daytime >= 18 or daytime < 6))) then  //not IsUnitType(u, UNIT_TYPE_PEON) and not IsUnitType(u, UNIT_TYPE_MECHANICAL)  //Repetitive judgment
    if follow_zeppelin != null and not IsUnitInGroup(follow_zeppelin, unit_rescueing) and not IsUnitType(u, UNIT_TYPE_FLYING) then
      //    call SetUnitUserData(follow_zeppelin, UNIT_RESCUEING)
      call CreateDebugTag("Zepplin to fountain", 10, follow_zeppelin, 3.00, 1.50)
      call GroupAddUnit(unit_rescueing, follow_zeppelin)
      set g = CreateGroup()
      call GroupAddUnit(g, follow_zeppelin)
      call GroupAddUnit(unit_healing, u)	  
      call TQAddGroupJob(0, ZEPPELIN_MOVE, ZTARGET_FOUNTAIN, u, g)
      set g = null
    else
      call GroupAddUnit(unit_healing, u)
      call CreateDebugTag("Going to Fountain", 10, u, 3.00, 1.50)
      call TQAddUnitJob(0, HEALTH_FOUNTAIN, 80, u)
      call IssuePointOrder(u, "move", GetUnitX(nearest_neutral[hFountainID]), GetUnitY(nearest_neutral[hFountainID]))
    endif
  elseif race_has_moonwells and TownCountDone(racial_farm) > 0 then  //and not IsUnitType(u, UNIT_TYPE_SUMMONED) then  //Repetitive judgment
    if follow_zeppelin != null and not IsUnitInGroup(follow_zeppelin, unit_rescueing) and not IsUnitType(u, UNIT_TYPE_FLYING) then
      call GroupAddUnit(unit_rescueing, follow_zeppelin)
      call CreateDebugTag("Zeppelin to Moonwells", 10, u, 3.00, 1.50)
      set g = CreateGroup()
      call GroupAddUnit(g, follow_zeppelin)
      call GroupAddUnit(unit_healing, u)
      call TQAddGroupJob(0, ZEPPELIN_MOVE, ZTARGET_MOONWELLS, u, g)
      set g = null
    else
      call CreateDebugTag("Going to Moonwells", 10, u, 3.00, 1.50)
      call GroupAddUnit(unit_healing, u)
      call TQAddUnitJob(0, MOON_WELL_CONTROL, 80, u)
    endif
  //elseif GetUnitCurrentOrder(u) != OrderId("move") then	
  elseif follow_zeppelin != null and not IsUnitInGroup(follow_zeppelin, unit_rescueing) and not IsUnitType(u, UNIT_TYPE_FLYING) then
    //    call SetUnitUserData(follow_zeppelin, UNIT_RESCUEING)
    call CreateDebugTag("Zepplin Home", 10, u, 3.00, 1.50)
    call GroupAddUnit(unit_rescueing, follow_zeppelin)
    set g = CreateGroup()
    call GroupAddUnit(g, follow_zeppelin)
    call GroupAddUnit(unit_healing, u)
    call TQAddGroupJob(0, ZEPPELIN_MOVE, ZTARGET_HOME, u, g)
    set g = null
  else
    call CreateDebugTag("Going Home", 10, u, 3.00, 1.50)
    call GroupAddUnit(unit_healing, u)
    call TQAddUnitJob(0, SEND_HOME, GetRandomInt(0,Max(exist_town_num-1,0)), u)
    //call TQAddUnitJob(GetTimeToReachLoc(u, home_location) + 1, RESET_GUARD_POSITION, 0, u)
    //call IssuePointOrderLoc(u, "move", home_location)
  endif
  set healer = null
endfunction

function GetMana takes unit u , integer id returns nothing
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  local integer mFountainID = GetManaFountainID()

  if race_use_fountain and GetUnitState(u, UNIT_STATE_MANA) < GetUnitState(u, UNIT_STATE_MAX_MANA) * 0.4 and neutral_enemy[mFountainID] <= 0 and not (id == old_id[racial_ghoul]) and not (id == old_id[racial_militia]) and neutral_available[mFountainID] and nearest_neutral[mFountainID] != null and (not neutral_guarded[mFountainID] or (neutral_night_buy[mFountainID] and (daytime >= 18 or daytime < 6))) then
    call CreateDebugTag("Going to mana fountain", 10, u, 3.00, 1.50)
    call GroupAddUnit(unit_healing, u)
    call TQAddUnitJob(8, MANA_FOUNTAIN, 80, u)
    call IssuePointOrder(u, "move", GetUnitX(nearest_neutral[mFountainID]), GetUnitY(nearest_neutral[mFountainID]))
  endif
endfunction

function MicroUnitsJob takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  local real unit_life = 0
  local real unit_life_max = 0
  local real unit_mana = 0
  local group new_healer_group = CreateGroup()
  local boolean ward_check = false
  local boolean prev_ward = ward_cast
  //local boolean deny = (GetGold() > 600 and GetWood() > 400) or GetGoldOwned() > 3000
  //local location unitloc = null
  local real health_sum = 0.0
  local integer count = 0
  local real unit_health_ratio = 0.0
  local integer id = 0
  if major_hero == null or not UnitAlive(major_hero) then
    set major_hero = GetMajorHero(major_hero)
  endif
  //call DisplayToAllJobDebug("MICRO_UNITS Job Started") 

  //call GroupEnumUnitsInRange(g,GetUnitX(major_hero),GetUnitY(major_hero),battle_radius,null)
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectUnittype(g,UNIT_TYPE_PEON,false)
  set g = SelectUnittype(g,UNIT_TYPE_STRUCTURE,false)
  set g = SelectByIllusion(g, false)
  set g = SelectByUnitStandard(g, true)
  //set g = SelectUnittype(g,UNIT_TYPE_SUMMONED,false)  // need search 'ohwd' and 'hphx'
  //call DisplayToAll("MICRO_UNITS: Group made")
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set unit_life = GetUnitState(u, UNIT_STATE_LIFE)
    set unit_life_max = GetUnitState(u, UNIT_STATE_MAX_LIFE)
    set unit_mana = GetUnitState(u, UNIT_STATE_MANA)
    set id = GetUnitTypeId(u)
    if id == 'ohwd' then
      //         call GroupAddUnit(new_healer_group, u)
      set ward_check = true
    endif
    if unit_life > 0 then
      //call DisplayToAllJobDebug("MICRO_UNITS: Main Loop")
      //set unitloc = GetUnitLoc(u)
      //if (attack_running or town_threatened) then //and DistanceBetweenUnits(major_hero, u) <= battle_radius then
        //call Trace("MIRCO_UNITS: Attack healing section")
        //if IsPlayerAlly(GetOwningPlayer(u), ai_player) then
          //call Trace("MICRO_UNITS: Friendly Unit")
          // if deny == true and not IsUnitType(u, UNIT_TYPE_HERO) and unit_life < RMin(0.1 * unit_life_max, 24) then
          //   call DenyUnit(u,id)
          // endif
          if not IsUnitType(u, UNIT_TYPE_MECHANICAL) and (id == 'hphx' or not IsUnitType(u, UNIT_TYPE_SUMMONED)) and unit_life < RMax(flee_health_percentage * unit_life_max, flee_minimum_health) then
            call SaveUnit(u,id)
          else
            if IsUnitHealer(u) then
              call GroupAddUnit(new_healer_group, u)
            endif
            //if GetUnitFoodUsed(u) > 0 and unit_mana < RMax(0.35 * GetUnitState(u, UNIT_STATE_MAX_MANA), 50) then
              //call GetMana(u, id)
            //endif
          endif
          //else
          //endif
        //else
          // HEAL ARMY CODE
          //INCONSISTENCY  - NOT MODDABLE DETECTED HERE
          //if id == 'ohwd' then
            //set ward_cast = true
          //endif
          // ///////////////////////////////////
          //if not (IsUnitType(u, UNIT_TYPE_MECHANICAL)) then
          //	set unit_health_ratio = unit_life / unit_life_max
          //	set health_sum = health_sum + unit_health_ratio
          //	set count = count + 1


          //	if GetHealerId(id) != -1 and GetUnitState(u, UNIT_STATE_MANA) >= (healer_mana_cost[GetHealerId(id)] * 2) / 3 and ((healer_upg_id[GetHealerId(id)] == 0) or (GetUpgradeLevel(healer_upg_id[GetHealerId(id)]) >= healer_upg_level[GetHealerId(id)])) then
            //		call GroupAddUnit(new_healer_group, u)
          //	endif

          //	if not IsUnitInGroup(u, unit_healing) then
            //		if unit_life < RMax(flee_health_percentage * unit_life_max, flee_minimum_health) then
              //		    //call DisplayToAllJobDebug("MICRO_UNITS Special Extra Save")
              //			call SaveUnit(u,id)
            //		elseif unit_health_ratio <= 0.5 then
              //		    //call DisplayToAllJobDebug("MICRO_UNITS Make Unit Heal")
              //			call MakeUnitHeal(u) 
            //		endif
          //	endif
        //endif
      //endif
    endif
    call GroupRemoveUnit(g,u)
    //call RemoveLocation(unitloc)
  endloop
  //set unitloc = null

  //call DisplayToAll("MICRO_UNITS: Clear up code")
  if prev_ward or not ward_cast then
    set ward_cast = ward_check
  endif

  call DestroyGroup(healer_group)
  set healer_group = new_healer_group
  set new_healer_group = null
  call DestroyGroup(g)
  set g = null
  call TQAddJob(1 * sleep_multiplier, MICRO_UNITS, 0)
  //call DisplayToAll("MICRO_UNITS END")

endfunction

function GetZTargetLocation takes integer target returns location
  if target == ZTARGET_HOME then
    return Location(GetLocationX(home_location), GetLocationY(home_location)) // Need to make new location otherwise home_location would be cleared
  elseif target == ZTARGET_MOONWELLS then
    return Location(GetLocationX(home_location), GetLocationY(home_location))
  else
    if nearest_neutral[NEUTRAL_POWER_FOUNTAIN] != null then
      return GetUnitLoc(nearest_neutral[NEUTRAL_POWER_FOUNTAIN])
    elseif nearest_neutral[NEUTRAL_HEAL_WARD] != null then
        return GetUnitLoc(nearest_neutral[NEUTRAL_HEAL_WARD])
    else
      return GetUnitLoc(nearest_neutral[NEUTRAL_HEALING_FOUNTAIN])
    endif
  endif
endfunction

function AddZepFinishingJob takes integer target, integer wait, unit hu returns nothing
  if target == ZTARGET_FOUNTAIN then
    call TQAddUnitJob(wait, HEALTH_FOUNTAIN, 80, hu)
  elseif target == ZTARGET_MOONWELLS then
    call TQAddUnitJob(wait, MOON_WELL_CONTROL, 80, hu)
  else
    call TQAddUnitJob(wait, SEND_HOME, GetRandomInt(0,Max(exist_town_num-1,0)), hu)  // 0 is home_location
  endif
endfunction

function ZeppelinMoveJob takes integer target, unit hu, group z returns nothing
  local location tl = null
  local unit zep = FirstOfGroup(z)
  local location zeploc = null
  local location heroloc = null
  local integer clearvars = 0  //=1.. Zepplin system can now finish so return
  if GetUnitState(hu, UNIT_STATE_LIFE) <= 0 then
    call GroupRemoveUnit(unit_rescueing, zep)
    call GroupRemoveUnit(unit_zepplin_move, zep)
    call RecycleGuardPosition(zep)
    call TQAddUnitJob(2, RESET_GUARD_POSITION, 80, hu)
    call DestroyGroup(z)
    set zep = null
    set zepdropping = false
    return
  endif
  call DisplayToAllJobDebug("ZEPPELIN_MOVE Start")
  if not UnitAlive(zep) then
    call GroupRemoveUnit(unit_rescueing, zep)
    call GroupRemoveUnit(unit_zepplin_move, zep)
    call AddZepFinishingJob(target, 1,hu)
    call DestroyGroup(z)
    set zep = null
    set zepdropping = false
    return
  endif
  set zeploc = GetUnitLoc(zep)
  set heroloc = GetUnitLoc(hu)
  set tl = GetZTargetLocation(target)
  if IsUnitInTransport(hu, zep) then
    if DistanceBetweenPoints(zeploc, tl) > 1000 and not zepdropping then  // and DistanceBetweenPoints(zeploc, ally_loc) < 1500 then
      call IssuePointOrderLoc(zep, "move", tl)
      call CreateDebugTag("Move to safe location", 10, zep, 3.00, 1.50)
    else
      if not zepdropping then
        call IssueImmediateOrder(zep, "stop")
      endif
      set zepdropping = true
      //call IssueTargetOrder(zep, "unload", hu)
      call IssuePointOrder(zep, "unloadall", GetLocationX(tl) + GetRandomReal(-200,200), GetLocationY(tl) + GetRandomReal(-200,200))
      call CreateDebugTag("unload unit", 10, zep, 3.00, 1.50)
      call AddZepFinishingJob(target, 1,hu)
    endif
  elseif not IsUnitInTransport(hu,zep) and (zepdropping or GetUnitState(hu,UNIT_STATE_LIFE)>= GetUnitState(hu,UNIT_STATE_MAX_LIFE) * 0.8) then
    call TQAddUnitJob(2, RESET_GUARD_POSITION, 80, hu)
    set clearvars = 1
  elseif not zepdropping then
    if DistanceBetweenPoints(heroloc, tl) < 1500 then //or DistanceBetweenPoints(zeploc, ally_loc) > 1300 then
      call AddZepFinishingJob(target, 1,hu)
      set clearvars = 1
    else
      call CreateDebugTag("Pick up unit", 10, zep, 3.00, 1.50)
      call IssueTargetOrder(zep, "smart", hu)
      call IssueTargetOrder(hu, "smart", zep)
    endif
  endif
  call RemoveLocation(tl)
  set tl = null
  call RemoveLocation(zeploc)
  set zeploc = null
  call RemoveLocation(heroloc)
  set heroloc = null
  if clearvars == 1 then
    call GroupRemoveUnit(unit_rescueing, zep)
    call GroupRemoveUnit(unit_zepplin_move, zep)
    call RecycleGuardPosition(zep)
    set zep = null
    call DestroyGroup(z)
    set zepdropping = false
    return
  endif
  set zep = null
  call TQAddGroupJob(2, ZEPPELIN_MOVE, target, hu, z)
endfunction
function TeleportJob takes unit hu returns nothing
  local group g = null
  local unit u = null
  local integer current_order = GetUnitCurrentOrder(hu)

  call DisplayToAllJobDebug("TELEPORT JOB Start")
  if not UnitAlive(hu) or current_order < 852008 or current_order > 852013 then
    if not UnitAlive(hu) then
      call CaptainGoHome()
    else
      call TeleportCaptain(GetLocationX(teleportloc), GetLocationY(teleportloc))
    endif
    set teleporting = false
    return
  endif
  set g = CreateGroup()
  call GroupEnumUnitsInRange(g, GetUnitX(hu), GetUnitY(hu), 2 * teleport_radius, null)
  call GroupRemoveUnit(g, hu)
  set g = SelectByPlayer(g, ai_player, true)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, false)
  set g = SelectByHidden(g, false)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if DistanceBetweenUnits(hu, u) > teleport_radius then
      call IssuePointOrder(u, "move", GetUnitX(hu), GetUnitY(hu))
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  call TQAddUnitJob(1, TELEPORT, 0, hu)
endfunction
function GetHarassPeonTarget takes unit ru, unit u returns unit
  local group g = CreateGroup()
  local location unitloc = GetUnitLoc(u)
  local player p = GetNearestEnemyToLoc_k(unitloc)

  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, true)
  set g = SelectByAlive(g, true)
  set g = SelectByLoaded(g, false)
  set g = SelectByHidden(g, false) // Hopefully to get peons not currently building
  set ru = GetNearestOfGroup(ru, g, unitloc)
  call RemoveLocation(unitloc)
  call DestroyGroup(g)
  set unitloc = null
  set g = null
  set p = null
  return ru
endfunction

function GetHarassExpansionTarget takes unit ru, unit u returns unit
  local group g = CreateGroup()
  local location unitloc = GetUnitLoc(u)
  local player p = GetNearestEnemyToLoc_k(unitloc)  
  local location baseloc = GetPlayerStartLocationLoc(p)
  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectUnittype(g, UNIT_TYPE_TOWNHALL, true)
  set g = SelectByLocation(g, baseloc, 1000, false)
  set g = SelectByAlive(g, true)
  set ru = GetNearestOfGroup(ru, g, unitloc)
  call RemoveLocation(unitloc)
  call RemoveLocation(baseloc)
  call DestroyGroup(g)
  set unitloc = null
  set baseloc = null
  set g = null
  set p = null
  return ru
endfunction

function GetHarassLocationTarget takes unit ru, real x, real y returns unit
  local group g = CreateGroup()
  call GroupEnumUnitsInRange(g, x, y, 1000, null)
  set g = SelectByEnemy(g, ai_player, true)
  set g = SelectByAlive(g, true)
  set ru = GetLeastHPUnitOfGroup(ru,g)
  set g = null
  return ru
endfunction

function GetHarassMainHallTarget takes unit ru, unit u returns unit
  local group g = CreateGroup()
  local location unitloc = GetUnitLoc(u)
  local player p = GetNearestEnemyToLoc_k(unitloc)  
  local location baseloc = GetPlayerStartLocationLoc(p)

  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectUnittype(g, UNIT_TYPE_TOWNHALL, true)
  set g = SelectByAlive(g, true)
  set g = SelectByLocation(g, baseloc, 1000, true)
  set ru = GetNearestOfGroup(ru, g, unitloc)
  call RemoveLocation(unitloc)
  call RemoveLocation(baseloc)
  call DestroyGroup(g)
  set unitloc = null
  set baseloc = null
  set g = null
  set p = null
  return ru
endfunction

function GroupOrderWindWalkInstant_d takes group g returns nothing
	local unit u = null
	loop
		set u = FirstOfGroup(g)
		exitwhen u == null
		if GetUnitAbilityLevel(u, 'AOwk') > 0 or GetUnitAbilityLevel(u, 'ANwk') > 0 then
			if not IsUnitInvisible(u, Player(PLAYER_NEUTRAL_AGGRESSIVE)) then
				//call CreateDebugTag("HARASS: WINDWALK COMMANDED", 10, u, 3.00, 1.50)
				call IssueImmediateOrder(u, "windwalk")
			endif
		endif
		call GroupRemoveUnit(g, u)
	endloop
	call DestroyGroup(g)
endfunction

function HarassJob takes integer ht, unit targ, group harasser returns nothing
  local unit target = targ
  local integer key = GetHandleId(harasser)
  local real strength_limit = LoadReal(additional_info, key, STRENGTH_LIMIT)
  local boolean state_attacking = LoadBoolean(additional_info, key, STATE_ATTACKING)
  local real flee_percent = LoadReal(additional_info, key, FLEE_PERCENT)
  local boolean avoiding_towers = LoadBoolean(additional_info, key, AVOID_TOWERS)
  local boolean state_retreat = LoadBoolean(additional_info, key, STATE_RETREAT)
  local real start_strength = LoadReal(additional_info, key, START_STRENGTH)
  local unit u = null
  local unit hu = null
  local player p = null
  local group g = null
  local real strength_sum = 0
  local real player_sum = 0
  local integer harass_num = 0
  local boolean towersdetected = false
  local boolean hero_harass = false
  local integer hiddencount = LoadInteger(additional_info, key, INVISIBLE_COUNT)
  local integer timedelay = LoadInteger(additional_info, key, WINDWALK_COUNT) // Delay count so windwalkers show themselves after a period of waiting

  call DisplayToAllJobDebug("HARASS JOB START")
  if not UnitAliveInGroup(harasser) then
    set target = null
    return
  endif
  set hu = FirstOfGroup(harasser)
  if hu == hero_unit[1] or hu == hero_unit[2] or hu == hero_unit[3] then
    //call Trace("HARASS WITH HERO RAN")
    set hero_harass = true
  endif

  if town_threatened and (not state_attacking or hero_harass) then
    call TQAddGroupJob(5 * sleep_multiplier, HARASS, ht, target, harasser)
    set target = null
    set hu = null
    return
  endif
  if state_retreat then
    if DistanceBetweenPoints_dk(GetUnitLoc(hu), home_location) > 1000 then
      call GroupOrderWindWalkInstant_d(CopyGroup(harasser))
      call GroupPointOrder(harasser, "move", GetLocationX(home_location), GetLocationY(home_location))
      call TQAddGroupJob(3 * sleep_multiplier, HARASS, ht, target, harasser)
      //call GroupRemoveUnit(unit_harassing, hu)
      set target = null
      set hu = null
      return
    else
      call SaveBoolean(additional_info, key, STATE_RETREAT , false)
      //call GroupRecycleGuardPositionInstant(harasser)
      call GroupRecycleHarrassPositionInstant(harasser)
      set target = null
      set hu = null
      return
    endif
  endif

  if target != null and (IsUnitHidden(target) or IsUnitLoaded(target) or IsUnitInvisible(target, ai_player)) then	// Checks to see if unit is not targetable and after small period will change to target it can hit
    set hiddencount = hiddencount + 1
    call SaveInteger(additional_info, key, INVISIBLE_COUNT , hiddencount)
  else
    set hiddencount = 0
    call SaveInteger(additional_info, key, INVISIBLE_COUNT , hiddencount)
  endif

  if target == null or not UnitAlive(target) or hiddencount > 2 then
    if target != null then
      call GroupOrderWindWalkInstant_d(CopyGroup(harasser))
    endif
    if ht == HARASS_TARGET_PEONS then
      set target = GetHarassPeonTarget(target, hu)
    elseif ht == HARASS_TARGET_EXPANSION then
      set target = GetHarassExpansionTarget(target, hu)
    elseif ht == HARASS_TARGET_LOCATION then
      set target = GetHarassLocationTarget(target, LoadReal(additional_info, key, LOCX), LoadReal(additional_info, key, LOCY))
    else
      set target = GetHarassMainHallTarget(target, hu)
    endif
  endif

  //if not state_attacking then	// first run
  if target != null and avoiding_towers and GetLocationTowerStrength(GetUnitX(target), GetUnitY(target), ver_harass_tower_check_radius) > 0 then
    set target = null
  //else
    //call GroupRemoveGuardPositionInstant(harasser)
  endif
  //endif

  if target != null and UnitAlive(target) then
    set g = CreateGroup()
    //if state_attacking then
    //  call GroupEnumUnitsInRange(g,GetUnitX(hu),GetUnitY(hu),harass_radius_attack_melee,null)
    //else
    //  call GroupEnumUnitsInRange(g,GetUnitX(hu),GetUnitY(hu),harass_radius_flee_melee,null)
    //endif
    //set g = SelectByAlive(g, true)
    //loop
    //  set u = FirstOfGroup(g)
    //  exitwhen u == null
    //  set p = GetOwningPlayer(u)
    //  if IsPlayerEnemy(ai_player, p) and IsUnitType(u, UNIT_TYPE_MELEE_ATTACKER) and p != Player(PLAYER_NEUTRAL_AGGRESSIVE) and IsUnitType(u, UNIT_TYPE_PEON) == false then
    //    set strength_sum = strength_sum + GetUnitStrength(u)
    //  endif
    //  call GroupRemoveUnit(g, u)
    //endloop

    //call GroupClear(g)
    if state_attacking then
      call GroupEnumUnitsInRange(g,GetUnitX(hu),GetUnitY(hu),harass_radius_attack_ranged,null)
    else
      call GroupEnumUnitsInRange(g,GetUnitX(hu),GetUnitY(hu),harass_radius_flee_ranged,null)
    endif
    set g = SelectByAlive(g, true)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      if not IsUnitHidden(u) then
        set p = GetOwningPlayer(u)
        if IsPlayerEnemy(ai_player, p) and IsUnitTower(u) and avoiding_towers then
          set towersdetected = true
        endif
        if IsPlayerEnemy(ai_player, p) and IsUnitType(u, UNIT_TYPE_RANGED_ATTACKER) and p != Player(PLAYER_NEUTRAL_AGGRESSIVE) and IsUnitType(u, UNIT_TYPE_PEON) == false then
          set strength_sum = strength_sum + GetUnitStrength(u)
        elseif IsUnitInGroup(u, harasser) then
          if ht == HARASS_TARGET_LOCATION then
            call CreateDebugTag("Distraction: Harrasing Opponent Location", 10, u, 3.00, 1.50)
          else
            call CreateDebugTag("Harassing Opponent", 10, u, 3.00, 1.50)
          endif
          //if GetUnitState(u, UNIT_STATE_LIFE) <= GetUnitState(u, UNIT_STATE_MAX_LIFE) * flee_percent then

          if GetUnitState(u, UNIT_STATE_LIFE) <= RMax(flee_health_percentage * GetUnitState(u, UNIT_STATE_MAX_LIFE), flee_minimum_health) and not IsUnitInGroup(u, unit_healing) and IsUnitType(u, UNIT_TYPE_HERO) == false then // Not used on heroes as micro hero is in control of that
            call GroupAddUnit(unit_healing, u)
            call IssuePointOrder(u, "move", GetLocationX(home_location), GetLocationY(home_location))
            call TQAddUnitJob(0.5, SEND_HOME, 0, u)  // 0 is home_location
            call GroupRemoveUnit(harasser, u)
            call GroupRemoveUnit(unit_harassing, u)
          elseif IsUnitInGroup(u, unit_healing) then // Another system moved unit to healing
            call GroupRemoveUnit(harasser, u)
            call GroupRemoveUnit(unit_harassing, u)
          else
            //call IssuePointOrder(u, "move", GetLocationX(home_location), GetLocationY(home_location))
            //call TQAddUnitJob(0.5, SEND_HOME, 0, u)  // 0 is home_location
            set harass_num = harass_num + 1
            set player_sum = player_sum + GetUnitStrength(u)
          endif
          //else

          //endif
        endif
      endif
      call GroupRemoveUnit(g, u)
    endloop
    call DestroyGroup(g)
    set g = null
    set p = null
    set hu = FirstOfGroup(harasser)
    if harass_num <= LoadInteger(additional_info, key, FLEE_NUMBER) or towersdetected or (player_sum <= start_strength * flee_percent and not hero_harass) then
      call SaveBoolean(additional_info, key, STATE_RETREAT, true)
      call GroupPointOrder(harasser, "move", GetLocationX(home_location), GetLocationY(home_location))
      //call GroupRecycleGuardPosition(harasser)
      //return
    elseif strength_sum < strength_limit then
      call SaveBoolean(additional_info, key, STATE_ATTACKING, true)
      if hu != null and IsUnitInvisible(hu, Player(PLAYER_NEUTRAL_AGGRESSIVE)) then
        set timedelay = timedelay + 1
        call SaveInteger(additional_info, key, WINDWALK_COUNT, timedelay)
      else
        set timedelay = -1	// Not a windwalker harassing so attack immediatly
        call SaveInteger(additional_info, key, WINDWALK_COUNT, 0)
      endif
      if hu != null and DistanceBetweenUnits(hu, target) > 650 then
        if DistanceBetweenUnits(hu, target) <= 5000 then
          call GroupOrderWindWalkInstant_d(CopyGroup(harasser))
        endif
        call CreateDebugTag("HARASS: Move to Target unit", 10, target, 3.00, 1.50)
        call GroupPointOrder(harasser, "move", GetUnitX(target), GetUnitY(target))
      else
        if timedelay >= 5 or timedelay == -1 or (hu != null and IsUnitDetected(hu, GetOwningPlayer(target))) then
          call GroupTargetOrder(harasser, "attack", target)
          call IssueTargetOrder(hu, "attack", target)
        endif
        call CreateDebugTag("HARASS: Attack Target", 10, target, 3.00, 1.50)
        //call CreateDebugTag("HARASS: Changing Target", 10, hu, 3.00, 1.50)
        //call HarassJob(ht, null, harasser)
        //return
      endif
    elseif strength_sum >= strength_limit*2 then
      call SaveBoolean(additional_info, key, STATE_RETREAT, true)
      call GroupPointOrder(harasser, "move", GetLocationX(home_location), GetLocationY(home_location))
      call SaveBoolean(additional_info, key, STATE_ATTACKING, false)	
      //call GroupRecycleGuardPosition(harasser)
    else
      call SaveBoolean(additional_info, key, STATE_RETREAT, true)
      call GroupPointOrder(harasser, "move", GetLocationX(home_location), GetLocationY(home_location))
      call SaveBoolean(additional_info, key, STATE_ATTACKING, false)
      //call TQAddGroupJob(30, HARASS, ht, target, harasser)
    endif
  else
    //call DisplayToAll("Target dead")
    call CreateDebugTag("HARASS: Target Dead", 10, target, 3.00, 1.50)
    call GroupPointOrder(harasser, "move", GetLocationX(home_location), GetLocationY(home_location))
    call SaveBoolean(additional_info, key, STATE_RETREAT, true)
    call SaveBoolean(additional_info, key, STATE_ATTACKING, false)
    //call GroupRecycleGuardPositionDelay(harasser,GetTimeToReachLoc(u, home_location) + 1)
    //return
  endif
  call TQAddGroupJob(2, HARASS, ht, target, harasser)
  set target = null
  set hu = null
endfunction
function RallypointJob takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  call DisplayToAllJobDebug("RALLY_POINT JOB START")
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  call GroupPointOrderLoc(g, "setrally", home_location)
  call DestroyGroup(g)
  set g = null
  call TQAddJob(60, RALLY_POINT, 0)
endfunction
function NeutralEnemyCheckJob takes integer nn returns nothing
  call DisplayToAllJobDebug("NEUTRAL_ENEMY_CHECK JOB START")
  set neutral_enemy[nn] = GetLocationNonCreepStrength(GetUnitX(nearest_neutral[nn]), GetUnitY(nearest_neutral[nn]), 1500)
  if not pathing_done then  // pathing_done give PathingThread continue check
    call TQAddJob(6 * sleep_multiplier, NEUTRAL_ENEMY_CHECK, nn)
  endif
endfunction

function CopyArmy takes integer from, integer to returns nothing
  set army_owner[to] = army_owner[from]
  set army_loc[to] = army_loc[from]
  set army_dir[to] = army_dir[from]
  set army_future[to] = army_future[from]
  set army_strength[to] = army_strength[from]
  set army_group[to] = army_group[from]
  set army_count[to] = army_count[from]
endfunction

function TrackArmy takes integer num returns boolean
  local group g = CreateGroup()
  local unit u = null
  local location l = Location(0,0)
  
  call GroupClear(army_group[num])
  set army_strength[num] = 0
  set army_count[num] = 0
  
  call GroupEnumUnitsInRangeOfLoc(g, army_loc[num], army_radius, null)
  set g = SelectByUnitStandard(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and GetOwningPlayer(u) == Player(army_owner[num]) and not (IsUnitType(u, UNIT_TYPE_STRUCTURE) or IsUnitType(u, UNIT_TYPE_PEON) or IsUnitInGroup(u, in_army_group)) then
      if GetOwningPlayer(u) != ai_player and IsUnitInvisible(u, ai_player) then 
			// Fix using invisible units to exploit amai to force defend its town
	  else
		  if u == major_hero then
	        set main_army = num
	      endif
	      call GroupAddUnit(army_group[num], u)
	      call GroupAddUnit(in_army_group, u)
	      set l = GetSumLoc_dd(l, GetUnitLoc(u))
	      set army_count[num] = army_count[num] + 1
	      set army_strength[num] = army_strength[num] + GetUnitStrength(u)
	  endif
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  set u = null
  
  if army_strength[num] == 0 then
    call DestroyGroup(army_group[num])
    call RemoveLocation(army_loc[num])
    call RemoveLocation(army_dir[num])
    call RemoveLocation(army_future[num])
    call RemoveLocation(l) 	
	set l = null	
    return false
  endif  
  
  call RemoveLocation(army_dir[num])
  set l = GetDivisionLoc_d(l, Max(army_count[num], 1))
  set army_dir[num] = GetSubtractionLoc_kd(l, army_loc[num])
  call CreateDebugTagLoc("Tracked Army: " + Int2Str(num) + " Strength:" + Int2Str(R2I(army_strength[num])), 10, GetLocationX(l), GetLocationY(l), 3.00, 1.50)
  set army_loc[num] = Location(GetLocationX(l), GetLocationY(l))
  call RemoveLocation(army_future[num])
  set army_future[num] = GetSumLoc_kd(army_loc[num], GetMultipleLoc(army_dir[num], army_future_mult))
  
 // if army_strength[num] != 0 then
   // call PingMinimap(GetLocationX(l), GetLocationY(l), 4)
 // endif
  call RemoveLocation(l)   
  set l = null
  
  return true
endfunction

function TrackExistingArmies takes nothing returns nothing
  local integer i = 0
  local integer first_free = 0
  loop
    exitwhen i >= army_num
    if TrackArmy(i) then
      call CopyArmy(i, first_free)
      set first_free = first_free + 1
    endif
    set i = i + 1
  endloop
  set army_num = first_free
endfunction

function SeedNewArmyAtLoc takes location l, integer p returns nothing
  set army_owner[army_num] = p
  set army_loc[army_num] = l
  set army_dir[army_num] = Location(0,0)
  set army_future[army_num] = Location(0,0)
  set army_group[army_num] = CreateGroup()
  if TrackArmy(army_num) then
	set army_num = army_num + 1
  endif
endfunction

function SeedNewArmiesForPlayer takes integer p returns nothing
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsOfPlayer(g, Player(p), null)
  set g = SelectByUnitStandard(g, true)   // Hopefully fix issues of heroes doing other things not making false armies
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and not IsUnitInGroup(u, in_army_group) and (IsUnitType(u, UNIT_TYPE_HERO) or major_hero == u or (GetRandomInt(0, 30) == 1 and not (IsUnitType(u, UNIT_TYPE_STRUCTURE) or IsUnitType(u, UNIT_TYPE_PEON)))) then
      call SeedNewArmyAtLoc(GetUnitLoc(u), p)
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
endfunction

function SeedNewArmies takes nothing returns nothing
  local integer p = 0
  loop
    exitwhen p >= GetBJMaxPlayers()
    if GetPlayerSlotState(Player(p)) == PLAYER_SLOT_STATE_PLAYING then
      call SeedNewArmiesForPlayer(p)
    endif
    set p = p + 1
  endloop
endfunction

function UpdateSpecificTownThreat takes integer num returns nothing
  local integer i = 0
  local real dist = 0
  local real threat = 0
  local real max_threat = 0
  local location loc = null
  
  set town_threat[num] = 0
  loop
    if i == main_army then
      set i = i + 1
    endif
    exitwhen i >= army_num
    set dist = RMax(DistanceBetweenPoints(army_future[i], town_loc[num]), full_threat_distance)
    if dist <= no_threat_distance then
	  set loc = GetSubtractionLoc(town_loc[num], army_loc[i]) 
      if DistanceBetweenPoints(army_loc[i], town_loc[num]) < GetLengthOfLoc(army_dir[i]) and RAbs(GetAngleBetweenLocs(army_dir[i], loc)) <= 0.4 then
        set dist = full_threat_distance
      endif
	  call RemoveLocation(loc)
	  set loc = null
      set threat = distance_threat_mult * army_strength[i] / Pow(dist, distance_threat_exponent)
      if IsPlayerAlly(Player(town_owner[num]), Player(army_owner[i])) then
        set town_threat[num] = town_threat[num] - threat
      else
        set town_threat[num] = town_threat[num] + threat
        if threat > max_threat then
          set max_threat = threat
          set town_threat_army[num] = i
        endif
      endif
    endif
    set i = i + 1
  endloop
  if IsPlayerAlly(Player(town_owner[num]), ai_player) then
    if (most_threatened_town == -1 or town_threat[most_threatened_town] < town_threat[num]) and town_count[num] > 0 then
      set most_threatened_town = num
    endif
   // call DisplayToAll("Town threatened "+Int2Str(num)+" Threat: "+Int2Str(R2I(town_threat[num])))
   // call PingMinimapEx(GetLocationX(town_loc[num]), GetLocationY(town_loc[num]), 4, 255, 0, 0, true)
  elseif IsPlayerEnemy(Player(town_owner[num]), ai_player) and town_count[num] > 0 then
    if most_threatened_enemy_town == -1 or town_threat[most_threatened_enemy_town] < town_threat[num] then
      set most_threatened_enemy_town = num
    endif
  endif
endfunction

function UpdateTownThreat takes nothing returns nothing
  local integer i = 0
  local real accepted_threat_level = LinearInterpolation(atl_time_start, atl_time_end, atl_time_start_val, atl_time_end_val, TimerGetElapsed(tq_timer)) * LinearInterpolation(atl_enemy_start, atl_enemy_end, atl_enemy_start_mult, atl_enemy_end_mult, c_enemy_total)
  set town_threatened = false
  //call Trace("ARMY_TRACK: Town threat update")
  set most_threatened_town = -1
  set most_threatened_enemy_town = -1
  loop
    exitwhen i >= town_num
    call UpdateSpecificTownThreat(i)
    set i = i + 1
  endloop
  if town_threat[most_threatened_town] > accepted_threat_level and town_threat[most_threatened_town] > (I2R(c_ally_total + 1) / c_enemy_total) * town_threat[most_threatened_enemy_town] then
    set town_threatened = true
  endif
  if town_threatened then
	call SetCaptainHome(DEFENSE_CAPTAIN, GetLocationX(town_loc[most_threatened_town]), GetLocationY(town_loc[most_threatened_town]))	
  endif
endfunction

function ArmyTrackJob takes nothing returns nothing
  local unit alliance
  call DisplayToAllJobDebug("ARMY_TRACK JOB START")
  call GroupClear(in_army_group)
  call TrackExistingArmies()
  call SeedNewArmies()
  //set alliance = GetAllianceTarget()
  //if alliance != null then
	//call CreateDebugTag("Alliance Target", 10, alliance, 3.00, 1.50)
  //endif
  call UpdateTownThreat()
  call TQAddJob(4, ARMY_TRACK, 0)
endfunction
function CopyTown takes integer from, integer to returns nothing
  set town_owner[to] = town_owner[from]
  set town_loc[to] = town_loc[from]
  set town_value[to] = town_value[from]
  set town_threat[to] = town_threat[from]
  set town_group[to] = town_group[from]
  set town_count[to] = town_count[from]
endfunction






function TrackTown takes integer num returns boolean
  local group g = CreateGroup()
  local unit u = null
  local location l = Location(0,0)
  local location unitloc = null
  local location temploc = null
  
  call GroupClear(town_group[num])
  set town_value[num] = 0
  set town_count[num] = 0
  set town_can_tp[num] = false
  call GroupEnumUnitsInRangeOfLoc(g, town_loc[num], town_radius, null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitState(u, UNIT_STATE_LIFE) > 0 and GetOwningPlayer(u) == Player(town_owner[num]) and IsUnitType(u, UNIT_TYPE_STRUCTURE) and not IsUnitInGroup(u, in_town_group) then
      call GroupAddUnit(town_group[num], u)
      call GroupAddUnit(in_town_group, u)
	  set temploc = l
      set unitloc = GetUnitLoc(u)
      set l = GetSumLoc(temploc, unitloc)
      set town_count[num] = town_count[num] + 1
      set town_value[num] = town_value[num] + 1
      if IsUnitType(u, UNIT_TYPE_TOWNHALL) and UnitAlive(u) then
        set town_can_tp[num] = true
      endif
	  call RemoveLocation(temploc)
	  call RemoveLocation(unitloc)
	  set temploc = null
	  set unitloc = null
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  set temploc = l
  set l = GetDivisionLoc(temploc, Max(town_count[num], 1))
  call RemoveLocation(temploc)
  set temploc = null
  call RemoveLocation(town_loc[num])
  set town_loc[num] = l
  set l = null
  if town_count[num] == 0 then
    call DestroyGroup(town_group[num])
	set town_group[num] = null
    call RemoveLocation(town_loc[num])
	set town_loc[num] = null
    return false
  endif
  return true
endfunction

function TrackExistingTowns takes nothing returns nothing
  local integer i = 0
  local integer first_free = 0
  loop
    exitwhen i >= town_num
    if TrackTown(i) then
      call CopyTown(i, first_free)
      set first_free = first_free + 1
    endif
    set i = i + 1
  endloop
  set town_num = first_free
endfunction

function SeedNewTownAtLoc takes location l, integer p returns nothing
  set town_owner[town_num] = p
  set town_loc[town_num] = l
  set town_threat[town_num] = 0
  set town_group[town_num] = CreateGroup()
  call TrackTown(town_num)
  set town_num = town_num + 1
endfunction

function SeedNewTownsForPlayer takes integer p returns nothing
  local group g = CreateGroup()
  local unit u = null
  local location l = null
  call GroupEnumUnitsOfPlayer(g, Player(p), null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitType(u, UNIT_TYPE_STRUCTURE) and UnitAlive(u) and not IsUnitInGroup(u, in_town_group) then
      call SeedNewTownAtLoc(GetUnitLoc(u), p)
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  set l = null
endfunction

function SeedNewTowns takes nothing returns nothing
  local integer p = 0
  loop
    exitwhen p >= GetBJMaxPlayers()
    if GetPlayerSlotState(Player(p)) == PLAYER_SLOT_STATE_PLAYING then
      call SeedNewTownsForPlayer(p)
    endif
    set p = p + 1
  endloop
endfunction

function TownTrackJob takes nothing returns nothing
  call DisplayToAllJobDebug("TOWN_TRACK Job Start")
  call GroupClear(in_town_group)
  call TrackExistingTowns()
  call SeedNewTowns()
  call TQAddJob(9, TOWN_TRACK, 0)
endfunction
function GetMilitiaHall takes unit u returns unit
  local group g = CreateGroup()
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and GetUnitAbilityLevel(u, race_militia_hall_ability) > 0 then
      call DestroyGroup(g)
      set g = null
      return u
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return u
endfunction

function IsMilitiaAllowed takes nothing returns boolean
  if use_militia_only_on_bigger_threats then
    if militia_allowed then
      return town_threat[most_threatened_town] > 0
    else
      return town_threat[most_threatened_town] > 7
    endif
  endif
  return true
endfunction

function MilitiaCheckJob takes nothing returns nothing
  local group g = null
  local unit u = null
  local integer i = 0
  local boolean big_dist = false
  local integer militiarequired = 0
  call DisplayToAllJobDebug("MILITIA_CHECK JOB START")
  if militia_hall == null or GetUnitState(militia_hall, UNIT_STATE_LIFE) <= 0 then
    set militia_hall = GetMilitiaHall(militia_hall)
  endif
  if race_militia_available and (militia_hall == null or towerrush) then
    call TQAddJob(30, MILITIA_CHECK, 0)
    return
  endif
  if militia_check_enabled and GetUnitState(militia_hall, UNIT_STATE_LIFE) > 0 then
    set militia_allowed = IsMilitiaAllowed()
    set g = CreateGroup()
    call GroupEnumUnitsOfType(g, race_militia_unitstring, null)
    set g = SelectByPlayer(g, ai_player, true)
    set g = SelectByAlive(g, true)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      if not militia_allowed or DistanceBetweenPoints_dk(GetUnitLoc(u), home_location) > race_militia_max_distance then
        call IssueImmediateOrder(u, "militiaoff")
      endif
      call GroupRemoveUnit(g,u)
    endloop
    set militiarequired = Max(1,GetLocationNonCreepStrength(GetUnitX(militia_hall), GetUnitY(militia_hall), 1500)/2) // Militia are 2 strength so divide total enemy strength by 2
    call GroupEnumUnitsOfType(g, race_militiaworker_unitstring, null)
    set g = SelectByPlayer(g, ai_player, true)
    set g = SelectByAlive(g, true)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      set big_dist = DistanceBetweenUnits(u, militia_hall) > 1500
      if militia_allowed and i>= 2 and i < militiarequired + 2 and not big_dist then
        if GetUnitAbilityLevel(u, race_militia_ability) <= 0 then
          call UnitAddAbility(u, race_militia_ability)
        endif
      elseif GetUnitAbilityLevel(u, race_militia_ability) > 0 then
        call UnitRemoveAbility(u, race_militia_ability)
      endif
      if not big_dist then
        set i = i + 1
      endif
      call GroupRemoveUnit(g,u)
    endloop
    call DestroyGroup(g)
    set g = null
  endif
  //if GetUnitAbilityLevel(militia_hall, race_militia_hall_ability) > 0 then
  if race_militia_available then
    call TQAddJob(5, MILITIA_CHECK, 0)
  endif
endfunction


function TowerRushBuilderControl takes unit u, location l returns nothing
    local real builder_x = 0
    local real builder_y = 0
    local integer buildrange = 1100
	local integer randomnum = GetRandomInt(1,4)
	local unit loccheck = null
	local location unitloc = null
	local location t = null
	
	if towers_built < 3 then
		set t = GetProjectedLoc(tower_target_loc, GetSubtractionLoc(tower_target_loc, toweringplayerloc), 600)	
	elseif towers_built < 6 then
		set t = GetProjectedLoc(tower_target_loc, GetSubtractionLoc(tower_target_loc, toweringplayerloc), 350)	
	elseif towers_built <= 9 then
		set t = Location(GetLocationX(tower_target_loc), GetLocationY(tower_target_loc))	
	endif
	
	if first_tower_point_x == 0 and first_tower_point_y == 0 then
		set first_tower_point_x = GetLocationX(t)
		set first_tower_point_y = GetLocationY(t)
		set enemy_point_x = GetLocationX(tower_target_loc)
		set enemy_point_y = GetLocationY(tower_target_loc)		
	endif
	
	if DistanceBetweenPoints(l, tower_target_loc) > buildrange and GetUnitCurrentOrder(u) != OrderId("move") then
		call CreateDebugTag("TRush: builder moving", 10, u, 4.00, 2.00)
		call IssuePointOrderLoc(u, "move", t)
	elseif towers_built == 0 and DistanceBetweenPoints(l, tower_target_loc) <= buildrange and GetUnitCurrentOrder(u) != OrderId("smart") and GetUnitCurrentOrder(u) != OrderId("repair") then
		if not IsTerrainPathable(GetLocationX(l), GetLocationY(l), PATHING_TYPE_BUILDABILITY) then
			call IssueImmediateOrder(u, "stop")
			call CreateDebugTag("TRush: First Building", 10, u, 4.00, 2.00)
			set loccheck = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), old_id[race_tower_id], first_tower_point_x, first_tower_point_y, 270.0)
			set unitloc = GetUnitLoc(loccheck)
			//set first_tower_point_x = GetLocationX(unitloc)
			//set first_tower_point_y = GetLocationY(unitloc)
			call RemoveUnit(loccheck)
			set loccheck = null
			call RemoveLocation(unitloc)
			set unitloc = null
			if GetGold() < GetUnitGoldCost2(race_tower_id) or GetWood() < GetUnitWoodCost2(race_tower_id) then
			//set gold_buffer = GetUnitGoldCost2(towerid)
			//set wood_buffer = GetUnitWoodCost2(towerid)
			else
			//set gold_buffer = 0
			//set wood_buffer = 0
				set towers_built = 1
				call IssueBuildOrderById(u, old_id[race_tower_id], first_tower_point_x, first_tower_point_y)
			endif
		else
			call CreateDebugTag("TRush: Not Buildable location", 10, u, 4.00, 2.00)
			call IssuePointOrderLoc(u, "move", t)
		endif
	elseif DistanceBetweenPoints(l, tower_target_loc) <= buildrange and GetUnitCurrentOrder(u) != OrderId("smart") and GetUnitCurrentOrder(u) != OrderId("repair") then
		if towers_built < 3 or (towers_built < 6 and GetGold() >= GetUnitGoldCost(race_tower_id) and GetWood() >= GetUnitWoodCost(race_tower_id)) or (towers_built <= 9 and GetGold() >= GetUnitGoldCost(race_tower_id)*2 and GetWood() >= GetUnitWoodCost(race_tower_id)*2) then
			set builder_x = GetLocationX(t)
			set builder_y = GetLocationY(t)				
			//set builder_x = ((enemy_point_x - first_tower_point_x) / 6) + first_tower_point_x
			//set builder_y = ((enemy_point_y - first_tower_point_y) / 6) + first_tower_point_y	
		//else
			//set builder_x = ((enemy_point_x - GetLocationX(loc1)) / 6) + GetLocationX(loc1) 
			//set builder_y = ((enemy_point_x - GetLocationX(loc1)) / 6) + GetLocationY(loc1)
			//set builder_x = GetLocationX(l) - GetRandomInt(100,300)
			//set builder_y = GetLocationY(l) - GetRandomInt(100,300)				
		//endif
			set loccheck = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), old_id[race_tower_id], builder_x, builder_y, 270.0)
			set unitloc = GetUnitLoc(loccheck)
			set builder_x = GetLocationX(unitloc)
			set builder_y = GetLocationY(unitloc)
			call RemoveUnit(loccheck)
			set loccheck = null
			call RemoveLocation(unitloc)
			set unitloc = null
			if not IsTerrainPathable(builder_x, builder_y, PATHING_TYPE_BUILDABILITY) then
				call CreateDebugTag("TRush: Building", 10, u, 4.00, 2.00)
				if GetGold() < GetUnitGoldCost2(race_tower_id) or GetWood() < GetUnitWoodCost2(race_tower_id) then
					//set gold_buffer = GetUnitGoldCost2(towerid)
					//set wood_buffer = GetUnitWoodCost2(towerid)
				else
					//set gold_buffer = 0
					//set wood_buffer = 0
					call IssueBuildOrderById(u, old_id[race_tower_id], builder_x, builder_y)
				endif
			else
				call CreateDebugTag("TRush: Not Buildable location", 10, u, 4.00, 2.00)
				call IssuePointOrderLoc(u, "move", t)
			endif
		endif
	else
	endif
	
			call RemoveLocation(t)
			set t = null	
endfunction

function TowerRushJob takes nothing returns nothing
    local group g = CreateGroup()
    local unit u = null
    local integer requirement = race_towerrush_requirement
    local integer towerid = race_tower_id
    local integer upgradeid = race_tower_upgrade
    local integer buildtries = 9
    local real time_next_try = 0
    local location loc1 = null
    local location loc2 = null
    local location loc3 = null
    local integer i = 0
    local integer v = 0
	local integer randomnum

	
	  call DisplayToAllJobDebug("TOWER_RUSH Job START")
	
if upgradeid != 0 then
	call GroupEnumUnitsInRange(g, first_tower_point_x, first_tower_point_y, 1000, null)
	loop
    		set u = FirstOfGroup(g)
    		exitwhen u == null
    		if GetOwningPlayer(u) == ai_player and GetUnitTypeId(u) == old_id[towerid] and GetUnitState(u, UNIT_STATE_LIFE) > 0 then
                   call TQAddJob(5, TOWER_RUSH, 0)	
				if GetGold() < GetUnitGoldCost2(upgradeid) or GetWood() < GetUnitWoodCost2(upgradeid) then
					set gold_buffer = GetUnitGoldCost2(upgradeid)
      				set wood_buffer = GetUnitWoodCost2(upgradeid)
				else
		      		call IssueImmediateOrderById(u, old_id[upgradeid])
				endif
			  return
		else

		endif 	
		call GroupRemoveUnit(g, u)
	endloop
	

endif

    if GetPlayerSlotState(rushedplayer) != PLAYER_SLOT_STATE_PLAYING or GetPlayerUnitCount(rushedplayer,true) <= 0 or (towers_built == 0 and not (first_tower_point_x == 0 and first_tower_point_y == 0) and GetLocationNonCreepStrength(first_tower_point_x, first_tower_point_y, 1500) > GetOwnStrength() * 4) then    //or (builder[1] != null and (GetUnitState(builder[1], UNIT_STATE_LIFE) <= 0  and GetUnitState(builder[3], UNIT_STATE_LIFE) <= 0 and GetUnitState(builder[2], UNIT_STATE_LIFE) <= 0)) then
        call Trace("I have finished the tower rush")
        call RecycleGuardPosition(builder[1])
        call RecycleGuardPosition(builder[2])
        call RecycleGuardPosition(builder[3])
        set builder[1] = null
        set builder[2] = null
        set builder[3] = null
		set towers_built = 0
        set first_tower_point_x = 0
        set first_tower_point_y = 0
		call RemoveLocation(toweringplayerloc)
        set enemy_point_x = 0
        set enemy_point_y = 0
        call RemoveLocation(tower_target_loc)
		set towerrush = false
	    set gold_buffer = 0
		set wood_buffer = 0
		call SetCaptainHome(BOTH_CAPTAINS, GetLocationX(home_location), GetLocationY(home_location))
	  return
    endif

	if towers_built < 3 then
		set gold_buffer = GetUnitGoldCost2(towerid) * 2
		set wood_buffer = GetUnitWoodCost2(towerid) * 2
	elseif towers_built < 6 then
		set gold_buffer = GetUnitGoldCost2(towerid)
		set wood_buffer = GetUnitWoodCost2(towerid) 
	elseif towers_built <= 9 then
		set gold_buffer = 0
		set wood_buffer = 0
	endif
		
	call GroupEnumUnitsOfPlayer(g, ai_player, null)
	set g = SelectByAlive(g,true)
	set g = SelectById(g, old_id[racial_peon], true)
	set g = GetNearestSubGroupOfGroup(g, tower_target_loc, 3)

	if (builder[1] == null or GetUnitState(builder[1], UNIT_STATE_LIFE) <= 0) and GetUnitCountDone(old_id[racial_peon]) > 7 then
		set builder[1] = FirstOfGroup(g)
	endif
	call GroupRemoveUnit(g,builder[1])
	if (builder[2] == null or GetUnitState(builder[2], UNIT_STATE_LIFE) <= 0) and GetUnitCountDone(old_id[racial_peon]) > 7 then
		set builder[2] = FirstOfGroup(g)
	endif	
	call GroupRemoveUnit(g,builder[2])
	if (builder[3] == null or GetUnitState(builder[3], UNIT_STATE_LIFE) <= 0) and GetUnitCountDone(old_id[racial_peon]) > 7 then
		set builder[3] = FirstOfGroup(g)
	endif
	call GroupRemoveUnit(g,builder[3])
    
    if towers_built < buildtries then
	    if TownCountDone(requirement) <= 0 then 
			set time_next_try = 5
		else
	        call RemoveGuardPosition(builder[1])
	        call RemoveGuardPosition(builder[2])
	        call RemoveGuardPosition(builder[3])
	        set loc1 = GetUnitLoc(builder[1])
			set loc2 = GetUnitLoc(builder[2])
			set loc3 = GetUnitLoc(builder[3])

	        set time_next_try = 2

			call TowerRushBuilderControl(builder[1], loc1)
			call TowerRushBuilderControl(builder[2], loc2)
			call TowerRushBuilderControl(builder[3], loc3)
		endif
	endif

	set towers_built = 0
	call GroupEnumUnitsInRange(g, enemy_point_x, enemy_point_y, 3000, null)
	loop
    	set u = FirstOfGroup(g)
    	exitwhen u == null
		exitwhen towers_built == buildtries
    	if GetOwningPlayer(u) == ai_player and GetUnitTypeId(u) == old_id[towerid] then
    		set towers_built = towers_built + 1
			if GetUnitState(u, UNIT_STATE_LIFE) < GetUnitState(u, UNIT_STATE_MAX_LIFE) then
    			set randomnum = GetRandomInt(1,3)
				if GetUnitCurrentOrder(builder[randomnum]) != OrderId("repair") then
					call IssueTargetOrder(builder[randomnum], "repair", u)
				endif
			endif
		endif 	
		if upgradeid != 0 and GetUnitTypeId(u) == old_id[upgradeid] then
			set towers_built = towers_built + 1
		endif
		call GroupRemoveUnit(g, u)
	endloop
    
	call DestroyGroup(g)
	set g = null
	call RemoveLocation(loc1)
	call RemoveLocation(loc2)
	call RemoveLocation(loc3)
    set loc1 = null
    set loc2 = null
    set loc3 = null
    call TQAddJob(RMax(time_next_try,1), TOWER_RUSH, 0)
endfunction



function StartTowerRush takes integer delay returns nothing
  set toweringplayerloc = GetStartLocationLoc(GetPlayerStartLocation(rushedplayer))

  call Trace("Starting the tower rush")
  set towerrush = true
  call SetPeonsRepair(false)
  set towers_built = 0
  call DisplayToAllies(chat_towerrush)
  set tower_target_loc = GetLocationInDistanceFromLoc(toweringplayerloc,front_base_distance)

  call TQAddJob(delay , TOWER_RUSH, 0)

endfunction

function TowerRushCheck takes nothing returns nothing
local integer i = GetRandomInt(1,100)
  call DisplayToAllJobDebug("TOWER_RUSH_CHECK JOB START")

	if not towerrush then
	 if hero_rush_bonus[hero[1]] >= race_towerrush_hero_rush_level then
	//	if ai_time > 60 then     // 5 mins
	//		set towerrush = false
	//		//call Trace("Tower Rush - Out of Time")
	//	elseif GetNearestEnemyDistance() < 8000 then   // Total percentage to be choosen is 33%
	//		call StartTowerRush()
	//	elseif i <= 75 and GetNearestEnemyDistance() < 11000 then // Total percentage to be choosen is 25%
	//		call StartTowerRush()
	//	elseif i <= 50 and GetNearestEnemyDistance() < 14000 then // Total percentage to be choosen is 16%
	//		call StartTowerRush()
	//	elseif i <= 20 and GetNearestEnemyDistance() < 16000 then // Total percentage to be choosen is 7%
	//	endif
	  endif
	endif
endfunction


function SearchTree takes nothing returns nothing
local integer i = 2
loop
	exitwhen i > 3 or ancient_exp_unit != null
	set ancient_exp_unit = GetOneOfId(ancient_exp_unit, ai_player, old_id[racial_hall[i]])
	set i = i + 1
endloop
endfunction

function AncientExpansionJob takes nothing returns nothing
local unit u = null
local location exp_loc = null
local location wisp_loc = null
local unit temp = null 
local boolean isstrong = false
call DisplayToAllJobDebug("ANCIENT_EXPANSION JOB STARTED")

if current_expansion == null then
	//	set current_expansion = ExpNearestMin()
	call ChooseExpansion()
endif

if (ancient_exp_unit != null and GetUnitState(ancient_exp_unit, UNIT_STATE_LIFE) <= 0) or current_expansion == null then
	// Found out so no point trying ancient expansion again
	set ancient_exp_state = 0
	set ancient_exp_unit = null
	call SetCaptainHome(BOTH_CAPTAINS,GetLocationX(front_loc[0]),GetLocationY(front_loc[0]))
	call GroupRecycleGuardPositionInstant(CopyGroup(ancient_exp_group))
	set gold_buffer = 0
	set wood_buffer = 0
	set ancient_exp_nobuild = false
	return
endif
set exp_time_count = ai_time
set not_taken_expansion = current_expansion
set u = GetExpFoe(u)
if ancient_exp_state == 0 then
	//if current_expansion == null then
		//call TQAddJob(5, ANCIENT_EXPANSION, 0)
		//set u = null
		//return
	//endif
	call Trace("Expansion Distance: " + Int2Str(R2I(GetExpansionDistance())))
	call Trace("Expansion state 0: Get the Wisp and Location")
	set gold_buffer = GetUnitGoldCost2(racial_expansion)
	set wood_buffer = GetUnitWoodCost2(racial_expansion)
	set ancient_exp_count = 0

if GetGold() < GetUnitGoldCost2(racial_expansion) or GetWood() < GetUnitWoodCost2(racial_expansion) then
		if (race_manual_loading and TownCount(race_manual_loading_mine) == 0) or GetMinesOwned() == 0 then
			set ancient_exp_state = 1  // cannot build , need move tree
			call TQAddJob(5, ANCIENT_EXPANSION, 0)
			set u = null
			set ancient_exp_nobuild = true
			return
		endif
	else
		if ancient_exp_wisp == null or not UnitAlive(ancient_exp_wisp) then
			set ancient_exp_wisp = GetExpansionPeon()
			if ancient_exp_wisp == null then
				set ancient_exp_wisp = GetExpansionPeon2(ancient_exp_wisp)
			endif
		endif
		if u != null then
			//if ancient_exp_loc != null then
				//call RemoveGuardPosition(ancient_exp_wisp)
				//set exp_loc = GetUnitLoc(current_expansion)
				//call RemoveLocation(ancient_exp_loc)
				//set ancient_exp_loc = GetBuildLocationInDistanceFromLoc(old_id[racial_expansion], exp_loc, ver_creeps_attack_buildings_dist + 500)
				//call IssuePointOrderByIdLoc(ancient_exp_wisp, old_id[racial_expansion], ancient_exp_loc)
				//set ancient_exp_state = 1
				//call RemoveLocation(exp_loc)
				//set exp_loc = null
			//endif
			call CreateDebugTag("Expansion State 0 - wait attack creep", 10, ancient_exp_wisp, 3.00, 1.50)
		else
			call CreateDebugTag("Expansion State 0 - build racial_expansion", 10, ancient_exp_wisp, 3.00, 1.50)
			call RemoveGuardPosition(ancient_exp_wisp)
			//set exp_loc = GetUnitLoc(current_expansion)
			if ancient_exp_loc == null then
				set temp = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), old_id[racial_expansion], GetUnitX(current_expansion), GetUnitY(current_expansion), 270.0)
				set exp_loc = GetUnitLoc(temp)
				call RemoveUnit(temp)
				call IssuePointOrderByIdLoc(ancient_exp_wisp,old_id[racial_expansion], exp_loc)
				call RemoveLocation(exp_loc)
				set exp_loc = null
				set temp = null
			else
				call IssuePointOrderByIdLoc(ancient_exp_wisp,old_id[racial_expansion], ancient_exp_loc)
			endif
			set ancient_exp_state = 5
			//call RemoveLocation(exp_loc)
			//set exp_loc = null
		endif
	endif
	call TQAddJob(5, ANCIENT_EXPANSION, 0)

elseif ancient_exp_state == 1 then
	call CreateDebugTag("Expansion State 1 - Ordering wisp", 10, ancient_exp_wisp, 3.00, 1.50)
	set wisp_loc = GetUnitLoc(ancient_exp_wisp)
	if gold_buffer != 0 and DistanceBetweenPoints(wisp_loc, ancient_exp_loc) <= 400 then
		set gold_buffer = 0
		set wood_buffer = 0
	endif
	if wisp_loc != null then
		call RemoveLocation(wisp_loc)
		set wisp_loc = null
	 endif
	if GetUnitState(ancient_exp_wisp, UNIT_STATE_LIFE) > 0 and not ancient_exp_nobuild then
		call IssuePointOrderByIdLoc(ancient_exp_wisp, old_id[racial_expansion], ancient_exp_loc)
		call TQAddJob(5, ANCIENT_EXPANSION, 0)
	else
		set ancient_exp_unit = GetOneOfIdNearLoc(ancient_exp_unit, ai_player, old_id[racial_expansion], ancient_exp_loc, 400)
		if ancient_exp_unit == null and TownCount(race_manual_loading_mine) == 0 then  // no mine , check all hall
			set ancient_exp_unit = GetOneOfId(ancient_exp_unit, ai_player, old_id[racial_expansion])
			if ancient_exp_unit == null then
				call SearchTree()
			endif
		endif
		if ancient_exp_unit == null then
			set ancient_exp_state = 0
			set u = null
			set ancient_exp_nobuild = false
		else
			if GetLocationNonCreepStrength(GetUnitX(ancient_exp_unit), GetUnitY(ancient_exp_unit), 1500) <= 0 then
				set ancient_exp_state = 2
				call RemoveGuardPosition(ancient_exp_unit)
				call IssueImmediateOrderById(ancient_exp_unit, OrderIdCancel)
				call IssueImmediateOrder(ancient_exp_unit, "unroot")
			endif
			//set no_attack_allowed = true
		endif
		call TQAddJob(1, ANCIENT_EXPANSION, 0)
	endif
elseif ancient_exp_state == 2 then
	call CreateDebugTag("Expansion State 2: Uproot Tree", 10, ancient_exp_unit, 3.00, 1.50)
	call IssueImmediateOrderById(ancient_exp_unit, OrderIdCancel)
	call IssueImmediateOrder(ancient_exp_unit, "unroot")
	if hero_built[1] then
		set ancient_exp_state = 3
		//call RemoveGuardPosition(hero_unit[1])
		//call IssuePointOrder(hero_unit[1], "move", GetUnitX(ancient_exp_unit), GetUnitY(ancient_exp_unit))
		//call GroupClear(ancient_exp_group)
		//call GroupEnumUnitsOfPlayer(ancient_exp_group, ai_player, null)
		//set ancient_exp_group = SelectByAlive(ancient_exp_group, true)
		//set ancient_exp_group = SelectUnittype(ancient_exp_group, UNIT_TYPE_STRUCTURE, false)
		//set ancient_exp_group = SelectUnittype(ancient_exp_group, UNIT_TYPE_PEON, false)
		//set ancient_exp_group = SelectByUnitStandard(ancient_exp_group, true)
		//call GroupRemoveGuardPositionInstant(ancient_exp_group)
		//call GroupPointOrder(ancient_exp_group, "smart", GetUnitX(ancient_exp_unit), GetUnitY(ancient_exp_unit))
	endif
	call TQAddJob(3, ANCIENT_EXPANSION, 0)
elseif ancient_exp_state == 3 then
	call CreateDebugTag("Expansion State 3: Awaiting Hero", 10, ancient_exp_unit, 3.00, 1.50)
	set isstrong = GetOwnStrength() > GetExpansionStrength()
	call SetCaptainHome(BOTH_CAPTAINS,R2I(GetUnitX(ancient_exp_unit)),R2I(GetUnitY(ancient_exp_unit)))
	if DistanceBetweenUnits(ancient_exp_unit, hero_unit[1]) <= 750 or u == null or isstrong then
		if ancient_exp_count > 0 then
			call GroupClear(ancient_exp_group)
			call GroupEnumUnitsInRange(ancient_exp_group, GetUnitX(ancient_exp_unit), GetUnitY(ancient_exp_unit), 1000, null)
			set ancient_exp_group = SelectByPlayer(ancient_exp_group, ai_player, true)
			set ancient_exp_group = SelectByAlive(ancient_exp_group, true)
			set ancient_exp_group = SelectUnittype(ancient_exp_group, UNIT_TYPE_STRUCTURE, false)
			set ancient_exp_group = SelectUnittype(ancient_exp_group, UNIT_TYPE_PEON, false)
			set ancient_exp_group = SelectByUnitStandard(ancient_exp_group, true)
			if not isstrong then
				call GroupAddUnit(ancient_exp_group, ancient_exp_unit)
				call IssueTargetOrder(ancient_exp_unit, "move", current_expansion)
			endif
			////call GroupAddTypeAndRemoveGuard(ancient_exp_group, race_ancient_expansion_help_id, ai_player)
			//call GroupPointOrder(ancient_exp_group, "smart", GetUnitX(u), GetUnitY(u))
			set ancient_exp_state = 4
		else
			set ancient_exp_count = ancient_exp_count + 1
		endif
	else
		if ancient_exp_count > 0 then
			set ancient_exp_count = ancient_exp_count - 1
		endif
		//call GroupEnumUnitsOfPlayer(ancient_exp_group, ai_player, null)
		//set ancient_exp_group = SelectByAlive(ancient_exp_group, true)
		//set ancient_exp_group = SelectUnittype(ancient_exp_group, UNIT_TYPE_STRUCTURE, false)
		//set ancient_exp_group = SelectUnittype(ancient_exp_group, UNIT_TYPE_PEON, false)
		//set ancient_exp_group = SelectByUnitStandard(ancient_exp_group, true)
		//call GroupRemoveGuardPositionInstant(ancient_exp_group)
		//call GroupPointOrder(ancient_exp_group, "smart", GetUnitX(ancient_exp_unit), GetUnitY(ancient_exp_unit))
	endif
	call TQAddJob(5, ANCIENT_EXPANSION, 0)
elseif ancient_exp_state == 4 then
	call CreateDebugTag("Expansion State 4: Attacking and taking expansion", 10, ancient_exp_unit, 3.00, 1.50)
	call SetCaptainHome(BOTH_CAPTAINS,R2I(GetUnitX(ancient_exp_unit)),R2I(GetUnitY(ancient_exp_unit))) 
	if u == null then
		call GroupRemoveUnit(ancient_exp_group, ancient_exp_unit)
		call IssueTargetOrder(ancient_exp_unit, "entangle", current_expansion)
		call TQAddUnitJob(R2I(GetTimeToReachUnit(ancient_exp_unit, current_expansion)*2 + 5), RESET_GUARD_POSITION, 0, ancient_exp_unit)
		call GroupRecycleGuardPositionInstant(CopyGroup(ancient_exp_group))
		//call RemoveLocation(ancient_exp_loc)
		set ancient_exp_state = 0
		//set no_attack_allowed = false
		set not_taken_expansion = null
		set ancient_expanding = false
		set ancient_attack_running = false
		set ancient_exp_nobuild = false
		call SetCaptainHome(BOTH_CAPTAINS,GetLocationX(front_loc[0]),GetLocationY(front_loc[0]))
		return
	else
		//call GroupAddTypeAndRemoveGuard(ancient_exp_group, race_ancient_expansion_help_id, ai_player)
		if GetUnitState(ancient_exp_unit, UNIT_STATE_LIFE) <= GetUnitState(ancient_exp_unit, UNIT_STATE_MAX_LIFE) * 0.40 then
			call IssueImmediateOrderById(ancient_exp_unit, OrderId("eattree"))
		elseif ancient_attack_running then
			if DistanceBetweenUnits(ancient_exp_unit, u) <= 750 then
				call GroupTargetOrder(ancient_exp_group, "attack", u)
			else
				call GroupPointOrder(ancient_exp_group, "attack", GetUnitX(u), GetUnitY(u))
			endif
		endif
		call TQAddJob(2, ANCIENT_EXPANSION, 0)
	endif
elseif ancient_exp_state == 5 then
	call CreateDebugTag("Expansion State 5: Fast Expand as camp clear", 10, ancient_exp_wisp, 3.00, 1.50)
	if GetUnitState(ancient_exp_wisp, UNIT_STATE_LIFE) > 0 and CheckExpansionTaken(current_expansion) == false then
		if GetUnitCurrentOrder(ancient_exp_wisp) != old_id[racial_expansion] then
			call IssuePointOrderByIdLoc(ancient_exp_wisp, old_id[racial_expansion], ancient_exp_loc)
		endif
		call TQAddJob(5, ANCIENT_EXPANSION, 0)
	else
		set gold_buffer = 0
		set wood_buffer = 0
		//call RemoveLocation(ancient_exp_loc)
		set ancient_exp_state = 0
		//set no_attack_allowed = false
		set not_taken_expansion = null
		set ancient_expanding = false
	endif
endif
set u = null
endfunction


function AncientExpansionCheck takes nothing returns nothing
	local unit u = null
	call DisplayToAllJobDebug("ANCIENT_EXPANSION_CHECK JOB START")
	if not ancient_expanding then
		if current_expansion != null then
			set u = GetExpFoe(u)
			call Trace("expansion free")
			if GetExpansionStrength() < race_ancient_expansion_strength and u != null and hero_rush_bonus[hero[1]] >= race_ancient_expansion_hero_rush_level then
				call Trace("Acient expansion - Begin Job")
				set ancient_expanding = true
				call TQAddJob(1, ANCIENT_EXPANSION, 0)
				set u = null
				return
			elseif hero_rush_bonus[hero[1]] < race_ancient_expansion_hero_rush_level then
				call Trace("Ancient Expansion not possible with hero")
				set u = null
				return
			endif
			set u = null
		else
			call Trace("Ancient expansion - No expansion available")
		endif
	endif
	call TQAddJob(50, ANCIENT_EXPANSION_CHECK, 0)
endfunction

function ChatVarsJob takes nothing returns nothing
  call DisplayToAllJobDebug("CHAT_VARS JOB START")
  call SetChatVarR("Time", TimerGetElapsed(tq_timer))
  call SetChatVar("RandomRace", race_name[GetRandomInt(1,RACE_NUMBER)])
  call SetChatVar("OwnGold", Int2Str(GetGold()))
  call SetChatVarR("OwnGold", GetGold())
  call SetChatVar("OwnLumber", Int2Str(GetWood()))
  call SetChatVarR("OwnLumber", GetWood())
  call SetChatVarR("Strength", GetOwnStrength())
  call TQAddJob(6, CHAT_VARS, 0)
endfunction

function SelectByZiggurat takes group rg returns group
  local unit u = null
  local integer i = 0
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set i = 0
    loop
      exitwhen i > ziggarray
      if GetUnitTypeId(u) == racial_zigg[i] then
        call GroupAddUnit(rg, u )
      endif
      set i = i + 1
    endloop
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function CheckSellZiggurat takes unit u returns nothing
  local group g = CreateGroup()
  call GroupEnumUnitsInRange(g, GetUnitX(u), GetUnitY(u), race_ziggurat_keep_distance, null)
  set g = SelectByPlayer(g, ai_player, true)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  if (BlzGroupGetSize(g) <= 1) then
    call Unsummon(u)
  endif
  call DestroyGroup(g)
  set g = null
endfunction

function SellZigguratJob takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  local integer i = 0

  call DisplayToAllJobDebug("SELL_ZIGGURATS JOB START")
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectByZiggurat(g)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call CheckSellZiggurat(u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  call TQAddJob(30, SELL_ZIGGURATS, 0)
endfunction

function AngleBetweenPoints takes location locA, location locB returns real
  return bj_RADTODEG * Atan2(GetLocationY(locB) - GetLocationY(locA), GetLocationX(locB) - GetLocationX(locA))
endfunction

function IsUnitFacingUnit takes unit u, unit target returns boolean
  local location unitloc = GetUnitLoc(u)
  local location targetloc = GetUnitLoc(target)
  local real angle = AngleBetweenPoints(unitloc, targetloc)
  local real unitfacing = GetUnitFacing(u)
  local boolean isFacing = false
  if (unitfacing - 25 >= angle or unitfacing + 25 <= angle) then //or (IsUnitType(u, UNIT_TYPE_MELEE_ATTACKER) and DistanceBetweenUnits(u, target) > 128) then
    set isFacing = true
  endif
  call RemoveLocation(unitloc)
  call RemoveLocation(targetloc)
  set unitloc = null
  set targetloc = null
  return isFacing
endfunction

function GroupMicroSystem takes group g, group meleeg, group focus_group returns nothing
  local unit u = null
  local location unitloc = null
  local location l = null
  local unit melee = null
  local group copy = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set unitloc = GetUnitLoc(u)
    set copy = CopyGroup(meleeg)
    set melee = GetNearestOfGroup(melee, copy, unitloc)
    if melee != null and not IsUnitInGroup(u, focus_fire_group) and IsUnitFacingUnit(melee, u) and DistanceBetweenUnits(u, melee) < 150 and GetUnitMoveSpeed(melee) <= GetUnitMoveSpeed(u) and (not IsUnitType(u, UNIT_TYPE_FLYING) or (IsUnitType(u, UNIT_TYPE_FLYING) and IsUnitType(melee, UNIT_TYPE_ATTACKS_FLYING))) then // 220 is the smallest ranged unit in warcraft 3.
      set l = GetSubtractionLoc_kd(unitloc, GetUnitLoc(melee))
      set l = GetProjectedLoc_dd(unitloc, l, 400)
      call RemoveGuardPosition(u)
      call CreateDebugTagLoc("FF: MICRO LOC", 10, GetLocationX(l), GetLocationY(l), 3.00, 1.50)  
      call IssuePointOrderLoc(u, "move", l)
      call TQAddUnitJob(1, RESET_GUARD_POSITION_ONLY, 80, u)
      call GroupRemoveUnit(focus_group, u) // prevent focus fire controls interrupting
      call RemoveLocation(l)
    else
      call RemoveLocation(unitloc)
    endif
    call DestroyGroup(copy)
    call GroupRemoveUnit(g, u)
  endloop
  set copy = null
set melee = null
  set unitloc = null
  set l = null
endfunction

function GroupOrderFocusWindInstant_d takes group g returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if (GetUnitAbilityLevel(u, 'AOwk') > 0 or GetUnitAbilityLevel(u, 'ANwk') > 0) then
      //call CreateDebugTag("HARASS: WINDWALK COMMANDED", 10, u, 3.00, 1.50)
      if not IsUnitInGroup(u, windwalk_group) then
        call GroupAddUnit(windwalk_group, u)
      endif
      if not UnitInvis(u) then
        call CreateDebugTag("FF: windwalk", 10, u, 1.00, 0.80)
        call IssueImmediateOrder(u, "windwalk")
        call TQAddUnitJob(8, RESET_WINDWALKER, 0, u)
      endif
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
endfunction

function GroupOrderAttack_d takes group g, unit target returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call RemoveGuardPosition(u)
    if UnitInvis(u) then
      call IssueTargetOrder(u, "attack", target)
    endif
    call RecycleGuardPosition(u)
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
endfunction

function FocusGroupRemoveGuard takes group g returns nothing
  local unit u = null
  local group ug = CopyGroup(g)

  loop
    set u = FirstOfGroup(ug)
    exitwhen u == null
    if not IsUnitInGroup(u, focus_fire_group) then
      call CreateDebugTag("FF", 10, u, 1.00, 0.80)
      //call RemoveGuardPosition(u)
      //call TQAddUnitJob(1.5, RESET_GUARD_POSITION_ONLY, 80, u)
    endif
    call GroupRemoveUnit(ug,u)
  endloop
  call DestroyGroup(ug)
  set ug = null
endfunction

function FilterFocusFireGroupIfFacing takes group g, unit target returns nothing
  local unit u = null
  local group ug = CopyGroup(g)
  
  loop
    set u = FirstOfGroup(ug)
    exitwhen u == null
    if IsUnitFacingUnit(u, target) then
      call GroupRemoveUnit(focus_fire_group,u)
    endif
    call GroupRemoveUnit(ug,u)
  endloop
  call DestroyGroup(ug)
  set ug = null
endfunction

function FocusFire takes unit u returns nothing
  local group t = CreateGroup()
  local group temp_focus = CreateGroup()
  
  call GroupEnumUnitsInRange(t, GetUnitX(u), GetUnitY(u), focus_fire_ranged_dist, null)
  set t = SelectUnittype(t, UNIT_TYPE_RANGED_ATTACKER, true)
  set temp_focus = GroupAddGroup(temp_focus, t)
  call GroupClear(t)
  // call DestroyGroup(t)
  // set t = CreateGroup()
  call GroupEnumUnitsInRange(t, GetUnitX(u), GetUnitY(u), focus_fire_melee_dist, null)
  set t = SelectUnittype(t, UNIT_TYPE_MELEE_ATTACKER, true)
  set temp_focus = GroupAddGroup(temp_focus, t)
  call GroupClear(t)
  // call DestroyGroup(t)
  // set t = CreateGroup()
  call GroupEnumUnitsInRange(t, GetUnitX(u), GetUnitY(u), normal_battle_radius, null)
  set t = SelectByInvisible(t, GetOwningPlayer(u), true)
  set temp_focus = GroupAddGroup(temp_focus, t)
  call DestroyGroup(t)
  set t = null
  set temp_focus = SelectByPlayer(temp_focus, ai_player, true)
  if IsUnitType(u, UNIT_TYPE_FLYING) == true then
    set temp_focus = SelectUnittype(temp_focus, UNIT_TYPE_ATTACKS_FLYING, true)
  endif
  set temp_focus = SelectUnittype(temp_focus, UNIT_TYPE_PEON, false)
  set temp_focus = SelectByAlive(temp_focus, true)
  set temp_focus = SelectByUnitStandard(temp_focus, true)
  //set temp_focus = SelectByOrderOr2(focus_fire_group,OrderId("move"),OrderId("attack"),OrderId("stop"), true)
  set temp_focus = SelectByOrder(temp_focus, OrderId("blizzard"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("flamestrike"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("massteleport"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("earthquake"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("voodoo"), false)	
  set temp_focus = SelectByOrder(temp_focus, OrderId("deathanddecay"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("starfall"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("tranquility"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("clusterrockets"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("tornado"), false)
  set temp_focus = SelectByOrder(temp_focus, OrderId("volcano"), false)
  call BlzGroupRemoveGroupFast(focus_fire_group, temp_focus) // Remove units that have already focus fired this iteration (intentionally wrong way round)
  if FirstOfGroup(micro_enemymelee_group) != null then
    call GroupMicroSystem(micro_ranged_group, micro_enemymelee_group, temp_focus)   // Move ranged units away from melee units, if moved here they will not focus fire
  endif
  call DestroyGroup(t)
  if BlzGroupGetSize(temp_focus) > 0 then
    if focus_fire_unit == null or focus_fire_unit != u then
      if IsUnitType(u,UNIT_TYPE_STRUCTURE) == false and not IsUnitOwnedByPlayer(u, Player(PLAYER_NEUTRAL_AGGRESSIVE)) then // Dont windwalk for non-critical enemies
        call GroupOrderFocusWindInstant_d(CopyGroup(temp_focus))
      endif
      set focus_fire_unit = u
    endif
    call CreateDebugTag("FF: here:" + Int2Str(BlzGroupGetSize(temp_focus)), 10, u, 1.00, 0.80)
    call FocusGroupRemoveGuard(temp_focus)
    call GroupTargetOrder(temp_focus, "attack", u)
    call GroupOrderAttack_d(CopyGroup(windwalk_group), u) // Forces Windwalking invisible units to attack directly as normal group order is ignored
    set focus_fire_group = GroupAddGroup(focus_fire_group, temp_focus) // Finally add units to group to say they have focus fired
  endif
  set t = null
  call DestroyGroup(temp_focus)
  set temp_focus = null
endfunction

function FocusEnemyUnitsNearGroup takes group g returns nothing
  local unit u = null
  local real hero_min_health = 100000
  local unit hero_min_health_unit = null
  local real min_health = 100000
  local unit min_health_unit = null
  local real building_min_health = 100000
  local unit building_min_health_unit = null
  local real disabled_min_health = 100000
  local unit disabled_min_health_unit = null
  local real range_strength = 0
  local integer enemy_count = 0
  local real unit_life = 0
  local real x = 0
  local real y = 0
  call GroupClear(micro_ranged_group)
  call GroupClear(micro_enemymelee_group)
  call MoveLocation(enemy_melee_loc, 0,0)
  if town_threatened then
    set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_AGGRESSIVE), false)
  endif
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set unit_life = GetUnitState(u, UNIT_STATE_LIFE)
    if unit_life > 0 and not IsUnitHidden(u) then
      if IsPlayerEnemy(GetOwningPlayer(u), ai_player) and not (UnitInvis(u) and not IsUnitDetected(u, ai_player)) and IsUnitVisible(u, ai_player) then
        if IsUnitType(u, UNIT_TYPE_MELEE_ATTACKER) == true then
          set x = x + GetUnitX(u)  // Prevent loc exceeding map range
          set y = y + GetUnitY(u)
          //set enemy_melee_loc = GetSumLoc_dd(enemy_melee_loc, GetUnitLoc(u))
          set enemy_count = enemy_count + 1
          call GroupAddUnit(micro_enemymelee_group, u)
        endif
        if IsUnitType(u, UNIT_TYPE_HERO) then
          if unit_life < hero_min_health then
            set hero_min_health = unit_life
            set hero_min_health_unit = u
          endif
        else
          if unit_life < min_health and not UnitIsSleeping(u) and (unit_life < GetUnitState(u, UNIT_STATE_MAX_LIFE) or IsUnitType(u, UNIT_TYPE_MELEE_ATTACKER) or IsUnitType(u, UNIT_TYPE_RANGED_ATTACKER) or IsUnitType(u, UNIT_TYPE_TOWNHALL)) then
            set min_health = unit_life
            set min_health_unit = u
          endif
          if unit_life < disabled_min_health and GetUnitMoveSpeed(u) == 0 and not IsUnitType(u, UNIT_TYPE_STRUCTURE) and not UnitIsSleeping(u) then
            set disabled_min_health = unit_life
            set disabled_min_health_unit = u
          endif
          if unit_life < building_min_health and IsUnitType(u, UNIT_TYPE_STRUCTURE) then
            set building_min_health = unit_life
            set building_min_health_unit = u
          endif
        endif
      elseif IsPlayerAlly(GetOwningPlayer(u), ai_player) then
        if IsUnitType(u, UNIT_TYPE_RANGED_ATTACKER) then
          set range_strength = range_strength + GetUnitStrength(u)
          if unit_life < GetUnitState(u, UNIT_STATE_MAX_LIFE)*0.70 then 
            call GroupAddUnit(micro_ranged_group, u) // Only add to micro orders if damaged
          endif
        endif
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  if enemy_count != 0 then
    set x = x / I2R(enemy_count)
    set y = y / I2R(enemy_count)
    call RemoveLocation(enemy_melee_loc)
    set enemy_melee_loc = Location(x, y)
    //set enemy_melee_loc = GetDivisionLoc_d(enemy_melee_loc, I2R(enemy_count))
  endif
  if hero_min_health_unit != null and (hero_min_health < focus_fire_limit * range_strength or disabled_min_health_unit == hero_min_health_unit) then
    call SetTargetHeroes(true)
    call FocusFire(hero_min_health_unit)
  else
    call SetTargetHeroes(false)
    if disabled_min_health_unit != null then
      if min_health_unit != null then
        if min_health * 3 < disabled_min_health then
          call FocusFire(min_health_unit)
        else
          call FocusFire(disabled_min_health_unit)
        endif
      else
        call FocusFire(disabled_min_health_unit)
      endif
    elseif min_health_unit != null then
      call FocusFire(min_health_unit)
    elseif building_min_health_unit != null then
      call FocusFire(building_min_health_unit)
    endif
  endif
  set u = null
  set hero_min_health_unit = null
  set min_health_unit = null
  set building_min_health_unit = null
  set disabled_min_health_unit = null
endfunction

function FocusFireJob takes nothing returns nothing
  local group g = CreateGroup()
  local integer i = 0

  call DisplayToAllJobDebug("FOCUSFIRE_CONTROL JOB START")

  if major_hero == null or not UnitAlive(major_hero) or IsUnitInGroup(major_hero, unit_healing) then
    set major_hero = GetMajorHeroReplacement_k(major_hero,last_major_hero_loc)
  endif
 //if retreat_controlled and (attack_running or town_threatened) then
 
   call GroupClear(focus_fire_group)
 
  if not CaptainRetreating() and (attack_running or town_threatened) then
    if (major_hero != null) then 
      call MoveLocation(last_major_hero_loc, GetUnitX(major_hero), GetUnitY(major_hero))
      call GroupEnumUnitsInRange(g,GetUnitX(major_hero),GetUnitY(major_hero),battle_radius,null)
      call FocusEnemyUnitsNearGroup(g)
    endif
    if (main_army >= 0 and army_loc[main_army] != null) then
      call GroupEnumUnitsInRange(g, GetLocationX(army_loc[main_army]), GetLocationY(army_loc[main_army]), battle_radius, null)
      call FocusEnemyUnitsNearGroup(g)
    endif
    loop
      exitwhen i >= army_num
      if (army_loc[i] != null and Player(army_owner[i]) == ai_player and main_army != i) then
        call GroupEnumUnitsInRange(g, GetLocationX(army_loc[i]), GetLocationY(army_loc[i]), battle_radius, null)
        call FocusEnemyUnitsNearGroup(g)
      endif
      set i = i + 1
    endloop
  //else
    //call GroupRecycleGuardPositionInstant(windwalk_group)
    //loop
    //	set u = FirstOfGroup(windwalk_group)
    //	exitwhen u == null
    //	call GroupRemoveUnit(windwalk_group, u)
    //	if not IsUnitInGroup(u, unit_healing) and not IsUnitInGroup(u, unit_harassing) then
    //		call RecycleGuardPosition(u)
    //	endif
    //endloop
  endif
  call SetTargetHeroes(difficulty != EASY)
  call DestroyGroup(g)
  set g = null 
  call TQAddJob(2 * sleep_multiplier, FOCUSFIRE_CONTROL, 0)
endfunction


function GetMoonWell takes unit u, player p, integer id returns unit
  local group g = CreateGroup()
  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == id and GetUnitState(u, UNIT_STATE_MANA) >= 30 then
      call DestroyGroup(g)
      set g = null
      return u
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  return u

endfunction

function HeadtoMoonWell takes unit u, integer p returns nothing
    local real dist = 0
    local real enemystrength = 0
    set dist = DistanceBetweenUnits(u, nearest_moon_well)
    set enemystrength = GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 800)
    if dist >= 1000 and enemystrength > 0 and ((GetUnitState(u, UNIT_STATE_MANA) > 50 and GetUnitAbilityLevel(u, 'AEbl') >= 1) or (GetUnitState(u, UNIT_STATE_MANA) > 10 and GetUnitAbilityLevel(u, 'AEbl') > 1)) then
        call IssuePointOrder(u, "blink", GetUnitX(nearest_moon_well), GetUnitY(nearest_moon_well))
        call IssuePointOrder(u, "smart", GetUnitX(nearest_moon_well), GetUnitY(nearest_moon_well))
    elseif dist >= 1000 and GetUnitAbilityLevel(u, 'Ashm') > 0 and enemystrength > 0 and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) < 6) and not IsUnitType(u, UNIT_TYPE_HERO) then
        call IssueImmediateOrder(u, "ambush")
    else
      call IssuePointOrder(u, "smart", GetUnitX(nearest_moon_well), GetUnitY(nearest_moon_well))
    endif
    call TQAddUnitJob(4, MOON_WELL_CONTROL, p, u)
endfunction

function MoonWellJob takes unit u, integer p returns nothing
  local real dist = 0
  local real enemystrength = 0

  call DisplayToAllJobDebug("MOON_WELL_CONTROL JOB START")
  if GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
    call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)
    return
  elseif GetUnitState(u, UNIT_STATE_LIFE) >= GetUnitState(u, UNIT_STATE_MAX_LIFE) * (I2R(p)/100) or IsUnitType(u, UNIT_TYPE_SUMMONED) then
    call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)
    return
  elseif nearest_moon_well == null or GetUnitState(nearest_moon_well, UNIT_STATE_MANA) < 30 then
    set nearest_moon_well = GetMoonWell(nearest_moon_well, ai_player, old_id[racial_farm])
    if nearest_moon_well == null then
        set dist = DistanceBetweenPoints_dk(GetUnitLoc(u), home_location)
        set enemystrength = GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 800)
        if dist >= 1000 and enemystrength > 0 and ((GetUnitState(u, UNIT_STATE_MANA) > 50 and GetUnitAbilityLevel(u, 'AEbl') == 1) or (GetUnitState(u, UNIT_STATE_MANA) > 10 and GetUnitAbilityLevel(u, 'AEbl') > 1)) then
            call IssuePointOrder(u, "blink", GetLocationX(home_location), GetLocationY(home_location))
            call IssuePointOrder(u, "move", GetLocationX(home_location), GetLocationY(home_location))
            call TQAddUnitJob(2, SEND_HOME, 0, u)  // 0 is home_location
        elseif dist >= 1000 and enemystrength > 0 and GetUnitAbilityLevel(u, 'Ashm') > 0 and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) < 6) and not IsUnitType(u, UNIT_TYPE_HERO) then
            call IssueImmediateOrder(u, "ambush")
            call TQAddUnitJob(4, MOON_WELL_CONTROL, p, u)
        elseif dist >= 1000 then
            call IssuePointOrder(u, "move", GetLocationX(home_location), GetLocationY(home_location))
            call TQAddUnitJob(4, MOON_WELL_CONTROL, p, u)
        elseif IsUnitType(u,UNIT_TYPE_HERO)==true then
          call TQAddUnitJob(2, SEND_HOME, 0, u)  // 0 is home_location
        else
          call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)
        endif
    else
      call HeadtoMoonWell(u, p)
    endif
  else
    call HeadtoMoonWell(u, p)
  endif

endfunction

function GetFastBuildPeasantNumber takes nothing returns integer
  local integer minres = Min(GetGold(),GetWood())
  if minres < 40 or GetMinesOwned() == 0 then
    //call Trace("0 fast build peasants")
    return 0
  elseif minres < 250 then  
    //call Trace("1 fast build peasant")
    return 1
  elseif minres < 350 then
    //call Trace("2 fast build peasants")
    return 2
  elseif minres < 450 then
    //call Trace("3 fast build peasants")
    return 3
  else
    //call Trace("4 fast build peasants")
    return 4
  endif
endfunction

function GetBuildingBuilt takes unit u returns unit
  local group g = CreateGroup()
  if expansion_changed then
    call GroupEnumUnitsInRange(g, last_expansion_x, last_expansion_y, 1000, null)
  else
    call GroupEnumUnitsInRange(g, next_expansion_x, next_expansion_y, 1000, null)	 
  endif
  set g = SelectByPlayer(g, ai_player, true)
  set g = SelectByHidden(g, false)
  set g = SelectByAlive(g, true)
  set g = SelectNumberOfId(g, 1, old_id[racial_hall[1]])
  set u = FirstOfGroup(g)
  call DestroyGroup(g)
  set g = null
  return u
endfunction

function FastBuildBuilding takes nothing returns nothing
  local unit u = null
  local group g = null
  local location unitloc = null
  set u = GetBuildingBuilt(u)
  call Trace("Town hall is being built soon")
  if u == null then
    return
  endif
  set unitloc = GetUnitLoc(u)
  set g = CreateGroup()
  call Trace("Town hall is being built")
  call GroupEnumUnitsOfPlayer(g, ai_player,null)
  set g = SelectNumberOfId(g, 50, old_id[racial_militia] )
  set g = SelectByHidden(g, false)
  set g = SelectByAlive(g, true)
  if FirstOfGroup(g) == null then
    call GroupClear(g)
    call GroupEnumUnitsOfPlayer(g, ai_player, null)
    set g = SelectNumberOfId(g, 50, old_id[racial_peon] )
    set g = SelectByHidden(g, false)
    set g = SelectByAlive(g, true)
  endif
  set g = GetNearestSubGroupOfGroup(g, unitloc, GetFastBuildPeasantNumber())
  call GroupTargetOrder(g, "repair", u)
  call Trace("Fast Build Town Hall")
  set town_hall_built = true
  call RemoveLocation(unitloc)
  call DestroyGroup(g)
  set unitloc = null
  set g = null
  set u = null
endfunction

function FastBuildCheck takes nothing returns nothing
  if GetUnitX(current_expansion) != next_expansion_x or GetUnitY(current_expansion) != next_expansion_y then
    set last_expansion_x = next_expansion_x
    set last_expansion_y = next_expansion_y
    set next_expansion_x = GetUnitX(current_expansion)
    set next_expansion_y = GetUnitY(current_expansion)
    set expansion_changed = true
  else
    set expansion_changed = false
  endif
  if TownCount(racial_hall[1]) - TownCountDone(racial_hall[1]) > 0 then
    //if expansion_changed and not town_hall_built then
    if not town_hall_built then  
      call FastBuildBuilding()
    endif
  else
    set town_hall_built = false
  endif
endfunction

function FastBuild takes nothing returns nothing
  if current_expansion != null and not towerrush then
    call FastBuildCheck()
  endif
  call TQAddJob(10, FAST_BUILD, 0)
endfunction

function GetMilitiaExpansionLoc takes integer unitid returns nothing
    local unit u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), unitid, GetUnitX(militia_expansion), GetUnitY(militia_expansion), 270.0)
    if DistanceBetweenUnits(u, militia_expansion) > race_max_expa_mine_distance then
      call RemoveUnit(u)
      set u = null
      return
    endif	
    set militia_loc = GetUnitLoc(u)
    call RemoveUnit(u)
    set u = null

endfunction

function BuildMilitiaExpansion takes unit peon , integer unitid returns boolean
  //local unit u = null

  call Trace("did a check")

  if militia_loc == null then
    return false
  endif

  return IssuePointOrderByIdLoc(peon, unitid, militia_loc)

endfunction

function GetMilitiaExpansionStrength takes nothing returns integer
  return GetLocationCreepStrength(GetUnitX(militia_expansion), GetUnitY(militia_expansion), expansion_radius)
endfunction

function TryMilitiaExpansionFoot takes nothing returns nothing
local group g = null
local unit u = null
local integer ownstrength = 0
local integer expansionstrength = 0
local location l = null
local boolean buildend = false

	call DisplayToAllJobDebug("MILITIA_EXPAND JOB START")

	if towerrush or GetMinesOwned() >= 2 then  // have mine , peon need harvest
		call TQAddJob(80, MILITIA_EXPAND, 0)
		return
	endif
	set ownstrength = GetOwnStrength()
	if militia_state == 0 then
	if not militia_expanding then
		if current_expansion != null then
		set militia_time_count = militia_time_count + 1
		call Trace("Expansion Distance: " + Int2Str(R2I(GetExpansionDistance())))
		set expansionstrength = GetExpansionStrength()
		//if GetExpansionDistance() <= 6600 and expansionstrength < 20 then //and militia_time_count < militia_time_out then //and expansionstrength < 36 then // and hero[1] == racial_militiahero then
		if GetExpansionDistance() <= 5800 and expansionstrength < 20 then
			call Trace("Our Strength:" + Int2Str(ownstrength) + " Expansion Strength:" + Int2Str(expansionstrength))
			if TownCountDone(hero[1])>0 and not town_threatened and GetPlayerStrength(ai_player) >= minimum_attack_strength and TownCountDone(racial_peon) > 6 and ownstrength + 6 >= expansionstrength then
				set gold_buffer = GetUnitGoldCost2(racial_expansion)
				set wood_buffer = GetUnitWoodCost2(racial_expansion)	
				set militia_expansion = current_expansion 
						if GetGold() >= GetUnitGoldCost2(racial_expansion) and GetWood() >= GetUnitWoodCost2(racial_expansion) then
						if GetMilitiaExpansionStrength() <= 0 then
							set militia_expanding = false
							set militia_state = 2
						else
							set militia_expanding = true
							call Trace("Militia active")
							set militia_state = 1
						endif		
						endif
					endif
				else
					set gold_buffer = 0
					set wood_buffer = 0
					call Trace("MILITIA_EXPAND: Militia expansion will not be done")
					//set militia = false
					set buildend = true
				endif
			endif
		endif
		if not buildend then
			call TQAddJob(7, MILITIA_EXPAND, 0)
			return
		endif
	elseif militia_state == 1 then
		set gold_buffer = GetUnitGoldCost2(racial_expansion)
		set wood_buffer = GetUnitWoodCost2(racial_expansion)	
		set u = GetExpFoe(u)
		if ownstrength + 6 < GetExpansionStrength() then
		    set militia_expanding = false
			set militia_state = 0 // Lost units so stop trying to expand
		elseif GetMilitiaExpansionStrength() <= 0 and u == null then
			set militia_expanding = false
			set militia_state = 2
			call Trace("Militia state 1 done")
		else
			set militia_expanding = true
		endif
		set u = null
		call TQAddJob(2, MILITIA_EXPAND, 0)
		return
	elseif militia_state == 2 then
	call Trace("Militia state 2")
	if GetMilitiaExpansionStrength() > 0 then
		set militia_state = 1
		set militia_expanding = true
	endif
	set gold_buffer = GetUnitGoldCost2(racial_expansion)
	set wood_buffer = GetUnitWoodCost2(racial_expansion)	
	set g = CreateGroup()
	call GroupEnumUnitsOfPlayer(g, ai_player,null)
	set g = SelectNumberOfId(g, 50, old_id[racial_militia] )
	set g = SelectByHidden(g, false)
	set g = SelectByAlive(g, true)
	if FirstOfGroup(g) == null then
		call GroupClear(g)
		call GroupEnumUnitsOfPlayer(g, ai_player, null)	 
		set g = SelectNumberOfId(g, 50, old_id[racial_peon] )
		set g = SelectByHidden(g, false)
		set g = SelectByAlive(g, true)
	endif
	//call GroupClear(g)
	set l = GetUnitLoc(current_expansion)
	set g = GetNearestSubGroupOfGroup(g, l, 4)
	call RemoveLocation(l)
	set l = null
	set militia_builder = FirstOfGroup(g)
	//call GroupRemoveUnit(g, militia_builder)
	//set militia_fastb1 = FirstOfGroup(g)
	//call GroupRemoveUnit(g, militia_fastb1)
	//set militia_fastb2 = FirstOfGroup(g)
	//call GroupRemoveUnit(g, militia_fastb2)
	//set militia_fastb3 = FirstOfGroup(g)
	call RemoveGuardPosition(militia_builder)
	call DestroyGroup(g)
	set g = null
	if militia_builder != null then
		set militia_state = 3
		call Trace("Militia state 2 done")
	 endif
	call TQAddJob(2, MILITIA_EXPAND, 0)
	return
	elseif militia_state == 3 then
		if GetMilitiaExpansionStrength() > 0 then
			set militia_state = 1
			set militia_expanding = true
		endif
		if militia_builder == null or GetUnitState(militia_builder, UNIT_STATE_LIFE) <=0 then
			set militia_state = 2
		else
			if CheckExpansionTaken(militia_expansion) then
				//set militia = false
				set militia_state = 0
				set militia_expansion = null
				call RemoveLocation(militia_loc)
				set militia_loc = null
				set gold_buffer = 0
				set wood_buffer = 0
				call Trace("Militia Ended")
				call RecycleGuardPosition(militia_builder)
				set buildend = true
			else
				if militia_loc == null then
					call GetMilitiaExpansionLoc(old_id[racial_expansion])
				endif
				if GetGold() >= GetUnitGoldCost2(racial_hall[1]) and GetWood() >= GetUnitWoodCost2(racial_hall[1]) then
					//call IssueTargetOrder(militia_fastb1, "stop", current_expansion)
					//call IssueTargetOrder(militia_fastb2, "stop", current_expansion)
					call RecycleGuardPosition(militia_builder)  // has to be here or peasant comes off construction
					set buildend = BuildMilitiaExpansion(militia_builder, old_id[racial_expansion])
					//set militia = false
					//set militia_state = 0
					//set militia_expansion = null
					call Trace("Militia Build commanded")
				else 
					set gold_buffer = GetUnitGoldCost2(racial_expansion)
					set wood_buffer = GetUnitWoodCost2(racial_expansion)
					call Trace("Moving near")
					call RemoveGuardPosition(militia_builder)
					if militia_loc == null then
						call IssueTargetOrder(militia_builder, "move", current_expansion)
						//call IssueTargetOrder(militia_fastb1, "move", current_expansion)
						//call IssueTargetOrder(militia_fastb2, "move", current_expansion)
					else
						call IssuePointOrderLoc(militia_builder, "move", militia_loc)
					endif
				endif
		endif
		endif
		if not buildend then
			call TQAddJob(3, MILITIA_EXPAND, 0)
			return
		endif
	endif
	call TQAddJob(50, MILITIA_EXPAND, 0)
endfunction



function SendHomeMoveUnitToLoc takes unit u, location l returns nothing
	local integer enemystrength = GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 800)
	if (GetUnitAbilityLevel(u, 'AOwk') > 0 or GetUnitAbilityLevel(u, 'ANwk') > 0) then
		if enemystrength > 0 and not UnitInvis(u) then
			call IssueImmediateOrder(u, "windwalk")
		endif
	endif
	if enemystrength > 0 and ((GetUnitState(u, UNIT_STATE_MANA) > 50 and GetUnitAbilityLevel(u, 'AEbl') == 1) or (GetUnitState(u, UNIT_STATE_MANA) > 10 and GetUnitAbilityLevel(u, 'AEbl') > 1)) then
		call IssuePointOrder(u, "blink", GetLocationX(l), GetLocationY(l))
		call IssuePointOrder(u, "move", GetLocationX(l), GetLocationY(l))
	elseif GetUnitAbilityLevel(u, 'Ashm') > 0 and enemystrength > 0 and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) < 6) and not IsUnitType(u, UNIT_TYPE_HERO) then
		call CreateDebugTag("SEND_HOME: Night Hide", 10, u, 3.00, 1.50)
		call IssueImmediateOrder(u, "ambush")
	else
		call CreateDebugTag("SEND_HOME: Moving to Location", 10, u, 3.00, 2.00)
		//call RemoveGuardPosition(u)
		call IssuePointOrder(u, "move", GetLocationX(l), GetLocationY(l))
	endif
endfunction

function SomeUnitHasHealingItem takes unit ru, unit u, integer rhi returns unit
	local group g = CreateGroup()
	call GroupEnumUnitsInRange(g, GetUnitX(u), GetUnitY(u), 400, null)
	set g = SelectByPlayer(g,ai_player, true)
	set g = SelectByAlive(g,true)
	loop
		set ru = FirstOfGroup(g)
		exitwhen ru == null
		if GetItemNumberOnUnit(rhi, ru) > 0 then
			call DestroyGroup(g)
			set g = null
			return ru
		endif
		call GroupRemoveUnit(g, ru)
	endloop
	call DestroyGroup(g)
	set g = null
	return null
endfunction

function SendUnitHomeJob takes unit u, integer p returns nothing

  local location l = null
  local unit nearshopunit = null 
  local group g = null
  local unit corpse = null
  local integer racial_healing_item = GetHeroHealingItem()
  local integer racial_mana_item = GetHeroManaItem()
  local integer enemystrength = 0
  local unit otherhero = null
  local item it = null

  call DisplayToAllJobDebug("SEND_HOME Job")

  if IsUnitType(u, UNIT_TYPE_HERO) then
    if racial_healing_item != 0 then
      set otherhero = SomeUnitHasHealingItem(otherhero, u, racial_healing_item)
    endif
    //set shop_wanted = 1
    if buy_type[racial_healing_item] == BT_RACIAL_ITEM then
      //set shop_unit = GetUnitOfTypeNearUnit(old_id[racial_shop], u, shop_unit)
      set nearshopunit = GetUnitOfTypeNearUnit(old_id[racial_shop], u, nearshopunit)
      //	set shop_distance_limit = raceshop_distance_limit
    else
      //	set shop_unit = nearest_neutral[NEUTRAL_MERCHANT]
      if not (neutral_guarded[NEUTRAL_MERCHANT] and ((GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 5 and GetFloatGameState(GAME_STATE_TIME_OF_DAY) < 18) or not neutral_night_buy[NEUTRAL_MERCHANT])) then
        set nearshopunit = nearest_neutral[NEUTRAL_MERCHANT]
      endif
      //	set shop_distance_limit = merchant_distance_limit
    endif
    //set shop_sent = u
    //call TQAddJob(0, BUY_ITEM, racial_healing_item)
    //set nearshopunit = shop_unit
  endif

  call DisplayToAllJobDebug("SEND_HOME Starting check")

  // set enemystrength = GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 800)
  if GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
    call CreateDebugTag("SEND_HOME unit dead", 10, u, 3.00, 1.50)
    call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)  
  elseif GetUnitState(u, UNIT_STATE_LIFE) >= GetUnitState(u, UNIT_STATE_MAX_LIFE) * (I2R(60)/100) and GetUnitCurrentOrder(u) != OrderId("cannibalize") then
    call CreateDebugTag("SEND_HOME Healed", 10, u, 3.00, 1.50)	
    call TQAddUnitJob(2, RESET_GUARD_POSITION, 0, u)
  elseif racial_healing_item != 0 and GetItemNumberOnUnit(racial_healing_item, u) > 0 then
    call CreateDebugTag("Hero: Use healing item", 10, u, 3.00, 2.00)
    if GetItemInstantType(racial_healing_item) == ITEMTYPE_CONTINUOUS and DistanceBetweenPoints_dk(GetUnitLoc(u), exist_town[p]) >= 1200 then
      call SendHomeMoveUnitToLoc(u,exist_town[p])  // This should be required for all regenerative type healing items
      call TQAddUnitJob(4, SEND_HOME, p, u)
    else
      call CreateDebugTag("Hero: Use healing item", 10, u, 3.00, 1.50)
      set it = GetItemOfTypeOnUnit(racial_healing_item, u)
      call UnitUseItem(u, it )
      call UnitUseItemTarget(u, it, u)
      if racial_mana_item != 0 and GetUnitState(u, UNIT_STATE_MANA) < 100 and GetItemNumberOnUnit(racial_mana_item, u) > 0 then
        call UnitUseItem(u, GetItemOfTypeOnUnit(racial_mana_item, u))
      endif
      call TQAddUnitJob(Max(3,GetItemHealingTime(racial_healing_item)), SEND_HOME, p, u) // Have to add delay as continous healing items run out
      set it = null
    endif
  elseif otherhero != null and IsUnitType(u, UNIT_TYPE_HERO) then
      if GetSlotsFreeOnUnit(u) > 0 then  // prevent create on the ground
        call UnitAddItem(u, GetItemOfTypeOnUnit(racial_healing_item, otherhero))
        call TQAddUnitJob(2, RESET_GUARD_POSITION, 0, u)
      else
        call TQAddUnitJob(4, SEND_HOME, p, u)
      endif
  elseif nearshopunit != null and IsUnitType(u, UNIT_TYPE_HERO) and GetSlotsFreeOnUnit(u) > 0 and GetItemNumberOnUnit(racial_healing_item, u) <= 0 then
      if DistanceBetweenUnits(u, nearshopunit) >= buy_distance then
        set l = GetUnitLoc(nearshopunit)
        call SendHomeMoveUnitToLoc(u,l)
        call RemoveLocation(l)
        set l = null
        call TQAddUnitJob(4, SEND_HOME, p, u)
      else
        call CreateDebugTag("SEND_HOME Stop at Shop", 10, u, 3.00, 2.00)	
        call IssueImmediateOrder(u, "stop")
        call IssueNeutralImmediateOrderById(ai_player, nearshopunit, old_id[racial_healing_item])
        if GetUnitState(u, UNIT_STATE_MANA) < 100 and GetItemNumberOnUnit(racial_mana_item, u) <= 0 then
          call IssueNeutralImmediateOrderById(ai_player, nearshopunit, old_id[racial_mana_item])
        endif
        call TQAddUnitJob(2, RESET_GUARD_POSITION, 0, u)  // end job
        //call RecycleGuardPosition(u)
      endif
  else
      if DistanceBetweenPoints_dk(GetUnitLoc(u), exist_town[p]) >= 1200 then
       call SendHomeMoveUnitToLoc(u,exist_town[p])
      else
        set g = CreateGroup()
        call GroupEnumUnitsInRangeOfLoc(g, exist_town[p], 1000, null)
        set g = SelectByAlive(g, false)
        set g = SelectUnittype(g,UNIT_TYPE_STRUCTURE,false)
        set g = SelectUnittype(g,UNIT_TYPE_DEAD,true)
        set corpse = FirstOfGroup(g)
        call DestroyGroup(g)
        set g = null
        if town_threatened then
          call CreateDebugTag("SEND_HOME town_threatened", 10, u, 3.00, 1.50)
          call RecycleGuardPosition(u)   // Gives unit control for only a little bit but dosn't remove from healing group
        elseif GetUnitAbilityLevel(u, 'Ashm') > 0 and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) < 6) and not IsUnitType(u, UNIT_TYPE_HERO) then
          call IssueImmediateOrder(u, "ambush")
          call CreateDebugTag("SEND_HOME hide", 10, u, 3.00, 1.50)
        elseif GetUnitCurrentOrder(u) != OrderId("cannibalize") and (GetUnitAbilityLevel(u, 'Acn2') > 0 or GetUnitAbilityLevel(u, 'Acan') > 0 or GetUnitAbilityLevel(u, 'ACcn') > 0)  and corpse != null then
          call IssueTargetOrder(u, "move" , corpse)
          call IssueImmediateOrder(u, "cannibalize")
          call CreateDebugTag("SEND_HOME cannibalize", 10, u, 3.00, 1.50)
        elseif GetUnitAbilityLevel(u, 'Ahrl') > 0 and GetUnitCurrentOrder(u) != OrderId("cannibalize") then   // 'Ahrl' Ghoul Harvest lumber ability
          call IssueImmediateOrder(u, "autoharvestlumber")
          call CreateDebugTag("SEND_HOME harvest lumber", 10, u, 3.00, 1.50)
        endif
      endif
      call TQAddUnitJob(4, SEND_HOME, p, u)
      //call DisplayToAllJobDebug("SEND_HOME: JOB Finished!!!! ")
  endif
  set nearshopunit = null
  set otherhero = null
  set corpse = null
endfunction
function ResetWindWalkerGuardPosition takes unit u returns nothing
  call DisplayToAllJobDebug("RESET_GUARD_POSITION JOB START")
  	if not IsUnitInGroup(u, unit_healing) and not IsUnitInGroup(u, unit_rescueing ) and not IsUnitInGroup(u, unit_harassing ) and not IsUnitInGroup(u, unit_zepplin_move ) then
	else
		call GroupRemoveUnit(windwalk_group, u)
		return
	endif
	if IsUnitInvisible(u, Player(PLAYER_NEUTRAL_AGGRESSIVE)) then
		//call IssueImmediateOrder(u, "windwalk")
		//call UnitRemoveAbility(u, 'BOwk')
		if CaptainRetreating() and isfleeing then
			call RecycleGuardPosition(u)
			call GroupRemoveUnit(windwalk_group, u)
			//call AddAssault(1, GetUnitTypeId(u))
			return
		else
			call RecycleGuardPosition(u)
			call AddAssault(1, GetUnitTypeId(u))
			//call IssuePointOrder(u, "move", GetLocationX(army_loc[main_army]), GetLocationY(army_loc[main_army]))
			call TQAddUnitJob(8, RESET_WINDWALKER, 0, u)		
		endif
	else
		call RecycleGuardPosition(u)
		call GroupRemoveUnit(windwalk_group, u)
		call AddAssault(1, GetUnitTypeId(u))	
		return
	endif

	//	return
	//endif
	//call TQAddUnitJob(3, RESET_WINDWALKER, 0, u)
endfunction


function BuildExpansionJob takes unit u returns nothing
	local unit v = null
	//if i == 1 then  // current_expansion
		if UnitAlive(u) == false then
			return
		endif
		set v = GetOtherExpansionNearby(v,GetUnitX(current_expansion), GetUnitY(current_expansion))
		if v != null then
			call IssueImmediateOrder(u, "stop")
			set v = null
			return
		endif
		if DistanceBetweenUnits(u, current_expansion) > race_max_expa_mine_distance then
			call TQAddUnitJob(2 * sleep_multiplier, BUILD_EXPANSION, 0, u)
		endif
	//elseif i == 2 then	// Construct expansion

	//endif

endfunction


function ItemExpansionJob takes nothing returns nothing
  local unit u = null
  local unit temp = null
  local location loc = null
  local location item_exp_loc = null
  local item exp_item = null
  local integer time_next_try = 5
  if (itemhero != null and GetUnitState(itemhero, UNIT_STATE_LIFE) <= 0) or town_threatened or current_expansion == null then
    call RecycleGuardPosition(itemhero)
    call Trace("Expansion cannot or no Expansion")  // no call ChooseExpansion() , this is passive expansion , avoidance buy repeat item
    set item_attack_running = false
    set item_expanding = false
    set expitem_buy = false
    set item_exp_state = 0
    set itemhero = null
    return
  endif
  set exp_time_count = ai_time
  set u = GetExpFoe(u)
  if item_exp_state == 0 then
    call Trace("Expansion Distance: " + Int2Str(R2I(GetExpansionDistance())))
    call Trace("Expansion state 0: Check Expansion Hero and Location")
    if itemhero == null then
      set exp_item = GetItemOfType(exp_item,race_item_expansion_item_id)
      if exp_item != null then
        set itemhero = GetItemHero(exp_item)
      endif
    endif
    if itemhero == null and expitem_buy == false then
      set u = null
      if GetGold() < gold_price[race_item_expansion_item_id] + 120 or GetWood() < wood_price[race_item_expansion_item_id] + 80 then
        call Trace("Expansion no gold or wood")
        set item_expanding = false
        set item_exp_state = 0
        set itemhero = null
        return
      endif
      set shop_ordered = true
      call TQAddJob(5, BUY_ITEM, race_item_expansion_item_id)
      call TQAddJob(20, ITEM_EXPANSION, 0)
      return
    endif
    call SetItemDroppable( GetItemOfTypeOnUnit(race_item_expansion_item_id, itemhero), false )  //prevent droppable
    call SetItemPawnable( GetItemOfTypeOnUnit(race_item_expansion_item_id, itemhero), false )  //can selling
    set expitem_buy = true
    set not_taken_expansion = current_expansion
    if u == null then
      set temp = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), old_id[racial_expansion], GetUnitX(current_expansion), GetUnitY(current_expansion), 270.0)
      set item_exp_loc = GetUnitLoc(temp)
      call RemoveUnit(temp)
      set temp = null
      set loc = GetUnitLoc(current_expansion)
      call RemoveLocation(item_exp_guard_loc)
      set item_exp_guard_loc = AIGetProjectedLoc(loc, item_exp_loc, 850, 0)  //Guarding position
      call RemoveLocation(loc)
      set loc = null
      call RemoveGuardPosition(itemhero)
      call UnitUseItemPoint(itemhero, GetItemOfTypeOnUnit(race_item_expansion_item_id, itemhero), GetLocationX(item_exp_loc), GetLocationY(item_exp_loc))
      set item_exp_state = 3
      call RemoveLocation(item_exp_loc)
      set item_exp_loc = null
    else
      set item_exp_state = 1
    endif
  elseif item_exp_state == 1 then
    call Trace("Expansion state 1: Wait Rush Expansion")
    if u == null then
      set item_exp_state = 2
      set item_attack_running = false
      set time_next_try = 1
    endif
  elseif item_exp_state == 2 then
    call RemoveGuardPosition(itemhero)
    call UnitUseItemPoint(itemhero, GetItemOfTypeOnUnit(race_item_expansion_item_id, itemhero), GetLocationX(item_exp_loc), GetLocationY(item_exp_loc))
    set item_exp_state = 3
  elseif item_exp_state == 3 then
    call Trace("Expansion state 3: Check Use Item")
    if GetItemOfTypeOnUnit(race_item_expansion_item_id, itemhero) != null and not CheckExpansionTaken (current_expansion) then
      set temp = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), old_id[racial_expansion], GetUnitX(current_expansion), GetUnitY(current_expansion), 270.0)
      set item_exp_loc = GetUnitLoc(temp)
      call RemoveUnit(temp)
      set temp = null
      call RemoveGuardPosition(itemhero)
      call UnitUseItemPoint(itemhero, GetItemOfTypeOnUnit(race_item_expansion_item_id, itemhero), GetLocationX(item_exp_loc), GetLocationY(item_exp_loc))
      set time_next_try = 1
      call RemoveLocation(item_exp_loc)
      set item_exp_loc = null
    else
      call Trace("Expansion Done")
      call RecycleGuardPosition(itemhero)
      set item_attack_running = false
      set item_expanding = false
      set expitem_buy = false
      set item_exp_state = 0
      set itemhero = null
      call SetItemDroppable( GetItemOfTypeOnUnit(race_item_expansion_item_id, itemhero), true )  //prevent droppable
      call SetItemPawnable( GetItemOfTypeOnUnit(race_item_expansion_item_id, itemhero), true )  //can selling
      set u = null
      return
    endif
  endif
  set u = null
  call TQAddJob(time_next_try, ITEM_EXPANSION, 0)
endfunction


function ItemExpansionCheck takes nothing returns nothing
  call DisplayToAllJobDebug("ITEM_EXPANSION_CHECK JOB START")
  if not item_expanding then
    if current_expansion != null and not CheckExpansionTaken(current_expansion) and GetResourceAmount(current_expansion) > (gold_price[race_item_expansion_item_id] + 300) and not_taken_expansion == null and shop_unit != null and race_item_expansion_item_id != 0 then
      call Trace("Item expansion free")  // this is passive expansion , no set not_taken_expansion , but need current_expansion not not_taken_expansion
      if tier >= race_item_sale_level then
        call Trace("Item expansion - Begin Job")
        set item_expanding = true
        call TQAddJob(1, ITEM_EXPANSION, 0)
      endif
    endif
  endif
  call Trace("Item expansion - No expansion available")
  call TQAddJob(50, ITEM_EXPANSION_CHECK, 0)
endfunction

function ItemTypeCheck takes unit u , item it , integer t returns boolean
  local integer i = GetItemTypeId(it)
  local integer c = 0
  if it == null or GetItemType(it) == ITEM_TYPE_CHARGED or GetItemType(it) == ITEM_TYPE_POWERUP then
    return false
  endif
  loop
    exitwhen t > 5 or c < 0
    set t = t + 1  // just need check remaining Slot
    set c = GetItemTypeId(UnitItemInSlot(u, t))
    if c != 0 then  // check same item and same ability's item
      if c == i then
        set c = -1
      elseif i == 'nspi' and ( c == 'brac' or c == 'spsh' ) then
        return true
      elseif i == 'brac' and c == 'nspi' then
        return true
      elseif i == 'spsh' and c == 'nspi' then
        return true
      endif
    endif
  endloop
  if false then  // check repeat ability
  elseif i == 'evtl' and (c < 0 or GetUnitAbilityLevel(u,'AEev') > 0 or GetUnitAbilityLevel(u,'ACes') > 0 or GetUnitAbilityLevel(u,'ACev') > 0 or GetUnitAbilityLevel(u,'ANdb') > 0 or GetUnitAbilityLevel(u,'Acdb') > 0 ) then
    return true
  elseif i == 'clsd' and (c < 0 or GetUnitAbilityLevel(u,'Ashm') > 0 or GetUnitAbilityLevel(u,'Sshm') > 0 or GetUnitAbilityLevel(u,'Ahid') > 0 or GetUnitAbilityLevel(u,'Apiv') > 0 ) then
    return true
  elseif i == 'brac' and (c < 0 or GetUnitAbilityLevel(u,'Amim') > 0 or GetUnitAbilityLevel(u,'ACmi') > 0 or GetUnitAbilityLevel(u,'ACm2') > 0 or GetUnitAbilityLevel(u,'ACm3') > 0 ) then
    return true
  elseif i == 'spsh' and (c < 0 or GetUnitAbilityLevel(u,'Amim') > 0 or GetUnitAbilityLevel(u,'ACmi') > 0 or GetUnitAbilityLevel(u,'ACm2') > 0 or GetUnitAbilityLevel(u,'ACm3') > 0 ) then
    return true
  elseif i == 'clfm' and (c < 0 or GetUnitAbilityLevel(u,'AEim') > 0 or GetUnitAbilityLevel(u,'ACim') > 0 or GetUnitAbilityLevel(u,'ANpi') > 0 or GetUnitAbilityLevel(u,'Apig') > 0 ) then
    return true
  elseif i == 'nspi' and (c < 0 or GetUnitAbilityLevel(u,'Amim') > 0 or GetUnitAbilityLevel(u,'ACmi') > 0 or GetUnitAbilityLevel(u,'ACm2') > 0 or GetUnitAbilityLevel(u,'ACm3') > 0 ) then
    return true
  elseif i == 'ajen' and (c < 0 or GetUnitAbilityLevel(u,'AOae') > 0 or GetUnitAbilityLevel(u,'AOr2') > 0 or GetUnitAbilityLevel(u,'SCae') > 0 ) then
    return true
  elseif i == 'lgdh' and (c < 0 or GetUnitAbilityLevel(u,'AUau') > 0 or GetUnitAbilityLevel(u,'ACua') > 0) then
    return true
  elseif i == 'kpin' and (c < 0 or GetUnitAbilityLevel(u,'AHab') > 0 or GetUnitAbilityLevel(u,'ACba') > 0) then
    return true
  elseif i == 'sbch' and (c < 0 or GetUnitAbilityLevel(u,'AUav') > 0 or GetUnitAbilityLevel(u,'ACvp') > 0) then
    return true
  elseif i == 'afac' and (c < 0 or GetUnitAbilityLevel(u,'AEar') > 0 or GetUnitAbilityLevel(u,'ACat') > 0) then
    return true
  elseif i == 'lhst' and (c < 0 or GetUnitAbilityLevel(u,'AHad') > 0 or GetUnitAbilityLevel(u,'ACav') > 0) then
    return true
  elseif i == 'war2' and (c < 0 or GetUnitAbilityLevel(u,'Aakb') > 0) then
    return true
  elseif i == 'ward' and (c < 0 or GetUnitAbilityLevel(u,'ACac') > 0) then
    return true
  elseif c < 0 then
    if false then  // check repeat item
    elseif i == 'bspd' then
      return true
    elseif i == 'desc' then
      return true
    elseif i == 'modt' then
      return true
    elseif i == 'dsum' then
      return true
    elseif i == 'stel' then
      return true
    elseif i == 'amrc' then
      return true
    elseif i == 'spre' then
      return true
    elseif i == 'ssan' then
      return true
    elseif i == 'ssil' then
      return true
    endif
  endif
  return false
endfunction

function CheckItem takes nothing returns nothing
  local integer i = 1
  local integer c = 0
  local integer t = 0
  local group g = CreateGroup()
  local unit u = null
  local unit array tempu
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectUnittype(g, UNIT_TYPE_HERO, true)  // Prevent hero more than 3 , no use hero_unit[i]
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and IsStandardUnit(u) and not IsUnitBuying(u) then
      set tempu[i] = u  // no attack , no need check IsUnitInvisible
      set i = i + 1
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  if i > 2 then  // if no or just one hero , cannot move item
    set c = i - 1
    set i = 1
    loop
      set u = tempu[i]
      exitwhen u == null
      if GetSlotsFreeOnUnit(u) < 6 then  // have item
        set t = 0
        loop
          exitwhen t > 5
          if ItemTypeCheck(u,UnitItemInSlot(u,t),t) then
            set tempu[0] = tempu[GetRandomInt(1,c)]
            if tempu[0] != u and GetSlotsFreeOnUnit(tempu[0]) > 0 and DistanceBetweenUnits(tempu[0],u) <= 1600 then
              call RemoveGuardPosition(u)
              call RemoveGuardPosition(tempu[0])
              call IssueTargetOrder(tempu[0], "move", u)  // two hero near
              call UnitDropItemTarget(u,UnitItemInSlot(u,t),tempu[0])
              call TQAddUnitJob(10, RESET_GUARD_POSITION, 80, tempu[0])
              call TQAddUnitJob(10, RESET_GUARD_POSITION, 80, u)
              set t = 5  // once move one item
            endif
          endif
          set t = t + 1
        endloop
      endif
      set i = i + 1
    endloop
  endif
  loop
    set i = i - 1
    exitwhen i < 0
    set tempu[i] = null
  endloop
endfunction

function ItemRepeatCheck takes nothing returns nothing
  if not town_threatened and not CaptainRetreating() and not CaptainInCombat(true) then
    call CheckItem()  // Prevent the map set unit die will drop item , so no judge CreepsOnMap
  endif
  call TQAddJob(160, ITEM_REPEAT_CHECK, 0)
endfunction

function TQDoJob takes integer jid, integer par, unit unit_par, group group_par returns nothing
if jid < 20 then
if jid < 16 then
if jid < 8 then
if jid < 4 then
if jid < 2 then
if jid < 1 then
call BuyNeutral(par)
 else
call BuyNeutralHero(par)
 endif
 else
if jid < 3 then
call UpdateStrengthJob()
 else
call DetectDefeatJob()
 endif
 endif
 else
if jid < 6 then
if jid < 5 then
call DetectDoubleExpJob()
 else
call HarvestCheckJob()
 endif
 else
if jid < 7 then
call MicroUnitsJob()
 else
call MilitiaCheckJob()
 endif
 endif
 endif
 else
if jid < 12 then
if jid < 10 then
if jid < 9 then
call TowerRushJob()
 else
call FocusFireJob()
 endif
 else
if jid < 11 then
call FastBuild()
 else
call TryMilitiaExpansionFoot()
 endif
 endif
 else
if jid < 15 then
if jid < 13 then
call BuildExpansionJob(unit_par)
 else
if jid < 14 then
call RallypointJob()
 else
call AncientExpansionJob()
 endif
 endif
 else
call HarassJob(par, unit_par, group_par)
 endif
 endif
 endif
 else
if jid < 17 then
call RetreatControlJob()
 else
if jid < 18 then
call MicroHeroJob(par)
 else
if jid < 19 then
call ArmyTrackJob()
 else
call FireChat()
 endif
 endif
 endif
 endif
 else
if jid < 38 then
if jid < 25 then
if jid < 22 then
if jid < 21 then
call TowerRushCheck()
 else
call AncientExpansionCheck()
 endif
 else
if jid < 23 then
call ItemExpansionCheck()
 else
if jid < 24 then
call RepairControlJob()
 else
call ResetByHealthJob(unit_par, par)
 endif
 endif
 endif
 else
if jid < 29 then
if jid < 27 then
if jid < 26 then
call ZeppelinMoveJob(par, unit_par, group_par)
 else
call TeleportJob(unit_par)
 endif
 else
if jid < 28 then
call TownTrackJob()
 else
call ChatVarsJob()
 endif
 endif
 else
if jid < 36 then
if jid < 33 then
if jid < 32 then
if jid < 31 then
if jid < 30 then
call RevealEnemy()
 else
call Chat(par)
 endif
 else
call CleanupBlocksJob()
 endif
 else
call NeutralGuardedJob(par)
 endif
 else
if jid < 34 then
call ResetWindWalkerGuardPosition(unit_par)
 else
if jid < 35 then
call SellZigguratJob()
 else
call ExchangeJob()
 endif
 endif
 endif
 else
if jid < 37 then
call ZeppelinFollowJob()
 else
call ResetGuardPositionJob(unit_par)
 endif
 endif
 endif
 endif
 else
if jid < 39 then
call ItemRepeatCheck()
 else
if jid < 43 then
if jid < 41 then
if jid < 40 then
call ResetGuardPositionOnlyJob(unit_par)
 else
call BuyItemJob(par)
 endif
 else
if jid < 42 then
call HealthFountainJob(unit_par, par)
 else
call ManaFountainJob(unit_par, par)
 endif
 endif
 else
if jid < 45 then
if jid < 44 then
call NeutralEnemyCheckJob(par)
 else
call MoonWellJob(unit_par, par)
 endif
 else
if jid < 46 then
call SendUnitHomeJob(unit_par, par)
 else
call ItemExpansionJob()
 endif
 endif
 endif
 endif
 endif
 endif
endfunction

function TQHandleOnce takes nothing returns boolean
  local integer jid = tq_jid[1]
  local integer par = tq_par[1]
  local unit unit_par = tq_unit_par[1]
  local group group_par = tq_group_par[1]
  if TimerGetElapsed(tq_timer) >= tq_time[1] then
    call TQRemoveRoot()
    call TQDoJob(jid, par, unit_par, group_par)
    set unit_par = null
    set group_par = null
    return true
  endif
  set unit_par = null
  set group_par = null
  return false
endfunction

function TQInitJobs takes nothing returns nothing
  call TQAddJob(GetRandomReal(5, 30), TIMED_CHAT, C_Greet)
  call TQAddJob(GetRandomReal(5, 10), TIMED_CHAT, C_STRATEGY)
  call TQAddJob(GetRandomReal(3, 5), CHAT_QUEUE, 0)
  call TQAddJob(GetRandomReal(50, 65), UPDATE_STRENGTH, 0)
  call TQAddJob(GetRandomReal(120, 135), REVEAL_ENEMY, 0)
  call TQAddJob(GetRandomReal(90, 110), DETECT_DEFEAT, 0)
  call TQAddJob(GetRandomReal(100, 120), DETECT_DOUBLE_EXP, 0)
  call TQAddJob(GetRandomReal(80, 100), ZEPPELIN_FOLLOW, 0)
  call TQAddJob(GetRandomReal(0, 10), REPAIR_CONTROL, 0)
  call TQAddJob(GetRandomReal(60, 70), CLEANUP_BLOCKS, 0)
  call TQAddJob(GetRandomReal(10, 20), MICRO_UNITS, 0)
  call TQAddJob(GetRandomReal(20, 30), RALLY_POINT, 0)
  call TQAddJob(GetRandomReal(50, 60), ARMY_TRACK, 0)
  call TQAddJob(GetRandomReal(50, 60), TOWN_TRACK, 0)
  call TQAddJob(GetRandomReal(1, 2), CHAT_VARS, 0)
  call TQAddJob(GetRandomReal(40, 60), FOCUSFIRE_CONTROL, 0)
  call TQAddJob(GetRandomReal(200, 220), ITEM_REPEAT_CHECK, 0)

  if force_number > 1 then
    call TQAddJob(GetRandomReal(75, 90), EXCHANGE, 0)
  endif
  if race_manual_loading or ( not race_manual_loading and not race_uses_mine_expansion and first_town_mine == 3) or (race_uses_mine_expansion and first_town_mine != 0) then
    call TQAddJob(GetRandomReal(200 - Min(first_town_mine,1) * 198, 220 - Min(first_town_mine,1) * 208), HARVEST_CHECK, 0)
  endif
  if race_militia_available then
    call TQAddJob(GetRandomReal(80, 90), MILITIA_CHECK, 0)
  endif
  if race_towerrush_available then
    call TQAddJob(GetRandomReal(0, 10), TOWER_RUSH_CHECK, 0)
  endif
  if race_ancient_expansion_available then
    call TQAddJob(GetRandomReal(10, 20), ANCIENT_EXPANSION_CHECK, 0)
  endif
  if race_sell_ziggurats then
    call TQAddJob(GetRandomReal(300, 400), SELL_ZIGGURATS, 0)
  endif
  if race_has_power_build then
    call TQAddJob(GetRandomReal(10, 20), FAST_BUILD, 0)
  endif
  if militia then
    call TQAddJob(GetRandomReal(40, 50), MILITIA_EXPAND, 0)
  endif
  if race_item_expansion_available then
    call TQAddJob(GetRandomReal(60, 80), ITEM_EXPANSION_CHECK, 0)
  endif
endfunction

function TQLoop takes nothing returns nothing
  local real i = 0
  local texttag t = null
  if debugging then
    set t = CreateTextTag()
    call UpdateDebugTextTag(t, null, 24, GetLocationX(home_location) + 300, GetLocationY(home_location) + 300)
    call SetTextTagPermanent(t, true)
  endif
  set tq_time[0] = 0
  call TimerStart(tq_timer, 1000000, false, null)
  //call Trace("Starting Job Loop Thread")
  call TQInitJobs()
  //call Trace("Job Initialisation done")
  loop
    exitwhen player_defeated
    if tq_length > 0 then
      if not TQHandleOnce() then
        if debugging then
          call UpdateDebugTextTag(t, Int2Str(tq_jid[1]), 24, GetLocationX(home_location) + 300, GetLocationY(home_location) + 300)
        endif
        set i = tq_time[1] - TimerGetElapsed(tq_timer) + 0.05
        if i > 0 then
          call Sleep(RMin(i ,1))
        endif
      else
        call Sleep(0.05)
      endif
    else
      call Trace("TQLOOP: No job is ready to fire")
      call Sleep(sleep_multiplier)
    endif
  endloop
  if debugging then
    call SetTextTagText(t, "Shutting down Job Thread", 0.1)
  endif
  call Trace("Shutting down Job Thread")
  loop
    call ExchangeOnce()
    call Sleep(30)
  endloop
endfunction

function CheckNeutral takes integer nn returns nothing
  if neutral_available[nn] == true then
    set neutral_ordered[nn] = false
    set neutral_sent[nn] = null
    set buy_time_large[nn] = -1
    set buy_time_small[nn] = -1

    //call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "checkneutral")
    set nearest_neutral[nn] = GetNearestNeutral(nearest_neutral[nn],neutral_id[nn])
    //call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "finished check")
    set neutral_guards[nn] = GetCreepGuardGroup(neutral_guards[nn],nn)
    set neutral_guarded[nn] = GetNeutralGuard(nn)
    set neutral_night_buy[nn] = CanCreepGuardsSleep(nn)
    // set neutral_night_buy[nn] = not no_sleep

    if nearest_neutral[nn] != null then
      call Trace("Neutral Pathing ID done: " + Int2Str(nn)) 
    else
      call Trace("Neutral Pathing ID done (no pathable neutral): " + Int2Str(nn))
    endif
  endif

endfunction

function InitNeutralBuildings takes nothing returns nothing
  local group g = CreateGroup()
  local integer i = 0
  local integer j = 0
  local integer k = 0
  local integer m = 0
  local integer array camp
  local integer array roost
  local integer array merc_types
  local boolean mercfound = false
  local boolean roostfound = false
  local boolean tavernfound = false
  local unit u = null

  set neutral_id[NEUTRAL_MERCHANT] = 'ngme'
  set neutral_id[NEUTRAL_HEALING_FOUNTAIN] = 'nfoh'
  set neutral_id[NEUTRAL_MANA_FOUNTAIN] = 'nmoo'
  set neutral_id[NEUTRAL_OBSERVATORY] = 'ngad'
  set neutral_id[NEUTRAL_POWER_FOUNTAIN] = 'nfnp'
  set neutral_id[NEUTRAL_HEAL_WARD] = 'ohwd'


  set camp[1] = 'nmr5'
  set camp[2] = 'nmr4'
  set camp[3] = 'nmr8'
  set camp[4] = 'nmr9'
  set camp[5] = 'nmrb'
  set camp[6] = 'nmr6'
  set camp[7] = 'nmr2'
  set camp[8] = 'nmer'
  set camp[9] = 'nmr3'
  set camp[10] = 'nmr7'
  set camp[11] = 'nmra'
  set camp[12] = 'nmr0'
  set j = 12


  set roost[1] = 'ndrk'
  set roost[2] = 'ndru'
  set roost[3] = 'ndrz'
  set roost[4] = 'ndrg'
  set roost[5] = 'ndrr'
  set m = 5

  call GroupEnumUnitsOfPlayer(g, Player(PLAYER_NEUTRAL_PASSIVE), null)
  loop
  set u = FirstOfGroup(g)
  exitwhen u == null
  if GetUnitTypeId(u) == neutral_id[NEUTRAL_TAVERN] then
    set neutral_available[NEUTRAL_TAVERN] = true
  elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_MERCHANT] then
    set neutral_available[NEUTRAL_MERCHANT] = true
  elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_OBSERVATORY] then
    set neutral_available[NEUTRAL_OBSERVATORY] = true
  elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_HEALING_FOUNTAIN] then
    set neutral_available[NEUTRAL_HEALING_FOUNTAIN] = true
  elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_MANA_FOUNTAIN] then
    set neutral_available[NEUTRAL_MANA_FOUNTAIN] = true
  elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_POWER_FOUNTAIN] then
    set neutral_available[NEUTRAL_POWER_FOUNTAIN] = true
  elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_HEAL_WARD] and not IsUnitType(u, UNIT_TYPE_SUMMONED) then
    set neutral_available[NEUTRAL_HEAL_WARD] = true
  elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_SHIPYARD] then
    set neutral_available[NEUTRAL_SHIPYARD] = true
  elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_MARKETPLACE] then
    set neutral_available[NEUTRAL_MARKETPLACE] = true
  else
     if not mercfound then
      set i = 0
      loop
        set i = i + 1
        if GetUnitTypeId(u) == camp[i] then
          set mercfound = true
        endif
        exitwhen mercfound or i >= j
      endloop
    endif  
    if not roostfound then
      set k = 0
      loop
        set k = k + 1
        if GetUnitTypeId(u) == roost[k] then
          set roostfound = true
        endif
        exitwhen roostfound or k >= m
      endloop
    endif
  endif  
  call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null

if mercfound then

  if not mercfound then
  elseif i == 1 then
    set merc_unit[0] = SATYR_SHADOWDANCER
    set merc_unit[1] = FURBOLG_SHAMAN
    set merc_unit[2] = THUNDER_LIZARD
    set merc_unit[3] = 0
    set merc_types[1] = FURBOLG_SHAMAN
    set merc_types[2] = SATYR_SHADOWDANCER
    set merc_types[3] = 0
    set merc_types[4] = THUNDER_LIZARD
    set merc_types[5] = THUNDER_LIZARD
    set merc_types[6] = 0
  elseif i == 2 then
    set merc_unit[0] = CENTAUR_OUTRUNNER
    set merc_unit[1] = HARPY_ROGUE
    set merc_unit[2] = RAZORMANE_MEDICINE_MAN
    set merc_unit[3] = HARPY_WINDWITCH
    set merc_types[1] = RAZORMANE_MEDICINE_MAN
    set merc_types[2] = HARPY_WINDWITCH
    set merc_types[3] = CENTAUR_OUTRUNNER
    set merc_types[4] = HARPY_ROGUE
    set merc_types[5] = 0
    set merc_types[6] = CENTAUR_OUTRUNNER
  elseif i == 3 then
    set merc_unit[0] = ROGUE
    set merc_unit[1] = ASSASSIN
    set merc_unit[2] = KOBOLD_GEOMANCER
    set merc_unit[3] = FOREST_TROLL_HIGH_PRIEST
    set merc_types[1] = FOREST_TROLL_HIGH_PRIEST
    set merc_types[2] = KOBOLD_GEOMANCER
    set merc_types[3] = ROGUE
    set merc_types[4] = ASSASSIN
    set merc_types[5] = 0
    set merc_types[6] = 0
  elseif i == 4 then
    set merc_unit[0] = ROGUE
    set merc_unit[1] = ASSASSIN
    set merc_unit[2] = KOBOLD_GEOMANCER
    set merc_unit[3] = FOREST_TROLL_HIGH_PRIEST
    set merc_types[1] = FOREST_TROLL_HIGH_PRIEST
    set merc_types[2] = KOBOLD_GEOMANCER
    set merc_types[3] = ROGUE
    set merc_types[4] = ASSASSIN
    set merc_types[5] = 0
    set merc_types[6] = 0
  elseif i == 5 then
    set merc_unit[0] = BURNING_ARCHER
    set merc_unit[1] = KOBOLD_GEOMANCER
    set merc_unit[2] = WILDKIN
    set merc_unit[3] = 0
    set merc_types[1] = 0
    set merc_types[2] = KOBOLD_GEOMANCER
    set merc_types[3] = WILDKIN
    set merc_types[4] = BURNING_ARCHER
    set merc_types[5] = 0
    set merc_types[6] = BURNING_ARCHER
  elseif i == 6 then
    set merc_unit[0] = MURLOC_FLESHEATER
    set merc_unit[1] = SLUDGE_FLINGER
    set merc_unit[2] = SATYR_SOULSTEALER
    set merc_unit[3] = 0
    set merc_types[1] = 0
    set merc_types[2] = SATYR_SOULSTEALER
    set merc_types[3] = MURLOC_FLESHEATER
    set merc_types[4] = SLUDGE_FLINGER
    set merc_types[5] = 0
    set merc_types[6] = MURLOC_FLESHEATER
  elseif i == 7 then
    set merc_unit[0] = GNOLL_BRUTE
    set merc_unit[1] = GNOLL_WARDEN
    set merc_unit[2] = OGRE_MAGI
    set merc_unit[3] = MUD_GOLEM
    set merc_types[1] = 0
    set merc_types[2] = OGRE_MAGI
    set merc_types[3] = GNOLL_BRUTE
    set merc_types[4] = GNOLL_WARDEN
    set merc_types[5] = 0
    set merc_types[6] = GNOLL_BRUTE
  elseif i == 8 then
    set merc_unit[0] = FOREST_TROLL_BERSERKER
    set merc_unit[1] = FOREST_TROLL_SHADOW_PRIEST
    set merc_unit[2] = OGRE_MAULER
    set merc_unit[3] = MUD_GOLEM
    set merc_types[1] = FOREST_TROLL_SHADOW_PRIEST
    set merc_types[2] = MUD_GOLEM
    set merc_types[3] = OGRE_MAULER
    set merc_types[4] = FOREST_TROLL_BERSERKER
    set merc_types[5] = 0
    set merc_types[6] = 0
  elseif i == 9 then
    set merc_unit[0] = GNOLL_OVERSEER
    set merc_unit[1] = ICE_TROLL_BERSERKER
    set merc_unit[2] = ICE_TROLL_TRAPPER
    set merc_unit[3] = MUD_GOLEM
    set merc_types[1] = 0
    set merc_types[2] = MUD_GOLEM
    set merc_types[3] = GNOLL_OVERSEER
    set merc_types[4] = ICE_TROLL_BERSERKER
    set merc_types[5] = ICE_TROLL_TRAPPER
    set merc_types[6] = 0
  elseif i == 10 then
    set merc_unit[0] = NERUBIAN_WARRIOR
    set merc_unit[1] = ICE_TROLL_BERSERKER
    set merc_unit[2] = FROST_REVENANT
    set merc_unit[3] = NERUBIAN_WEBSPINNER
    set merc_types[1] = 0
    set merc_types[2] = FROST_REVENANT
    set merc_types[3] = NERUBIAN_WARRIOR
    set merc_types[4] = ICE_TROLL_BERSERKER
    set merc_types[5] = NERUBIAN_WEBSPINNER
    set merc_types[6] = NERUBIAN_WARRIOR
  elseif i == 11 then
    set merc_unit[0] = BURNING_ARCHER
    set merc_unit[1] = KOBOLD_GEOMANCER
    set merc_unit[2] = WILDKIN
    set merc_unit[3] = 0
    set merc_types[1] = 0
    set merc_types[2] = KOBOLD_GEOMANCER
    set merc_types[3] = WILDKIN
    set merc_types[4] = BURNING_ARCHER
    set merc_types[5] = 0
    set merc_types[6] = BURNING_ARCHER
  elseif i == 12 then
    set merc_unit[0] = KOBOLD
    set merc_unit[1] = MURLOC_HUNTSMAN
    set merc_unit[2] = ASSASSIN
    set merc_unit[3] = KOBOLD_GEOMANCER
    set merc_types[1] = 0
    set merc_types[2] = KOBOLD_GEOMANCER
    set merc_types[3] = KOBOLD
    set merc_types[4] = ASSASSIN
    set merc_types[5] = MURLOC_HUNTSMAN
    set merc_types[6] = KOBOLD
  endif

  set merc_healer = merc_types[1]
  set merc_caster = merc_types[2]
  set merc_melee = merc_types[3]
  set merc_range = merc_types[4]
  set merc_stopper = merc_types[5]
  set merc_rush = merc_types[6]

  set merc_number = 0
  set j = 0
  loop
    exitwhen j >= 4
    if merc_unit[j] != 0 then
      set merc_number = merc_number + 1
    endif
    set j = j + 1
  endloop

  set neutral_id[NEUTRAL_MERC_CAMP] = camp[i]
  set neutral_available[NEUTRAL_MERC_CAMP] = true
endif

if roostfound then
  if not roostfound then
  elseif k == 1 then
    set dragons[1] = BLACK_DRAGON_1
    set dragons[2] = BLACK_DRAGON_2
    set dragons[3] = BLACK_DRAGON_3
  elseif k == 2 then
    set dragons[1] = BLUE_DRAGON_1
    set dragons[2] = BLUE_DRAGON_2
    set dragons[3] = BLUE_DRAGON_3
  elseif k == 3 then
    set dragons[1] = BRONZE_DRAGON_1
    set dragons[2] = BRONZE_DRAGON_2
    set dragons[3] = BRONZE_DRAGON_3
  elseif k == 4 then
    set dragons[1] = GREEN_DRAGON_1
    set dragons[2] = GREEN_DRAGON_2
    set dragons[3] = GREEN_DRAGON_3
  elseif k == 5 then
    set dragons[1] = RED_DRAGON_1
    set dragons[2] = RED_DRAGON_2
    set dragons[3] = RED_DRAGON_3
  endif
  set dragon_number = 3

  set neutral_id[NEUTRAL_DRAGON_ROOST] = roost[k]
  set neutral_available[NEUTRAL_DRAGON_ROOST] = true
endif

endfunction

function CheckAllNeutrals takes nothing returns nothing
  local integer i = 0

  loop
    exitwhen i >= NEUTRAL_COUNT
    call CheckNeutral(i)
    set i = i + 1
    call Sleep(0.1)
  endloop

endfunction

function CheckNeutralQuick takes integer nn returns nothing
if neutral_available[nn] == true then
  set neutral_ordered[nn] = false
  set neutral_sent[nn] = null
  set buy_time_large[nn] = -1
  set buy_time_small[nn] = -1

  set nearest_neutral[nn] = GetNearestNeutralQuick(nearest_neutral[nn],neutral_id[nn])
  set neutral_guards[nn] = GetCreepGuardGroup(neutral_guards[nn],nn)
  set neutral_guarded[nn] = GetNeutralGuard(nn)
  set neutral_night_buy[nn] = CanCreepGuardsSleep(nn)
  if neutral_guarded[nn] then
    call TQAddJob(30 * sleep_multiplier, NEUTRAL_GUARDED, nn)
    if nn == NEUTRAL_TAVERN and hero[1] != 0 and buy_type[hero[1]] == BT_NEUTRAL_HERO then  //guarantee to train Ownrace hero at the first time
      set recalculate_heros = true
    endif
  endif
endif
endfunction

function CheckAllNeutralsQuick takes nothing returns nothing
  local integer i = 0

  loop
    exitwhen i >= NEUTRAL_COUNT
    call CheckNeutralQuick(i)
    set i = i + 1
  endloop

  if nearest_neutral[NEUTRAL_HEALING_FOUNTAIN] != null then
    call TQAddJob(10, NEUTRAL_ENEMY_CHECK, NEUTRAL_HEALING_FOUNTAIN)
  endif
  if nearest_neutral[NEUTRAL_MANA_FOUNTAIN] != null then
    call TQAddJob(10, NEUTRAL_ENEMY_CHECK, NEUTRAL_MANA_FOUNTAIN)
  endif
  if nearest_neutral[NEUTRAL_POWER_FOUNTAIN] != null then
    call TQAddJob(10, NEUTRAL_ENEMY_CHECK, NEUTRAL_POWER_FOUNTAIN)
  endif
  if nearest_neutral[NEUTRAL_HEAL_WARD] != null then
    call TQAddJob(10, NEUTRAL_ENEMY_CHECK, NEUTRAL_HEAL_WARD)
  endif
 endfunction
function PathingThread takes nothing returns nothing
  local integer i = 0
  local integer t = 0
  call SetAIArray()
  //  set command_wait = 0.5
  //  set command_wait = 3
  call ComputeFrontPoints()
  //  call Sleep(3)
  if debugging then
     call PingFrontPoints()
  endif
  //set current_expansion = GetExpNearestMin(current_expansion)  // Rough guide to what first expansion should be
  call CheckAllNeutralsQuick() // Old system check
  call MakeExpansionList()
  set water_map = water_expansion_list_length >= expansion_list_length
  set active_expansion = water_expansion_list_length + expansion_list_length > c_enemy_total + c_ally_total + 1  // have more mine , should positive Expansion
  set first_expansion_chosen = first_expansion_chosen == true or (water_expansion_list_length > 0)  // no expansion but have water expansion , can take expansion
  call ChooseExpansion()
  call CheckFastExpansion()
  call CheckAllNeutrals() // The more advanced new system check
  set pathing_done = true
  loop // no need repeated run
    call Sleep(6 * sleep_multiplier)
    if active_expansion and exp_number < c_enemy_total + c_ally_total + 1 then
      set active_expansion = false
    endif
    if t == 5 then
      loop
        exitwhen i >= NEUTRAL_COUNT
        if neutral_guarded[i] then
          call NeutralGuardedJob(i)
        endif
        set i = i + 1
      endloop
      set t = 0
      set i = 0
    endif
    if nearest_neutral[NEUTRAL_HEALING_FOUNTAIN] != null then
      call NeutralEnemyCheckJob(NEUTRAL_HEALING_FOUNTAIN)
    endif
    if nearest_neutral[NEUTRAL_MANA_FOUNTAIN] != null then
      call NeutralEnemyCheckJob(NEUTRAL_MANA_FOUNTAIN)
    endif
    if nearest_neutral[NEUTRAL_POWER_FOUNTAIN] != null then
      call NeutralEnemyCheckJob(NEUTRAL_POWER_FOUNTAIN)
    endif
    if nearest_neutral[NEUTRAL_HEAL_WARD] != null then
      call NeutralEnemyCheckJob(NEUTRAL_HEAL_WARD)
    endif
    set t = t + 1
  endloop

endfunction

function QueueReset takes nothing returns nothing
  set queue_length 	= 0
  set queue_pointer	= 0
endfunction

function QueueRestart takes nothing returns nothing
  set queue_pointer	= 0
endfunction

function QueueGetNextUnit takes nothing returns unit
  return target_queue_u[queue_pointer]
endfunction

function QueueGetNextX takes nothing returns integer
  return target_queue_x[queue_pointer]
endfunction

function QueueGetNextY takes nothing returns integer
  return target_queue_y[queue_pointer]
endfunction

function QueuePopCommand takes nothing returns nothing
  set queue_pointer = queue_pointer + 1
endfunction

function QueueFinished takes nothing returns boolean
  return queue_pointer >= queue_length
endfunction

function QueueGetNextCommand takes nothing returns boolean
  if QueueFinished() then
    set queue_running = false
    call QueueReset()
    return false
  else
    set queue_t_u = QueueGetNextUnit()
    if queue_t_u == null then
      set queue_t_x = QueueGetNextX()
      set queue_t_y = QueueGetNextY()
      set queue_attack_p = true
      set queue_attack_u = false
    else
      set queue_attack_u = true
      set queue_attack_p = false
    endif
    call QueuePopCommand()
    return true
  endif
endfunction

function QueueSetCommand takes integer x, integer y, unit u returns nothing
  set target_queue_x[queue_length] = x
  set target_queue_y[queue_length] = y
  set target_queue_u[queue_length] = u
  set queue_length = queue_length + 1
endfunction

function QueueRemoveCommand takes nothing returns nothing
  set queue_length = queue_length - 1
endfunction

function cmd_cancel takes integer cmd, integer data returns nothing
  if cmd == 0 then		// Cancel all orders
    set break_attack = false
    set go_home = false
    set strategy = chosen_strategy
    set attack_player = false
    set attack_point = false
    set no_attack = false
    set no_creep_attack = false
    set no_player_attack = false
    set queue_running	= false
    call Trace("Cancel All command" )

  elseif cmd == 1 then	// Cancel build orders
    set strategy = chosen_strategy
    call Trace("Cancel Build Command" )

  elseif cmd == 2 then	// Cancel attacking orders
    set attack_player = false
    set attack_point = false
    set no_attack = false
    set no_creep_attack = false
    set no_player_attack = false
    set queue_running = false
    call Trace("Cancel Attack Command" )

  endif
endfunction

function cmd_attack takes integer cmd, integer data returns nothing
  local group gr = null
  if cmd == 10 then	// Stop the current attack
    set break_attack = true
    set go_home = true
    set queue_running = false
    set attack_player = false
    set attack_point = false
    call Trace("Stop Attack Command" )

  elseif cmd == 11 then	// Start no attacks
    set break_attack = true
    set no_attack = true
    call Trace("No Attacks Command" )
  elseif cmd == 12 then	// Attack specific player
    set break_attack = true
    set go_home = false
    set attack_target_p = data
    set attack_player = true
    set attack_point = false
    call Trace("Attack Player Command" )

  elseif cmd == 13 then	// Attack specific point
    call Trace("Attack Point Command" )
    loop
      exitwhen CommandsWaiting()!=0
      call Sleep(0.5)
    endloop
    set attack_target_x = GetLastCommand()
    set attack_target_y = GetLastData()
    set break_attack = true
    set go_home = false
    set attack_point = true
    set attack_player = false
    call PopLastCommand()
    call Trace("Attack Coordinates received" )

  elseif cmd == 14 then	// No attacks on creeps
    set no_creep_attack = true
    call Trace("Attack No Creeps" )

  elseif cmd == 15 then	// No attack on players
    set no_player_attack = true
    call Trace("Attack No Player" )

  elseif cmd == 16 then	// Attack selected unit
    set gr = CreateGroup()
    call GroupEnumUnitsSelected(gr, Player(data), null)
    set target_unit	= FirstOfGroup(gr)
    call DestroyGroup(gr)
    set gr = null
    if target_unit == null then
      call DisplayToAllies(chat_no_unit_selected)
    endif
    set attack_point = false
    set attack_player = false
    set attack_unit = true
    set break_attack = true
    set go_home = false
    call DisplayToAllies(chat_confirm_attack_unit)

  elseif cmd == 17 then // Towerrush
    if race_towerrush_available then
      call StartTowerRush(1)
      call DisplayToAllies(chat_towerrush)
      call DisplayToObservers( chat_towerrush )
    else
      call DisplayToAllies(chat_no_orc)
      call DisplayToObservers( chat_no_orc )
    endif

  endif
endfunction

function cmd_build takes integer cmd, integer data returns nothing
  if false then
  elseif cmd == 20 then
    set strategy = 50
    set bn_airair = data
  elseif cmd == 21 then
    set strategy = 51
    set bn_airground = data
  elseif cmd == 22 then
    set strategy = 52
    set bn_groundair = data
  elseif cmd == 23 then
    set strategy = 53
    set bn_groundground = data
  elseif cmd == 24 then
    set strategy = 54
    set bn_farm = data
  elseif cmd == 25 then
    set strategy = 55
    set bn_guard = data
  endif
endfunction

function cmd_queue takes integer cmd, integer data returns nothing
  local group gr = null
  if cmd == 30 then	// Cancel queue
    call QueueReset()
    set queue_running = false
    call Trace("Cancel Queue Command" )

  elseif cmd == 31 then	// Queue Attack specific point
    call Trace("Queue Attack Point Command" )
    loop
      exitwhen CommandsWaiting()!=0
      call Sleep(0.5)
    endloop
    call QueueSetCommand(GetLastCommand(), GetLastData(), null)
    call PopLastCommand()
    call Trace("Attack Coordinates received" )

  elseif cmd == 32 then	// Queue Attack selected unit
    set gr = CreateGroup()
    call GroupEnumUnitsSelected(gr, Player(data), null)
    if FirstOfGroup(gr) == null then
      call DisplayToAllies(chat_no_unit_selected)
    else
      call QueueSetCommand(0,0, FirstOfGroup(gr))
      call DisplayToAllies(chat_confirm_attack_unit)
    endif
    call DestroyGroup(gr)
    set gr = null

  elseif cmd == 33 then	// Starting or Restarting queue
    call QueueRestart()
    if QueueGetNextCommand() then
      set queue_running = true
      set no_attack = false
      call Trace("Queue started" )
    else
      call Trace("Queue is empty" )
    endif

  elseif cmd == 34 then	// Pausing queue
    set queue_running = false

  elseif cmd == 35 then	// Unpausing queue
    set queue_running = true

  elseif cmd == 36 then	// Removing last command
    call QueueRemoveCommand()

  endif
endfunction

function cmd_misc takes integer cmd, integer data returns nothing
  if cmd == 50 then	// Triggering chat
    set chatting = not chatting

  elseif cmd == 51 then	// Triggering debug
    set debugging = not debugging

  elseif cmd == 52 then	// Triggering balancing
    set balancing = not balancing

  elseif cmd == 53 then
    set strat_change_allowed = not strat_change_allowed

  elseif cmd == 60 then // Show strat name
    call DisplayToAllies(GetCurrentStrategyReport() + GetCurrentDynamicReport())

  elseif cmd == 61 then // Show all strats
    call DisplayStratNames()

  elseif cmd == 70 then // change strategy
    if data < rp_strat_length then
      set strategy = data
      set chosen_strategy = strategy
    else
      call DisplayToAllies(invalid_strategy_number)
    endif

  elseif cmd == 71 then // change language
    if false then
    elseif data == 0 then
      set language = "English"
    elseif data == 1 then
      set language = "Deutsch"
    elseif data == 2 then
      set language = "Swedish"
    elseif data == 3 then
      set language = "French"
    elseif data == 4 then
      set language = "Spanish"
    elseif data == 5 then
      set language = "Romanian"
    elseif data == 6 then
      set language = "Russian"
    elseif data == 7 then
      set language = "Portuguese"
    elseif data == 8 then
      set language = "Norwegian"
    elseif data == 9 then
      set language = "Chinese"
    endif
    call InitChatArrays()
  endif
endfunction

function cmd_loop takes nothing returns nothing
  local integer cmd = 0
  local integer data = 0
  call StaggerSleep(0,3)
  call Trace("Starting Commander Thread Loop" )
  
  loop
    loop
      exitwhen CommandsWaiting()!=0
      exitwhen player_defeated
      call Sleep(command_wait * sleep_multiplier)
    endloop
    exitwhen player_defeated
    set cmd = GetLastCommand()
    set data = GetLastData()
    call PopLastCommand()
    call Trace("Receiving command" )

    if cmd < 10 then
      call cmd_cancel(cmd, data)

    elseif cmd < 20 then
      call cmd_attack(cmd, data)

    elseif cmd < 30 then
      call cmd_build(cmd, data)

    elseif cmd < 40 then
      call cmd_queue(cmd, data)

    else
      call cmd_misc(cmd, data)

    endif

  endloop

endfunction

function InitCheckHarvest takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  local integer i = GOLD_MINE
  local integer c = 0
  local integer p = 1
  local real check = 0
  local real distance = 0
  if race_manual_loading then
    set i = race_manual_loading_mine
  elseif race_uses_mine_expansion then
    set i = racial_expansion
  endif
  call GroupEnumUnitsInRangeOfLoc(g, home_location, 1600, null)
  set g = SelectByAlive(g,true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetResourceAmount(u) > 0 then
      if GetUnitTypeId(u) == old_id[GOLD_MINE] then
        set check = DistanceBetweenPoints_kd(home_location,GetUnitLoc(u))  // human and orc need find closest mine
        if check <= distance then
          set distance = check
          set own_town_mine[0] = u  // fix home_location mine
        endif
        set c = c + 1
      else
        if i != GOLD_MINE and GetUnitTypeId(own_town_mine[0]) == old_id[GOLD_MINE] then
           set own_town_mine[0] = u  // fix home_location mine
        endif
      endif
    endif
    if (IsUnitType(u, UNIT_TYPE_TOWNHALL) or GetUnitTypeId(u) == old_id[racial_expansion]) and GetOwningPlayer(u) != ai_player then
      set p = p + 1  // have more player , need fix harvest , but maybe no need fix expensive
    endif
    call GroupRemoveUnit(g, u)
  endloop
  if p > 1 then  // more mine and more player
    if c == p and i != GOLD_MINE then
      set first_town_mine = 1 // mode one , one player have one mine , and this mine too close (like (4)synergybigpaved.w3x) , just fix UD and ELF harvest
    elseif c > p then
      set first_town_mine = 2  // mode two , one player have more mine , fix UD and ELF harvest and all race expensive - prior take closest home_location mine
    endif
  elseif c > p then // more mine and one player
    set first_town_mine = 3 // mode three , one player have this mine , fix all race harvest and expensive - prior take closest home_location mine
  endif
  if first_town_mine == 0 and i != GOLD_MINE then
    set first_town_mine = 1  // just one mine , but now cannot harvest , need fix UD harvest
    // some map home_location 1500 radius just one mine , but old war3 (maybe 1.24~1.28 , 1.36 no this bug) UD and ELF still cannot harvest(maybe need 2300 radius no more mine)
  endif
  call DestroyGroup(g)
  set g = null
  call HarvestGold(0,3)
  call HarvestWood(0,2)  // Early triggering Harvest , convenient HARVEST_CHECK job check peon
endfunction

function InitTownBuilt takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i >= max_towns
    set town_built[i] = false
    set i = i + 1
  endloop
  set town_built[0] = true
  set own_town_loc[0] = Location(GetLocationX(home_location), GetLocationY(home_location))
  set exist_town[0] = home_location
  set own_town_dist[0] = 0
  set own_town_mine[0] = GetMineNearLoc(own_town_mine[0] ,home_location, 1500)
endfunction

function GetBuildLock takes nothing returns nothing
    loop
      exitwhen build_lock
      //call Trace("Build Lock not received")
      call Sleep(0.5)
    endloop
    set build_lock = false
endfunction

function ReleaseBuildLock takes nothing returns nothing
    set build_lock = true
endfunction

function InitUpkeep takes nothing returns nothing
  set upkeep_allowed[UPKEEP_LOW] = UPKEEP_UNDECIDED
  set upkeep_border[UPKEEP_LOW] = 40
  set upkeep_resistance[UPKEEP_LOW] = 500
  set upkeep_save_time[UPKEEP_LOW] = 12
  set upkeep_mines_needed[UPKEEP_LOW] = 0
  set upkeep_time[UPKEEP_LOW] = -1
  set upkeep_allowed[UPKEEP_HIGH] = UPKEEP_UNDECIDED
  set upkeep_border[UPKEEP_HIGH] = 70
  set upkeep_resistance[UPKEEP_HIGH] = 2000
  set upkeep_save_time[UPKEEP_HIGH] = 40
  set upkeep_mines_needed[UPKEEP_HIGH] = 2
  set upkeep_time[UPKEEP_HIGH] = -1
endfunction

function InitLastUpkeep takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    set last_upkeep_allowed[i] = UPKEEP_UNDECIDED
    set i = i + 1
  endloop
endfunction

function CheckUpkeepAllowed takes integer food returns nothing
  local integer mines = GetMinesOwned()
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    if food > upkeep_border[i] then
      set upkeep_allowed[i] = UPKEEP_ALLOWED
    elseif mines < upkeep_mines_needed[i] then
      set upkeep_allowed[i] = UPKEEP_NOT_ALLOWED
      set last_upkeep_allowed[i] = UPKEEP_NOT_ALLOWED
      set upkeep_time[i] = -1
    else
      set upkeep_allowed[i] = UPKEEP_UNDECIDED
    endif
    set i = i + 1
  endloop
endfunction

function ApplyUpkeepCheck takes integer afford_food, integer food, integer food_cost, integer cost_qty, integer need_qty returns integer
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    if food + food_cost * cost_qty > upkeep_border[i] then
      if upkeep_allowed[i] == UPKEEP_UNDECIDED then
        if total_gold > upkeep_resistance[i] then
          set upkeep_allowed[i] = UPKEEP_ALLOWED
        else
          set upkeep_allowed[i] = UPKEEP_NOT_ALLOWED
        endif
      endif
      if upkeep_allowed[i] == UPKEEP_NOT_ALLOWED then
        if food_cost == 0 then
          set afford_food = need_qty
        else
          set afford_food = Max(upkeep_border[i] - food, 0) / food_cost
        endif
      endif
    endif
    set i = i + 1
  endloop
  return afford_food
endfunction

function ApplyUpkeepSaving takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    if upkeep_allowed[i] == UPKEEP_ALLOWED then
      set upkeep_time[i] = -1
    elseif last_upkeep_allowed[i] == UPKEEP_UNDECIDED and upkeep_allowed[i] == UPKEEP_NOT_ALLOWED then
      if upkeep_time[i] == -1 then
        if total_gold > 0 and total_wood > 0 then
          set upkeep_time[i] = ai_time
        endif
      elseif use_linear_upkeep_saving then
        set total_gold = total_gold - R2I(LinearInterpolation(upkeep_time[i], upkeep_time[i] + upkeep_save_time[i], 0, upkeep_resistance[i], ai_time))
      elseif ai_time >= upkeep_time[i] + upkeep_save_time[i] then
        set total_gold = total_gold - upkeep_resistance[i]
      endif
    endif
    set i = i + 1
  endloop
endfunction

function UpdateLastUpkeep takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    set last_upkeep_allowed[i] = upkeep_allowed[i]
    set i = i + 1
  endloop
endfunction

function ResetUpkeepSaveTime takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    if upkeep_allowed[i] == UPKEEP_UNDECIDED then
      set upkeep_time[i] = -1
    endif
    set i = i + 1
  endloop
endfunction

function InitBuildArrayAM takes nothing returns nothing
    local integer i = 0
    call GetBuildLock()
    set build_length = 0
    loop
      exitwhen i >= building_length
      set income_percentage[building[i]] = 1 / I2R(building_length)
      set i = i + 1
    endloop
    call ReleaseBuildLock()
endfunction

function InitUpgradeTimeArray takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > OBJECT_NUM
    set upgrade_time[i] = -1
    set i = i + 1
  endloop
endfunction

function InitPlayerStrengthCache takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= GetBJMaxPlayers()
    set p_str_cache[i] = 0
    set p_str_cache_timeout[i] = 0
    set i = i + 1
  endloop
endfunction

function InitHeroArrays takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > 3
    set hero[i] = 0
    set hero_built[i] = false
    set hero_unit[i] = null
    set i = i + 1
  endloop
  set hero_revive_prio[1] = hero1_revive_prio
  set hero_revive_prio[2] = hero2_revive_prio
  set hero_revive_prio[3] = hero3_revive_prio
endfunction

function InitNeutralSpecial takes nothing returns nothing
  set neutral_zeppelin = ZEPPELIN
  set neutral_shredder = SHREDDER
  set tp_item = TOWN_PORTAL
endfunction

function InitCreepStrengthArray takes nothing returns nothing
endfunction

function InitGlobalSettings takes nothing returns nothing
  set sleep_multiplier = 1
  set slm_start = 4
  set slm_end = 10
  set slm_start_mult = 1
  set slm_end_mult = 2
  set hero_radius = 200
  set use_linear_upkeep_saving = false
  set repair_threshold = 6
  set repair_threshold_threatened = 8
  set max_follow_dist = 1000
  set neutral_hero_time = 25
  set buy_distance = 350
  set buy_timeout_large = 120
  set buy_timeout_small = 15
  set build_array_reset_time = 100
  set rp_strat_normal = 250
  set strategy_tier_bonus = 35
  set attacking_strategy = 4
  set focus_fire_limit = 35
  set focus_fire_ranged_dist = 600
  set focus_fire_melee_dist = 50
  set flee_health_percentage = 0.25
  set flee_minimum_health = 100
  set statue_distance = 300
  set teleport_radius = 800
  set gold_exchange_level = 650
  set wood_exchange_level = 350
  set max_towns = 5
  set add_tag = true
  set add_skill = false
  set fav_hero_add  = 20
  set max_harass_groups = 10
  set attacking_aggression = 1
  set expansion_radius = 1000
  set harass_radius_attack_ranged = 800
  set harass_radius_attack_melee = 400
  set harass_radius_flee_ranged = 1200
  set harass_radius_flee_melee = 800
  set chatting = true
  set full_threat_distance = 600
  set no_threat_distance = 3000
  set distance_threat_exponent = 0.8
  set distance_threat_mult = 540
  set atl_time_start = 300
  set atl_time_end = 900
  set atl_time_start_val = 10
  set atl_time_end_val = 20
  set atl_enemy_start = 1
  set atl_enemy_end = 4
  set atl_enemy_start_mult = 1
  set atl_enemy_end_mult = 1.5
  set teleport_low_threat = 70
  set teleport_high_threat = 120
  set teleport_low_threat_distance = 5000
  set teleport_high_threat_distance = 3000
  set teleport_army_min_strength = 20
  set teleport_min_threat = 70
  set shredder_peon_count = 6
  set minimum_peon_wood = 2000
  set maximum_peon_wood = 200
  set ver_neutral_heroes_available = false
  set ver_neutral_hero_number = 0
  set ver_only_heroes_buy = true
  set ver_food_limit = 90
  set normal_battle_radius = 1500
  set creep_battle_radius = 750
  set expansion_taken_radius = 1000
  set ver_strat_change_enemy_strength_min = 25
  set ver_hero_base_value = 4
  set ver_hero_ultimate_level = 6
  set ver_hero_ultimate_value = 4
  set ver_creeps_attack_buildings_dist = 1500
  set ver_mercs_night_buy = false
  set ver_tower_check_radius = 2000
  set ver_harass_tower_check_radius = 1400
  set destroy_buildings_on_defeat = true
  set attack_reform_length = 10
  set ver_heroes = true
  set front_base_distance = difficulty * 50 + 1100
  set fixedcomputername = false
  set debugging = false
  set front_base_distance = 1100
  set green_creep_camp_strength_bonus = 0
  set orange_creep_camp_strength_bonus = 2
  set red_creep_camp_strength_bonus = 4
  set strategy_change_threshold = 1.05
  set disable_surrender = false
  set minor_hero_skill_value = 30
  set rare_hero_skill_value = 10
  set major_hero_skill_value = 60
  set ver_optimal_gold = 5
  set fav_hero_add = 20
  set ver_flee_multiple1 = 1
  set ver_flee_multiple2 = 2
  set ver_flee_multiple3 = 3
  set ver_low_aggression = -15
  set ver_high_aggression = 45
  if racial_lumber == 0 or race_no_wood_harvest then
    set front_base_distance = front_base_distance + 100
  endif
endfunction

function IsGameFFA takes nothing returns boolean
  local boolean array team_exists
  local integer i = 0
  local integer tc = 0
  loop
    exitwhen i >= GetBJMaxPlayers()
    set team_exists[i] = false
    set i = i + 1
  endloop
  set i = 0
  loop
    exitwhen i >= GetBJMaxPlayers()
    if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then
      set team_exists[GetPlayerTeam(Player(i))] = true
    endif
    set i = i + 1
  endloop
  set i = 0
  loop
    exitwhen i >= GetBJMaxPlayers()
    if team_exists[i] then
      set tc = tc + 1
    endif
    set i = i + 1
  endloop
  return tc > 3
endfunction


function InitRaceNames takes nothing returns nothing
  set race_name[1] = "ELF"
  set race_name[2] = "HUMAN"
  set race_name[3] = "ORC"
  set race_name[4] = "UNDEAD"
endfunction

function InitSpecialRaces takes nothing returns nothing
  local integer i = 0
  local string s = null
  loop
    exitwhen i >= GetBJMaxPlayers()
    set s = Int2Str(i)
    set player_race[i] = LoadInteger(com, RACE, i)
    set player_race_pref[i] = LoadInteger(com, RACE_PREF, i)
    set i = i + 1
  endloop
  set s = null
endfunction

function InitStandardRaces takes nothing returns nothing
  local integer i = 0
  local player p = null
  loop
    exitwhen i >= GetBJMaxPlayers()
    set p = Player(i)
    if GetPlayerRace(p) == RACE_NIGHTELF then
      set player_race[i] = SR_ELF
      if IsPlayerRacePrefSet(p, RACE_PREF_NIGHTELF) then
        set player_race_pref[i] = SR_ELF
      else
        set player_race_pref[i] = SR_RANDOM
      endif
    elseif GetPlayerRace(p) == RACE_HUMAN then
      set player_race[i] = SR_HUMAN
      if IsPlayerRacePrefSet(p, RACE_PREF_HUMAN) then
        set player_race_pref[i] = SR_HUMAN
      else
        set player_race_pref[i] = SR_RANDOM
      endif
    elseif GetPlayerRace(p) == RACE_ORC then
      set player_race[i] = SR_ORC
      if IsPlayerRacePrefSet(p, RACE_PREF_ORC) then
        set player_race_pref[i] = SR_ORC
      else
        set player_race_pref[i] = SR_RANDOM
      endif
    else
      set player_race[i] = SR_UNDEAD
      if IsPlayerRacePrefSet(p, RACE_PREF_UNDEAD) then
        set player_race_pref[i] = SR_UNDEAD
      else
        set player_race_pref[i] = SR_RANDOM
      endif
    endif
    set i = i + 1
  endloop
  set p = null
endfunction

function InitRaces takes nothing returns nothing
  if LoadBoolean(com, USE_SPECIAL_RACES, StringHash("Special")) then
    call InitSpecialRaces()
  else
    call InitStandardRaces()
  endif
endfunction

function GetMaxFarms takes nothing returns integer
  local integer fm = GetFoodMade(old_id[racial_farm])
  local integer div = ver_food_limit / fm
  if div * fm < ver_food_limit then
    set div = div + 1
  endif
  return div
endfunction



function InitAMAI takes nothing returns nothing
  if debugging and IsPlayerObserver(GetLocalPlayer()) then
    call SetPlayerAlliance(ai_player, GetLocalPlayer(), ALLIANCE_HELP_REQUEST,  true)
    call SetPlayerAlliance(ai_player, GetLocalPlayer(), ALLIANCE_HELP_RESPONSE, true)
    call SetPlayerAlliance(ai_player, GetLocalPlayer(), ALLIANCE_SHARED_XP,     true)
    call SetPlayerAlliance(ai_player, GetLocalPlayer(), ALLIANCE_SHARED_SPELLS, true)
    call SetPlayerAlliance(ai_player, GetLocalPlayer(), ALLIANCE_SHARED_VISION, true)
    call SetPlayerAlliance(ai_player, GetLocalPlayer(), ALLIANCE_SHARED_CONTROL, true)
    call SetPlayerAlliance(ai_player, GetLocalPlayer(), ALLIANCE_SHARED_ADVANCED_CONTROL, true)
  endif
  set unitNames[1] = "ARCHMAGE"
  set unitNames[2] = "PALADIN"
  set unitNames[3] = "MTN_KING"
  set unitNames[4] = "BLADE_MASTER"
  set unitNames[5] = "FAR_SEER"
  set unitNames[6] = "TAUREN_CHIEF"
  set unitNames[7] = "DEATH_KNIGHT"
  set unitNames[8] = "DREAD_LORD"
  set unitNames[9] = "LICH"
  set unitNames[10] = "DEMON_HUNTER"
  set unitNames[11] = "KEEPER"
  set unitNames[12] = "MOON_PRIESTESS"
  set unitNames[13] = "COPTER"
  set unitNames[14] = "ELEMENTAL"
  set unitNames[15] = "FOOTMAN"
  set unitNames[16] = "GRYPHON"
  set unitNames[17] = "KNIGHT"
  set unitNames[18] = "MORTAR"
  set unitNames[19] = "PEASANT"
  set unitNames[20] = "PRIEST"
  set unitNames[21] = "RIFLEMAN"
  set unitNames[22] = "SORCERESS"
  set unitNames[23] = "STEAM_TANK"
  set unitNames[24] = "MILITIA"
  set unitNames[25] = "AVIARY"
  set unitNames[26] = "BARRACKS"
  set unitNames[27] = "BLACKSMITH"
  set unitNames[28] = "CANNON_TOWER"
  set unitNames[29] = "CASTLE"
  set unitNames[30] = "GUARD_TOWER"
  set unitNames[31] = "HOUSE"
  set unitNames[32] = "HUMAN_ALTAR"
  set unitNames[33] = "KEEP"
  set unitNames[34] = "LUMBER_MILL"
  set unitNames[35] = "SANCTUM"
  set unitNames[36] = "TOWN_HALL"
  set unitNames[37] = "WATCH_TOWER"
  set unitNames[38] = "WORKSHOP"
  set unitNames[39] = "UPG_SIGHT"
  set unitNames[40] = "UPG_DEFEND"
  set unitNames[41] = "UPG_HAMMERS"
  set unitNames[42] = "UPG_BREEDING"
  set unitNames[43] = "UPG_GUN_RANGE"
  set unitNames[44] = "UPG_SENTINEL"
  set unitNames[45] = "UPG_BOMBS"
  set unitNames[46] = "CATAPULT"
  set unitNames[47] = "WITCH_DOCTOR"
  set unitNames[48] = "GRUNT"
  set unitNames[49] = "HEAD_HUNTER"
  set unitNames[50] = "KODO_BEAST"
  set unitNames[51] = "PEON"
  set unitNames[52] = "RAIDER"
  set unitNames[53] = "SHAMAN"
  set unitNames[54] = "TAUREN"
  set unitNames[55] = "WYVERN"
  set unitNames[56] = "ORC_ALTAR"
  set unitNames[57] = "ORC_BARRACKS"
  set unitNames[58] = "BESTIARY"
  set unitNames[59] = "FORGE"
  set unitNames[60] = "FORTRESS"
  set unitNames[61] = "GREAT_HALL"
  set unitNames[62] = "LODGE"
  set unitNames[63] = "STRONGHOLD"
  set unitNames[64] = "BURROW"
  set unitNames[65] = "TOTEM"
  set unitNames[66] = "ORC_WATCH_TOWER"
  set unitNames[67] = "UPG_ORC_WAR_DRUMS"
  set unitNames[68] = "UPG_ORC_PILLAGE"
  set unitNames[69] = "UPG_ORC_BERSERK"
  set unitNames[70] = "UPG_ORC_PULVERIZE"
  set unitNames[71] = "UPG_ORC_ENSNARE"
  set unitNames[72] = "UPG_ORC_VENOM"
  set unitNames[73] = "UPG_ORC_REGEN"
  set unitNames[74] = "ABOMINATION"
  set unitNames[75] = "ACOLYTE"
  set unitNames[76] = "BANSHEE"
  set unitNames[77] = "CRYPT_FIEND"
  set unitNames[78] = "FROST_WYRM"
  set unitNames[79] = "GARGOYLE"
  set unitNames[80] = "GARGOYLE_MORPH"
  set unitNames[81] = "GHOUL"
  set unitNames[82] = "MEAT_WAGON"
  set unitNames[83] = "NECRO"
  set unitNames[84] = "SKEL_WARRIOR"
  set unitNames[85] = "SHADE"
  set unitNames[86] = "UNDEAD_MINE"
  set unitNames[87] = "UNDEAD_ALTAR"
  set unitNames[88] = "BONEYARD"
  set unitNames[89] = "NECROPOLIS_1"
  set unitNames[90] = "NECROPOLIS_2"
  set unitNames[91] = "NECROPOLIS_3"
  set unitNames[92] = "SAC_PIT"
  set unitNames[93] = "CRYPT"
  set unitNames[94] = "SLAUGHTERHOUSE"
  set unitNames[95] = "DAMNED_TEMPLE"
  set unitNames[96] = "ZIGGURAT_1"
  set unitNames[97] = "ZIGGURAT_2"
  set unitNames[98] = "GRAVEYARD"
  set unitNames[99] = "UPG_CANNIBALIZE"
  set unitNames[100] = "UPG_GHOUL_FRENZY"
  set unitNames[101] = "UPG_FIEND_WEB"
  set unitNames[102] = "UPG_STONE_FORM"
  set unitNames[103] = "UPG_WYRM_BREATH"
  set unitNames[104] = "UPG_SKEL_LIFE"
  set unitNames[105] = "UPG_PLAGUE"
  set unitNames[106] = "WISP"
  set unitNames[107] = "ARCHER"
  set unitNames[108] = "DRUID_TALON"
  set unitNames[109] = "DRUID_TALON_M"
  set unitNames[110] = "BALLISTA"
  set unitNames[111] = "DRUID_CLAW"
  set unitNames[112] = "DRUID_CLAW_M"
  set unitNames[113] = "DRYAD"
  set unitNames[114] = "HIPPO"
  set unitNames[115] = "HIPPO_RIDER"
  set unitNames[116] = "HUNTRESS"
  set unitNames[117] = "CHIMAERA"
  set unitNames[118] = "ANCIENT_LORE"
  set unitNames[119] = "ANCIENT_WAR"
  set unitNames[120] = "ANCIENT_WIND"
  set unitNames[121] = "TREE_AGES"
  set unitNames[122] = "TREE_ETERNITY"
  set unitNames[123] = "TREE_LIFE"
  set unitNames[124] = "ANCIENT_PROTECT"
  set unitNames[125] = "ELF_ALTAR"
  set unitNames[126] = "CHIMAERA_ROOST"
  set unitNames[127] = "HUNTERS_HALL"
  set unitNames[128] = "MOON_WELL"
  set unitNames[129] = "ELF_MINE"
  set unitNames[130] = "UPG_ULTRAVISION"
  set unitNames[131] = "UPG_BLESSING"
  set unitNames[132] = "UPG_SCOUT"
  set unitNames[133] = "UPG_GLAIVE"
  set unitNames[134] = "UPG_BOWS"
  set unitNames[135] = "UPG_MARKSMAN"
  set unitNames[136] = "UPG_ABOLISH"
  set unitNames[137] = "UPG_CHIM_ACID"
  set unitNames[138] = "UPG_HIPPO_TAME"
  set unitNames[139] = "UPG_BOLT"
  set unitNames[140] = "UPG_MARK_CLAW"
  set unitNames[141] = "UPG_MARK_TALON"
  set unitNames[142] = "UPG_MELEE"
  set unitNames[143] = "UPG_RANGED"
  set unitNames[144] = "UPG_ARMOR"
  set unitNames[145] = "UPG_LEATHER"
  set unitNames[146] = "UPG_MASONRY"
  set unitNames[147] = "UPG_WOOD"
  set unitNames[148] = "UPG_PRAYING"
  set unitNames[149] = "UPG_SORCERY"
  set unitNames[150] = "UPG_ORC_MELEE"
  set unitNames[151] = "UPG_ORC_RANGED"
  set unitNames[152] = "UPG_ORC_ARMOR"
  set unitNames[153] = "UPG_ORC_SPIKES"
  set unitNames[154] = "UPG_ORC_DOCS"
  set unitNames[155] = "UPG_ORC_SHAMAN"
  set unitNames[156] = "UPG_UNHOLY_STR"
  set unitNames[157] = "UPG_CR_ATTACK"
  set unitNames[158] = "UPG_UNHOLY_ARMOR"
  set unitNames[159] = "UPG_CR_ARMOR"
  set unitNames[160] = "UPG_NECROS"
  set unitNames[161] = "UPG_BANSHEE"
  set unitNames[162] = "UPG_STR_MOON"
  set unitNames[163] = "UPG_STR_WILD"
  set unitNames[164] = "UPG_MOON_ARMOR"
  set unitNames[165] = "UPG_HIDES"
  set unitNames[166] = "UPG_DRUID_TALON"
  set unitNames[167] = "UPG_DRUID_CLAW"
  set unitNames[168] = "HEALING_POTION"
  set unitNames[169] = "MANA_POTION"
  set unitNames[170] = "CIRCLET_OF_NOBILITY"
  set unitNames[171] = "PERIAPT_OF_VITALITY"
  set unitNames[172] = "BOOTS_OF_SPEED"
  set unitNames[173] = "M_SCROLL_OF_HEALING"
  set unitNames[174] = "SCROLL_OF_PROTECTION"
  set unitNames[175] = "TOWN_PORTAL"
  set unitNames[176] = "POTION_OF_INVISIBILITY"
  set unitNames[177] = "POTION_OF_LESSER_INVULNERBILITY"
  set unitNames[178] = "SATYR_SHADOWDANCER"
  set unitNames[179] = "FURBOLG_SHAMAN"
  set unitNames[180] = "THUNDER_LIZARD"
  set unitNames[181] = "CENTAUR_OUTRUNNER"
  set unitNames[182] = "HARPY_ROGUE"
  set unitNames[183] = "RAZORMANE_MEDICINE_MAN"
  set unitNames[184] = "HARPY_WINDWITCH"
  set unitNames[185] = "FEL_BEAST"
  set unitNames[186] = "DRAENEI_DISCIPLE"
  set unitNames[187] = "VOIDWALKER"
  set unitNames[188] = "DRAENEI_DARKSLAYER"
  set unitNames[189] = "ROGUE"
  set unitNames[190] = "ASSASSIN"
  set unitNames[191] = "KOBOLD_GEOMANCER"
  set unitNames[192] = "FOREST_TROLL_HIGH_PRIEST"
  set unitNames[193] = "BURNING_ARCHER"
  set unitNames[194] = "WILDKIN"
  set unitNames[195] = "MURLOC_FLESHEATER"
  set unitNames[196] = "SLUDGE_FLINGER"
  set unitNames[197] = "SATYR_SOULSTEALER"
  set unitNames[198] = "BARBED_ARACHNATHID"
  set unitNames[199] = "BLUE_DRAGONSPAWN_MEDDLER"
  set unitNames[200] = "MAGNATAUR_WARRIOR"
  set unitNames[201] = "POLAR_FURBOLG_SHAMAN"
  set unitNames[202] = "GNOLL_BRUTE"
  set unitNames[203] = "GNOLL_WARDEN"
  set unitNames[204] = "OGRE_MAGI"
  set unitNames[205] = "MUD_GOLEM"
  set unitNames[206] = "FOREST_TROLL_BERSERKER"
  set unitNames[207] = "FOREST_TROLL_SHADOW_PRIEST"
  set unitNames[208] = "OGRE_MAULER"
  set unitNames[209] = "GNOLL_OVERSEER"
  set unitNames[210] = "ICE_TROLL_BERSERKER"
  set unitNames[211] = "ICE_TROLL_TRAPPER"
  set unitNames[212] = "NERUBIAN_WARRIOR"
  set unitNames[213] = "FROST_REVENANT"
  set unitNames[214] = "NERUBIAN_WEBSPINNER"
  set unitNames[215] = "MURGUL_SNARECASTER"
  set unitNames[216] = "MAKRURA_SNAPPER"
  set unitNames[217] = "MAKRURA_DEEPSEER"
  set unitNames[218] = "GIANT_SEA_TURTLE"
  set unitNames[219] = "KOBOLD"
  set unitNames[220] = "MURLOC_HUNTSMAN"
  set unitNames[221] = "BLACK_DRAGON_1"
  set unitNames[222] = "BLACK_DRAGON_2"
  set unitNames[223] = "BLACK_DRAGON_3"
  set unitNames[224] = "BLUE_DRAGON_1"
  set unitNames[225] = "BLUE_DRAGON_2"
  set unitNames[226] = "BLUE_DRAGON_3"
  set unitNames[227] = "BRONZE_DRAGON_1"
  set unitNames[228] = "BRONZE_DRAGON_2"
  set unitNames[229] = "BRONZE_DRAGON_3"
  set unitNames[230] = "GREEN_DRAGON_1"
  set unitNames[231] = "GREEN_DRAGON_2"
  set unitNames[232] = "GREEN_DRAGON_3"
  set unitNames[233] = "NETHER_DRAGON_1"
  set unitNames[234] = "NETHER_DRAGON_2"
  set unitNames[235] = "NETHER_DRAGON_3"
  set unitNames[236] = "RED_DRAGON_1"
  set unitNames[237] = "RED_DRAGON_2"
  set unitNames[238] = "RED_DRAGON_3"
  set unitNames[239] = "ZEPPELIN"
  set unitNames[240] = "SAPPER"
  set unitNames[241] = "SHREDDER"
  set unitNames[242] = "GOLD_MINE"
  set unitNames[243] = "JAINA"
  set unitNames[244] = "MURADIN"
  set unitNames[245] = "CHURCH"
  set unitNames[246] = "MAGE_TOWER"
  set unitNames[247] = "GROM"
  set unitNames[248] = "THRALL"
  set unitNames[249] = "PIG_FARM"
  set unitNames[250] = "CHAOS_GRUNT"
  set unitNames[251] = "CHAOS_WARLOCK"
  set unitNames[252] = "CHAOS_RAIDER"
  set unitNames[253] = "CHAOS_PEON"
  set unitNames[254] = "CHAOS_KODO"
  set unitNames[255] = "CHAOS_GROM"
  set unitNames[256] = "CHAOS_BLADEMASTER"
  set unitNames[257] = "CHAOS_BURROW"
  set unitNames[258] = "MALGANIS"
  set unitNames[259] = "TICHONDRIUS "
  set unitNames[260] = "PIT_LORD"
  set unitNames[261] = "SYLVANUS"
  set unitNames[262] = "CENARIUS"
  set unitNames[263] = "ILLIDAN"
  set unitNames[264] = "ILLIDAN_DEMON"
  set unitNames[265] = "MAIEV"
  set unitNames[266] = "HIGH_ARCHER "
  set unitNames[267] = "HIGH_FOOTMAN"
  set unitNames[268] = "HIGH_FOOTMEN"
  set unitNames[269] = "HIGH_SWORDMAN"
  set unitNames[270] = "DRAGON_HAWK"
  set unitNames[271] = "CORRUPT_TREANT"
  set unitNames[272] = "POISON_TREANT"
  set unitNames[273] = "PLAGUE_TREANT"
  set unitNames[274] = "SHANDRIS"
  set unitNames[275] = "ELF_FARM"
  set unitNames[276] = "ELF_GUARD_TOWER"
  set unitNames[277] = "HIGH_SKY"
  set unitNames[278] = "HIGH_EARTH"
  set unitNames[279] = "HIGH_TOWER"
  set unitNames[280] = "ELF_HIGH_BARRACKS"
  set unitNames[281] = "CORRUPT_LIFE"
  set unitNames[282] = "CORRUPT_WELL"
  set unitNames[283] = "CORRUPT_PROTECTOR"
  set unitNames[284] = "CORRUPT_WAR"
  set unitNames[285] = "UPG_ORC_CHAOS"
  set message_add = c2s(GetPlayerColor(ai_player))
  if race_militia_available then
    set militia_hall = GetMilitiaHall(militia_hall)
  endif
  call InitDigits()
  set ai_id = Int2Str(GetAiPlayer())
  call SaveBoolean(com, IS_AMAI, GetAiPlayer(), true)	
  call InitRaces()
  if IsGameFFA() then
    set game_is_ffa = true
    set attacking_strategy = 5
  endif
  call countAllyEnemy()
  if c_enemy_total == 1 and c_ally_total == 0 then
    set game_is_1on1 = true
  endif
  set sleep_multiplier = sleep_multiplier * LinearInterpolation(I2R(slm_start), I2R(slm_end), slm_start_mult, slm_end_mult, I2R(c_ai_total))
  set difficulty = MeleeDifficulty()
  set income_per_mine = income_per_mine * Max(difficulty - 1, 1)
  call Trace("Init AMAI step 1")
  call InitNeutralSpecial()
  call InitHeroArrays()
  call InitArrays()  // Has been moved to be set before all other code as is only variable declaration
  call InitChatArrays()
  call InitChatEvents()
  call InitTrans()
  call InitTranslations()
  call InitRaceNames()
  call InitCT()
  call InitChatVars()
  call InitCreepStrengthArray()
  call StopGathering()
  call InitBuildArrayAM()
  call InitUpkeep()
  call InitNeutralBuildings()
  call StartThread(function PathingThread)
  //call StartThread(function ExpansionThread)
  //call StartThread(function CheckAllNeutrals)
  call InitHealers()
  call InitUpgradeTimeArray()
  call InitPlayerStrengthCache()
  call SetNearestEnemy()
  call InitTownBuilt()
  set max_farms = GetMaxFarms()
  set mine_loc = GetUnitLoc(own_town_mine[0])


endfunction

function AMAI takes code heroes, code peons, code attacks returns nothing
  local boolean isNewbie = (difficulty == EASY)

  // call sendToNextAI()
  call SaveBoolean(com, TEAM_STATEGY_INUSE, strategy_type[chosen_strategy], true)
  set last_strategy = strategy

  call SetMeleeAI()

  call SetDefendPlayer(true)
  call SetRandomPaths(true)
  call SetTargetHeroes(not isNewbie)
  call SetPeonsRepair(true)
  call SetHeroesFlee(true)
  call SetHeroesBuyItems(not isNewbie)
  call SetUnitsFlee(not isNewbie)
  call SetGroupsFlee(not isNewbie)
  call SetWatchMegaTargets(true)
  call SetIgnoreInjured(race_ignore_injured)
  call SetHeroesTakeItems(true)
  call SetSlowChopping(false)
  call SetCaptainChanges(true)
  call SetSmartArtillery(not isNewbie)

  call CreateCaptains()
  call Trace("Setting hero levels")
  call SetHeroLevels(heroes)
  call Trace("heros set")
  if GetMinesOwned() > 1 then
    call InitCheckHarvest()  // now home_location distance 1500 have more mine , ELF and UD cannot harvest (old war3 version distance need 2200+ ), this can fix
  endif
  call Sleep(0.1)
  // Job Thread
  call StartThread(function TQLoop)
  //call Trace("TQLoop")
  call StartThread(peons)
  //call Trace("peons")
  call StartThread(attacks)
  //call Trace("attacks")
  call StartThread(function cmd_loop)
  //call Trace("cmd_loop")
endfunction

function InitCampaignDefenders takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > 200
    set campaign_defenders[i] = 0
    set i = i + 1
  endloop
endfunction

function KeyAddTimeModify takes integer k_add returns integer
  local real t = TimerGetElapsed(tq_timer)
  return R2I(LinearInterpolation(k_add_start_time, k_add_end_time, k_add_start_mult, k_add_end_mult, t) * I2R(k_add))
endfunction

function GetKeyBuildingAddExt takes integer kb returns integer
  if TownCountDone(kb) > 1 then
    return kb_add4
  elseif TownCountDone(kb) > 0 then
    return kb_add1
  elseif TownCount(kb) > 0 then
    return kb_add2
  elseif TownCountDone(needed1[kb]) > 0 and TownCountDone(needed2[kb]) > 0 then
    return kb_add3
  endif
  return 0
endfunction

function GetKeyBuildingAdd takes integer sn returns integer
  return KeyAddTimeModify(GetKeyBuildingAddExt(key_building1[sn]) + GetKeyBuildingAddExt(key_building2[sn]))
endfunction

function KeyBuildingAdd takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i>= rp_strat_length
    set rp_strat[i] = rp_strat[i] + GetKeyBuildingAdd(i)
    set i = i + 1
  endloop
endfunction

function GetKeyUpgradeAddExt takes integer kb returns integer
  local integer ul = GetUpgradeLevel(old_id[kb])
  if ul >= 3 then
    return ku_add3
  elseif ul == 2 then
    return ku_add2
  elseif ul == 1 then
    return ku_add1
  endif
  return 0
endfunction

function GetKeyUpgradeAdd takes integer sn returns integer
  return KeyAddTimeModify(GetKeyUpgradeAddExt(key_upgrade1[sn]) + GetKeyUpgradeAddExt(key_upgrade2[sn]))
endfunction

function KeyUpgradeAdd takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i>= rp_strat_length
    set rp_strat[i] = rp_strat[i] + GetKeyUpgradeAdd(i)
    set i = i + 1
  endloop
endfunction

function GetKeyUnitAddExt takes integer kb returns integer
  if kb != 0 then
    return TownCountDone(kb) * GetFoodUsed(old_id[kb])
  endif
  return 0
endfunction

function GetKeyUnitAdd takes integer sn returns integer
  return KeyAddTimeModify(GetKeyUnitAddExt(key_unit[sn]))
endfunction

function KeyUnitAdd takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i>= rp_strat_length
    set rp_strat[i] = rp_strat[i] + GetKeyUnitAdd(i)
    set i = i + 1
  endloop
endfunction

function SmallMapsAdd takes nothing returns nothing
  local integer i = 0
  if GetPlayers() > 3 or mapSize >= 3 then
    return
  endif
  loop
    exitwhen i >= rp_strat_length
    if strategy_tier[i] == 1 then
      set rp_strat[i] = rp_strat[i] + small_map_tier1_bonus
    endif
    set i = i + 1
  endloop
endfunction

function sum_rp_strat takes integer num returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i >= num
    set sum = sum + rp_strat[i]
    set i = i + 1
  endloop
  return sum
endfunction

function choose_strategy takes nothing returns integer
  local integer i = 1
  local integer rp_sum = sum_rp_strat(rp_strat_length)
  local integer strategy_roll = GetRandomInt(1, rp_sum)
  if rp_sum <= 0 then
    return 0
  endif
  loop
    exitwhen strategy_roll <= sum_rp_strat(i)
    set i = i + 1
  endloop
  
  return i - 1
endfunction

function mult_rp_strat takes integer m returns nothing
  local integer i = 0
  loop
    exitwhen i >= rp_strat_length
    set rp_strat[i] = rp_strat[i] * m
    set i = i + 1
  endloop
endfunction

function div_rp_strat takes integer d returns nothing
  local integer i = 0
  loop
    exitwhen i >= rp_strat_length
    set rp_strat[i] = rp_strat[i] / d
    set i = i + 1
  endloop
endfunction

function make_rp_strat_positive takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= rp_strat_length
    if rp_strat[i] < 0 then
      set rp_strat[i] = 0
    endif
    set i = i + 1
  endloop
endfunction

function normalize_rp_strat takes nothing returns nothing
  local integer i = 0
  local integer sum = sum_rp_strat(rp_strat_length)
  if sum == 0 then
    set sum = 1
  endif
  loop
    exitwhen i >= rp_strat_length
    set rp_strat[i] = (rp_strat[i] * rp_strat_normal) / sum
    set i = i + 1
  endloop
endfunction

function add_tier_bonus takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= rp_strat_length
    if tier == strategy_tier[i] then
        set rp_strat[i] = rp_strat[i] + strategy_tier_bonus
    endif
    set i = i + 1
  endloop
endfunction

function display_rp_strat takes nothing returns nothing
  local integer i = 0
  local integer sum = 0
  if balancing then
    set sum = sum_rp_strat(rp_strat_length)
    if sum == 0 then
      set sum = 1
    endif
    loop
      exitwhen i >= rp_strat_length
      call DisplayToAll(GetStrategyName(i)+": "+Int2Str(R2I(I2R(100 * rp_strat[i]) / I2R(sum)))+" %")
      set i = i + 1
    endloop
  endif
endfunction

function init_rp_strat_sort takes nothing returns nothing
  set rp_strat_sort_length = 0
endfunction

function sum_rp_strat_sort takes integer num returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i >= num
    set sum = sum + rp_strat[rp_strat_sort[i]]
    set i = i + 1
  endloop
  return sum
endfunction

function display_rp_strat_sort takes nothing returns nothing
  local integer i = 0
  local integer sum = 0
  if balancing then
    set sum = sum_rp_strat_sort(relevant_strat_change_number)
    loop
      exitwhen i >= relevant_strat_change_number
      call DisplayToAll(GetStrategyName(rp_strat_sort[i])+": "+Int2Str(R2I(I2R(100 * rp_strat[rp_strat_sort[i]]) / I2R(sum)))+" %")
      set i = i + 1
    endloop
  endif
endfunction

function sort_rp_strat takes nothing returns nothing
  local integer i = 0
  local integer j = 0
  loop
    exitwhen i >= rp_strat_length
    set j = rp_strat_sort_length - 1
    loop
      exitwhen j < 0
      exitwhen rp_strat[rp_strat_sort[j]] > rp_strat[i]
      set rp_strat_sort[j + 1] = rp_strat_sort[j]
      set j = j - 1
    endloop
    set rp_strat_sort[j + 1] = i
    set rp_strat_sort_length = rp_strat_sort_length + 1
    set i = i + 1
  endloop
endfunction

function nullify_bad_strats takes nothing returns nothing
  local integer i = 0
  loop
    if rp_strat[i] < (rp_strat[strategy] - (strat_persistence + (FoodUsed() * strat_food_persistence))) * strategy_change_threshold then
      set rp_strat[i] = 0
    endif
    set i = i + 1
    exitwhen i >= rp_strat_length
  endloop
endfunction

function finish_strategy_change takes nothing returns nothing
  local integer strategy_roll = 0
  local integer sum = 0
  local integer i = 0

  call KeyBuildingAdd()
  call KeyUpgradeAdd()
  call KeyUnitAdd()
  call add_tier_bonus()
  set rp_strat[strategy] = rp_strat[strategy] + strat_persistence + strat_food_persistence * FoodUsed() // Add the bonuses to persistance
  call nullify_bad_strats()

  set rp_strat[strategy] = R2I(I2R(rp_strat[strategy]) * Pow(c_enemy_total,0.75))
  call make_rp_strat_positive()
  call init_rp_strat_sort()
  call sort_rp_strat()
  set sum = sum_rp_strat_sort(relevant_strat_change_number)
  if sum < 1 then
    return
  endif
  set strategy_roll = GetRandomInt(1,sum)
  set sum = 0
  loop
    set sum = sum + rp_strat[rp_strat_sort[i]]
    if strategy_roll <= sum then
      //if rp_strat[rp_strat_sort[i]] / Max(rp_strat[strategy], 1) > strategy_change_threshold then
      set strategy = rp_strat_sort[i]
      set chosen_strategy = strategy
      call SetChatVar("Strategy", GetCurrentStrategyName())
      //endif
      return
    endif
    set i = i + 1
  endloop
endfunction

function removeNonBeginningStrats takes nothing returns nothing
  local integer i = 0
  if nearest_enemy_range < 5000 or not ((game_is_ffa and c_enemy_total > 3) or (c_ally_total > 2 and c_enemy_total > 3)) then
    loop
      exitwhen i >= rp_strat_length
      if not beginning_strat[i] and (debug_strategy != i) then
        set rp_strat[i] = 0
      endif
      set i = i + 1
    endloop
  endif
endfunction

function AddStrategyHeroRP takes integer h, integer to_add returns nothing
  local integer i = 0
  loop
    exitwhen i >= hero_number
    if all_heroes[i] == h then
      set hero_rp[i] = hero_rp[i] + to_add
    endif
    set i = i + 1
  endloop
endfunction

function ApplyStrategyRaceAggression takes nothing returns nothing
  local integer i = 0
  local integer l = tiernum * RACE_NUMBER
  loop
    exitwhen i >= l
    set race_aggression[i] = b_race_aggression[i] + strategy_race_aggression[strategy*l + i]
    set i = i + 1
  endloop
endfunction

function make_hero_rp_positive takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= hero_number
    if hero_rp[i] < 0 then
      set hero_rp[i] = 0
    endif
    set i = i + 1
  endloop
endfunction

function sum_hero_rp takes nothing returns integer
  local integer i = first_choosable_hero
  local integer sum = 0
  loop
    exitwhen i >=hero_number
    set sum = sum + hero_rp[i]
    set i = i + 1
  endloop
  return sum
endfunction

function ChooseHero takes nothing returns integer
  local integer i = first_choosable_hero
  local integer sum = 0
  local integer rp_sum = sum_hero_rp()
  local integer hero_roll = GetRandomInt(1,Max(rp_sum,1))
  if rp_sum <= 0 then
    return 0
  endif
  loop
    set sum = sum + hero_rp[i]
    if hero_roll <= sum then
      return i
    endif
    set i = i + 1
  endloop
  return 0
endfunction

function remove_hero takes integer h returns nothing
  local integer i = h
  set hero_number = hero_number - 1
  loop
    exitwhen i >= hero_number
    set hero_rp[i] = hero_rp[i + 1]
    set all_heroes[i] = all_heroes[i + 1]
    set i = i + 1
  endloop
endfunction

function GetExistingHero takes nothing returns integer
  local group g = CreateGroup()
  local unit u = null
  local integer oid = 0
  local integer i = 0
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectUnittype(g, UNIT_TYPE_HERO, true)
  set u = FirstOfGroup(g)
  call DestroyGroup(g)
  set g = null
  if u == null then
    call DisplayToAll("Hero not found")
    return 0
  endif
  set oid = GetUnitTypeId(u)
  set u = null
  loop
    exitwhen i >= hero_number
    if old_id[all_heroes[i]] == oid then
      set chosen = i
      return all_heroes[i]
    endif
    set i = i + 1
  endloop
  call DisplayToAll("Unknown hero")
  return 0
endfunction

function ChooseFirstHero takes nothing returns integer
  //if ver_neutral_heroes_available and neutral_available[NEUTRAL_TAVERN] and neutral_guarded[NEUTRAL_TAVERN] then
    //call remove_hero(7)
    //set first_choosable_hero = ver_neutral_hero_number
  //endif
  if IsMapFlagSet(MAP_RANDOM_HERO) then
    set hero[1] = GetExistingHero()
  else
    call make_hero_rp_positive()
    set chosen = ChooseHero()
    set hero[1] = all_heroes[chosen]
  endif
  return chosen
endfunction

function ChooseSecondHero takes nothing returns nothing
  call make_hero_rp_positive()
  call remove_hero(chosen)
  set chosen = ChooseHero()
  set hero[2] = all_heroes[chosen]
endfunction

function ChooseRestHeroes takes nothing returns nothing
  call make_hero_rp_positive()
  call remove_hero(chosen)
  set hero[3] = all_heroes[ChooseHero()]
endfunction

function GetMinesHarvested takes nothing returns integer
  local integer twm = TownWithMine()
  local integer i = twm
  local integer sum = 0
  local integer mine = racial_expansion
  if race_manual_loading then
    set mine = race_manual_loading_mine
  endif
  if first_town_mine > 0 or race_manual_loading or race_uses_mine_expansion then  //home_location have multiple mine or just one mine but UD and ELF cannot harvested
    set twm = TownCountDone(mine)
    set i = twm
  endif
  if twm < 0 then
    return 0
  endif
  if race_manual_loading or race_uses_mine_expansion then
    return i
  else
    loop
      exitwhen i > twm + 3
      if TownHasMine(i) and TownCountEx(mine,true,i) > 0 then
        set sum = sum + 1
      endif
      set i = i + 1
    endloop
  endif
  return sum
endfunction

function GetGoldIncome takes nothing returns real
  local integer inc = GetMinesHarvested()*income_per_mine
  if inc > GetGoldOwned() then
    set inc = GetGoldOwned()
  endif
  return I2R(inc + GetGold())/300
endfunction

function GetIncomePercentage takes integer qty returns real
  if qty == 0 then
    return 0.0
  endif
  return 1 - 1/I2R(qty)
endfunction

function GetFactoryQty takes integer qty, integer build_time, integer gold_cost, real in_percentage returns integer
  local real gip = GetIncomePercentage(qty) * gold_income * in_percentage
  local real gic = I2R(Max(gold_cost,1))/I2R(Max(build_time, 1))
  return Max(Min(R2I(gip/gic), difficulty),1)
endfunction

function IsOneOnlyBuilding takes integer unitid returns boolean
  if false then
  endif
  return false
endfunction

function Get_f_qty takes integer qty, integer unitid, integer town  returns integer
  if buy_type[unitid] != BT_UNIT or unitid == racial_peon or IsOneOnlyBuilding(needed1[unitid]) then
    return 1
  endif
  return GetFactoryQty(qty - TownCountTown(unitid, town), GetUnitBuildTime(old_id[unitid]), GetUnitGoldCost2(unitid), income_percentage[needed1[unitid]])
endfunction

function AddBlock takes integer req_qty, integer req_type, boolean only_done, integer allow_qty, integer allow_type, integer expire_time returns nothing
  set bl_req_qty[bl_length] = req_qty
  set bl_req_type[bl_length] = req_type
  set bl_only_done[bl_length] = only_done
  set bl_allow_qty[bl_length] = allow_qty
  set bl_allow_type[bl_length] = allow_type
  set bl_expire_time[bl_length] = expire_time
  set bl_length = bl_length + 1
endfunction

function InitBlockList takes nothing returns nothing
  set bl_length = 0
endfunction

function BlockListCheck takes integer qty, integer t returns integer
  local integer i = 0
  local integer max_qty = qty
  loop
    exitwhen i >= bl_length
    if ai_time < bl_expire_time[i] and bl_allow_type[i] == t then
      if TownCountEx(bl_req_type[i], bl_only_done[i], -1) < bl_req_qty[i] then
        set max_qty = Min(max_qty, bl_allow_qty[i])
      endif
    endif
    set i = i + 1
  endloop
  return max_qty
endfunction

function AddRBlock takes integer req_gold, integer req_wood, integer req_food, integer allow_qty, integer allow_type, integer expire_time returns nothing
  set rbl_req_gold[rbl_length] = req_gold
  set rbl_req_wood[rbl_length] = req_wood
  set rbl_req_food[rbl_length] = req_food
  set rbl_allow_qty[rbl_length] = allow_qty
  set rbl_allow_type[rbl_length] = allow_type
  set rbl_expire_time[rbl_length] = expire_time
  set rbl_length = rbl_length + 1
endfunction

function InitRBlockList takes nothing returns nothing
  set rbl_length = 0
endfunction

function RBlockListCheck takes integer qty, integer t returns integer
  local integer i = 0
  local integer max_qty = qty
  loop
    exitwhen i >= rbl_length
    if ai_time < rbl_expire_time[i] and rbl_allow_type[i] == t then
      if total_gold < rbl_req_gold[i] or total_wood < rbl_req_wood[i] or FoodUsed() < rbl_req_food[i] then
        set max_qty = Min(max_qty, rbl_allow_qty[i])
        set blocked_gold = Max(blocked_gold, rbl_req_gold[i])
        set blocked_wood = Max(blocked_wood, rbl_req_wood[i])
		set blocked_food = Max(blocked_food, rbl_req_food[i])
      endif
    endif
    set i = i + 1
  endloop
  return max_qty
endfunction


function SetBuildAllAMCore takes integer t, integer qty, integer unitid, integer town, integer bloc, integer prio returns nothing
  local integer i = 0
  local integer j = 0
  if unitid == 0 or qty == 0 then
    return
  endif
  if t == BUILD_UPGRADE then
    if GetUpgradeLevel(old_id[unitid]) >= qty then
      return
    endif
  elseif t == BUILD_ITEM then
    if GetItemNumber(unitid) >= qty then
      return
    endif
  elseif TownCountTown(unitid, town) >= qty or (buy_type[unitid] > BT_RACIAL_ITEM and not neutral_available[GetNeutralNumber(unitid)]) then
    return
  endif
  call GetBuildLock()
  set j = Max(build_length - 1,0)
  loop
    exitwhen i >= build_length
    exitwhen build_prio[i] < prio
    if build_item[i] == unitid and build_qty[i] >= qty and build_town[i] == town then
      call ReleaseBuildLock()
      return
    endif
    set i = i + 1
  endloop
  loop
    exitwhen j < i
    set build_qty[j+1] = build_qty[j]
    set build_type[j+1] = build_type[j]
    set build_item[j+1] = build_item[j]
    set build_town[j+1] = build_town[j]
    set build_loc[j+1] = build_loc[j]
    set build_prio[j+1] = build_prio[j]
    set j = j - 1
  endloop
  set build_qty[i] = qty
  set build_type[i] = t
  set build_item[i] = unitid
  set build_town[i] = town
  set build_loc[i] = bloc
  set build_prio[i] = prio
  set build_length = build_length + 1
  call ReleaseBuildLock()

  if qty > 1 then
    call SetBuildAllAMCore(t, qty - 1, unitid, town, bloc, prio + prio_q_inc )
  endif

endfunction

function RefreshNeeded takes integer t, integer qty, integer unitid, integer town, integer bloc, integer prio returns nothing
  if buy_type[unitid] == BT_ML_UPGRADE then
    if qty == 1 then
      if needed1[unitid] != 0 then
        call SetBuildAllAMCore(BUILD_UNIT, Get_f_qty(qty, unitid, town), needed1[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    elseif qty == 2 then
      call SetBuildAllAMCore(BUILD_UPGRADE, 1, unitid, town, BLOC_STD, prio + prio_n_inc)
      if needed2[unitid] != 0 then
        call SetBuildAllAMCore(BUILD_UNIT, 1, needed2[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    else
      call SetBuildAllAMCore(BUILD_UPGRADE, 1, unitid, town, BLOC_STD, prio + prio_n_inc + prio_n_inc)
      call SetBuildAllAMCore(BUILD_UPGRADE, 2, unitid, town, BLOC_STD, prio + prio_n_inc)
      if needed3[unitid] != 0 then
        call SetBuildAllAMCore(BUILD_UNIT, 1, needed3[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    endif
  elseif buy_type[unitid] == BT_HERO or buy_type[unitid] == BT_NEUTRAL_HERO then
    if unitid == hero[1] or unitid == hero[2] or unitid == hero[3] then
      if needed1[unitid] != 0 then
        call SetBuildAllAMCore(BUILD_UNIT, 1, needed1[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    endif
    if (unitid == hero[2] and not hero_built[2]) or (unitid == hero[3] and not hero_built[3]) then
      if needed2[unitid] != 0 then
        call SetBuildAllAMCore(BUILD_UNIT, 1, needed2[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    endif
    if unitid == hero[3] and not hero_built[3] then
      if needed3[unitid] != 0 then
        call SetBuildAllAMCore(BUILD_UNIT, 1, needed3[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    endif
  else
    if needed1[unitid] != 0 then
      if needed3[unitid] == UPGRADED then
        call SetBuildAllAMCore(BUILD_UNIT, qty + TownCountExForUpgrade(needed1[unitid],unitid,false,town), needed1[unitid], town, bloc, prio + prio_n_inc)
      else
        call SetBuildAllAMCore(BUILD_UNIT, Get_f_qty(qty, unitid, town), needed1[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    endif
    if needed2[unitid] != 0 then
      call SetBuildAllAMCore(BUILD_UNIT, 1, needed2[unitid], -1, BLOC_STD, prio + prio_n_inc)
    endif
    if needed3[unitid] != 0 and needed3[unitid] != UPGRADED then
      call SetBuildAllAMCore(BUILD_UNIT, 1, needed3[unitid], -1, BLOC_STD, prio + prio_n_inc)
    endif
  endif
  if unitid == KNIGHT then
    call SetBuildAllAMCore(BUILD_UNIT, 1, LUMBER_MILL, -1, BLOC_STD, prio + prio_n_inc)
  endif
  if unitid == UPG_BREEDING then
    call SetBuildAllAMCore(BUILD_UNIT, 1, LUMBER_MILL, -1, BLOC_STD, prio + prio_n_inc)
  endif
  if unitid == HIPPO_RIDER then
    call SetBuildAllAMCore(BUILD_UPGRADE, 1, UPG_HIPPO_TAME, -1, BLOC_STD, prio + prio_n_inc)
  endif
endfunction

function SetBuildAllAM takes integer t, integer mqty, integer unitid, integer town, integer bloc, integer prio returns nothing
  set mqty = BlockListCheck(mqty, unitid)
  if unitid != 0 and mqty != 0 then
    call SetBuildAllAMCore(t, mqty, unitid, town, bloc, prio)
    call RefreshNeeded(t, mqty, unitid, town, bloc, prio)
  endif
endfunction

function CanBuildUnit takes integer unitid returns boolean
  local boolean b = (needed1[unitid] == 0 or TownCountDone(needed1[unitid]) > 0) and (needed2[unitid] == 0 or TownCountDone(needed2[unitid]) > 0) and (needed3[unitid] == 0 or needed3[unitid] == UPGRADED or TownCountDone(needed3[unitid]) > 0)
  set b = b and (unitid != KNIGHT or TownCountDone(LUMBER_MILL) > 0)
  set b = b and (unitid != UPG_BREEDING or TownCountDone(LUMBER_MILL) > 0)
  set b = b and (unitid != HIPPO_RIDER or GetUpgradeLevel(old_id[UPG_HIPPO_TAME]) >= 1)
  return b
endfunction

function BuildUnit takes integer qty, integer unitid, integer prio returns nothing
    call SetBuildAllAM(BUILD_UNIT,qty,unitid,-1, BLOC_STD, prio)
endfunction

function SetBuildUnitIfAvailable takes integer qty, integer unitid, integer prio returns nothing
  if CanBuildUnit(unitid) then
    call BuildUnit(qty, unitid, prio)
  endif
endfunction

function SetBuildUnitExAM takes integer easy, integer med, integer hard, integer unitid, integer prio returns nothing
    if difficulty == EASY then
        call SetBuildAllAM(BUILD_UNIT,easy,unitid,-1, BLOC_STD, prio)
    elseif difficulty == NORMAL then
        call SetBuildAllAM(BUILD_UNIT,med,unitid,-1, BLOC_STD, prio)
    else
        call SetBuildAllAM(BUILD_UNIT,hard,unitid,-1, BLOC_STD, prio)
    endif
endfunction

function SecondaryTownAM takes integer town, integer qty, integer unitid, integer prio returns nothing
    call SetBuildAllAM(BUILD_UNIT,qty,unitid,town, BLOC_STD, prio)
endfunction

function BuildUpgr takes integer qty, integer unitid, integer prio returns nothing
    call SetBuildAllAM(BUILD_UPGRADE,qty,unitid,-1, BLOC_STD, prio)
endfunction


function BuildAdvUpgr takes integer qty, integer unitid, integer starttier, integer unitcount, integer maxunits, integer tierprio, integer prio returns nothing
  if tier >= starttier then
    if unitcount > 0 then
        if qty >= tier-starttier+1 then
        call BuildUpgr(tier-starttier + 1, unitid, R2I(LinearInterpolation(0, maxunits, 1, prio + ((tier-starttier)* tierprio) , unitcount)))
      else
        // If tier greater than the start tier and qty is less than the difference between the two
        call BuildUpgr(qty, unitid, R2I(LinearInterpolation(0, maxunits, 1, prio + ((tier-starttier)* tierprio), unitcount)))
      endif
    endif
  endif
endfunction


function BuildAdvUpgr2 takes integer qty, integer upgid, integer starttier, integer unitcount, real unitper, integer max, integer prio returns nothing
  if tier >= starttier then
    if unitcount > 0 then
      if GetRandomInt(1, 100) <= Min(R2I(unitcount/unitper), max) then
        if qty >= tier-starttier+1 then
        call BuildUpgr(tier-starttier + 1, upgid, prio + ((tier-starttier)*4))
      else
        // If tier greater than the start tier and qty is less than the difference between the two
        call BuildUpgr(qty, upgid, prio + ((tier-starttier)*4))
      endif
      endif
    endif
  endif
endfunction
function SetBuildUpgrExAM takes integer easy, integer med, integer hard, integer unitid, integer prio returns nothing
    if difficulty == EASY then
        call SetBuildAllAM(BUILD_UPGRADE,easy,unitid,-1, BLOC_STD, prio)
    elseif difficulty == NORMAL then
        call SetBuildAllAM(BUILD_UPGRADE,med,unitid,-1, BLOC_STD, prio)
    else
        call SetBuildAllAM(BUILD_UPGRADE,hard,unitid,-1, BLOC_STD, prio)
    endif
endfunction

function BuildExpa takes integer qty, integer unitid, integer prio returns nothing
    call SetBuildAllAM(BUILD_EXPAND,qty,unitid,-1, BLOC_STD, prio)
endfunction

function BuildItem takes integer qty, integer unitid, integer prio returns nothing
    call SetBuildAllAM(BUILD_ITEM,qty,unitid,-1, BLOC_STD, prio)
endfunction

function BuildFront takes integer qty, integer unitid, integer prio returns nothing
  call SetBuildAllAM(BUILD_UNIT, qty, unitid, -1, BLOC_FRONT, prio)
endfunction

function BuildAtMine takes integer qty, integer unitid, integer prio returns nothing
  call SetBuildAllAM(BUILD_UNIT, qty, unitid, -1, BLOC_MINE, prio)
endfunction

function SetBuildReact takes integer food, integer min1, integer unit1, integer min2, integer unit2, real enemy_strength, real strength1, real strength2, integer prio returns nothing
  local integer num1 = R2I(LinearInterpolation(strength1, strength2, I2R(food), 0, enemy_strength))/GetFoodUsed(old_id[unit1])
  local integer num2 = (food - num1 * GetFoodUsed(old_id[unit1]))/GetFoodUsed(old_id[unit2])
  local integer prio1 = 0
  local integer prio2 = 0
  local integer food1 = food/GetFoodUsed(old_id[unit1]) 
  local integer food2 = food/GetFoodUsed(old_id[unit2]) 

  if food1 > food2 then
    set prio1 = prio+(food1-1)*2 - (min1+num1-1)*2        // So builds starting at the max priority possible
    set prio2 = prio+(food1-1)*2 - (min2+num2-1)*2        // i.e build 6 footmen instead of 12 but will build those 6 starting at same proirity of 12
  else                                                    // This is so it builds less than the max it still builds at same priority.
    set prio1 = prio+(food2-1)*2 - (min1+num1-1)*2 - 4    // I assuming the second unit id is less common so make sure it has smaller prioity so that first unit gets its requirements first
    set prio2 = prio+(food2-1)*2 - (min2+num2-1)*2 - 4
  endif

  if min1 + num1 > 0 then
    call BuildUnit(min1 + num1, unit1, prio1)
  endif
  if min2 + num2 > 0 then
    call BuildUnit(min2 + num2, unit2, prio2)
  endif
endfunction

function GetTier takes nothing returns integer
  local integer i = tiernum
  loop
    exitwhen i <= 1
    exitwhen TownCountDone(racial_hall[i]) >= 1
    set i = i - 1
  endloop
  return i
endfunction

function DetermineCounterForce takes nothing returns integer
  local integer strength = 0
  local integer total_strength = 0
  local integer array tstrength
  local integer num_strengths
  local integer j
  local integer random
  local integer maxstr = 0
  local integer secondstr = -1
  local integer thirdstr = -1
  local integer array temps
  local real ally_null = 0    // Blank point
  local string strdebug = " Counter Strengths: "

  set num_strengths = 0
  set j = 0
  set tstrength[num_strengths] = R2I(RMax(enemy_air - (ally_piercing/20) - (ally_null/20),0)*10)
  //set strength = strength + tstrength[num_strengths]
  set strengthtext[num_strengths] = "air"
  set num_strengths = num_strengths + 1
  set tstrength[num_strengths] = R2I(RMax(enemy_casters - (ally_null/20) - (ally_null/20),0)*10)
  //set strength = strength + tstrength[num_strengths]
  set strengthtext[num_strengths] = "casters"
  set num_strengths = num_strengths + 1
  set tstrength[num_strengths] = R2I(RMax(enemy_towers - (ally_siege/20) - (ally_null/20),0)*10)
  //set strength = strength + tstrength[num_strengths]
  set strengthtext[num_strengths] = "towers"
  set num_strengths = num_strengths + 1
  set tstrength[num_strengths] = R2I(RMax(enemy_piercing - (ally_mediumarmor/20) - (ally_null/20),0)*10)
  //set strength = strength + tstrength[num_strengths]
  set strengthtext[num_strengths] = "piercing"
  set num_strengths = num_strengths + 1
  set tstrength[num_strengths] = R2I(RMax(enemy_normal - (ally_normal/20) - (ally_null/20),0)*10)
  //set strength = strength + tstrength[num_strengths]
  set strengthtext[num_strengths] = "normal"
  set num_strengths = num_strengths + 1
  set tstrength[num_strengths] = R2I(RMax(enemy_siege - (ally_mediumarmor/20) - (ally_null/20),0)*10)
  //set strength = strength + tstrength[num_strengths]
  set strengthtext[num_strengths] = "siege"
  set num_strengths = num_strengths + 1
  set tstrength[num_strengths] = R2I(RMax(enemy_magic - (ally_mediumarmor/20) - (ally_null/20),0)*10)
  //set strength = strength + tstrength[num_strengths]
  set strengthtext[num_strengths] = "magic"
  set num_strengths = num_strengths + 1
  set tstrength[num_strengths] = R2I(RMax(enemy_unarmored - (ally_piercing/20) - (ally_siege/20),0)*10)
  //set strength = strength + tstrength[num_strengths]
  set strengthtext[num_strengths] = "unarmored"
  set num_strengths = num_strengths + 1
  set tstrength[num_strengths] = R2I(RMax(enemy_lightarmor - (ally_piercing/20) - (ally_magic/20),0)*10)
  //set strength = strength + tstrength[num_strengths]
  set strengthtext[num_strengths] = "lightarmor"
  set num_strengths = num_strengths + 1
  set tstrength[num_strengths] = R2I(RMax(enemy_mediumarmor - (ally_normal/20) - (ally_null/20),0)*10)
  //set strength = strength + tstrength[num_strengths]
  set strengthtext[num_strengths] = "mediumarmor"
  set num_strengths = num_strengths + 1
  set tstrength[num_strengths] = R2I(RMax(enemy_heavyarmor - (ally_magic/20) - (ally_null/20),0)*10)
  //set strength = strength + tstrength[num_strengths]
  set strengthtext[num_strengths] = "heavyarmor"
  set num_strengths = num_strengths + 1

  loop
    exitwhen j >= num_strengths
    if tstrength[j] > tstrength[maxstr] then
      set thirdstr = secondstr
      set secondstr = maxstr
      set maxstr = j
    elseif secondstr == -1 or tstrength[j] > tstrength[secondstr] then
      set thirdstr = secondstr
      set secondstr = j
    elseif thirdstr == -1 or tstrength[j] > tstrength[thirdstr] then
      set thirdstr = j
    endif
    set j = j + 1
  endloop
  if chosen_counter >= 0 then
    if tstrength[chosen_counter] > 0 then
      call Trace("Persistence counter bonus:" + Int2Str(R2I(strat_persistence/20)))
      set tstrength[chosen_counter] = tstrength[chosen_counter] + R2I(strat_persistence/20) // Bonus to current counter
      //set strength = strength + R2I(strat_persistence/200)
    endif
  endif
  //call Trace("Highest Enemy Unit Strength is:" + strengthtext[maxstr] + " with total:" + Int2Str(tstrength[maxstr]))
  set j = 0
  // Remove bad strats to not affect calculations with really low amounts of strength
  loop
    exitwhen j >= num_strengths
    if tstrength[j] < 3 then
      set tstrength[j] = 0
    endif
    set total_strength = total_strength + tstrength[j]
    set strdebug = strdebug + strengthtext[j] + ":" + Int2Str(tstrength[j]) + " - "
    set j = j+1
  endloop

  // No strength so just use a random option
  if total_strength == 0 then
    set no_counter = true
    set j = GetRandomInt(0, num_strengths - 1)
    call Trace("Chosen counter:" + Int2Str(j) + strdebug)
  else
    set no_counter = false
    set j = 0
    set random =GetRandomInt(1, total_strength)
    set strength = 0
    loop
      if j < num_strengths then
        set strength = strength + tstrength[j]
      endif
      exitwhen random <= strength or j >= num_strengths
      set j = j + 1	// Will be the the chosen strength to build units against
    endloop
    if (j == 11) then
      call Trace("!ERROR: Should not get a counter that is not within the strength range!")
    endif
    call Trace("Random Num:" + Int2Str(random) + " Chosen counter:" + Int2Str(j) + strdebug)
  endif
  set strdebug = null
  return j
endfunction

function ResetDynamicSystem takes nothing returns nothing
	set totalanti_air = 0
	set totalchance_air = 0
	set totalanti_casters = 0
	set totalchance_casters = 0
	set totalanti_towers = 0
	set totalchance_towers = 0
	set totalanti_piercing = 0
	set totalchance_piercing = 0
	set totalanti_normal = 0
	set totalchance_normal = 0
	set totalanti_siege = 0
	set totalchance_siege = 0
	set totalanti_magic = 0
	set totalchance_magic = 0
	set totalanti_unarmored = 0
	set totalchance_unarmored = 0
	set totalanti_lightarmor = 0
	set totalchance_lightarmor = 0
	set totalanti_mediumarmor = 0
	set totalchance_mediumarmor = 0
	set totalanti_heavyarmor = 0
	set totalchance_heavyarmor = 0
endfunction

function AddUnitToAntiair takes integer u, integer percent returns nothing
	set dyanti_air[totalanti_air]= u
	set dychance_air[totalanti_air]= percent
	set totalanti_air = totalanti_air + 1
	set totalchance_air = totalchance_air + percent
endfunction
function AddUnitToAnticasters takes integer u, integer percent returns nothing
	set dyanti_casters[totalanti_casters]= u
	set dychance_casters[totalanti_casters]= percent
	set totalanti_casters = totalanti_casters + 1
	set totalchance_casters = totalchance_casters + percent
endfunction
function AddUnitToAntitowers takes integer u, integer percent returns nothing
	set dyanti_towers[totalanti_towers]= u
	set dychance_towers[totalanti_towers]= percent
	set totalanti_towers = totalanti_towers + 1
	set totalchance_towers = totalchance_towers + percent
endfunction
function AddUnitToAntipiercing takes integer u, integer percent returns nothing
	set dyanti_piercing[totalanti_piercing]= u
	set dychance_piercing[totalanti_piercing]= percent
	set totalanti_piercing = totalanti_piercing + 1
	set totalchance_piercing = totalchance_piercing + percent
endfunction
function AddUnitToAntinormal takes integer u, integer percent returns nothing
	set dyanti_normal[totalanti_normal]= u
	set dychance_normal[totalanti_normal]= percent
	set totalanti_normal = totalanti_normal + 1
	set totalchance_normal = totalchance_normal + percent
endfunction
function AddUnitToAntisiege takes integer u, integer percent returns nothing
	set dyanti_siege[totalanti_siege]= u
	set dychance_siege[totalanti_siege]= percent
	set totalanti_siege = totalanti_siege + 1
	set totalchance_siege = totalchance_siege + percent
endfunction
function AddUnitToAntimagic takes integer u, integer percent returns nothing
	set dyanti_magic[totalanti_magic]= u
	set dychance_magic[totalanti_magic]= percent
	set totalanti_magic = totalanti_magic + 1
	set totalchance_magic = totalchance_magic + percent
endfunction
function AddUnitToAntiunarmored takes integer u, integer percent returns nothing
	set dyanti_unarmored[totalanti_unarmored]= u
	set dychance_unarmored[totalanti_unarmored]= percent
	set totalanti_unarmored = totalanti_unarmored + 1
	set totalchance_unarmored = totalchance_unarmored + percent
endfunction
function AddUnitToAntilightarmor takes integer u, integer percent returns nothing
	set dyanti_lightarmor[totalanti_lightarmor]= u
	set dychance_lightarmor[totalanti_lightarmor]= percent
	set totalanti_lightarmor = totalanti_lightarmor + 1
	set totalchance_lightarmor = totalchance_lightarmor + percent
endfunction
function AddUnitToAntimediumarmor takes integer u, integer percent returns nothing
	set dyanti_mediumarmor[totalanti_mediumarmor]= u
	set dychance_mediumarmor[totalanti_mediumarmor]= percent
	set totalanti_mediumarmor = totalanti_mediumarmor + 1
	set totalchance_mediumarmor = totalchance_mediumarmor + percent
endfunction
function AddUnitToAntiheavyarmor takes integer u, integer percent returns nothing
	set dyanti_heavyarmor[totalanti_heavyarmor]= u
	set dychance_heavyarmor[totalanti_heavyarmor]= percent
	set totalanti_heavyarmor = totalanti_heavyarmor + 1
	set totalchance_heavyarmor = totalchance_heavyarmor + percent
endfunction

function BuildAntiairStrength takes nothing returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer chance = 0

	if totalchance_air > 0 then
		set choice = GetRandomInt(0,totalchance_air) // Build this unit
		loop
			set chance = chance + dychance_air[i]
			exitwhen choice <= chance or i >= totalanti_air
			set i = i + 1
		endloop
		if i >= totalanti_air and i > 0 then
			set u = dyanti_air[i-1]
		else
			set u = dyanti_air[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_air then
			//set food1 = food/GetFoodUsed(old_id[units[choice]])
			call Trace("Dynamic building Unit:" + unitNames[u] + " " +Int2Str(u))
			set chosen_counter_unit = u
		endif
	endif

endfunction
function BuildAnticastersStrength takes nothing returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer chance = 0

	if totalchance_casters > 0 then
		set choice = GetRandomInt(0,totalchance_casters) // Build this unit
		loop
			set chance = chance + dychance_casters[i]
			exitwhen choice <= chance or i >= totalanti_casters
			set i = i + 1
		endloop
		if i >= totalanti_casters and i > 0 then
			set u = dyanti_casters[i-1]
		else
			set u = dyanti_casters[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_casters then
			//set food1 = food/GetFoodUsed(old_id[units[choice]])
			call Trace("Dynamic building Unit:" + unitNames[u] + " " +Int2Str(u))
			set chosen_counter_unit = u
		endif
	endif

endfunction
function BuildAntitowersStrength takes nothing returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer chance = 0

	if totalchance_towers > 0 then
		set choice = GetRandomInt(0,totalchance_towers) // Build this unit
		loop
			set chance = chance + dychance_towers[i]
			exitwhen choice <= chance or i >= totalanti_towers
			set i = i + 1
		endloop
		if i >= totalanti_towers and i > 0 then
			set u = dyanti_towers[i-1]
		else
			set u = dyanti_towers[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_towers then
			//set food1 = food/GetFoodUsed(old_id[units[choice]])
			call Trace("Dynamic building Unit:" + unitNames[u] + " " +Int2Str(u))
			set chosen_counter_unit = u
		endif
	endif

endfunction
function BuildAntipiercingStrength takes nothing returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer chance = 0

	if totalchance_piercing > 0 then
		set choice = GetRandomInt(0,totalchance_piercing) // Build this unit
		loop
			set chance = chance + dychance_piercing[i]
			exitwhen choice <= chance or i >= totalanti_piercing
			set i = i + 1
		endloop
		if i >= totalanti_piercing and i > 0 then
			set u = dyanti_piercing[i-1]
		else
			set u = dyanti_piercing[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_piercing then
			//set food1 = food/GetFoodUsed(old_id[units[choice]])
			call Trace("Dynamic building Unit:" + unitNames[u] + " " +Int2Str(u))
			set chosen_counter_unit = u
		endif
	endif

endfunction
function BuildAntinormalStrength takes nothing returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer chance = 0

	if totalchance_normal > 0 then
		set choice = GetRandomInt(0,totalchance_normal) // Build this unit
		loop
			set chance = chance + dychance_normal[i]
			exitwhen choice <= chance or i >= totalanti_normal
			set i = i + 1
		endloop
		if i >= totalanti_normal and i > 0 then
			set u = dyanti_normal[i-1]
		else
			set u = dyanti_normal[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_normal then
			//set food1 = food/GetFoodUsed(old_id[units[choice]])
			call Trace("Dynamic building Unit:" + unitNames[u] + " " +Int2Str(u))
			set chosen_counter_unit = u
		endif
	endif

endfunction
function BuildAntisiegeStrength takes nothing returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer chance = 0

	if totalchance_siege > 0 then
		set choice = GetRandomInt(0,totalchance_siege) // Build this unit
		loop
			set chance = chance + dychance_siege[i]
			exitwhen choice <= chance or i >= totalanti_siege
			set i = i + 1
		endloop
		if i >= totalanti_siege and i > 0 then
			set u = dyanti_siege[i-1]
		else
			set u = dyanti_siege[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_siege then
			//set food1 = food/GetFoodUsed(old_id[units[choice]])
			call Trace("Dynamic building Unit:" + unitNames[u] + " " +Int2Str(u))
			set chosen_counter_unit = u
		endif
	endif

endfunction
function BuildAntimagicStrength takes nothing returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer chance = 0

	if totalchance_magic > 0 then
		set choice = GetRandomInt(0,totalchance_magic) // Build this unit
		loop
			set chance = chance + dychance_magic[i]
			exitwhen choice <= chance or i >= totalanti_magic
			set i = i + 1
		endloop
		if i >= totalanti_magic and i > 0 then
			set u = dyanti_magic[i-1]
		else
			set u = dyanti_magic[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_magic then
			//set food1 = food/GetFoodUsed(old_id[units[choice]])
			call Trace("Dynamic building Unit:" + unitNames[u] + " " +Int2Str(u))
			set chosen_counter_unit = u
		endif
	endif

endfunction
function BuildAntiunarmoredStrength takes nothing returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer chance = 0

	if totalchance_unarmored > 0 then
		set choice = GetRandomInt(0,totalchance_unarmored) // Build this unit
		loop
			set chance = chance + dychance_unarmored[i]
			exitwhen choice <= chance or i >= totalanti_unarmored
			set i = i + 1
		endloop
		if i >= totalanti_unarmored and i > 0 then
			set u = dyanti_unarmored[i-1]
		else
			set u = dyanti_unarmored[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_unarmored then
			//set food1 = food/GetFoodUsed(old_id[units[choice]])
			call Trace("Dynamic building Unit:" + unitNames[u] + " " +Int2Str(u))
			set chosen_counter_unit = u
		endif
	endif

endfunction
function BuildAntilightarmorStrength takes nothing returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer chance = 0

	if totalchance_lightarmor > 0 then
		set choice = GetRandomInt(0,totalchance_lightarmor) // Build this unit
		loop
			set chance = chance + dychance_lightarmor[i]
			exitwhen choice <= chance or i >= totalanti_lightarmor
			set i = i + 1
		endloop
		if i >= totalanti_lightarmor and i > 0 then
			set u = dyanti_lightarmor[i-1]
		else
			set u = dyanti_lightarmor[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_lightarmor then
			//set food1 = food/GetFoodUsed(old_id[units[choice]])
			call Trace("Dynamic building Unit:" + unitNames[u] + " " +Int2Str(u))
			set chosen_counter_unit = u
		endif
	endif

endfunction
function BuildAntimediumarmorStrength takes nothing returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer chance = 0

	if totalchance_mediumarmor > 0 then
		set choice = GetRandomInt(0,totalchance_mediumarmor) // Build this unit
		loop
			set chance = chance + dychance_mediumarmor[i]
			exitwhen choice <= chance or i >= totalanti_mediumarmor
			set i = i + 1
		endloop
		if i >= totalanti_mediumarmor and i > 0 then
			set u = dyanti_mediumarmor[i-1]
		else
			set u = dyanti_mediumarmor[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_mediumarmor then
			//set food1 = food/GetFoodUsed(old_id[units[choice]])
			call Trace("Dynamic building Unit:" + unitNames[u] + " " +Int2Str(u))
			set chosen_counter_unit = u
		endif
	endif

endfunction
function BuildAntiheavyarmorStrength takes nothing returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer chance = 0

	if totalchance_heavyarmor > 0 then
		set choice = GetRandomInt(0,totalchance_heavyarmor) // Build this unit
		loop
			set chance = chance + dychance_heavyarmor[i]
			exitwhen choice <= chance or i >= totalanti_heavyarmor
			set i = i + 1
		endloop
		if i >= totalanti_heavyarmor and i > 0 then
			set u = dyanti_heavyarmor[i-1]
		else
			set u = dyanti_heavyarmor[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_heavyarmor then
			//set food1 = food/GetFoodUsed(old_id[units[choice]])
			call Trace("Dynamic building Unit:" + unitNames[u] + " " +Int2Str(u))
			set chosen_counter_unit = u
		endif
	endif

endfunction

function DynamicBuildUnit takes integer count, integer prio returns nothing
	local integer num
	if chosen_counter_unit > 0 then
		if IsUnitIdType(old_id[chosen_counter_unit], UNIT_TYPE_STRUCTURE) == false and not (buy_type[chosen_counter_unit] > BT_RACIAL_ITEM and buy_type[chosen_counter_unit] < BT_MERCHANT_ITEM) then // Normal units/upgrades
			set num = R2I((count - FoodUsed())/GetFoodUsed(old_id[chosen_counter_unit]))
			if num > 0 and GetUnitCount(old_id[chosen_counter_unit]) < num then
				call BuildUnit(Min(num, GetUnitCountDone(old_id[chosen_counter_unit]) + 10), chosen_counter_unit, prio)  
			endif
		elseif buy_type[chosen_counter_unit] > BT_RACIAL_ITEM and buy_type[chosen_counter_unit] < BT_MERCHANT_ITEM then // A neutral mercenary
			set num = R2I((count - FoodUsed())/GetFoodUsed(old_id[chosen_counter_unit]))
			if num > 0 then
				call BuildUnit(GetUnitCountDone(old_id[chosen_counter_unit]) + 1, chosen_counter_unit, prio)
			endif
		else // structure
			call BuildUnit(1, chosen_counter_unit, prio*2) 
		endif
	endif
endfunction

function DynamicStrategySelector takes nothing returns nothing
	local integer strength_count = 0

	if chosen_counter == strength_count then
		//call Trace("I'm building anti air units")
		call BuildAntiairStrength()
	endif
	set strength_count = strength_count + 1
	if chosen_counter == strength_count then
		//call Trace("I'm building anti casters units")
		call BuildAnticastersStrength()
	endif
	set strength_count = strength_count + 1
	if chosen_counter == strength_count then
		//call Trace("I'm building anti towers units")
		call BuildAntitowersStrength()
	endif
	set strength_count = strength_count + 1
	if chosen_counter == strength_count then
		//call Trace("I'm building anti piercing units")
		call BuildAntipiercingStrength()
	endif
	set strength_count = strength_count + 1
	if chosen_counter == strength_count then
		//call Trace("I'm building anti normal units")
		call BuildAntinormalStrength()
	endif
	set strength_count = strength_count + 1
	if chosen_counter == strength_count then
		//call Trace("I'm building anti siege units")
		call BuildAntisiegeStrength()
	endif
	set strength_count = strength_count + 1
	if chosen_counter == strength_count then
		//call Trace("I'm building anti magic units")
		call BuildAntimagicStrength()
	endif
	set strength_count = strength_count + 1
	if chosen_counter == strength_count then
		//call Trace("I'm building anti unarmored units")
		call BuildAntiunarmoredStrength()
	endif
	set strength_count = strength_count + 1
	if chosen_counter == strength_count then
		//call Trace("I'm building anti lightarmor units")
		call BuildAntilightarmorStrength()
	endif
	set strength_count = strength_count + 1
	if chosen_counter == strength_count then
		//call Trace("I'm building anti mediumarmor units")
		call BuildAntimediumarmorStrength()
	endif
	set strength_count = strength_count + 1
	if chosen_counter == strength_count then
		//call Trace("I'm building anti heavyarmor units")
		call BuildAntiheavyarmorStrength()
	endif
	set strength_count = strength_count + 1

endfunction

function InitHarass takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > max_harass_groups
    set harass_size[i] = 0
    set harass_time[i] = -1000000
    set i = i + 1
  endloop
  set distraction_group = 0
endfunction

function AddHarass takes integer groupnum, integer qty, integer unitid returns nothing
  if (harass_size[groupnum] < max_harass_groups ) then
    set harass_qty[harass_size[groupnum]] = qty
    set harass_units[harass_size[groupnum]] = unitid
    set harass_size[groupnum] = harass_size[groupnum] + 1
  else
    call Trace("ERROR: Too many harass unit groups added to harass group")
  endif
endfunction

function AddHarassUnittype takes integer groupnum, integer harassnum, group g, group harasser, integer key returns group
  local group cg = CopyGroup(g)
  local unit u = null
  local real player_sum = 0
  set cg = SelectNumberOfId(cg, harass_qty[harassnum], old_id[harass_units[harassnum]])
  loop
    set u = FirstOfGroup(cg)
    exitwhen u == null
    call GroupAddUnit(unit_harassing, u)
    call RemoveGuardPosition(u)
    call GroupAddUnit(harasser,u)
    set player_sum = player_sum + GetUnitStrength(u)
    call GroupRemoveUnit(cg,u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(cg)
  set cg = null
  call SaveReal(additional_info, key, START_STRENGTH, player_sum)
  return harasser
endfunction

function StartHarass takes integer groupnum, integer harass_target, boolean avoid_towers, real strength_limit, real flee_percent, integer flee_number, real lx, real ly returns nothing
  local integer i = 0
  local integer t = 0
  local group harasser = CreateGroup()
  local group g = CreateGroup()
  local integer key = GetHandleId(harasser)
  local real strength = 0
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectByHidden(g, false)
  set g = SelectByAlive(g, true)
  set g = SelectByFullHealth(g, true)
  set g = SelectByUnitStandard(g, true)
  set g = SelectByUnitFree(g, true)
  loop
    exitwhen i >= harass_size[groupnum] or FirstOfGroup(g) == null or t >= 12
    set t = t + harass_qty[i]
    if t > 12 then  // Group Order max control 12 unit
      set harass_qty[i] = t - 12
      set t = 12
    endif
    if harass_qty[i] > 0 then
      set harasser = AddHarassUnittype(groupnum, i , g, harasser, key)
      set strength = strength + LoadReal(additional_info, key, START_STRENGTH)
    endif
    set i = i + 1
  endloop
  call DestroyGroup(g)
  set g = null
  if FirstOfGroup(harasser) == null or strength <= 0 then
    call GroupRecycleHarrassPositionInstant(harasser)
    set harasser = null
    return
  endif
  set harass_time[groupnum] = ai_time
  call SaveReal(additional_info, key, START_STRENGTH, strength)
  call SaveBoolean(additional_info, key, AVOID_TOWERS, avoid_towers)
  //if avoid_towers and GetLocationTowerStrength(GetUnitX(target), GetUnitY(target), ver_tower_check_radius) > 0
  call SaveReal(additional_info, key, STRENGTH_LIMIT, strength_limit)
  call SaveBoolean(additional_info, key, STATE_ATTACKING, true)
  call SaveReal(additional_info, key, FLEE_PERCENT, flee_percent)
  call SaveInteger(additional_info, key, FLEE_NUMBER, flee_number)
  call SaveInteger(additional_info, key, INVISIBLE_COUNT, 0)
  call SaveReal(additional_info, key, LOCX, lx)
  call SaveReal(additional_info, key, LOCY, ly)
  call TQAddGroupJob(0, HARASS, harass_target, null, harasser)
  set harasser = null
endfunction

function GetHarassGroupStrength takes integer groupnum returns real
  local real sum = 0
  local real p = GetPlayerHandicap(ai_player)
  local integer id = 0
  local unit u = null
  local group g = CopyGroup(unit_harassing)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set id = GetUnitTypeId(u)
    set sum = TownCountDone(id) * GetFoodUsed(id) * p
   call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  return sum
endfunction

function Harass takes integer groupnum, integer harass_target, boolean avoid_towers, real strength_limit, real flee_percent, integer flee_number, boolean cond, integer min_time, integer time returns nothing
  if cond and ai_time - harass_time[groupnum] >= time and ai_time >= min_time then
    call StartHarass(groupnum, harass_target, avoid_towers, strength_limit, flee_percent, flee_number, 0, 0)
  endif
endfunction


function StartUpgradeAM takes integer level, integer upgid returns integer
  local integer gold_cost = 0
  local integer wood_cost = 0
  local integer upg_level = GetUpgradeLevel(old_id[upgid])

  if upg_level >= level or ai_time < upgrade_time[upgid] then
    return BUILT_ALL
  endif
  
  if town_threatened then
    return BUILT_SOME // ignore upgrades and build units instead
  endif

  set gold_cost = GetUpgradeGoldCost(old_id[upgid])
  set wood_cost = GetUpgradeWoodCost(old_id[upgid])

  set build_free[needed1[upgid]] = build_free[needed1[upgid]] - 1
  if build_free[needed1[upgid]] >= 0 then
    set total_gold = total_gold - gold_cost
    set total_wood = total_wood - wood_cost
    if total_gold < 0 then
      set total_gold = 0
    endif
    if total_wood < 0 then
      set total_wood = 0
    endif
  endif

  if total_gold <= 0 and not (gold_cost == 0) then
    return NOT_ENOUGH_RES
  endif

  if total_wood <= 0 and not (wood_cost == 0) then
    return NOT_ENOUGH_RES
  endif

  if SetUpgrade(old_id[upgid]) then
    set upgrade_time[upgid] = ai_time + 10
    return BUILT_ALL
  else
    return CANNOT_BUILD
  endif
  return BUILT_SOME
endfunction




function GuardSecondaryAM takes integer townid, integer qty, integer unitid, integer prio returns nothing
  if TownHasHall(townid) and TownHasMine(townid) then
    call SecondaryTownAM( townid, qty, unitid, prio )
  endif
endfunction

function DefendTownsEx takes boolean only_done, integer qty, integer unitid, integer prio returns nothing
  local integer twm = Max(TownWithMine(),1)
  local integer i = twm
  loop
    exitwhen i > twm + 2
    if TownHasMine(i) and TownCountEx(racial_expansion,only_done,i) > 0 then
      call SecondaryTownAM(i, qty, unitid, prio)
    endif
    set i = i + 1
  endloop
endfunction

function DefendTowns takes integer qty, integer unitid, integer prio returns nothing
  call DefendTownsEx(false, qty, unitid, prio)
endfunction

function DefendTownsDone takes integer qty, integer unitid, integer prio returns nothing
  call DefendTownsEx(true, qty, unitid, prio)
endfunction

function DefendTownsCond takes integer qty, integer unitid, integer min_dist, integer max_dist, integer min_gold, integer prio returns nothing
  local integer twm = Max(TownWithMine(),1)
  local integer i = twm
  loop
    exitwhen i > twm + 2
    if TownHasMine(i) and town_built[i] and own_town_dist[i] >= min_dist and own_town_dist[i] <= max_dist and GetResourceAmount(own_town_mine[i]) >= min_gold then
      call SecondaryTownAM(i, qty, unitid, prio)
    endif
    set i = i + 1
  endloop
endfunction

function BasicExpansionAM takes boolean build_it, integer unitid, integer prio returns nothing
  if build_it and HallsCompleted(unitid) then
    call BuildExpa( TownCount(unitid)+1, unitid, prio )
  endif
endfunction

function UpgradeAllAM takes integer baseid, integer newid, integer prio returns nothing
  call BuildUnit( TownCountDone(baseid), newid, prio )
endfunction


function FoodPoolAM takes integer food, boolean weak, integer id1, integer use1, boolean strong, integer id2, integer use2, integer prio returns nothing
  if strong then
    call BuildUnit( (food - use1 * TownCount(id1)) / use2, id2, prio )
  elseif weak then
    call BuildUnit( (food - use2 * TownCount(id2)) / use1, id1, prio )
  endif
endfunction


function MeleeTownHallAM takes integer townid, integer unitid, integer prio returns nothing
  if TownHasMine(townid) and not TownHasHall(townid) then
    call SecondaryTownAM( townid, 1, unitid, prio )
  endif
endfunction

function AddRefresh takes integer t, integer qty, integer unitid, integer town, integer bloc, integer prio returns nothing
    set t_build_qty[t_build_length] = qty
    set t_build_type[t_build_length] = t
    set t_build_item[t_build_length] = unitid
    set t_build_town[t_build_length] = town
    set t_build_loc[t_build_length] = bloc
    set t_build_prio[t_build_length] = prio
    set t_build_length = t_build_length + 1
endfunction

function RefreshAllNeeded takes nothing returns nothing
    local integer index = 0
    loop
      exitwhen index >= t_build_length
      call RefreshNeeded(t_build_type[index], t_build_qty[index], t_build_item[index], t_build_town[index], t_build_loc[index], t_build_prio[index])
      set index = index + 1
    endloop
endfunction

function GetNeutralHero takes integer unitid returns integer
	local integer i = 0

  call Trace("I Want a Tavern Hero")

  if not neutral_available[NEUTRAL_TAVERN] then
    call Trace("No Tavern Available")
    return BUILT_ALL
  endif
  if nearest_neutral[NEUTRAL_TAVERN] == null or neutral_guarded[NEUTRAL_TAVERN] then
    // Returns null if it cannot path to a tavern succesfully
    // Should switch to using transportation to get to it
    // Not Yet Implemented - will instead just build standard heroes
    call Trace("Tavern not usable: Getting standard hero")
    set recalculate_heros = true
    //set first_choosable_hero = ver_neutral_hero_number
    //loop
    //	exitwhen i > hero_number
    //	set all_heroes[i] = all_heroes_copy[i]
    //	set i = i + 1
    //endloop	
    //if hero[1] == unitid then
    //	set picked_hero = ChooseFirstHero()
    //elseif hero[2] == unitid then
    //	set hero[1] = GetExistingHero()
    //	call ChooseSecondHero()
    //else
    //	call ChooseRestHeroes()
    //endif
    //if nearest_neutral[NEUTRAL_TAVERN] == null then
    //	call DisplayToAll("No Tavern Reachable")
    //else
    //	call DisplayToAll("Tavern is guarded")
    //endif
    
    // call set_skills()       NOT YET IMPLEMENTED - if tavern is not passable it just chooses a normal hero, unfortunately it at moment has no skills
    return CANNOT_BUILD
  endif


  if (unitid == hero[1] and hero_built[1]) or (unitid == hero[2] and hero_built[2]) or (unitid == hero[3] and hero_built[3]) then
    call Trace("Try To Resurrect Tavern Hero")
	if SetProduce(1,old_id[unitid],-1) then
      return BUILT_ALL
    else
      return CANNOT_BUILD
    endif
  endif

 //   if neutral_sent[NEUTRAL_TAVERN] == null then
 //   	set neutral_sent[NEUTRAL_TAVERN] = GetUnitToBuy(nearest_neutral[NEUTRAL_TAVERN])
 //   	if neutral_sent[NEUTRAL_TAVERN]  == null then

  if TownCountDone(needed1[unitid]) < 1 or (unitid == hero[2] and TownCountDone(needed2[unitid]) < 1) or (unitid == hero[3] and TownCountDone(needed3[unitid]) < 1) then
    call Trace("Requirements failed to get hero")
    return CANNOT_BUILD
  endif


  if not neutral_ordered[NEUTRAL_TAVERN] then
    call Trace("Prepare to Do Tavern Job")
    set neutral_ordered[NEUTRAL_TAVERN] = true
    set neutral_wanted[NEUTRAL_TAVERN] = 1
    call TQAddJob(0, BUY_NEUTRAL_HERO, unitid)
  endif
  return BUILT_SOME
endfunction

function CheckNotBuiltFrom takes integer unitid returns boolean
  return true
endfunction

function GetBuildLocation takes integer bloc returns location
  if bloc == BLOC_MINE then
    return mine_loc
  endif
  if front_loc[0] != null then
    return front_loc[GetRandomInt(0, front_loc_num - 1)]
  endif
  return home_location
endfunction

function UpgradeBuilding takes integer qty, integer unitid, integer town, integer bloc returns integer
  local unit u = null
  local group g = CreateGroup()
  local integer current_town = town
  local integer num = 0
  if town == -1 then
    set current_town = 0
  endif
  if bloc != BLOC_STD then
    call GroupEnumUnitsInRangeOfLoc(g, GetBuildLocation(bloc), 800, null)
    set g = SelectByPlayer(g, ai_player, true)
    set g = SelectByAlive(g, true)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      if GetUnitTypeId(u) == old_id[needed1[unitid]] then
        if IssueImmediateOrderById(u, old_id[unitid]) then
          set num = num + 1
          if num >= qty then
            call DestroyGroup(g)
            set g = null
            set u = null
            return BUILT_ALL
          endif
        endif
      endif
      call GroupRemoveUnit(g,u)
    endloop
  endif
  if own_town_loc[current_town] != null then
    call GroupClear(g)
    call GroupEnumUnitsInRangeOfLoc(g, own_town_loc[current_town], 2000, null)
    set g = SelectByPlayer(g, ai_player, true)
    set g = SelectByAlive(g, true)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      if GetUnitTypeId(u) == old_id[needed1[unitid]] then
        if IssueImmediateOrderById(u, old_id[unitid]) then
          set num = num + 1
          if num >= qty then
            call DestroyGroup(g)
            set g = null
            set u = null
            return BUILT_ALL
          endif
        endif
      endif
      call GroupRemoveUnit(g,u)
    endloop
  endif
  call DestroyGroup(g)
  set g = null
  if town != -1 then
    if num == 0 then
      return CANNOT_BUILD
    else
      return BUILT_SOME
    endif
  endif
  set g = CreateGroup()
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == old_id[needed1[unitid]] then
      if IssueImmediateOrderById(u, old_id[unitid]) then
        set num = num + 1
        if num >= qty then
          call DestroyGroup(g)
          set g = null
          set u = null
          return BUILT_ALL
        endif
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  if num == 0 then
    return CANNOT_BUILD
  else
    return BUILT_SOME
  endif
endfunction

function BuildAtSpecialLoc takes integer unitid, integer town, integer bloc returns integer
  local unit u = CreateUnitAtLoc(Player(PLAYER_NEUTRAL_PASSIVE), old_id[unitid], GetBuildLocation(bloc), 270.0)
  local location l = GetUnitLoc(u)
  local unit peon = GetExpansionPeon()

  if peon == null then
    set peon = GetExpansionPeon2(peon)	// In case we can't get the expansion peon
  endif
  call RemoveUnit(u)
  set u = null
  if l == null then
    //call Trace("BuildatspecialLoc: No location found")
    //call RemoveLocation(l)
    //set l = null
    set peon = null
    return CANNOT_BUILD
  elseif peon == null then
    call Trace("BuildatspecialLoc: No peon available")
    call RemoveLocation(l)
    set l = null
    return CANNOT_BUILD	
  elseif not IssuePointOrderByIdLoc(peon, old_id[unitid], l) then
    //call Trace("Building at special point")
  //else
    // call Trace("BuildatspecialLoc: Not able to build here")
    call RemoveLocation(l)
    set l = null
    set peon = null
    return CANNOT_BUILD
  endif
  call RemoveLocation(l)
  set l = null
  set peon = null
  return BUILT_SOME
endfunction

function StartUnitAM takes integer ask_qty, integer unitid, integer town, integer bloc, integer prio, integer max_order returns integer
    local integer have_qty = 0
    local integer need_qty = 0
    local integer afford_gold = 0
    local integer afford_wood = 0
    local integer afford_food = 0
    local integer afford_qty = 0
    local integer gold_cost = 0
    local integer wood_cost = 0
    local integer food_cost = 0
    local integer cost_qty = 0
    local integer n1 = needed1[unitid]
    local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
    local integer nn = GetNeutralNumber(unitid)

    if town != -1 and (not town_built[town] or (unitid != racial_expansion and TownCountTown(racial_expansion, town) <= 0)) then
        return BUILT_ALL
    endif

    if buy_type[unitid] > BT_RACIAL_ITEM and (ai_time < available_time[unitid] or (neutral_guarded[nn] and ((daytime >= 5 and daytime < 18) or not neutral_night_buy[nn] or (buy_type[unitid] != BT_NEUTRAL_HERO and not ver_mercs_night_buy)))) then
      return BUILT_SOME
    endif

    if needed3[unitid] == UPGRADED and town != -1 and ai_time < available_time[unitid] then
      return BUILT_SOME
    endif

    //------------------------------------------------------------------------
    // if we have all we're asking for then make nothing
    //
    set have_qty = Max(TownCountTown(unitid,town),max_order)

    if have_qty >= ask_qty then
      return BUILT_ALL
    endif
    set need_qty = ask_qty - have_qty

    //------------------------------------------------------------------------
    // limit the qty we're requesting to the amount of resources available
    //
    set gold_cost = GetUnitGoldCost2(unitid)
    set wood_cost = GetUnitWoodCost2(unitid)
    set food_cost = GetFoodUsed(old_id[unitid])

    if gold_cost == 0 then
      set afford_gold = need_qty
    else
      set afford_gold = total_gold / gold_cost
    endif
    if afford_gold < need_qty then
      set afford_qty = afford_gold
    else
      set afford_qty = need_qty
    endif

    if wood_cost == 0 then
      set afford_wood = need_qty
    else
      set afford_wood = total_wood / wood_cost
    endif
    if afford_wood < afford_qty then
      set afford_qty = afford_wood
    endif

    if food_cost == 0 then
      set afford_food = need_qty
    else
      set afford_food = total_food / food_cost
    endif
    if afford_food < afford_qty then
      set afford_qty = afford_food
    endif

    //------------------------------------------------------------------------
    // whether we make right now what we're requesting or not, assume we will
    // and deduct the cost of the units from our fake gold total right away
    //
    if (buy_type[unitid] == BT_UNIT or buy_type[unitid] == BT_HERO) and CheckNotBuiltFrom(unitid) then
      set cost_qty = build_free[n1]
      if cost_qty > need_qty then
        set cost_qty = need_qty
      endif
      if cost_qty < 0 then
        set cost_qty = 0
      endif
      set build_free[n1] = build_free[n1] - need_qty
      if unitid != racial_peon then
        set gold_sum[n1] = gold_sum[n1] + need_qty * gold_cost
        set build_time_sum[n1] = build_time_sum[n1] + need_qty * GetUnitBuildTime(old_id[unitid])
        set build_num[n1] = build_num[n1] + need_qty
        set prio_sum[n1] = prio_sum[n1] + need_qty * prio
      endif
    else
      set cost_qty = need_qty
    endif

    set cost_qty = Min(cost_qty, afford_food)

    set afford_food = ApplyUpkeepCheck(afford_food, ver_food_limit - total_food, food_cost, cost_qty, need_qty)

    set cost_qty = Min(cost_qty, afford_food)
    set afford_qty = Min(afford_qty, cost_qty)

    set total_gold = total_gold - gold_cost * cost_qty
    set total_wood = total_wood - wood_cost * cost_qty
    set total_food = total_food - food_cost * cost_qty

    if total_gold < 0 then
      set total_gold = 0
    endif
    if total_wood < 0 then
      set total_wood = 0
    endif
    if total_food < 0 then
      set total_food = 0
    endif

    // if we're waiting on gold and wood; pause build orders
    if total_gold <= 0 and not (gold_cost == 0) then
      return NOT_ENOUGH_RES
    elseif total_wood <= 0 and not (wood_cost == 0) then
      return NOT_ENOUGH_RES
    elseif afford_qty <= 0 then
      return BUILT_SOME
    endif

    //------------------------------------------------------------------------
    // give the AI a chance to make the units (it may not be able to right now
    // but that doesn't stop us from trying other units after this as long
    // as we have enough money to make this AND the needed, unbuilt ones)
    //

    if needed3[unitid] == UPGRADED then
      if (needed1[unitid] != 0 and GetUnitCountEx(needed1[unitid],true,town) < 1) or (needed2[unitid] != 0 and TownCountDone(needed2[unitid]) < 1) then
        return CANNOT_BUILD
      endif
    endif



    if buy_type[unitid] == BT_NEUTRAL_HERO then
      return GetNeutralHero(unitid)
    endif

   if unitid == racial_rushcreep then
     if CreepsOnMap() and not towerrush then
       call BuildBRAtCreep()
     endif
     set racial_rushcreep = -1  //just run once
     return BUILT_SOME
   endif

    if buy_type[unitid] > BT_RACIAL_ITEM and buy_type[unitid] <= BT_MERCHANT_ITEM then
      if not (neutral_ordered[nn] or attack_running) and nearest_neutral[nn] != null then
        set neutral_ordered[nn] = true
        set neutral_wanted[nn] = afford_qty + have_qty
        call TQAddJob(0, BUY_NEUTRAL, unitid)
      endif
      return BUILT_SOME
    endif

    if needed3[unitid] == UPGRADED and buy_type[unitid] == BT_BUILDING then
      return UpgradeBuilding(afford_qty, unitid, town, bloc)
    endif

    if unitid == racial_lumber and TownCount(racial_lumber) < 1 then
      if BuildLumberMillAtBase() then
        return BUILT_SOME
      else
        return CANNOT_BUILD
      endif
    endif

    if bloc != BLOC_STD then
      if not CanBuildUnit(unitid) then
        return CANNOT_BUILD
      endif
      if bloc == BLOC_FRONT and not front_locs_computed then
        return BUILT_SOME
      endif
      if BuildAtSpecialLoc(unitid, town, bloc) != CANNOT_BUILD then   // This only occurs if no peon could be obtained
        return BUILT_SOME
      endif
    endif

    if SetProduce(afford_qty,old_id[unitid],town) then
      if town != -1 and unitid == racial_expansion then
        set town_built[town] = false
      endif
      if needed3[unitid] == UPGRADED then
        set available_time[unitid] = ai_time + GetUnitBuildTime(old_id[unitid]) / 5 + 1
      endif
      if (afford_qty == need_qty) and (need_qty == cost_qty) then
        return BUILT_ALL
      else
        return BUILT_SOME
      endif
    else
      return CANNOT_BUILD
    endif
endfunction

function ConstructExpansion takes unit peon, integer unitid returns boolean
  local unit u = null
  if ai_time > exp_loc_cache_timeout then
	set u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), unitid, GetUnitX(current_expansion), GetUnitY(current_expansion), 270.0)
    if DistanceBetweenUnits(u, current_expansion) > race_max_expa_mine_distance then
      call RemoveUnit(u)
      set u = null
      return false
    endif
    call RemoveLocation(exp_loc_cache)
    set exp_loc_cache = GetUnitLoc(u)
    set exp_loc_cache_timeout = ai_time + 4
  //  call SetUnitExploded(u, true)
  //  call KillUnit(u)
    call RemoveUnit(u)
    set u = null
  endif
  call TQAddUnitJob(2 * sleep_multiplier, BUILD_EXPANSION, 0, peon)
  return IssuePointOrderByIdLoc(peon, unitid, exp_loc_cache)
endfunction

function IsWaterExpansion takes unit u returns boolean
  //local integer i = 0
  // loop
  //   exitwhen i == water_expansion_list_length
  //   if water_expansion_list[i] == u then
  //     return true
  //   endif
  //   set i = i + 1
  // endloop
  return IsUnitInGroup(u,water_expansion)
endfunction

function BuildMovePeonZeppelin takes unit peon, unit target returns boolean
  // Disabled just in case
  if IsUnitInTransport(peon, build_zeppelin) then
    if DistanceBetweenUnits(build_zeppelin, target) > 300 then
      call IssuePointOrder(build_zeppelin, "move", GetUnitX(target) + GetRandomReal(-200,200), GetUnitY(target) + GetRandomReal(-200,200))
    else
      call IssueImmediateOrder(build_zeppelin, "stop")
      call IssueTargetOrder(build_zeppelin, "unload", peon)
      call Sleep(0.5)  //unload time
      call GroupRemoveUnit(unit_zepplin_move, build_zeppelin)
      call IssueImmediateOrder(peon, "stop")
      return true
    endif
  else
    if DistanceBetweenUnits(peon, target) < race_max_expa_mine_distance then
      call GroupRemoveUnit(unit_zepplin_move, build_zeppelin)
      call IssueImmediateOrder(peon, "stop")
      return true
    else
      call IssueTargetOrder(peon, "smart", build_zeppelin)
    endif
  endif
  return false
endfunction

function StartExpansionAM takes integer qty, integer hall returns integer
  local integer count = TownCount(hall)
  local integer countdone = TownCountDone(hall)
  local integer mines = GetMinesOwned()
  local integer i = racial_expansion
  local unit    u = null
  local integer gold_cost = 0
  local integer wood_cost = 0
  local boolean f = false
  local boolean w = false
  if countdone >= qty then
    return BUILT_ALL
  endif
  if (count > countdone) or town_threatened then
    return BUILT_SOME
  endif

  if first_town_mine > 1 and MultipleMinefix() then
    return BUILT_ALL
  endif

  if current_expansion == null or CheckExpansionTaken(current_expansion) then
    call ChooseExpansion()
    if current_expansion == null then
     call Trace("AMAIStartexpa: Expansion Not Found")
      return BUILT_ALL
    endif
  endif
  if CheckExpansionTaken(current_expansion) then
    set current_expansion = null
    return BUILT_ALL
  endif
  // call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Expansion Taken Checked")

 // call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Expansion choosen")
  if first_town_mine > 0 and (race_uses_mine_expansion or race_manual_loading) then  //home_location have multiple mine , fix GetMinesOwned bug(ELF and UD)
    if race_manual_loading then
      set i = race_manual_loading_mine
    endif
    set mines = Min(TownCount(i),mines)  // check actual number of gold mines
  endif
  set gold_cost = GetUnitGoldCost2(hall)
  set wood_cost = GetUnitWoodCost2(hall)

  set total_gold = total_gold - gold_cost
  set total_wood = total_wood - wood_cost

  if total_gold < 0 then
    set total_gold = 0
  endif
  if total_wood < 0 then
    set total_wood = 0
  endif
  if mines != 0 then
    if total_gold <= 0 and not (gold_cost == 0) then
      return NOT_ENOUGH_RES
    endif
    if total_wood <= 0 and not (wood_cost == 0) then
      return NOT_ENOUGH_RES
    endif
  elseif GetGold() < gold_cost or GetWood() < wood_cost then  //fix priority , if have rescources and not mine , ensure expansion
    return NOT_ENOUGH_RES
  endif

  set take_exp = (GetExpFoe(u) != null)
  set u = null
  if take_exp or total_gold <= 0 or total_wood <= 0 then
    return BUILT_SOME
  endif

 // call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Expansion rescources sorted")

  if expansion_peon == null or not UnitAlive(expansion_peon) then
    set expansion_peon = GetExpansionPeon()
    if expansion_peon == null or not UnitAlive(expansion_peon) then
      set expansion_peon = GetExpansionPeon2(expansion_peon)
    endif
  endif
  //  call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Peon Got")
  set f = IsUnitInGroup(current_expansion, far_expansion)
  set w = IsWaterExpansion(current_expansion)
  if not w and DistanceBetweenUnits(expansion_peon,current_expansion) > 6000 and not f then
    call GroupAddUnit(far_expansion, current_expansion)
    set f = true
  endif

  if expansion_peon != null and UnitAlive(expansion_peon) then
    if (w or f) and neutral_available[NEUTRAL_OBSERVATORY] then
      if build_zeppelin == null or not UnitAlive(build_zeppelin) then
        if not UnitAlive(build_zeppelin) then
          call GroupRemoveUnit(unit_zepplin_move, build_zeppelin)
        endif
        set build_zeppelin = GetUnusedZeppelinNearUnit(build_zeppelin, expansion_peon)
        if build_zeppelin == null then
          call Trace("No Zeppelin found for transporting peon")
        else
          call GroupAddUnit(unit_zepplin_move, build_zeppelin)
        endif
      endif
      call Trace("AMAIStartexpa: Is a water or far expansion so using zeppelin")
      if (w and build_zeppelin == null) or (build_zeppelin != null and not BuildMovePeonZeppelin(expansion_peon, current_expansion)) then
        call Trace("AMAIStartexpa: zeppelin cannot expand")
        return BUILT_SOME
      endif
    endif
    set exp_time_count = ai_time	// This sets time to next expansion to current time so it waits enough time before starting another expansion 
    if race_uses_mine_expansion then
      call TQAddUnitJob(2 * sleep_multiplier, BUILD_EXPANSION, 0, expansion_peon)
      call IssueTargetOrderById(expansion_peon, old_id[hall], current_expansion)
    else
      call ConstructExpansion(expansion_peon,old_id[hall])
    endif
  endif
  //  call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Expansion Finished")
  return BUILT_SOME
endfunction

function BuyItem takes integer qty, integer id returns boolean
  if attack_running then
    return false
  endif
  if shop_ordered then
    //call Trace("Already ordered to get an item")
    return true
  endif
  set shop_wanted = qty
  if buy_type[id] == BT_RACIAL_ITEM then
    set shop_unit = GetOneOfId(shop_unit, ai_player, old_id[racial_shop])
    set shop_distance_limit = raceshop_distance_limit
  else
    set shop_unit = nearest_neutral[NEUTRAL_MERCHANT]
    set shop_distance_limit = merchant_distance_limit
  endif
  if shop_unit != null then
    set shop_ordered = true
    call TQAddJob(0, BUY_ITEM, id)
    return true
  endif
  return false
endfunction

function BuyAllyShopItem takes integer qty, integer id returns boolean
  local group g = null
  local unit u = null
  local integer i = 0
  local integer m = 0
  if attack_running then
    return false
  endif
  if shop_ordered then
    //call Trace("Already ordered to get an item")
    return true
  endif
  loop
    exitwhen i < 0 or i >= c_ally_total
    set m = GetRandomInt(0,c_ally_total-1)
    set i = i + 1
    if GetPlayerSlotState(ally_force[m]) == PLAYER_SLOT_STATE_PLAYING then
      set i = -1
    endif
  endloop
  set shop_unit = null
  if m > 1 then
    set g = CreateGroup()
    call GroupEnumUnitsOfPlayer(g, ally_force[m], null)
    set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      if GetUnitAbilityLevel(u, 'Aall') > 0 and UnitAlive(u) and not IsUnitHidden(u) then  // select ally shop , use JOB TrackTown record ally shop is best, but worried about affecting efficiency , if use new JOB then too wasteful
        if shop_unit == null or GetRandomInt(0,1) == 1 then
          set shop_unit = u  // get Random shop
        endif
      endif
      call GroupRemoveUnit(g, u)
    endloop
    call DestroyGroup(g)
    set g = null
  endif
  if shop_unit == null then
    return false
  endif
  set shop_wanted = qty
  set shop_distance_limit = raceshop_distance_limit
  set shop_ordered = true
  call TQAddJob(0, BUY_ITEM, id)
  return true
endfunction

function StartEmergencyItem takes integer ask_qty, integer itemid returns integer
  local integer gold_cost = gold_price[itemid]
  local integer wood_cost = wood_price[itemid]
  local integer have_qty = GetItemNumber(itemid)
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  local integer gold = GetGold()
  local integer wood = GetWood()

  if have_qty >= ask_qty or (buy_type[itemid] == BT_MERCHANT_ITEM and not neutral_available[NEUTRAL_MERCHANT]) then
    return BUILT_ALL
  endif

  if nearest_neutral[NEUTRAL_MERCHANT] == null and buy_type[itemid] == BT_MERCHANT_ITEM then
    call Trace("No merchant available to buy emergency item")
    // Cannot path so will require transporter
    // NYI
    return BUILT_ALL
  endif

  if available_time[itemid] > ai_time or (buy_type[itemid] == BT_MERCHANT_ITEM and neutral_guarded[NEUTRAL_MERCHANT] and ((daytime >= 5 and daytime < 18) or not neutral_night_buy[NEUTRAL_MERCHANT])) then
    return BUILT_SOME
  endif

  if (needed1[itemid] != 0 and TownCountDone(needed1[itemid]) < 1) or (needed2[itemid] != 0 and TownCountDone(needed2[itemid]) < 1) or (needed3[itemid] != 0 and TownCountDone(needed3[itemid]) < 1) then
    call Trace("Emergency item not enough requirements to buy item")
    return CANNOT_BUILD
  endif

  set gold = gold - gold_cost
  set wood = wood - wood_cost

  if gold < 0 then
    set gold = 0
  endif
  if wood < 0 then
    set wood = 0
  endif

  if gold <= 0 and not (gold_cost == 0) then
    return NOT_ENOUGH_RES
  endif

  if wood <= 0 and not (wood_cost == 0) then
    return NOT_ENOUGH_RES
  endif

  if BuyItem(have_qty + 1, itemid) then
    call Trace("Buying emergency item")
    return BUILT_SOME
  else
    return CANNOT_BUILD
  endif
  return BUILT_SOME
endfunction

function StartItem takes integer ask_qty, integer itemid returns integer
  local integer gold_cost = gold_price[itemid]
  local integer wood_cost = wood_price[itemid]
  local integer have_qty = GetItemNumber(itemid)
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)


  if have_qty >= ask_qty or (buy_type[itemid] == BT_MERCHANT_ITEM and not neutral_available[NEUTRAL_MERCHANT]) then
    return BUILT_ALL
  endif

  if nearest_neutral[NEUTRAL_MERCHANT] == null and buy_type[itemid] == BT_MERCHANT_ITEM then
    // Cannot path so will require transporter
    // NYI
    return BUILT_ALL
  endif

  if available_time[itemid] > ai_time or GetSlotsFree() <= 0 or (buy_type[itemid] == BT_MERCHANT_ITEM and neutral_guarded[NEUTRAL_MERCHANT] and ((daytime >= 5 and daytime < 18) or not neutral_night_buy[NEUTRAL_MERCHANT])) then
    return BUILT_SOME
  endif

  if (needed1[itemid] != 0 and TownCountDone(needed1[itemid]) < 1) or (needed2[itemid] != 0 and TownCountDone(needed2[itemid]) < 1) or (needed3[itemid] != 0 and TownCountDone(needed3[itemid]) < 1) then
    return CANNOT_BUILD
  endif

  set total_gold = total_gold - gold_cost
  set total_wood = total_wood - wood_cost

  if total_gold < 0 then
    set total_gold = 0
  endif
  if total_wood < 0 then
    set total_wood = 0
  endif

  if total_gold <= 0 and not (gold_cost == 0) then
    return NOT_ENOUGH_RES
  endif

  if total_wood <= 0 and not (wood_cost == 0) then
    return NOT_ENOUGH_RES
  endif

  if BuyItem(have_qty + 1, itemid) then
    return BUILT_SOME
  else
    if IsHealingItem(itemid) and buy_type[itemid] == BT_RACIAL_ITEM and c_ally_total > 0 and GetGold() > 1000 then
      if BuyAllyShopItem(have_qty + 1,itemid) then  //return false just run next time
        return BUILT_SOME
      endif
    endif
    return CANNOT_BUILD
  endif
  return BUILT_SOME
endfunction

function BuildFarms takes integer qty returns nothing
  if TownCount(racial_farm) < race_farms_at_mine then
    call BuildAtMine(Min(TownCountDone(racial_farm) + qty, max_farms), racial_farm, farm_prio)
  elseif race_build_farms_front and front_locs_computed and TownCountDone(racial_farm) <= race_farms_front_limit + 1 and TownCountDone(racial_farm) >= 1 then
    call BuildFront(Min(TownCountDone(racial_farm) + qty, max_farms), racial_farm, farm_prio)
  else
    call BuildUnit(Min(TownCountDone(racial_farm) + qty, max_farms), racial_farm, farm_prio)
  endif
endfunction

function FarmBuilder takes nothing returns nothing
  if FoodCap() >= ver_food_limit then
    return
  endif
  if FoodSpace() <= farm_food2 then
    call BuildFarms(2)
  elseif FoodSpace() <= farm_food then
    call BuildFarms(1)
  endif
endfunction

function ShredderBuilder takes nothing returns nothing
  local real g = GetGold()
  local real w = Max(GetWood(),1)
  local real gdivw = g / w
  if neutral_available[NEUTRAL_OBSERVATORY] and gdivw > 4 and g - w > 500 and w < 550 and g > GetUnitGoldCost2(neutral_shredder) and w > GetUnitWoodCost2(neutral_shredder) and ai_time - available_time[neutral_shredder] >= -1 then
    if (race_has_ghouls) then
      call BuildUnit(1, neutral_shredder, ghoul_prio - 4)
    else
      call BuildUnit(1, neutral_shredder, peon_prio - 10)
    endif
  endif
endfunction

function BuildPeons takes integer number returns nothing
  if first_town_mine == 2 and not towerrush then  // startloc have more mine compensate
    if not race_manual_loading and not race_uses_mine_expansion and not race_has_ghouls then
      set number = number + 3
    endif
  endif
  call BuildUnit(number, racial_peon, peon_prio)
endfunction

function BuildGhouls takes integer number returns nothing
  call BuildUnit(number, racial_ghoul, ghoul_prio)
endfunction

function PeonBuilder takes nothing returns nothing
  local integer mo = GetMinesHarvested()
  local integer sc = TownCount(neutral_shredder)
  local real w = GetWood()
  if race_uses_shredder then
    call ShredderBuilder()
  else
    set sc = 0
  endif
  //if w <= maximum_peon_wood then 
  //  call BuildPeons( peon_1_mine_number * mo + Max(max_lumber_peons - shredder_peon_count*sc, 1 )  )  // number of peons per mine + wood peons
  //elseif w >= minimum_peon_wood then
  //  call BuildPeons( peon_1_mine_number * mo + Max(min_lumber_peons - shredder_peon_count*sc, 1 )  )
  //else
  //  call BuildPeons( peon_1_mine_number * mo + Max(Max(min_lumber_peons, R2I(I2R(max_lumber_peons) / 2)) - shredder_peon_count*sc, 1 )  )
  //endif

  if race_has_ghouls then
    if mo <= 1 then
      call BuildPeons(min_peon_number_single_mine)
    elseif mo <= 2 then
      call BuildPeons(min_peon_number_double_mine)
    else
      call BuildPeons(min_peon_number_multi_mine)
    endif
  else
    if mo <= 1 then
      // call BuildPeons(Max(min_peon_number_single_mine, R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_1_mine_number, 5, w)) - shredder_peon_count*sc))
      call BuildPeons(Max(R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_1_mine_number, min_peon_number_single_mine, w) - shredder_peon_count*sc),min_peon_number_single_mine))  // the Max condition prevents having loads of shredders stoping amai getting peons for gold
    elseif mo <= 2 then
      // call BuildPeons(Max(min_peon_number_double_mine, R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_2_mines_number, 10, w)) - shredder_peon_count*sc))
      call BuildPeons(Max(R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_2_mines_number, min_peon_number_double_mine, w) - shredder_peon_count*sc),min_peon_number_double_mine))
    else
      // call BuildPeons(Max(min_peon_number_multi_mine, R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_mines_number, 10, w)) - shredder_peon_count*sc))
      call BuildPeons(Max(R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_mines_number, min_peon_number_multi_mine, w) - shredder_peon_count*sc),min_peon_number_multi_mine))	
    endif
  endif
  if race_has_ghouls then
    call BuildGhouls(Max(R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, race_max_ghouls, race_min_ghouls, w) - R2I(shredder_peon_count/2)*sc),2)) 
  endif
endfunction

function SetBuildFree takes nothing returns nothing
local integer i = 0
local integer j = 0
loop
  exitwhen i >= building_length
  set j = building[i]
  set build_free[j] = TownCountDone(j)
  set gold_sum[j] = 0
  set build_time_sum[j] = 0
  set build_num[j] = 0
  set prio_sum[j] = 0
  set i = i + 1
endloop
endfunction

function ExpansionBuilder takes nothing returns nothing
local integer mines = GetMinesOwned()
local integer gold_left = GetGoldOwned()
local integer i = racial_expansion
local boolean exp_prepared = false
local boolean rebuild = false
local unit u = null

if first_expansion_chosen and (current_expansion == null or CheckExpansionTaken(current_expansion)) then
  call ChooseExpansion()
  if current_expansion == null then
    call Trace("ExpansionBuilder: No mine available")
    return
  endif
endif
if CheckExpansionTaken(current_expansion) then
  set current_expansion = null
  return
endif
set exp_prepared = false
if first_town_mine > 0 and (race_uses_mine_expansion or race_manual_loading) then  //home_location have multiple mine , fix GetMinesOwned bug(ELF and UD)
  if race_manual_loading then
    set i = race_manual_loading_mine
  endif
  set mines = Min(TownCount(i),mines)  // check actual number of gold mines
endif

set i = 2
if active_expansion == true then
  set i = 3
endif
set u = GetExpFoe(u)
if mines < i and ai_time - exp_time_count > exp_first_time then
  if u != null then
    set take_exp = true
    //if attacking_expansion then
    //  set exp_prepared = true
    //  call Trace("ExpansionBuilder: Ready to expand to mine 2 - odd")
    //endif
  else
    set take_exp = false
    set exp_prepared = true
    call Trace("ExpansionBuilder:Ready to expand to mine 2")	
  endif
endif

if mines < 3 and ai_time - exp_time_count > exp_second_time then
  if u != null then
    set take_exp = true
  else
    set take_exp = false
    set exp_prepared = true
    call Trace("ExpansionBuilder:Ready to expand to mine 3")		
  endif
endif

if not exp_prepared and u == null then
  set rebuild = CheckExpansionRebuild()
  if rebuild then
    set exp_prepared = true
  endif
endif
set u = null
if mines < 1 or gold_left < 2000 or exp_prepared then
  call Trace("ExpansionBuilder: Putting mine on build list")
  if mines < 1 or gold_left < 2000 then
    call BuildExpa(TownCount(racial_expansion) + 1, racial_expansion, expa_emergency_prio)
  elseif rebuild then
    call BuildExpa(TownCount(racial_expansion) + 1, racial_expansion, expa_rebuild_prio)
  else
    call BuildExpa(TownCount(racial_expansion) + 1, racial_expansion, expa_prio)
  endif
endif

endfunction

function InitHeroInfo takes integer hn returns nothing
  if hero_loc[hn] != null then
    call RemoveLocation(hero_loc[hn])
  endif
  set hero_loc[hn] = GetUnitLoc(hero_unit[hn])
  if hero_enemy_loc[hn] != null then
    call RemoveLocation(hero_enemy_loc[hn])
  endif
  if hero_ally_loc[hn] != null then
    call RemoveLocation(hero_ally_loc[hn])
  endif
  set hero_enemy_loc[hn] = Location(0,0)
  set hero_ally_loc[hn] = Location(0,0)
  set hero_hp[hn] = 1
endfunction

function HeroReviver takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > 3
    if GetUnitCountDone(old_id[hero[i]]) > 0 then
      if not hero_built[i] then
        set hero_unit[i] = GetOneOfId(hero_unit[i], ai_player, old_id[hero[i]])
        if hero_unit[i] != null then
          set hero_built[i] = true
          call InitHeroInfo(i)
          call TQAddJob(1, MICRO_HERO, i)
        endif
      endif
    elseif hero_built[i] then
      call BuildUnit(1, hero[i], hero_revive_prio[i])
    endif
    set i = i + 1
  endloop
endfunction

function CheckUnitNewTown takes unit u, integer num returns boolean
  local integer i = 0
  local location l = GetUnitLoc(u)
  loop
    exitwhen i >= num
    if town_built[i] and own_town_loc[i] != null and DistanceBetweenPoints(l, own_town_loc[i]) < town_radius then
      call RemoveLocation(l)
      set l = null
      return false
    endif
    set i = i + 1
  endloop
  call RemoveLocation(l)
  set l = null
  return true
endfunction

function LocalizeOldTown takes integer num returns boolean
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsInRangeOfLoc(g, own_town_loc[num], 2000, null)
  set g = SelectByPlayer(g,ai_player,true)
  set g = SelectByHidden(g,false)
  set g = SelectByAlive(g,true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    exitwhen IsUnitType(u, UNIT_TYPE_STRUCTURE)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  if u == null then
    if num != 0 then  //Prevent moving away from the starting loc
      set exist_town[exist_town_num] = home_location
    endif
    return false
  endif
  set exist_town_num = exist_town_num + 1
  set u = null
  return true
endfunction

function LocalizeNewTown takes integer num returns boolean
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectByHidden(g,false)
  set g = SelectByAlive(g,true)
  set g = SelectById(g, old_id[racial_expansion], true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    exitwhen CheckUnitNewTown(u, num)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  if own_town_loc[num] != null then
    call RemoveLocation(own_town_loc[num])
  endif
  if u == null then
    set own_town_loc[num] = null
    set own_town_mine[num] = null
    set own_town_dist[num] = 0
    return false
  endif
  set own_town_loc[num] = GetUnitLoc(u)
  set own_town_mine[num] = GetMineNearLoc(own_town_mine[num], own_town_loc[num], 1500)
  set own_town_dist[num] = DistanceBetweenPoints(home_location, own_town_loc[num])
  set exist_town[exist_town_num] = own_town_loc[num]
  set exist_town_num = exist_town_num + 1
  if debugging then
    call PingMinimap(GetUnitX(u), GetUnitY(u), 20)
  endif
  set u = null
  return true
endfunction

function CheckTownBuilt takes nothing returns nothing
  local integer i = 0
  set exist_town_num = 0
  loop
    exitwhen i >= max_towns
    if not town_built[i] then
      if (TownCountEx(racial_expansion, true, i) > 0 and not (TownCountEx(racial_expansion, true, 50) > 0)) then
        set town_built[i] = LocalizeNewTown(i)
      endif
    else
       set town_built[i] = LocalizeOldTown(i)
    endif
    set i = i + 1
  endloop
endfunction

function TimeKeeper takes nothing returns nothing
  //local real new_time_of_day = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  //if new_time_of_day < time_of_day then
  //  call Chat(C_NewYear)
  //endif
  //set time_of_day = new_time_of_day
  set ai_time = R2I(TimerGetElapsed(tq_timer)/5)
  if ai_time >= taunt_start_time then
    call Chat(C_Taunt)
  endif
endfunction

function FactoryNumberUpdate takes nothing returns nothing
  local integer g_sum = 0
  local integer i = 0
  local integer j = 0
  set gold_income = GetGoldIncome() * gold_unit_percentage
  loop
    exitwhen i >= building_length
    set g_sum = g_sum + gold_sum[building[i]]
    set i = i + 1
  endloop
  if g_sum == 0 then
    return
  endif
  set i = 0
  loop
    exitwhen i >= building_length
    set j = building[i]
    set income_percentage[j] = I2R(gold_sum[j]) / I2R(g_sum)
    if build_num[j] > 0 then
      call BuildUnit(GetFactoryQty(build_num[j], build_time_sum[j] / build_num[j], gold_sum[j] / build_num[j], income_percentage[j]), j, prio_sum[j] / build_num[j])
    endif
    set i = i + 1
  endloop
endfunction

function OneBuildLoopAM takes nothing returns nothing
    local integer index = 0
    local integer index_free = 0
    local integer qty = 0
    local integer id = 0
    local integer tp = 0
    local integer ret = 0
    local integer town = 0
    local integer array max_order
    local integer mo = 0
    local integer traced = 0
    local integer tracedsome = 0
    local integer tracednoresources = 0
    local integer tracedall = 0
    local string logtype = ""

    call InitLastUpkeep()

    call TimeKeeper()
    call CheckTownBuilt()
    call SetBuildFree()
    call FarmBuilder()
    call PeonBuilder()
    if not campaign_ai then
      call ExpansionBuilder()
      call HeroReviver()
    endif
    set total_gold   = GetGold() - gold_buffer
    set total_wood   = GetWood() - wood_buffer
    set total_food   = ver_food_limit - FoodUsed()

    call CheckUpkeepAllowed(ver_food_limit - total_food)

    set blocked_gold = 0
    set blocked_wood = 0
    set blocked_food = 0
    set t_build_length = 0

    call GetBuildLock()
    loop
        exitwhen index >= build_length
        call Sleep(0.01)
        set id = build_item[index]
        set qty = RBlockListCheck(build_qty[index], id)
        set tp = build_type[index]
        set town = Max(build_town[index],0)
        set mo = max_order[id + town*OBJECT_NUM]

        if build_qty[index] > mo then
          if tp == BUILD_UNIT then
              set logtype = "unit "
              set ret = StartUnitAM(qty,id,build_town[index], build_loc[index], build_prio[index], mo)
          elseif tp == BUILD_UPGRADE then
              set logtype = "upgrade "
              set ret = StartUpgradeAM(qty,id)
          elseif tp == BUILD_EXPAND then
              set logtype = "expand "
              set ret = StartExpansionAM(qty,id)
          elseif tp == BUILD_ITEM then
              set logtype = "item "
              set ret = StartItem(qty,id)
          else
            set logtype = "unknown:" + Int2Str(tp)
          endif

          if qty > mo then
            set max_order[id + town*OBJECT_NUM] = qty
          endif
          
          if ret == CANNOT_BUILD then
            if (traced == 0) then
              call Trace("CANNOT BUILD " + logtype + unitNames[id] + " " + Int2Str(id))
              set traced = id
            endif
            call AddRefresh(tp, qty, id, build_town[index], build_loc[index], build_prio[index])
          elseif ret == BUILT_SOME and tracedsome == 0 then
            //call Trace("BUILT SOME " + logtype + unitNames[id] + " " + Int2Str(id))
            set tracedsome = id
          elseif ret == BUILT_ALL and tracedall == 0 then
            //call Trace("BUILT ALL " + logtype + unitNames[id] + " " + Int2Str(id))
            set tracedall = id
          elseif ret == NOT_ENOUGH_RES and tracednoresources == 0 then
            call Trace("NO RESOURCES " + logtype + unitNames[id] + " " + Int2Str(id))
            set tracednoresources = id
          endif
          exitwhen ret == NOT_ENOUGH_RES // Don't try and build anything else as thing we trying to buy is too expensive
          if ret == CANNOT_BUILD or ret == BUILT_SOME or ret == NOT_ENOUGH_RES or (ret == BUILT_ALL and qty < build_qty[index]) then
            set build_qty[index_free] = build_qty[index]
            set build_type[index_free] = build_type[index]
            set build_item[index_free] = build_item[index]
            set build_loc[index_free] = build_loc[index]
            set build_town[index_free] = build_town[index]
            set build_prio[index_free] = build_prio[index] + prio_t_inc
            set index_free = index_free + 1
          endif
          call ApplyUpkeepSaving()
        endif

        set index = index + 1
        set total_gold = total_gold - blocked_gold
        set total_wood = total_wood - blocked_wood
        //set total_food = total_food - blocked_food
        set blocked_gold = 0
        set blocked_wood = 0
        set blocked_food = 0
        call UpdateLastUpkeep()
    endloop


    if ret == NOT_ENOUGH_RES and gold_buffer + wood_buffer == 0 and not hero_built[1] then  // beginning of the game , if no resources build , build next unit , maybe next is peon
      set index = index + 1
    endif
    loop
          exitwhen index >= build_length
          set build_qty[index_free] = build_qty[index]
          set build_type[index_free] = build_type[index]
          set build_item[index_free] = build_item[index]
          set build_town[index_free] = build_town[index]
          set build_loc[index_free] = build_loc[index]
          set build_prio[index_free] = build_prio[index] + prio_t_inc
          set index_free = index_free + 1
          set index = index + 1
    endloop
    set build_length = index_free
    
    call ResetUpkeepSaveTime()
    call ReleaseBuildLock()
    call RefreshAllNeeded()
    call FactoryNumberUpdate()
    set logtype = null

endfunction


function BuildLoopAM takes nothing returns nothing
  local integer blc = 0
  call OneBuildLoopAM()
  call StaggerSleep(1,5)
  loop
    //call Trace("Build Loop")
    set blc = blc + 1
    call OneBuildLoopAM()
    exitwhen player_defeated
    if blc > build_array_reset_time then
      call InitBuildArrayAM()
      set blc = 0
    endif
    call Sleep(5 * sleep_multiplier)
  endloop
endfunction

function PlayGameAM takes nothing returns nothing
  call BuildLoopAM()
endfunction

function ConversionsAM takes integer desire, integer unitid returns nothing
  if unitid == HIPPO_RIDER then
    call MergeUnits(desire,oARCHER,oHIPPO,oHIPPO_RIDER)
  endif
endfunction

function SetAssaultGroupAM takes integer qty, integer max, integer unitid returns nothing
  call ConversionsAM(max,unitid)

  set attack_qty[attack_length] = qty
  set attack_max[attack_length] = max
  set attack_units[attack_length] = unitid
  set attack_length = attack_length + 1
endfunction

function SetMeleeGroupAM takes integer unitid returns nothing
  call SetAssaultGroupAM(0,60,unitid)
endfunction

function AttackGroupAddNeutrals takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= merc_number
    call SetMeleeGroupAM(merc_unit[i])
    set i = i + 1
  endloop
  set i = 1
  loop
    exitwhen i >= dragon_number
    call SetMeleeGroupAM(dragons[i])
    set i = i + 1
  endloop
endfunction

function AttackGroupAddUnknown takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  local integer id = 0
  local integer i = 0
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, false)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, false)
  set g = SelectUnittype(g, UNIT_TYPE_SUMMONED, false)
  set g = SelectByHidden(g,false)
  set g = SelectByAlive(g,true)
  loop
    exitwhen i >= attack_length or FirstOfGroup(g) == null
    set g = SelectById(g, old_id[attack_units[i]], false)
    set i = i + 1
  endloop
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set id = GetUnitTypeId(u)
    if (IsUnitType(u, UNIT_TYPE_ATTACKS_FLYING) or IsUnitType(u, UNIT_TYPE_ATTACKS_GROUND)) and id != 'ngir' then
      call AddAssault(60,id)  //other hero and unit , like other race and custom
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
endfunction

function FormGroupAM takes integer seconds returns nothing
  local integer index = 0
  local integer count = 0
  local integer unitid = 0
  local integer desire = 0

  call InitAssault()

  loop
    exitwhen index == attack_length

    set unitid = attack_units[index]


    set desire = attack_max[index]
    set count  = TownCountDone(unitid)

    if unitid == racial_ghoul then
      set desire = attacking_ghouls
      if towerrush then
        set desire = Min(Max(count - 2 , 0),desire)  // reserve
      endif
    endif

    call ConversionsAM(desire,unitid)

    if count >= desire then
      call AddAssault(desire,old_id[unitid])
    else
      if unitid != racial_ghoul or take_all_ghouls_along then
        set desire = attack_qty[index]
      endif

      if count < desire then
        call AddAssault(desire,old_id[unitid])
      else
        call AddAssault(count,old_id[unitid])
      endif
    endif

    set index = index + 1
  endloop
  call Sleep(seconds)
endfunction

function DoAttackJobs takes nothing returns nothing
  if major_hero == null or not UnitAlive(major_hero) then
    set major_hero = GetMajorHero(major_hero)
  endif
  set battle_radius = normal_battle_radius
  set break_attack = false
  //if major_hero != null and UnitAlive(major_hero) then
    if not retreat_controlled then
      call Trace("===Retreat control started===")
      set retreat_controlled = true
      call SetGroupsFlee(false)
      call SetTargetHeroes(false)
      call TQAddJob(2 * sleep_multiplier, RETREAT_CONTROL, 0)
    endif
  //endif
endfunction

function GetDistractionTarget takes unit ru, unit target returns unit
  local group g = CreateGroup()
  local location unitloc = GetUnitLoc(target)
  call GroupEnumUnitsOfPlayer(g, GetOwningPlayer(target), null)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  set g = SelectByLocation(g, unitloc, 3000, false)
  set ru = GetFarestOfGroup(ru, g, unitloc)
  call RemoveLocation(unitloc)
  set unitloc = null
  call DestroyGroup(g)
  set g = null
  return ru
endfunction

function DoDistractionAttack takes unit target returns nothing
  local unit d_target = null
  set d_target = GetDistractionTarget(d_target, target)
  if d_target == null then
    return
  endif
  call StartHarass(distraction_group, HARASS_TARGET_LOCATION, false, 15, 0.25, 1, GetUnitX(d_target), GetUnitY(d_target))
  set d_target = null
  call Sleep(15)
endfunction

function SleepInCombatAM takes nothing returns nothing
    local integer count = 0
    //local integer attack_length_counter = 0
    call Trace("SleepInCombat")
    loop
      exitwhen town_threatened
      exitwhen break_attack
      exitwhen not CaptainInCombat(true)  // goal is cleared
      exitwhen CaptainIsEmpty()// duh
      exitwhen town_threat_break
      exitwhen R2I(count/sleep_multiplier) >= 900 // Took longer than 15 mins to attack something is wrong
      //loop
        //exitwhen captain_flee and CaptainRetreating()
        //exitwhen isfleeing and CaptainRetreating()
        //call CaptainAttack(GetLocationX(last_ally_loc), GetLocationY(last_ally_loc))
        //call Sleep(1 * sleep_multiplier)
        //set attack_length_counter = attack_length_counter + 1
        //if attack_length_counter > attack_reform_length then
          //set attack_length_counter = 0
          //call FormGroupAM(2)
        //endif
      //endloop
      //call Sleep(1)
      set count = count + 1
      call Sleep(1 * sleep_multiplier)
    endloop
    set count = 0
    loop
      exitwhen count >= 8 or town_threatened
      set count = count + 1
      call Sleep(1)
    endloop
    call Trace("exit SleepInCombat")
endfunction

function GetNearAlliedStrength takes unit target returns real
  local integer i = 0
  local real sum = 0
  local location unitloc = GetUnitLoc(target)
  local real dist = DistanceBetweenPoints(unitloc, ally_loc) + 600
  loop
    exitwhen i >= army_num
    if Player(army_owner[i]) != ai_player and IsPlayerAlly(ai_player, Player(army_owner[i])) then
      if DistanceBetweenPoints(unitloc, army_loc[i]) > dist and DistanceBetweenPoints(unitloc, army_future[i]) < 1300 then
        set sum = sum + army_strength[i]
      endif
    endif
    set i = i + 1
  endloop
  call RemoveLocation(unitloc)
  set unitloc = null
  return sum
endfunction

function GetNearerAlliedStrength takes unit target returns real
  local integer i = 0
  local real sum = 0
  local location unitloc = GetUnitLoc(target)
  local real dist = DistanceBetweenPoints(unitloc, ally_loc) + 600
  loop
    exitwhen i >= army_num
    if Player(army_owner[i]) != ai_player and IsPlayerAlly(ai_player, Player(army_owner[i])) then
      if DistanceBetweenPoints(unitloc, army_loc[i]) <= dist and DistanceBetweenPoints(unitloc, army_future[i]) < 1600 then
        set sum = sum + army_strength[i]
      endif
    endif
    set i = i + 1
  endloop
  call RemoveLocation(unitloc)
  set unitloc = null
  return sum
endfunction

function CheckAttackWait takes unit target returns boolean
  local real target_strength = GetLocationStrength(GetUnitX(target), GetUnitY(target), battle_radius)
  local real strength = GetOwnStrength()
  local real nearer_strength = GetNearerAlliedStrength(target)
  if strength + nearer_strength > target_strength * 1.1 then
    return false
  endif
  return GetNearAlliedStrength(target) > 10.0
endfunction

function DesperationAssault takes nothing returns nothing
  local group g = null
  local unit u = null
  local integer i = 0
  if not player_defeated then
    call Trace("Adding desperation troops")
    set g = CreateGroup()
    call GroupEnumUnitsOfPlayer(g, ai_player, null)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      if (IsUnitType(u, UNIT_TYPE_ANCIENT) or not IsUnitType(u, UNIT_TYPE_STRUCTURE)) then
        call AddAssault(60, GetUnitTypeId(u))
      endif
      call GroupRemoveUnit(g, u )
    endloop
    call DestroyGroup(g)
    set g = null
  endif
endfunction

function CommonSleepUntilTargetDeadAM takes unit target, boolean iscreeping, boolean reform returns nothing
  local real dist = 0
  local integer attack_length_counter = 0
  local integer combat_length_counter = 0
  local group g = null

  if race_has_ghouls and race_ghouls_attack then
    set attack_length_counter = 5000  // Force army to regroup to try and get ghouls to go along
  endif
  loop
    exitwhen town_threat_break and town_threatened and most_threatened_town >= 0 and town_threat[most_threatened_town] >= teleport_low_threat and not desperation_assault
    exitwhen break_attack and not desperation_assault
    //exitwhen captain_flee and CaptainRetreating()
    exitwhen isfleeing and CaptainRetreating() and not desperation_assault
    exitwhen CaptainIsEmpty() and not desperation_assault
    //exitwhen not UnitAlive(target) and CaptainIsHome()  // A fail safe mechanism if getlocationnoncreepstrength malfunctions: not needed as issue now fixed
    if GetOwningPlayer(target) == ai_player or not UnitAlive(target) or (UnitInvis(target) and not IsUnitDetected(target, ai_player)) then
      set g = CreateGroup()
      call GroupEnumUnitsInRange(g,GetUnitX(target), GetUnitY(target),battle_radius,null)
      set g = SelectByAlive(g,true)
      set g = SelectByEnemy(g,ai_player, true)
      if not UnitAlive(target) or UnitInvis(target) then
        set g = SelectByVisible(g,ai_player,true)  // to find enemies that ai has noticed
      endif
      if iscreeping then
        set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_AGGRESSIVE), true)  // if creeping and unit invisible see if any other creeps targetable
      endif
      set target = FirstOfGroup(g)
      call DestroyGroup(g)
      exitwhen target == null
    endif
    //if not iscreeping then
       //	exitwhen GetLocationNonCreepStrength(unitx, unity, battle_radius) <= 0 and not UnitAlive(target) and GetLocationEnemyStrength(unitx, unity, battle_radius, true) <= 0 // enemies are dead and target dead
    //else
      //call Trace("Units, Creeps: " + Int2Str(GetLocationNonCreepStrength(unitx, unity, battle_radius)) + "," + Int2Str(GetLocationCreepStrength(unitx, unity, 500)))
    //	exitwhen GetLocationNonCreepStrength(unitx, unity, battle_radius) <= 0 and not UnitAlive(target) and GetLocationCreepStrength(unitx, unity, 500) <= 0			
    //endif
    set dist = DistanceBetweenPoints_kd(ally_loc, GetUnitLoc(target))
    if c_ally_total > 0 and dist > 1300 and dist < 2500 then
      if CheckAttackWait(target) then
        call AttackMoveXY(R2I(GetLocationX(ally_loc)), R2I(GetLocationY(ally_loc)))
      else
        call AttackMoveKill(target)
      endif
    else
      call AttackMoveKill(target)
    endif

    call Sleep(2 * sleep_multiplier)
    call CreateDebugTag("Reform until target dead", 10, target, 1.00, 0.80)
    //set attack_length_counter = attack_length_counter + 1
        //if reform and attack_length_counter > attack_reform_length then
    //  if CaptainInCombat(true) then
    //	set attack_length_counter = attack_length_counter - 2
    //  else
    //	set attack_length_counter = 0
    //	call FormGroupAM(2)
    //  endif
        //endif

    if desperation_assault and attack_length_counter > attack_reform_length * 5 then
      call DesperationAssault()
      set attack_length_counter = 0
    else 
      set attack_length_counter = attack_length_counter + 1
    endif
    if not desperation_assault then // Do not bother reforming in desperation mode, full attack speed
      if reform and CaptainInCombat(true) then
        set combat_length_counter = combat_length_counter + 1
      elseif reform then
        set attack_length_counter = attack_length_counter + 1
        set combat_length_counter = 0
      endif
      if reform and CaptainInCombat(true) and combat_length_counter > attack_reform_length * 3 then
        set combat_length_counter = 0
        call FormGroupAM(2)
      elseif reform and not CaptainInCombat(true) and attack_length_counter > attack_reform_length then
        set attack_length_counter = 0
        set combat_length_counter = 0
        call FormGroupAM(2)
      endif
    endif
  endloop
  set g = null
endfunction

function ReformUntilTargetDeadAM takes unit target, boolean iscreeping returns nothing
	call CommonSleepUntilTargetDeadAM(target,iscreeping,true)
endfunction

function SleepUntilTargetDeadAM takes unit target, boolean iscreeping returns nothing
	call CreateDebugTag("Sleep until target dead", 10, target, 3.00, 1.50)
	call CommonSleepUntilTargetDeadAM(target,iscreeping,false)
endfunction

function SleepUntilAtGoalAM takes nothing returns nothing
  local integer lcount = 0
  loop
    exitwhen town_threatened and most_threatened_town >= 0 and town_threat[most_threatened_town] >= teleport_low_threat
    set lcount = lcount + 1
    call Sleep(sleep_multiplier)
      exitwhen break_attack
    exitwhen CaptainRetreating() and isfleeing
    if lcount >= 6 then
      exitwhen CaptainAtGoal()        // reached goal
      exitwhen CaptainIsHome()        // failed to path and returned home
    endif
    exitwhen CaptainIsEmpty()       // all units died
    //call Trace("Sleeping until target reached")
    call Sleep(2 * sleep_multiplier)
  endloop
endfunction

function BRRush takes nothing returns nothing
  local location buildloc = null
  local location loc = null
  local unit u = null
  local unit utemp = null
  local group g = CreateGroup()
  local integer i = 0
  call GroupEnumUnitsInRange(g,GetUnitX(rushcreep_target), GetUnitY(rushcreep_target),800,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null or i == 1
    if UnitAlive(u) and GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_AGGRESSIVE) and IsPlayerEnemy(ai_player,GetOwningPlayer(u)) then
      set i = 1  // have other player
    elseif GetOwningPlayer(u) == ai_player and GetUnitTypeId(u) == 'eaom' then
      set utemp = u
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  set attack_running = true
  if i != 1 and GetUnitState(utemp, UNIT_STATE_LIFE) >= GetUnitState(utemp, UNIT_STATE_MAX_LIFE) * 0.65 then
    set buildloc = GetUnitLoc(utemp)
    call RemoveGuardPosition(utemp)
    call IssueImmediateOrder(utemp, "unroot")  //try unroot
    call Sleep(2.8)  //unroot time
    set loc = GetUnitLoc(rushcreep_target)
    call IssuePointOrderLoc(utemp, "attack", loc)
    call RemoveLocation(loc)
    set loc = null
    call AttackMoveKill(rushcreep_target)
    call ReformUntilTargetDeadAM(rushcreep_target, true)
    call Chat(C_Done)
    call SleepInCombatAM()
    call Trace("===BR Finished===")
    call IssuePointOrderLoc( utemp, "move", buildloc)  //prevent inability cannot root
    call Sleep(0.02)
    call IssuePointOrderLoc( utemp, "root", buildloc)  //root tree
    call TQAddUnitJob(GetTimeToReachLoc(utemp, buildloc) + 2, RESET_GUARD_POSITION, 0, u)
    call RemoveLocation(buildloc)
    set buildloc = null
  else
    call AttackMoveKill(rushcreep_target)
    call ReformUntilTargetDeadAM(rushcreep_target, true)
    call Chat(C_Done)
    call SleepInCombatAM()
    call Trace("===BR Finished , no tree ===")
  endif
  set attack_running = false
  if not UnitAlive(rushcreep_target) then
    set rushcreep_target = null
  endif
  set utemp = null
endfunction

function AttackMoveKillAAM takes unit target returns nothing
  if target == null or not UnitAlive(target) then
    call Trace("Bad target passed to AttackMoveKillAAM")
    call Sleep(3 * sleep_multiplier)
    return
  endif
  set attack_running = true
  call DoAttackJobs()
  if distraction_group != 0 and GetOwningPlayer(target) != Player(PLAYER_NEUTRAL_AGGRESSIVE) and GetRandomInt(1,10) < 5 then
    if GetHarassGroupStrength(distraction_group) < GetOwnStrength() / 3 then
      call DoDistractionAttack(target)
    endif
  endif
  call AttackMoveKill(target)
  call ReformUntilTargetDeadAM(target, false)
  call Chat(C_Done)
  call SleepInCombatAM()
  call Trace("===Attack Fully Finished===")
  set attack_running = false
  call Sleep(2.5)
endfunction

function AttackMoveKillCreep takes unit target returns nothing
  if target == null or not UnitAlive(target) then
    call Trace("Bad target passed to AttackMoveKillCreep")
    call Sleep(3 * sleep_multiplier)
    return
  endif
  set attack_running = true
  set break_attack = false
  if not retreat_controlled then
    call Trace("===Retreat control started===")
    set retreat_controlled = true
    call SetGroupsFlee(false)
    call SetTargetHeroes(false)
    call TQAddJob(2 * sleep_multiplier, RETREAT_CONTROL, 0)
  endif
  call AttackMoveKill(target)
  call ReformUntilTargetDeadAM(target, true)
  call Chat(C_Done)
  call SleepInCombatAM()
  call Trace("===Attack Fully Finished===")
  set attack_running = false
endfunction

function AttackMoveKillXYAAM takes integer x, integer y returns nothing
  set attack_running = true
  call DoAttackJobs()
  if zep_next_wave then
    call LoadZepWave(x,y)
    set zep_next_wave = false
  endif
  call AttackMoveXY(x,y)
  call SleepUntilAtGoalAM()
  call SleepInCombatAM()
  set attack_running = false
endfunction

function AttackMoveTowerRush takes nothing returns nothing
	local integer attack_length_counter = 0
	set attack_running = true
	loop
		exitwhen not towerrush
		exitwhen town_threatened and town_threat[most_threatened_town] >= teleport_low_threat
		exitwhen break_attack
		//exitwhen CaptainIsEmpty()       // all units died
		if first_tower_point_x == 0 and first_tower_point_y == 0 then
			call CreateDebugTag("Reform protect peon", 10, builder[1], 2.00, 1.50)
			call SetAllianceTarget(builder[1])		
  		call AttackMoveKill(builder[1])
		else
			//call SetCaptainHome(BOTH_CAPTAINS,R2I(((enemy_point_x - first_tower_point_x)/ 4) + first_tower_point_x),R2I(((enemy_point_y - first_tower_point_y)/ 4) + first_tower_point_y))
			if towers_built < 3 then
				call AttackMoveXY(R2I(((enemy_point_x - first_tower_point_x)/ 4) + first_tower_point_x), R2I(((enemy_point_y - first_tower_point_y)/ 4) + first_tower_point_y))
			elseif towers_built < 6 then
				call AttackMoveXY(R2I(((enemy_point_x - first_tower_point_x)/ 2) + first_tower_point_x), R2I(((enemy_point_y - first_tower_point_y)/ 4) + first_tower_point_y))			
			elseif towers_built <= 9 then
				call AttackMoveXY(R2I(enemy_point_x), R2I(enemy_point_y))
			endif
		endif
		call Sleep(2*sleep_multiplier)
		set attack_length_counter = attack_length_counter + 1
		if attack_length_counter > attack_reform_length then
			set attack_length_counter = 0
			call FormGroupAM(2)
		endif
	endloop
	call SleepInCombatAM()
	set attack_running = false
endfunction

function GetIntervalCreep takes unit u, integer lower, integer upper, integer str, integer anti_air_strength, boolean allow_air, integer sd returns unit
    local integer creepstrength = 0
    local integer middle = (lower + upper) / 2

    if sd < 0 then
      return null
    endif
    set u = GetCreepCamp(1, middle, allow_air)
    if u == null then
        return GetIntervalCreep(u, middle, upper, str, anti_air_strength, allow_air, sd - 1)
    else
      set creepstrength = GetCreepCampStrength(u) + 1
      if balancing then
        //call Trace("Creep strength: " + Int2Str(creepstrength))
        call PingMinimap(GetUnitX(u), GetUnitY(u), 1)
      endif
      if creepstrength < str then
        if air_strength <= anti_air_strength then
          return u
        else
          return GetIntervalCreep(u, lower, upper, str, anti_air_strength, false, sd)
        endif
      else
        return GetIntervalCreep(u, lower, middle, str, anti_air_strength, allow_air, sd - 1)
      endif
    endif
endfunction

function GetFittingCreep takes unit u, integer str returns unit
  local integer anti_air_strength = R2I(GetPlayerAntiAirStrength(ai_player))
  local integer creepstrength = 0
  local boolean allow_air = false      //anti_air_strength > 25
  local integer lvl = str

  set u = GetCreepCamp(1, lvl, true)
  if u != null then
    set air_strength = GetLocationCreepAirStrength(GetUnitX(u), GetUnitY(u), creep_camp_radius)
  endif
  set allow_air = air_strength <= anti_air_strength

  if (not allow_air) then
    set u = GetCreepCamp(1, lvl, false)
  endif

  if u == null then
    return u
  endif

  //call Trace("Our strength: " + Int2Str(str))
  set creepstrength = GetCreepCampStrength(u)
  if creepstrength < str and air_strength <= anti_air_strength then
    //call Trace("Creep match")
    call Trace("Creeping strength: " + Int2Str(creepstrength))
    set air_strength = creepstrength
    return u
  else
    //call Trace("No Creep ")
    return GetIntervalCreep(u, 1,100,str, anti_air_strength, allow_air, camp_scan_depth)
  endif
  return u



endfunction

function CreepAttack takes integer str returns nothing
  local unit target = null
  set target = GetFittingCreep(target,str)

  if target == null then
    call Trace("No creep target found")
    call Sleep(20)
    return
  endif
  call Chat(C_Creep)
  if air_strength > 15 then
    call SetAllianceTarget(target)
  endif
  call FormGroupAM(3)
  call AttackMoveKillCreep(target)
  call SetAllianceTarget(null)
  set target = null
endfunction

function QueueAttackMoveXY takes integer x, integer y returns nothing
  set attack_running = true
  call DoAttackJobs()
  loop
    call Sleep(sleep_multiplier)
    call AttackMoveXY(x,y)
    exitwhen break_attack
    exitwhen CaptainRetreating()
    exitwhen CaptainAtGoal()
    call Sleep(sleep_multiplier)
  endloop
  call SleepInCombatAM()
  if CaptainAtGoal() then
    call QueueGetNextCommand()
  endif
  set attack_running = false
endfunction

function GetRangePenalty takes unit target returns integer
  if major_hero == null then
    return 0
  elseif UnitAlive(target) == false then
    return 0
  else
    return R2I(DistanceBetweenUnits(major_hero, target)/1400)
  endif
endfunction

function GetWeakestEnemy takes nothing returns player
  local integer i = 0
  local integer pmin = 30
  local integer minstr = 1000
  local integer cstr = 0
  loop
    exitwhen i == c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set cstr = GetUnexactPlayerStrength(enemy_force[i])
      if cstr < minstr and GetBuilding(enemy_force[i]) != null then
        set pmin = i
        set minstr = cstr
      endif
    endif
  set i = i + 1
  endloop
  if pmin != 30 then
    return enemy_force[pmin]
  endif
  return null
endfunction

function GetStrongestEnemy takes nothing returns player
  local integer i = 0
  local integer pmax = 30
  local integer maxstr = 0
  local integer cstr = 0
  loop
    exitwhen i == c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set cstr = GetUnexactPlayerStrength(enemy_force[i])
      if cstr > maxstr then
        set pmax = i
        set maxstr = cstr
      endif
    endif
  set i = i + 1
  endloop
  if pmax != 30 then
    return enemy_force[pmax]
  endif
  return null
endfunction

function GetWeakAndNearEnemy takes nothing returns player
  local integer i = 0
  local integer pmin = -1
  local integer minstr = 10000
  local integer cstr = 0
  local unit cbuilding = null
  loop
    exitwhen i == c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set cbuilding = GetBuilding(enemy_force[i])
      if cbuilding != null and UnitAlive(cbuilding) then
        set cstr = GetUnexactPlayerStrength(enemy_force[i]) + GetRangePenalty(cbuilding)
        if cstr < minstr then
          set pmin = i
          set minstr = cstr
        endif
      endif
    endif
    set i = i + 1
  endloop
  // if pmin == -1 then
  //   call Trace("Debug: GetWeakAndNearEnemy failed!")
  //   set pmin = 0
  // endif
  set cbuilding = null
  if pmin != -1 then
    return enemy_force[pmin]
  endif
  return null
endfunction

function GetNearestEnemy takes nothing returns player
local integer i = 0
local integer nearplayer = 30
local real dist = 0
local real mindistance = 1000000

loop
  exitwhen i >= c_enemy_total
  if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
    set dist = DistanceBetweenPoints_kd(home_location, GetPlayerStartLocationLoc(enemy_force[i]))
    if dist < mindistance then
      set mindistance = dist
      set nearplayer = i
    endif
  endif
  set i = i + 1
endloop
if nearplayer != 30 then
  return enemy_force[nearplayer]
endif
return null
endfunction

function GetSecondNearestEnemy takes nothing returns player
  local integer i = 0
  local integer pmin = -1
  local integer spmin = -1
  local integer minstr = 10000
  local integer sminstr = 10000
  local integer cstr = 0
  local unit cbuilding = null
  loop
    exitwhen i == c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set cbuilding = GetBuilding(enemy_force[i])
      if cbuilding != null and UnitAlive(cbuilding) then
        set cstr = GetRangePenalty(cbuilding)
        if cstr < minstr then
          set spmin = pmin
          set pmin = i
          set sminstr = minstr
          set minstr = cstr
        elseif cstr < sminstr then
          set spmin = i
          set sminstr = cstr
        endif
      endif
    endif
    set i = i + 1
  endloop
  // if spmin == -1 then
  //   call Trace("Debug: GetSecondNearestEnemy failed!")
  //   set spmin = 0
  // endif
  set cbuilding = null
  if spmin != -1 then
    return enemy_force[spmin]
  endif
  return null
endfunction

function GetFFAEnemy takes nothing returns player
  if GetRandomInt(1, 3) == 1 then
    return GetSecondNearestEnemy()
  else
    return GetNearestEnemy()
  endif
endfunction

function GetTowerFactor takes unit target returns integer
  local integer tstrength = GetLocationTowerStrength(GetUnitX(target), GetUnitY(target), ver_tower_check_radius)
  if h_siege then
    return tstrength
  else
    return 4*tstrength
  endif
endfunction

function GetRace takes player p returns integer
  return player_race[GetPlayerId(p)]
endfunction

function GetRaceAggression takes unit target returns integer
  local integer i = Max((GetRace(GetOwningPlayer(target))-1) * tiernum + tier - 1,0)
  return race_aggression[i]
endfunction

function GetTargetStrength takes unit target returns integer
  local integer str = GetUnexactPlayerStrength(GetOwningPlayer(target))
  if str < 100 then
    set str = Min(str + GetRangePenalty(target), 100)
  endif
  return str
endfunction

function GetEnemyAllyStrength takes player tp returns integer
  local integer i = 0
  local integer ally_sum = 0
  local integer enemy_sum = 0
  local player p = null
  loop
    exitwhen i >= GetBJMaxPlayers()
    set p = Player(i)
    if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING and not IsPlayerObserver(p) then
      if p != ai_player and p != tp then
        if IsPlayerAlly(p, ai_player) then
          set ally_sum = ally_sum + R2I(GetPlayerStrength(p))
        elseif IsPlayerAlly(p, tp) then
          set enemy_sum = enemy_sum + GetUnexactPlayerStrength(p)
        endif
      endif
    endif
    set i = i + 1
  endloop
  set p = null
  return (enemy_sum - ally_sum)/2
endfunction

function IsTargetGood takes unit target, integer attacker_bonus returns boolean
  if target != null then
    set added_target_aggression = attacker_bonus
    set added_racial_aggression = GetRaceAggression(target)
    return GetTargetStrength(target) + GetEnemyAllyStrength(GetOwningPlayer(target)) + GetTowerFactor(target) <= own_strength + attacking_aggression + added_aggression + added_racial_aggression + attacker_bonus
  else
    return false
  endif
endfunction

function ChooseEnemyExpansionTarget takes unit u returns unit
  set u = GetEnemyExpansion()
  if u != null then
    if IsTargetGood(u, expansion_target_bonus) then
      call Trace("Hardcoded enemy expansion target chosen")
    else
      set u = null
    endif
  endif
  return u
endfunction

function ChooseEnemyBaseTarget takes unit u returns unit
  local integer c = 0
  call StartGetEnemyBase()
  loop
    exitwhen not WaitGetEnemyBase()
    if c > 4 then
      return null
    endif
    call Sleep(1)
    set c = c + 1
  endloop
  set u = GetEnemyBase()
  if u != null and IsTargetGood(u, comp_chosen_target_bonus) then
    call Trace("Hardcoded Enemy Base Target chosen")
    return u
  endif
  return null
endfunction

function ChooseAnEnemyTarget takes unit u returns unit
  local player target_enemy = null
  local group g = CreateGroup()
  local location enemy_base = null

  if attacking_strategy == 1 or attacking_strategy == 3 then
    set target_enemy = GetWeakestEnemy()
  //call Trace("Chooing Weakest Enemy")
  elseif attacking_strategy == 2 then
    set target_enemy = GetStrongestEnemy()
  //call Trace("Choosing Strongest Enemy")
  elseif attacking_strategy == 5 then
    set target_enemy = GetFFAEnemy()
  //call Trace("Choosing FFA Enemy")
  else
    set target_enemy = GetWeakAndNearEnemy()
  //call Trace("Choosing weakest closest Enemy")
  endif
  call GroupEnumUnitsOfPlayer(g, target_enemy, null)
  set enemy_base = GetPlayerStartLocationLoc(target_enemy)
  set g = SelectByAlive(g, true)
  set g = SelectUnittype(g, UNIT_TYPE_TOWNHALL, true)
  set g = SelectByLocation(g, enemy_base, 1000, false)
  set u = FirstOfGroup(g)
  if u == null then
    set u = GetBuilding(target_enemy)
  endif
  call DestroyGroup(g)
  set g = null
  call RemoveLocation(enemy_base)
  set enemy_base = null
  set target_enemy = null
  return u
endfunction

function ChooseAnyEnemyTarget takes unit u returns unit
  set u = ChooseAnEnemyTarget(u)
  if IsTargetGood(u,0) then
    call Trace("Enemy Advanced Target Chosen")
    set alli_target = u
    if attacking_strategy == 3 then
      set alli_target = GetBuilding(GetStrongestEnemy())
    endif
    return u
  endif
  return null
endfunction

function ChooseAttackTarget takes unit u returns unit
  //call DisplayToAll("Choosing attack target")
  if GetRandomReal(0.0,1.0) > comp_chosen_target_rate then
    set u = ChooseEnemyExpansionTarget(u)
    if u == null then
      //call DisplayToAll("Attack enemy Base")
      set u = ChooseEnemyBaseTarget(u)
    endif
    set alli_target = u
  endif

  if u == null then
    set u = ChooseAnyEnemyTarget(u)
  endif
  return u
endfunction

function SetChatVarsAttack takes unit u returns nothing
  local player p = GetOwningPlayer(u)
  call SetChatVar("TargetRace", race_name[player_race[GetPlayerId(p)]])
  call SetChatVar("TargetColor", ColorText(p))
  call SetChatVarR("TargetStrength", GetPlayerStrength(p))
  set p = null
endfunction

function Militia_Expansion takes integer m returns nothing
  local group g = null
  local group cg = null
  local unit u = null
  local unit efoe = null
  local integer t = 0
  set efoe = GetExpFoe(efoe)
  if efoe == null or IsUnitInGroup(current_expansion,water_expansion) then  //is WaterExpansion
    set efoe = null
    return
  endif
  set g = CreateGroup()
  set break_attack = false  // to persuade attack system to hopefully not exit early and do the reforming behaviour
  set militia_check_enabled = false
  //call BuildExpa( TownCount(racial_expansion)+1, racial_expansion, farm_prio + 50 )
  call DisplayToAlliesChat(militia_expansion_chat)
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectNumberOfId(g, 100, old_id[racial_peon] )
  set g = SelectByAlive(g, true)
  set g = GetNearestSubGroupOfGroup(g, home_location, m)
  //set expansion_peon = FirstOfGroup(g)
  call AddAbilityToGroup(CopyGroup(g), race_militia_ability)
  call GroupImmediateOrder(g, race_militia_unitstring)
  call RemoveInjuries()
  call FormGroupAM(4)
  loop
    exitwhen AreUnitsOfType(g, race_militia_id)
    exitwhen t > 4
    call Sleep(2)
    set t = t + 1
  endloop
  //call AddAssault(m, old_id[racial_militia])   // Lil problem with adding assaults. For some reasons
  //call AttackMoveKill(efoe)
  call GroupPointOrder(g, "attack", GetUnitX(current_expansion), GetUnitY(current_expansion))
  set town_threat_break = false
  //set captain_flee = false
  //call SetCaptainHome(ATTACK_CAPTAIN, GetUnitX(efoe), GetUnitY(efoe)) //
  //call AttackMoveKillCreep(efoe)
  set attack_running = true
  //if not retreat_controlled then
  //  call Trace("===Retreat control started===")
  //  set retreat_controlled = true
  //  call SetGroupsFlee(false)
  //  call SetTargetHeroes(false)
  //  call TQAddJob(2 * sleep_multiplier, RETREAT_CONTROL, 0)
  //endif
  call AttackMoveKill(efoe)
  call SleepUntilTargetDeadAM(efoe, true)
  call Chat(C_Done)
  call SleepInCombatAM()
  call Trace("===Attack Fully Finished===")
  call GroupPointOrder(g, "move", GetLocationX(home_location), GetLocationY(home_location))
  call GroupImmediateOrder(g, "militiaoff" )
  set attack_running = false
  //call SetCaptainHome(ATTACK_CAPTAIN, GetLocationX(home_location), GetLocationY(home_location))
  set militia_check_enabled = true
  set town_threat_break = true
  //set captain_flee = true
  //set militia = false
  set take_exp = false
  call DestroyGroup(g)
  set g = null
  set cg = null
  set efoe = null
  set u = null
endfunction

function SleepUntilTownDefended takes integer ai_strength returns nothing
	local integer defense_length_counter = 0
	set own_strength = ai_strength
	call Trace("==Sleep Defend Town==" )
	loop
		exitwhen not town_threatened
		exitwhen player_defeated
		if town_loc[most_threatened_town] != null and LinearInterpolation(ver_low_aggression,ver_high_aggression,ver_flee_multiple1,ver_flee_multiple2,attacking_aggression)*own_strength > army_strength[town_threat_army[most_threatened_town]] then
			if town_threat[most_threatened_town] >= teleport_low_threat then
				if not teleporting then
					call AttackMoveXY(R2I(GetLocationX(town_loc[most_threatened_town])), R2I(GetLocationY(town_loc[most_threatened_town])))
				endif
			endif
			call SetCaptainHome(DEFENSE_CAPTAIN, GetLocationX(town_loc[most_threatened_town]), GetLocationY(town_loc[most_threatened_town]))
		else
			//call Trace("Town threatened - retreat" )
			//if town_threat[most_threatened_town] >= teleport_low_threat then
				if not teleporting then
					call AttackMoveXY(R2I(GetLocationX(home_location)), R2I(GetLocationY(home_location)))
				endif
				set defense_length_counter = defense_length_counter + 1
				if defense_length_counter > attack_reform_length then
					set defense_length_counter = 0
					call FormGroupAM(2)
				endif
			//endif
			call SetCaptainHome(DEFENSE_CAPTAIN, GetLocationX(home_location), GetLocationY(home_location))
			//call ClearCaptainTargets()
			//call CaptainGoHome()
		endif
		call Sleep(2*sleep_multiplier)
		set own_strength = GetOwnStrength()
	endloop
	call Trace("==exit Sleep Defend Town==")
	call SetCaptainHome(DEFENSE_CAPTAIN, GetLocationX(home_location), GetLocationY(home_location))	
endfunction

function SetLeadAlly takes nothing returns nothing
  local integer i = 0
  local boolean checkdone = false
  local player p = null
  loop
    exitwhen i >= c_ally_total or checkdone
    set p = ally_force[i]
    if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING then
      if p != ai_player then
        set leadally = false
        set checkdone = true
      elseif p == ai_player then
        set leadally = true
        set checkdone = true
      endif
    endif
    set i = i + 1
  endloop
endfunction

function SingleMeleeAttackAM takes boolean needs_exp, boolean has_siege, boolean br_rush, integer ai_strength returns nothing
  local unit hall = null
  local unit mega = null
  local unit creep = null
  local unit common = null


  if desperation_assault and not no_attack then
    // Perpetual attack regardless of power or strength
    if c_ally_total > 0 then
      call SetLeadAlly()
      if difficulty != EASY then
        set common = GetAllianceTarget()
        if common != null then
          call Trace("===Desperation Attack Alliance Target===")
          call Chat(C_Ally)
          call FormGroupAM(3)
          call DesperationAssault()
          call AttackMoveKillAAM(common)
          call SetAllianceTarget(null)
          set common = null
          return
        endif
      endif
    endif

    set common = ChooseAnEnemyTarget(common)
    if (common != null) then
      call Trace("===Desperation Attack Random Enemy Target===")
      call SetAllianceTarget(common)
      call FormGroupAM(3)
      call DesperationAssault()
      call AttackMoveKillAAM(common)
      call SetAllianceTarget(null)
      set common = null
      return
    endif

  endif

  if town_threatened then
    set break_attack = false
    set isfleeing = false
    call FormGroupAM(1)
    call SleepUntilTownDefended(ai_strength)
    call SleepInCombatAM()
    return
  endif

  call Trace("===Single Melee Attack===" )
  call Trace("AI strength: " + Int2Str(ai_strength))	

  set h_siege = has_siege
  set own_strength = ai_strength

  call set_aggression()


  // Commander Control Attacks
  //
  if no_attack then
    call Trace("No Attack is on" )
    call Sleep(4 * sleep_multiplier)
    call ClearCaptainTargets()
    return
  endif

  if queue_running then

    if queue_attack_p then
      call Trace("Attacking point "+Int2Str(queue_t_x)+","+Int2Str(queue_t_y) )
      call FormGroupAM(3)
      call QueueAttackMoveXY(queue_t_x, queue_t_y)
      call Trace("Point reached or aborted" )
      return

    elseif queue_attack_u then
      if queue_t_u == null then
        call Trace("No unit targeted, queue stopped" )
        set queue_running = false
      elseif not UnitAlive(queue_t_u) then
        call Trace("Unit is dead, next command" )
        call QueueGetNextCommand()
      else
        call Trace("Attacking unit" )
        call FormGroupAM(3)
        call AttackMoveKillAAM(queue_t_u)
        call Trace("Attack complete" )
        return
      endif
    endif

  endif

  if attack_player then
    call Trace("Attacking player" )
    set hall = GetBuilding(Player(attack_target_p))
    if hall == null then
      call Trace("No target found" )
      set attack_player = false
      return
    endif
    call FormGroupAM(3)
    call AttackMoveKillAAM(hall)
    call Trace("Attack complete" )
    set hall = null
    return
  endif

  if attack_point then
    call Trace("Attacking point "+Int2Str(attack_target_x)+","+Int2Str(attack_target_y) )
    call FormGroupAM(3)
    call AttackMoveKillXYAAM(attack_target_x, attack_target_y)
    call Trace("Attack complete" )
    return
  endif

  if attack_unit then
    if target_unit == null then
      call Trace("No unit targeted" )
      set attack_unit = false
    elseif not UnitAlive(target_unit) then
      call Trace("Unit is dead" )
      set attack_unit = false
    else
      call Trace("Attacking unit" )
      call FormGroupAM(3)
      call AttackMoveKillAAM(target_unit)
      call Trace("Attack complete" )
      return
    endif
  endif

  if not creeping_only then	// Do the normal attack sequence

    // militia expansion
    //
    if militia_expanding then 
      call Trace("A Militia Expansion")
      call Militia_Expansion(6)
      set militia_expanding = false
      return
    endif

    // tower rush attack
    //
    if towerrush then
      call Trace("A Tower Rush Attack")
      call FormGroupAM(3)
      call AttackMoveTowerRush()
      return
    endif

    // ancient expansion attack
    //
    if ancient_expanding then
      if ancient_exp_state == 2 or ancient_exp_state == 3 then
        call Trace("An Ancient Expansion Attack")
        //call FormGroupAM(3)
        //call AddAssault(1, old_id[racial_hall[1]])
        call SetCaptainHome(BOTH_CAPTAINS,GetUnitX(ancient_exp_unit),GetUnitY(ancient_exp_unit))
        //call AttackMoveKillXYAAM(R2I(GetUnitX(ancient_exp_unit)), R2I(GetUnitY(ancient_exp_unit)))
        return
      elseif ancient_exp_state == 4 then
        set ancient_attack_running = true
        call Trace("An Ancient Expansion - Final stage")
        call FormGroupAM(3)
        //call AddAssault(1, old_id[racial_hall[1]])
        call SetCaptainHome(BOTH_CAPTAINS,GetUnitX(ancient_exp_unit),GetUnitY(ancient_exp_unit))
        set creep = GetExpFoe(creep)
        //if DistanceBetweenUnits(ancient_exp_unit, creep) <= 500 then
          call AttackMoveKillCreep(creep)
        //else
          //call AttackMoveKillXYAAM(R2I(GetUnitX(ancient_exp_unit)), R2I(GetUnitY(ancient_exp_unit)))
        //endif
        set ancient_attack_running = false
        set creep = null
        return
      endif
    endif

    // item expansion attack
    //
    if item_expanding then
      call Trace("An Item Expansion Attack or Guard")
      set item_attack_running = true
      call FormGroupAM(3)
      if item_exp_state == 1 then
        call AttackMoveKillCreep(GetExpFoe(creep))
        set item_attack_running = false
        set creep = null
      elseif item_exp_state > 0 then
        call AttackMoveKillXYAAM(R2I(GetLocationX(item_exp_guard_loc)),R2I(GetLocationY(item_exp_guard_loc)))  //Prevent the army from leaving before using the item , so no set item_attack_running
      endif
      return
    endif

    // ELF BR
    //
    if br_rush and rushcreep_target != null and UnitAlive(rushcreep_target) then
      call Trace("ELF BR Attack")
      call FormGroupAM(3)
      call BRRush()  //try BR
      return
    endif


    // defend expansion from other expansion
    //
    if double_expansion_target != null and IsTargetGood(double_expansion_target, 10) then
      call Trace("Double Expansion Attack")
      call SetAllianceTarget(double_expansion_target)
      call FormGroupAM(3)
      call AttackMoveKillAAM(double_expansion_target)
      if not UnitAlive(double_expansion_target) then
        set double_expansion_target = null
        call SetAllianceTarget(null)
      endif
      return
    endif

    if not (no_creep_attack or ai_no_creep) then

      // take expansions as needed
      //
      if needs_exp then
        if first_expansion_chosen and (current_expansion == null or CheckExpansionTaken(current_expansion)) then
          call ChooseExpansion()
          if current_expansion == null then
            return
          endif
        endif
        set creep = GetExpFoe(creep)
        if creep != null and UnitAlive(creep) then
          call Trace("Creep the Expansion")
          set attacking_expansion = true
          set battle_radius = creep_battle_radius
          call SetAllianceTarget(creep)
          call Chat(C_Expansion)
          call FormGroupAM(3)
          call AttackMoveKillCreep(creep)
          if creep == null then
            set take_exp = false
          endif
          call Sleep(10)
          set attacking_expansion = false
          set creep = null
          call SetAllianceTarget(null)
          return
        endif
        set creep = null
      endif
    endif

    // coordinate with allies
    //
    if c_ally_total > 0 then
    call SetLeadAlly()
      if difficulty != EASY then
        set common = GetAllianceTarget()
        if common != null then
        call Trace("Attack Alliance Target")
          call Chat(C_Ally)
          call FormGroupAM(3)
          call AttackMoveKillAAM(common)
          call Trace("Attack complete")
          call SetAllianceTarget(null)
          set common = null
          return
        endif
      endif
    endif

    if not no_player_attack then

      // all-out attack if the player is weak
      //
      if difficulty != EASY then
        set mega = GetMegaTarget()
        if mega != null and UnitAlive(mega) then
          call Trace("Mega Attack Target")
          call SetAllianceTarget(mega)
          call SetChatVarsAttack(mega)
          call Chat(C_Mega)
          call Chat(C_Megatarget)
          call FormGroupAM(3)
          call AttackMoveKillAAM(mega)
          call SetAllianceTarget(null)
          set mega = null
          return
        endif
        set mega = null
      endif

      if GetHeroXP(hero_unit[1]) < GetRandomInt(50,150) or GetHeroXP(hero_unit[1]) > GetRandomInt(300,850) or GetHeroXP(hero_unit[2]) > 450 or FoodUsed() > GetRandomInt(40,60) then

        set hall = ChooseAttackTarget(hall)
        if hall != null and UnitAlive(hall) then
          call SetChatVarsAttack(hall)
          call Chat(C_Attack)
          call SetAllianceTarget(alli_target)
          //set alli_target = null
          call FormGroupAM(3)
          call AttackMoveKillAAM(hall)
          call SetAllianceTarget(null)
          set hall = null
          return
        endif
        set hall = null
      endif
    endif
  endif // if not creep only

  if no_creep_attack or ai_no_creep then
    call Trace("no creeping" )
    call Sleep(4 * sleep_multiplier)
    return
  endif

  // nothing better to do, so kill a creep camp
  //
  set battle_radius = creep_battle_radius
  call Trace("Just gonna be creeping")
  call CreepAttack(own_strength)

endfunction


function SkillArraysAM takes nothing returns integer
  local integer level = GetHeroLevelAI()
  local integer hn = GetHeroNumber(GetHeroId())
  if level > max_hero_level then
    set max_hero_level = level
  endif
  return skills[(hn - 1) * HERO_LEVEL_NUMBER + level]
endfunction

function StoreSkills takes integer ta returns nothing
  local integer i = 1
  loop
    exitwhen i > HERO_LEVEL_NUMBER
    set skills[(ta - 1) * HERO_LEVEL_NUMBER + i] = tempskills[i]
    set i = i + 1
  endloop
endfunction

function LoadSkillsExt takes integer sa returns nothing
  local integer i = 1
  loop
    exitwhen i > HERO_LEVEL_NUMBER
    set tempskills[i] = allskills[sa + i]
    set i = i + 1
  endloop
endfunction

function LoadSkills takes integer sa, integer hn, integer ta returns nothing
  local integer perc = GetRandomInt(0,major_hero_skill_value+minor_hero_skill_value+rare_hero_skill_value)
  local integer sk = 0	// is which of the 3 skill lines is chosen

  if perc <= rare_hero_skill_value then
    set sk = HERO_SKILL_RARE
  elseif perc <= minor_hero_skill_value+rare_hero_skill_value then
    set sk = HERO_SKILL_MINOR
  endif
  set hero_skills[sa] = sk // set global variable so we can use the fact of knowning what skill was chosen in AMAI
  call LoadSkillsExt((sa-1)*3*HERO_LEVEL_NUMBER + sk*HERO_LEVEL_NUMBER + (hn-1)*9*HERO_LEVEL_NUMBER)
  call StoreSkills(ta)
endfunction

function HeroHealingBugFix takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > 3
    if HeroBugFixHealthCheck(i) then
      call Trace("HERO: Healing Bug Fix")
      call RecycleGuardPosition(hero_unit[i])
      call GroupRemoveUnit(unit_healing, hero_unit[i])
    endif
    set i = i + 1
  endloop
endfunction

function AwaitMeleeHeroesAM takes nothing returns boolean
  local integer i = 1
  local boolean hero_available = false

  loop
    //call HeroHealingBugFix()
    loop
      exitwhen i > 3
      if GetUnitCountDone(old_id[hero[i]]) > 0 then
        if not IsUnitInGroup(hero_unit[i], unit_healing) then
          return false
        endif
        set hero_available = true
      endif
      set i = i + 1
    endloop
    set i = 1
    exitwhen player_defeated or hero_available
    call Sleep(2 * sleep_multiplier)
    call Trace("AwaitMeleeHeroesAM: No Heroes Ready")
  endloop

  return true
endfunction

function GetArmyHealthState takes nothing returns real
  local group g = CreateGroup()
  local unit u = null
  local real health_sum = 0.0
  local integer count = 0
  local real uhs = 0.0
  local integer hid = 0
  local integer hFountainID = GetHealthFountainID()
  local integer id = 0
  call GroupClear(healer_group)
  call GroupClear(urgent_healing_group)
  call GroupClear(medium_healing_group)
  call GroupClear(small_healing_group)
  set urgent_healing_count = 0
  set medium_healing_count = 0
  set small_healing_count = 0
  set ward_cast = false
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set id = GetUnitTypeId(u)
    if id == 'ohwd' then
      set ward_cast = true
    endif
    if UnitAlive(u) and not (IsUnitHidden(u) or IsUnitType(u, UNIT_TYPE_PEON) or IsUnitType(u, UNIT_TYPE_STRUCTURE) or IsUnitIllusion(u)) then
      if IsUnitType(u, UNIT_TYPE_MECHANICAL) or IsUnitType(u, UNIT_TYPE_SUMMONED) then
        set health_sum = health_sum + 1 // Because is not currently handled by healing and we don't want army to run away if only 1 human unit is hurt
        set uhs = 1
      else 
        set uhs = GetUnitState(u, UNIT_STATE_LIFE) / GetUnitState(u, UNIT_STATE_MAX_LIFE)
        set health_sum = health_sum + uhs
      endif
      set count = count + 1
      set hid = GetHealerId(id)
      if hid != -1 and GetUnitState(u, UNIT_STATE_MANA) >= (healer_mana_cost[hid] * 2) / 3 and ((healer_upg_id[hid] == 0) or (GetUpgradeLevel(healer_upg_id[hid]) >= healer_upg_level[hid])) then
        call GroupAddUnit(healer_group, u)
      endif
      if uhs < 0.5 then
        call GroupAddUnit(urgent_healing_group, u)
        set urgent_healing_count = urgent_healing_count + 1
      elseif uhs < 0.75 then
        call GroupAddUnit(medium_healing_group, u)
        set medium_healing_count = medium_healing_count + 1
      elseif uhs < 1 then
        call GroupAddUnit(small_healing_group, u)
        set small_healing_count = small_healing_count + 1
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  if nearest_neutral[hFountainID] == null or not neutral_available[hFountainID] or not race_use_fountain then
    set fountain_available = false
  else
    set fountain_available = (neutral_night_buy[hFountainID] and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) < 6)) or not neutral_guarded[hFountainID]
  endif
  if count == 0 then
    return 1.0
  endif
  return ((health_sum / count) + (1-(urgent_healing_count + medium_healing_count) / count)) / 2
endfunction


function ApplyMassHealingItem takes unit u, item mh_i returns nothing
  local unit hu = null
  local real time = 0

  set hu = FirstOfGroup(urgent_healing_group)
  if hu == null then
    set hu = FirstOfGroup(medium_healing_group)
    if hu == null then
      set hu = FirstOfGroup(small_healing_group)
    endif
  endif

  call RemoveGuardPosition(u)
  call GroupPointOrder(urgent_healing_group, "move", GetUnitX(u), GetUnitY(u))
  call GroupPointOrder(medium_healing_group, "move", GetUnitX(u), GetUnitY(u))
  call GroupPointOrder(small_healing_group, "move", GetUnitX(u), GetUnitY(u))
  call IssuePointOrder(u, "move", GetUnitX(hu), GetUnitY(hu))
  set time = RMax((GetTimeToReachUnit(u, hu) + GetTimeToReachUnit(hu, u))/2,2)    // Average of times. Not accurate as is longer than it should be to definatly make sure units surround the hero
  call Sleep(time)
  call UnitUseItem(u, mh_i)
  call RecycleGuardPosition(u)
  set hu = null
endfunction

function ApplyHealingItem takes unit u, item heal_item returns nothing

	local unit target = null
	local group urgent = null
	local group medium = null
	set urgent = CopyGroup(urgent_healing_group)
	set medium = CopyGroup(medium_healing_group)
	call RemoveGuardPosition(u)
	call GroupPointOrder(urgent_healing_group, "move", GetUnitX(u), GetUnitY(u))
	call GroupPointOrder(medium_healing_group, "move", GetUnitX(u), GetUnitY(u))
	call GroupPointOrder(small_healing_group, "move", GetUnitX(u), GetUnitY(u))
	call Sleep(5 * sleep_multiplier)
	if false then
	else
		loop
			exitwhen not UnitHasItem(u, heal_item)
			set target = FirstOfGroup(urgent)
			if target != null then
				call UnitUseItemTarget(u, heal_item, target)
				call GroupRemoveUnit(urgent, target)
			else
				set target = FirstOfGroup(medium)
				if target != null then
					call UnitUseItemTarget(u, heal_item, target)
					call GroupRemoveUnit(medium, target)
				endif
			endif
			exitwhen target == null
			call Sleep(2 * sleep_multiplier)
		endloop
	endif
	call RecycleGuardPosition(u)
	call DestroyGroup(urgent)
	call DestroyGroup(medium)
	set urgent = null
	set medium = null
	set target = null
endfunction

function ApplyGlobalItem takes unit u, item heal_item returns nothing
  call UnitUseItem(u, heal_item)
endfunction
function HealArmy takes nothing returns nothing
  local real hs = 0.0
  local unit u = null
  local integer mh_item = 0
  local item mh_i = null
  local boolean mass_healed = false
  local boolean global_heal = false
  local integer sleepLength = 10
  local real healthTrigger = 0.75
  loop
    set hs = GetArmyHealthState()
    set mass_healed = false
    exitwhen (urgent_healing_count + medium_healing_count <= 3 and hs > healthTrigger) // and not shop_ordered	
    exitwhen player_defeated or town_threatened or ver_heroes == false
    call Trace("function HealArmy: Army is badly damaged and needs healing " + Real2Str(hs))
    set mh_item = GetMassHealingItem()
    if mh_item > 0 then
      set mass_healed = true
    endif
    if mh_item == 0 then
      set mh_item = GetMerchantMassHealingItem()
      if mh_item > 0 then
        set mass_healed = true
      endif
    endif
    if mh_item == 0 then
      set mh_item = GetGlobalHealingItem()
      if mh_item > 0 then
        set global_heal = true
      endif
    endif
    if mh_item == 0 then
      set mh_item = GetHealingItem()
    endif
    if mh_item > 0 then
      set mh_i = GetItemOfType(mh_i,mh_item)
      if mh_i != null then
        set u = GetItemHero(mh_i)
        if u != null then
          if mass_healed then
            set sleepLength = 10
            call ApplyMassHealingItem(u, mh_i)
          elseif global_heal then
            set sleepLength = 25
            call ApplyGlobalItem(u, mh_i)
          else
            set sleepLength = 10
            call ApplyHealingItem(u, mh_i)
          endif
          if hs <= healthTrigger then
            call Sleep(sleepLength * sleep_multiplier) // Wait some time for item effects to work
          endif
        endif
      else
        call StartEmergencyItem(1, mh_item)
        if hs <= healthTrigger then
          call Sleep(8*sleep_multiplier) // Wait some time for item to be bought
        endif
      endif
    endif
    call Sleep(2 * sleep_multiplier)
    exitwhen hs > healthTrigger // Still a large proportion of army is strong so exit loop
  endloop
  set mh_i = null
  set u = null
endfunction

function universal_attack_sequence takes nothing returns nothing
  local boolean needs_exp = false
  local boolean has_siege = false
  local boolean br_rush = false
  local integer ai_strength = 0
  //local integer ai_antiair_strength = 0
  local integer exp_strength = 0

  if hero_unit[1] == null and ver_heroes and not desperation_assault then
    call Sleep(sleep_multiplier)
    return
  endif
  call SetTargetHeroes(difficulty != EASY)
  set ai_strength = GetOwnStrength()
  //set ai_antiair_strength = air_strength
  if current_expansion != null then
    set exp_strength = GetExpansionStrength()
  endif
  if rushcreep_target != null and UnitAlive(rushcreep_target) then
    set br_rush = GetLocationCreepStrength(GetUnitX(rushcreep_target), GetUnitY(rushcreep_target), 510) <= ai_strength * 0.6
  endif
  set most_threatened_town = Max(most_threatened_town,0)
  if major_hero == null or not UnitAlive(major_hero) or not IsStandardUnit(major_hero) or (IsUnitType(major_hero, UNIT_TYPE_HERO) == false and ver_heroes) then
    set major_hero = GetMajorHero(major_hero)
  endif

  set needs_exp        = take_exp and (ai_strength > exp_strength)
  set has_siege        = ai_strength > 60
  set has_siege        = has_siege or TownCountDone(MORTAR) > 0
  set has_siege        = has_siege or TownCountDone(CATAPULT) > 0
  set has_siege        = has_siege or TownCountDone(MEAT_WAGON) > 0
  set has_siege        = has_siege or TownCountDone(BALLISTA) > 0
  set has_siege        = has_siege or TownCountDone(CHIMAERA) > 0

  call SingleMeleeAttackAM(needs_exp,has_siege,br_rush,ai_strength)
  set added_target_aggression = 0
  set added_racial_aggression = 0

    //call TeleportCaptain(GetLocationX(home_location), GetLocationY(home_location))

  loop
    exitwhen not teleporting
    //call Trace("UNIVERSAL ATTACK: Units are teleporting")
    call Sleep(1)
  endloop

  if town_threatened then
    set break_attack = false
    set isfleeing = false
    call FormGroupAM(1)
    call SleepUntilTownDefended(ai_strength)
    call SleepInCombatAM()
  elseif not towerrush and not ancient_expanding and not militia_expanding and not item_expanding then
    call SetCaptainHome(DEFENSE_CAPTAIN, GetLocationX(home_location), GetLocationY(home_location))
  endif

  if go_home then
    call Trace("UNIVERSAL ATTACK: Going home" )
    call ClearCaptainTargets()
    call CaptainGoHome()
  endif
  set break_attack = false
  set go_home = false
  if not town_threatened then
    call ClearCaptainTargets()   // Causes the pause in movement to allow units to catch up
                                 // disabled when town threatened as we want units to get back fast
  endif
endfunction

function universal_peon_assignment takes nothing returns nothing
  local integer T = TownWithMine()
  local integer g = GetGold()
  local integer w = GetWood()
  local integer pwh = 0
  local integer swh = 0
  local real gdivw = I2R(g)/I2R(Max(w,1))
  local integer i = T + 1

  if T < 0 then
    set T = 0
    set i = 1
  endif

  if g - w > 300 then
    set pwh = 2
  elseif g - w > 500 and w < 100 then
    set pwh = 5
  elseif g - w > 900 and w < 200 then
    set pwh = 8
  else
    set pwh = 2
  endif

  if w < 200 then
    set swh = 6 - pwh
  elseif gdivw < 0.5 then
    set swh = 0
  elseif gdivw < 0.8 then
    set swh = Max(1 - pwh,0)
  elseif gdivw < 1.1 then
    set swh = Max(2 - pwh,0)
  elseif gdivw < 1.4 then
    set swh = Max(3 - pwh,0)
  elseif gdivw < 1.7 then
    set swh = Max(4 - pwh,0)
  elseif gdivw < 2.0 then
    set swh = Max(5 - pwh,0)
  else
    set swh = Max(6 - pwh,0)
  endif

  set swh = Max(swh - 4 * TownCountDone(neutral_shredder),0)

  call ClearHarvestAI()

  if (desperation_assault) then
    return
  endif

  call HarvestGold(T,ver_optimal_gold - 1)
  call HarvestWood(0,1)
  call HarvestGold(T,1)
  call HarvestWood(0,pwh)
  call HarvestWood(0,swh)

  loop
    //set i = i + 1
    exitwhen i > Max(T + 3,TownCountDone(racial_expansion))
    if T != i and TownHasMine(i) and TownCountEx(racial_expansion,true,i) > 0 then
      if gdivw < 3.0 or g < 300 then
        call HarvestGold(i,ver_optimal_gold)
      else
        call HarvestGold(i,ver_optimal_gold - 2)
      endif
    endif
    set i = i + 1
  endloop

  call HarvestWood(0,20)
endfunction

function SetAIResources takes integer g, integer w returns nothing
  call SetPlayerGold(ai_player, g)
  call SetPlayerWood(ai_player, w)
endfunction

function IncreaseAIResources takes integer g, integer w returns nothing
  call IncreasePlayerGold(ai_player, g)
  call IncreasePlayerWood(ai_player, w)
endfunction

function AddWaveResources takes nothing returns nothing
  local integer g = 0
  local integer w = 0
  local integer i = 0
  local integer unitid = 0
  local integer desire = 0

  loop
    exitwhen i >= attack_length
    set unitid = attack_units[i]
    set desire = attack_qty[i]
    set g = g + desire * GetUnitGoldCost2(unitid)
    set w = w + desire * GetUnitWoodCost2(unitid)
    set i = i + 1
  endloop

  call IncreaseAIResources(g,w)

endfunction

function BuildAndAttack takes player p, integer prio returns nothing
    local integer index = 0
    local integer unitid = 0
    local integer desire = 0
    local boolean group_ready = true

    call AddWaveResources()

    loop
      set index = 0
      set group_ready = true
      loop
        exitwhen index >= attack_length
        set unitid = attack_units[index]
        set desire = attack_qty[index] + campaign_defenders[unitid]
        if TownCountDone(unitid)<desire then
          set group_ready = false
          call BuildUnit(desire , unitid, prio)
        endif
        set index = index + 1
      endloop
      exitwhen group_ready
      call Sleep(5 * sleep_multiplier)
    endloop

    call FormGroupAM(5)
    call SuicidePlayer(p, true)
    loop
      exitwhen CaptainIsEmpty()
      call Sleep(5 * sleep_multiplier)
    endloop

endfunction

function BuildDefendersAM takes integer prio returns nothing
  local integer index = 0
  local integer unitid = 0
  local integer qty = 0
  loop
    exitwhen index >= defense_length

    set unitid = defense_units[index]
    set qty = defense_qty[index]

    call BuildUnit(qty, unitid, prio)
    call ConversionsAM(qty,unitid)
    call AddDefenders(qty,old_id[unitid])
    set campaign_defenders[unitid] = qty

    set index = index + 1
  endloop
endfunction





function InitAI takes nothing returns nothing
  set ai_player = Player(GetAiPlayer())
  set sleep_seconds = 0
  call InitAiUnits()
  call InitArrays()
  call StopGathering()
endfunction

function StandardAI takes code heroes, code peons, code attacks returns nothing

    local boolean isNewbie = (MeleeDifficulty() == MELEE_NEWBIE)

    call InitAI()

    call SetMeleeAI()

    call SetDefendPlayer(true)
    call SetGroupsFlee(not isNewbie)
    call SetHeroesBuyItems(not isNewbie)
    call SetHeroesFlee(true)
    call SetHeroesTakeItems(true)
    call SetIgnoreInjured(true)
    call SetPeonsRepair(true)
    call SetSmartArtillery(not isNewbie)
    call SetTargetHeroes(not isNewbie)
    call SetUnitsFlee(not isNewbie)
    call SetWatchMegaTargets(true)

    call CreateCaptains()

    call SetHeroLevels(heroes)

    call Sleep(0.1)
    call StartThread(peons)
    call StartThread(attacks)
endfunction


function SetZepNextWave takes nothing returns nothing
    set zep_next_wave = true
endfunction

function SuicideSleep takes integer seconds returns nothing
    set sleep_seconds = sleep_seconds - seconds
    loop
        exitwhen seconds <= 0
        exitwhen allow_signal_abort and CommandsWaiting() != 0

        if seconds >= 5 then
            call Sleep(5)
            set seconds = seconds - 5
        else
            call Sleep(seconds)
            set seconds = 0
        endif
    endloop
endfunction

function WaitForSignal takes nothing returns integer
    local integer cmd
    local boolean display = false //xxx
    loop
        exitwhen CommandsWaiting() != 0

        //xxx
        call Trace("waiting for a signal to begin AI script...\n")
        set display = true
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        //xxx

    endloop

    //xxx
    if display then
        call Trace("signal received, beginning AI script\n")
    endif
    //xxx

    set cmd = GetLastCommand()
    call PopLastCommand()
    return cmd
endfunction

function SetWoodPeons takes integer count returns nothing
    set campaign_wood_peons = count
endfunction

function SetGoldPeons takes integer count returns nothing
    set campaign_gold_peons = count
endfunction

function SetHarvestLumber takes boolean harvest returns nothing
    if harvest then
        set campaign_wood_peons = 3
    else
        set campaign_wood_peons = 0
    endif
endfunction

function SetFormGroupTimeouts takes boolean state returns nothing
    set form_group_timeouts = state
endfunction

function DoCampaignFarms takes boolean state returns nothing
    set do_campaign_farms = state
endfunction

function GetMinorCreep takes nothing returns unit
    return GetCreepCamp(0,9,false)
endfunction

function GetMajorCreep takes nothing returns unit
    return GetCreepCamp(10,100,allow_air_creeps)
endfunction

function InitBuildArray takes nothing returns nothing
    set build_length = 0
endfunction

function InitMeleeGroup takes nothing returns nothing
    call InitAssaultGroup()
    call RemoveInjuries()
    call RemoveSiege()
endfunction

function PrepFullSuicide takes nothing returns nothing
    call InitAssaultGroup()
    call InitDefenseGroup()
    set campaign_gold_peons = 0
    set campaign_wood_peons = 0
endfunction

function SetReplacements takes integer easy, integer med, integer hard returns nothing
    if difficulty == EASY then
        call SetReplacementCount(easy)
    elseif difficulty == NORMAL then
        call SetReplacementCount(med)
    else
        call SetReplacementCount(hard)
    endif
endfunction

function StartTownBuilder takes code func returns nothing
    call StartThread(func)
endfunction

function SetBuildAll takes integer t, integer qty, integer unitid, integer town returns nothing
    if qty > 0 then
        set build_qty[build_length] = qty
        set build_type[build_length] = t
        set build_item[build_length] = unitid
        set build_town[build_length] = town
        set build_length = build_length + 1
    endif
endfunction

function SetBuildUnit takes integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_UNIT,qty,unitid,-1)
endfunction

function SetBuildNext takes integer qty, integer unitid returns nothing
    local integer has = GetUnitCount(unitid)
    if has >= qty then
        return
    endif
    call SetBuildAll(BUILD_UNIT,GetUnitCountDone(unitid)+1,unitid,-1)
endfunction

function SetBuildUnitEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call SetBuildAll(BUILD_UNIT,easy,unitid,-1)
    elseif difficulty == NORMAL then
        call SetBuildAll(BUILD_UNIT,med,unitid,-1)
    else
        call SetBuildAll(BUILD_UNIT,hard,unitid,-1)
    endif
endfunction

function SecondaryTown takes integer town, integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_UNIT,qty,unitid,town)
endfunction

function SecTown takes integer town, integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_UNIT,qty,unitid,town)
endfunction

function SetBuildUpgr takes integer qty, integer unitid returns nothing
    if MeleeDifficulty() != MELEE_NEWBIE or qty == 1 then
        call SetBuildAll(BUILD_UPGRADE,qty,unitid,-1)
    endif
endfunction

function SetBuildUpgrEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call SetBuildAll(BUILD_UPGRADE,easy,unitid,-1)
    elseif difficulty == NORMAL then
        call SetBuildAll(BUILD_UPGRADE,med,unitid,-1)
    else
        call SetBuildAll(BUILD_UPGRADE,hard,unitid,-1)
    endif
endfunction

function SetBuildExpa takes integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_EXPAND,qty,unitid,-1)
endfunction

function StartUpgrade takes integer level, integer upgid returns boolean
    local integer gold_cost
    local integer wood_cost

    if GetUpgradeLevel(upgid) >= level then
        return true
    endif

    set gold_cost = GetUpgradeGoldCost(upgid)
    if total_gold < gold_cost then
        return false
    endif

    set wood_cost = GetUpgradeWoodCost(upgid)
    if total_wood < wood_cost then
        return false
    endif

    return SetUpgrade(upgid)
endfunction

function BuildFactory takes integer unitid returns nothing
    if GetGold() > 1000 and GetWood() > 500 then
        call SetBuildUnit( 2, unitid )
    else
        call SetBuildUnit( 1, unitid )
    endif
endfunction

function GuardSecondary takes integer townid, integer qty, integer unitid returns nothing
    if TownHasHall(townid) and TownHasMine(townid) then
        call SecondaryTown( townid, qty, unitid )
    endif
endfunction

function BasicExpansion takes boolean build_it, integer unitid returns nothing
    if build_it and HallsCompleted(unitid) then
        call SetBuildExpa( TownCount(unitid)+1, unitid )
    endif
endfunction

function UpgradeAll takes integer baseid, integer newid returns nothing
    call SetBuildUnit( TownCountDone(baseid), newid )
endfunction

function FoodPool takes integer food, boolean weak, integer id1, integer use1, boolean strong, integer id2, integer use2 returns nothing
    if strong then
        call SetBuildUnit( (food - use1 * TownCount(id1)) / use2, id2 )
    elseif weak then
        call SetBuildUnit( (food - use2 * TownCount(id2)) / use1, id1 )
    endif
endfunction

function MeleeTownHall takes integer townid, integer unitid returns nothing
    if TownHasMine(townid) and not TownHasHall(townid) then
        call SecondaryTown ( townid, 1, unitid )
    endif
endfunction

function WaitForUnits takes integer unitid, integer qty returns nothing
    loop
        exitwhen TownCountDone(unitid) == qty
        call Sleep(2)
    endloop
endfunction

function StartUnit takes integer ask_qty, integer unitid, integer town returns boolean
    local integer have_qty
    local integer need_qty
    local integer afford_gold
    local integer afford_wood
    local integer afford_qty
    local integer gold_cost
    local integer wood_cost

    //------------------------------------------------------------------------
    // if we have all we're asking for then make nothing
    //
    if town == -1 then
        set have_qty = TownCount(unitid)
    else
        set have_qty = TownCountTown(unitid,town)
    endif

    if have_qty >= ask_qty then
        return true
    endif
    set need_qty = ask_qty - have_qty

    //------------------------------------------------------------------------
    // limit the qty we're requesting to the amount of resources available
    //
    set gold_cost = GetUnitGoldCost(unitid)
    set wood_cost = GetUnitWoodCost(unitid)

    if gold_cost == 0 then
        set afford_gold = need_qty
    else
        set afford_gold = total_gold / gold_cost
    endif
    if afford_gold < need_qty then
        set afford_qty = afford_gold
    else
        set afford_qty = need_qty
    endif

    if wood_cost == 0 then
        set afford_wood = need_qty
    else
        set afford_wood = total_wood / wood_cost
    endif
    if afford_wood < afford_qty then
        set afford_qty = afford_wood
    endif

    // if we're waiting on gold/wood; pause build orders
    if afford_qty < 1 then
        return false
    endif

    //------------------------------------------------------------------------
    // whether we make right now what we're requesting or not, assume we will
    // and deduct the cost of the units from our fake gold total right away
    //
    set total_gold = total_gold - gold_cost * need_qty
    set total_wood = total_wood - wood_cost * need_qty

    if total_gold < 0 then
        set total_gold = 0
    endif
    if total_wood < 0 then
        set total_wood = 0
    endif

    //------------------------------------------------------------------------
    // give the AI a chance to make the units (it may not be able to right now
    // but that doesn't stop us from trying other units after this as long
    // as we have enough money to make this AND the needed, unbuilt ones)
    //
    return SetProduce(afford_qty,unitid,town)
endfunction

function WaitForTown takes integer towns, integer townid returns nothing
    local integer i = 0
    loop
        call Sleep(10)
        exitwhen TownCount(townid) >= towns
        set i = i + 1
        exitwhen i == GetBJMaxPlayers()
    endloop
endfunction

function StartExpansion takes integer qty, integer hall returns boolean
    local integer count
    local integer town
    local unit    peon = null
    local integer gold_cost
    local boolean b = true

    set count = TownCount(hall)
    if count >= qty then
        return true
    endif

    set town = GetNextExpansion()
    if town == -1 then
        return true
    endif

    set take_exp = true

    set gold_cost = GetUnitGoldCost(hall)
    if gold_cost > total_gold then
        return false
    endif
    set total_gold = total_gold - gold_cost

    if GetExpansionFoe() != null then
        return true
    endif

    set peon = GetExpansionPeon()
    if peon != null then
        set b = SetExpansion(peon,hall)
        set peon = null
      return b
    endif
    return true
endfunction

function OneBuildLoop takes nothing returns nothing
    local integer index = 0
    local integer qty
    local integer id
    local integer tp

    set total_gold = GetGold() - gold_buffer
    set total_wood = GetWood()

    loop
        exitwhen index == build_length

        set qty = build_qty [index]
        set id  = build_item[index]
        set tp  = build_type[index]

        //--------------------------------------------------------------------
        if tp == BUILD_UNIT then
            if not StartUnit(qty,id,build_town[index]) then
                return
            endif

        //--------------------------------------------------------------------
        elseif tp == BUILD_UPGRADE then
            call StartUpgrade(qty,id)

        //--------------------------------------------------------------------
        else // tp == BUILD_EXPAND
            if not StartExpansion(qty,id) then
                return
            endif
        endif

        set index = index + 1
    endloop
endfunction

function BuildLoop takes nothing returns nothing
    call OneBuildLoop()
    call StaggerSleep(1,2)
    loop
        call OneBuildLoop()
        call Sleep(2)
    endloop
endfunction

function StartBuildLoop takes nothing returns nothing
    call StartThread(function BuildLoop)
endfunction

function SetInitialWave takes integer seconds returns nothing
    set sleep_seconds = seconds
endfunction

function AddSleepSeconds takes integer seconds returns nothing
    set sleep_seconds = sleep_seconds + seconds
endfunction

function SleepForever takes nothing returns nothing
    call Trace("going to sleep forever\n") //xxx
    loop
        call Sleep(100)
    endloop
endfunction

function PlayGame takes nothing returns nothing
    call StartBuildLoop()
    call SleepForever()
endfunction

function ConvertNeeds takes integer unitid returns nothing
    if GetUnitCount(unitid) < 1 then
        call StartUnit(1,unitid,-1)
    endif
endfunction

function Conversions takes integer desire, integer unitid returns nothing

    if GetUnitCount(unitid) >= desire then
        return
    endif

  	if unitid == HIPPO_RIDER then
            call ConvertNeeds(ARCHER)
		call ConvertNeeds(HIPPO)
      	call MergeUnits(desire,ARCHER,HIPPO,HIPPO_RIDER)
      endif


endfunction

function SetAssaultGroup takes integer qty, integer max, integer unitid returns nothing
    call Conversions(max,unitid)

    if qty <= 0 and TownCountDone(unitid) == 0 then
        return
    endif
    set harass_qty[harass_length] = qty
    set harass_max[harass_length] = max
    set harass_units[harass_length] = unitid
    set harass_length = harass_length + 1
endfunction

function Interleave3 takes integer e1, integer m1, integer h1, integer u1, integer e2, integer m2, integer h2, integer u2, integer e3, integer m3, integer h3, integer u3 returns nothing
    local integer i1 = 1
    local integer i2 = 1
    local integer i3 = 1
    local integer q1
    local integer q2
    local integer q3

    if difficulty == EASY then
        set q1 = e1
        set q2 = e2
        set q3 = e3
    elseif difficulty == NORMAL then
        set q1 = m1
        set q2 = m2
        set q3 = m3
    else // difficulty == HARD
        set q1 = h1
        set q2 = h2
        set q3 = h3
    endif

    loop
        exitwhen q1<=0 and q2<=0 and q3<=0

        if q1 > 0 then
            call SetAssaultGroup(i1,i1,u1)
            set q1 = q1 - 1
            set i1 = i1 + 1
        endif

        if q2 > 0 then
            call SetAssaultGroup(i2,i2,u2)
            set q2 = q2 - 1
            set i2 = i2 + 1
        endif

        if q3 > 0 then
            call SetAssaultGroup(i3,i3,u3)
            set q3 = q3 - 1
            set i3 = i3 + 1
        endif
    endloop
endfunction

function SetMeleeGroup takes integer unitid returns nothing
    if unitid == hero_id then
        call SetAssaultGroup(1,9,unitid)
    else
        call SetAssaultGroup((TownCountDone(unitid)*3)/4,20,unitid)
    endif
endfunction

function CampaignDefender takes integer level, integer qty, integer unitid returns nothing
    if qty > 0 and difficulty >= level then
        set defense_qty[defense_length] = qty
        set defense_units[defense_length] = unitid
        set defense_length = defense_length + 1
        call Conversions(qty,unitid)
        call SetBuildUnit(qty,unitid)
    endif
endfunction

function CampaignDefenderEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call CampaignDefender(EASY,easy,unitid)
    elseif difficulty == NORMAL then
        call CampaignDefender(NORMAL,med,unitid)
    else
        call CampaignDefender(HARD,hard,unitid)
    endif
endfunction

function CampaignAttacker takes integer level, integer qty, integer unitid returns nothing
    if qty > 0 and difficulty >= level then 
        call SetAssaultGroup(qty,qty,unitid)
    endif
endfunction

function CampaignAttackerEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call CampaignAttacker(EASY,easy,unitid)
    elseif difficulty == NORMAL then
        call CampaignAttacker(NORMAL,med,unitid)
    else
        call CampaignAttacker(HARD,hard,unitid)
    endif
endfunction

function FormGroup takes integer seconds, boolean testReady returns nothing
    local integer index
    local integer count
    local integer unitid
    local integer desire
    local integer readyPercent

    // normally test for CaptainReadiness() of 50%
    if testReady == true then
        set readyPercent = 50
        call Trace("forming group, requiring healthy guys\n") //xxx
    else
        set readyPercent = 0
        call Trace("forming group, unit health not important\n") //xxx
    endif

    call Trace("trying to gather forces\n") //xxx

    loop
        call SuicideSleep(seconds)
        call InitAssault()

        set index = 0
        loop
            exitwhen index == harass_length

            set unitid = harass_units[index]
            set desire = harass_max[index]
            set count  = TownCountDone(unitid)

            call Conversions(desire,unitid)

            if count >= desire then
                call AddAssault(desire,unitid)
            else
                set desire = harass_qty[index]

                if count < desire then
                    call AddAssault(desire,unitid)
                else
                    call AddAssault(count,unitid)
                endif
            endif

            set index = index + 1
        endloop

        //xxx
        if form_group_timeouts and (sleep_seconds < -60) then
            call Trace("exit form group -- timeout\n")
        elseif CaptainInCombat(true) then
            call Trace("exit form group -- can't form while already in combat\n")
        elseif CaptainIsFull() and CaptainReadiness() >= readyPercent then
            call Trace("exit form group -- ready\n")
        endif
        //xxx

        // time out and send group anyway if time has already expired
        exitwhen form_group_timeouts and (sleep_seconds < -60)
        exitwhen CaptainInCombat(true)
        exitwhen CaptainIsFull() and CaptainReadiness() >= readyPercent
    endloop
endfunction

function WavePrepare takes integer unitid returns integer
    return GetUnitBuildTime(unitid)
endfunction

function PrepTime takes nothing returns integer
    local integer unitid
    local integer missing
    local integer prep
    local integer count
    local integer largest = 30
    local integer index = 0

    loop
        exitwhen index == harass_length

        set unitid  = harass_units[index]
        set missing = harass_qty[index] + IgnoredUnits(unitid) - TownCount(unitid)
        set prep    = WavePrepare(unitid) * missing

        if prep > largest then
            set largest = prep
        endif

        set index = index + 1
    endloop
    call TraceI("next wave will require around %d seconds to build and gather\n",largest) //xxx

    return largest
endfunction

function PrepSuicideOnPlayer takes integer seconds returns boolean
    local integer wave_prep   = PrepTime()
    local integer save_length

    set save_length = harass_length
    set harass_length = 0

    call AddSleepSeconds(seconds)
    if sleep_seconds-wave_prep > 0 then
        call TraceI("going to sleep for %d seconds before gathering next attack wave\n",sleep_seconds-wave_prep) //xxx
        call SuicideSleep(sleep_seconds-wave_prep)
    endif

    call Trace("preparing suicide attack wave\n") //xxx

    set harass_length = save_length
    if harass_length < 1 then
        call Trace("ERROR - no units specificed, exiting early\n") //xxx
        return false
    endif

    return true
endfunction

function SleepUntilAtGoal takes nothing returns nothing
    loop
        exitwhen CaptainRetreating()
        exitwhen CaptainAtGoal()        // reached goal
        exitwhen CaptainIsHome()        // failed to path and returned home
        exitwhen CaptainIsEmpty()       // all units died
        call SuicideSleep(3)
    endloop
endfunction

function SleepInCombat takes nothing returns nothing
    local integer count = 0
    debug call Trace("SleepInCombat\n")
    loop
        loop
            exitwhen not CaptainInCombat(true)  // goal is cleared
            exitwhen CaptainIsEmpty()           // duh
            call SuicideSleep(1)
        endloop

        set count = count + 1
        exitwhen count >= 8

        //xxx this is what it should have been; do this for next patch?
        //call SuicideSleep(1)
    endloop
    debug call Trace("exit SleepInCombat\n")
endfunction

function AttackMoveXYA takes integer x, integer y returns nothing

    if zep_next_wave then
        call LoadZepWave(x,y)
        set zep_next_wave = false
    endif

    call AttackMoveXY(x,y)
    call SleepUntilAtGoal()
    call SleepInCombat()
endfunction

function SuicideOnPlayerWave takes nothing returns nothing
    call Trace("waiting for attack wave to enter combat\n") //xxx
    loop
        //xxx
        if allow_signal_abort and CommandsWaiting() != 0 then
            call Trace("ABORT -- attack wave override\n")
        endif

        if CaptainInCombat(true) then
            call Trace("done - captain has entered combat\n")
        endif

        if CaptainIsEmpty() then
            call Trace("done - all units are dead\n")
        endif

        if sleep_seconds < -300 then
            call Trace("done - timeout, took too long to reach engage the enemy\n")
        endif
        //xxx

        exitwhen allow_signal_abort and CommandsWaiting() != 0

        exitwhen CaptainInCombat(true)
        exitwhen CaptainIsEmpty()
        call SuicideSleep(10)
        exitwhen sleep_seconds < -300
    endloop

    call Trace("waiting for attack wave to die\n") //xxx
    loop
        //xxx
        if allow_signal_abort and CommandsWaiting() != 0 then
            call Trace("ABORT - attack wave override\n")
        endif

        if CaptainIsEmpty() then
            call Trace("done - all units are dead\n")
        endif

        if sleep_seconds < -300 then
            call Trace("done - timeout, took too long to reach engage the enemy\n")
        endif
        //xxx

        exitwhen allow_signal_abort and CommandsWaiting() != 0

        exitwhen CaptainIsEmpty()
        call SuicideSleep(10)
        exitwhen sleep_seconds < -300
    endloop
endfunction

function CommonSuicideOnPlayer takes boolean standard, boolean bldgs, integer seconds, player p, integer x, integer y returns nothing
    local integer save_peons

    if not PrepSuicideOnPlayer(seconds) then
        return
    endif

    set save_peons = campaign_wood_peons
    set campaign_wood_peons = 0

    loop
        //xxx
        if allow_signal_abort and CommandsWaiting() != 0 then
            call Trace("ABORT -- attack wave override\n")
        endif
        //xxx

        exitwhen allow_signal_abort and CommandsWaiting() != 0

        loop
            exitwhen allow_signal_abort and CommandsWaiting() != 0

            call FormGroup(5,true)
            exitwhen sleep_seconds <= 0
            call TraceI("waiting %d seconds before suicide\n",sleep_seconds) //xxx
        endloop

        if standard then
            if bldgs then
                exitwhen SuicidePlayer(p,sleep_seconds >= -60)
            else
                exitwhen SuicidePlayerUnits(p,sleep_seconds >= -60)
            endif
        else
            call AttackMoveXYA(x,y)
        endif

        call TraceI("waiting %d seconds before timeout\n",60+sleep_seconds) //xxx
        call SuicideSleep(5)
    endloop

    set campaign_wood_peons = save_peons
    set harass_length = 0

    call SuicideOnPlayerWave()
endfunction

function SuicideOnPlayer takes integer seconds, player p returns nothing
    call CommonSuicideOnPlayer(true,true,seconds,p,0,0)
endfunction

function SuicideOnUnits takes integer seconds, player p returns nothing
    call CommonSuicideOnPlayer(true,false,seconds,p,0,0)
endfunction

function SuicideOnPoint takes integer seconds, player p, integer x, integer y returns nothing
    call CommonSuicideOnPlayer(false,false,seconds,p,x,y)
endfunction

function SuicideUntilSignal takes integer seconds, player p returns nothing
    local integer save
    local integer wave_prep = PrepTime()

    loop
        call AddSleepSeconds(seconds)
        if sleep_seconds-wave_prep > 0 then
            call SuicideSleep(sleep_seconds-wave_prep)
        endif

        set save = campaign_wood_peons
        set campaign_wood_peons = 0
        loop
            loop
                call FormGroup(5, true)
                exitwhen sleep_seconds <= 0
                exitwhen CommandsWaiting() != 0
            endloop
            exitwhen SuicidePlayer(p,sleep_seconds >= -60)
            exitwhen CommandsWaiting() != 0
            call SuicideSleep(3)
        endloop
        set campaign_wood_peons = save

        loop
            exitwhen CaptainIsEmpty()
            exitwhen CommandsWaiting() != 0
            call SuicideSleep(5)
        endloop
        exitwhen CommandsWaiting() != 0
    endloop
endfunction

function SuicideOnce takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call SuicideUnit(easy,unitid)
    elseif difficulty == NORMAL then
        call SuicideUnit(med,unitid)
    else
        call SuicideUnit(hard,unitid)
    endif
endfunction

function SuicideUnitA takes integer unitid returns nothing
    if unitid != 0 then
        call SuicideUnit(1,unitid)
    endif
    call Sleep(0.1)
endfunction

function SuicideUnitB takes integer unitid, integer playerid returns nothing
    if unitid != 0 then
        call SuicideUnitEx(1,unitid,playerid)
    endif
    call Sleep(0.1)
endfunction

function SuicideUnits takes integer u1, integer u2, integer u3, integer u4, integer u5, integer u6, integer u7, integer u8, integer u9, integer uA returns nothing
    call Trace("MASS SUICIDE - this script is now technically done\n") //xxx

    call PrepFullSuicide()
    loop
        call SuicideUnitA(u1)
        call SuicideUnitA(u2)
        call SuicideUnitA(u3)
        call SuicideUnitA(u4)
        call SuicideUnitA(u5)
        call SuicideUnitA(u6)
        call SuicideUnitA(u7)
        call SuicideUnitA(u8)
        call SuicideUnitA(u9)
        call SuicideUnitA(uA)
    endloop
endfunction

function SuicideUnitsEx takes integer playerid, integer u1, integer u2, integer u3, integer u4, integer u5, integer u6, integer u7, integer u8, integer u9, integer uA returns nothing
    call Trace("MASS SUICIDE - this script is now technically done\n") //xxx

    call PrepFullSuicide()
    loop
        call SuicideUnitB(u1,playerid)
        call SuicideUnitB(u2,playerid)
        call SuicideUnitB(u3,playerid)
        call SuicideUnitB(u4,playerid)
        call SuicideUnitB(u5,playerid)
        call SuicideUnitB(u6,playerid)
        call SuicideUnitB(u7,playerid)
        call SuicideUnitB(u8,playerid)
        call SuicideUnitB(u9,playerid)
        call SuicideUnitB(uA,playerid)
    endloop
endfunction

function SuicideOnPlayerEx takes integer easy, integer med, integer hard, player p returns nothing
    if difficulty == EASY then
        call SuicideOnPlayer(easy,p)
    elseif difficulty == NORMAL then
        call SuicideOnPlayer(med,p)
    else
        call SuicideOnPlayer(hard,p)
    endif
endfunction

function SuicideOnUnitsEx takes integer easy, integer med, integer hard, player p returns nothing
    if difficulty == EASY then
        call SuicideOnUnits(easy,p)
    elseif difficulty == NORMAL then
        call SuicideOnUnits(med,p)
    else
        call SuicideOnUnits(hard,p)
    endif
endfunction

function SuicideOnPointEx takes integer easy, integer med, integer hard, player p, integer x, integer y returns nothing
    if difficulty == EASY then
        call SuicideOnPoint(easy,p,x,y)
    elseif difficulty == NORMAL then
        call SuicideOnPoint(med,p,x,y)
    else
        call SuicideOnPoint(hard,p,x,y)
    endif
endfunction

function ForeverSuicideOnPlayer takes integer seconds, player p returns nothing
    local integer length = harass_length
    loop
        exitwhen allow_signal_abort and CommandsWaiting() != 0
        call SuicideOnPlayer(seconds,p)
        set harass_length = length
    endloop
endfunction

function CommonSleepUntilTargetDead takes unit target, boolean reform returns nothing
    loop
        exitwhen CaptainRetreating()
        exitwhen CaptainReadinessHP() <= 40

        exitwhen not UnitAlive(target)
        exitwhen UnitInvis(target) and not IsUnitDetected(target,ai_player)

        if not TownThreatened() then
            call AttackMoveKill(target)
        endif

        call SuicideSleep(3)

        if reform and sleep_seconds < -40 then
            if CaptainInCombat(true) then
                set sleep_seconds = sleep_seconds + 5
            else
                set sleep_seconds = 0
                call FormGroup(1,false)
            endif
        endif
    endloop
endfunction

function SleepUntilTargetDead takes unit target returns nothing
    call CommonSleepUntilTargetDead(target,false)
endfunction

function ReformUntilTargetDead takes unit target returns nothing
    debug call Trace("ReformUntilTargetDead\n")
    call CommonSleepUntilTargetDead(target,true)
endfunction

function AttackMoveKillA takes unit target returns nothing
    if target == null then
        call SuicideSleep(3)
        return
    endif

    debug call Trace("AttackMoveKillA\n")
    call AttackMoveKill(target)
    call ReformUntilTargetDead(target)
    call SleepInCombat()
endfunction

function MinorCreepAttack takes nothing returns nothing
    local unit target = GetMinorCreep()
    call SetAllianceTarget(target)
    call FormGroup(3, true)
    call AttackMoveKillA(target)
    set target = null
endfunction

function MajorCreepAttack takes nothing returns nothing
    local unit target = GetMajorCreep()
    call SetAllianceTarget(target)
    call FormGroup(3,true)
    call AttackMoveKillA(target)
    set target = null
endfunction

function CreepAttackEx takes nothing returns nothing
    local unit target = GetCreepCamp(min_creeps,max_creeps,allow_air_creeps)
    call SetAllianceTarget(target)
    call FormGroup(3,true)
    call AttackMoveKillA(target)
    set target = null
endfunction

function AnyPlayerAttack takes nothing returns nothing
  local unit hall = GetEnemyExpansion()

  if hall == null then
    call StartGetEnemyBase()
    loop
      exitwhen not WaitGetEnemyBase()
      call SuicideSleep(1)
    endloop
    set hall = GetEnemyBase()
  endif

  call SetAllianceTarget(hall)
  call FormGroup(3,true)
  call AttackMoveKillA(hall)
  set hall = null
endfunction

function ExpansionAttack takes nothing returns nothing
  local unit creep = GetExpansionFoe()
  local integer x

  call FormGroup(3, true)
  if creep == null then
    set x = GetExpansionX()
    if x != -1 then
      call AttackMoveXYA(x,GetExpansionY())
    endif
  else
      call AttackMoveKillA(creep)
  endif
  set creep = null
endfunction

function AddSiege takes nothing returns nothing

    call SetAssaultGroup( 0, 9, MORTAR )
    call SetAssaultGroup( 0, 9, CATAPULT )
    call SetAssaultGroup( 0, 9, MEAT_WAGON )
    call SetAssaultGroup( 0, 9, BALLISTA )
    call SetAssaultGroup( 0, 9, CHIMAERA )

endfunction

function GetAllyCount takes player whichPlayer returns integer
    local integer    playerIndex = 0
    local integer    count = 0
    local player     indexPlayer

    loop
        set indexPlayer = Player(playerIndex)
        if whichPlayer != indexPlayer then
            if GetPlayerAlliance(whichPlayer,indexPlayer,ALLIANCE_PASSIVE) then
                if GetPlayerAlliance(indexPlayer,whichPlayer,ALLIANCE_PASSIVE) then
                    if GetPlayerStructureCount(indexPlayer,true) > 0 then
                        set count = count + 1
                    endif
                endif
            endif
        endif
        set playerIndex = playerIndex + 1
        exitwhen playerIndex == GetBJMaxPlayers()
    endloop
    set indexPlayer = null
    return count
endfunction

function SingleMeleeAttack takes boolean needs_exp, boolean has_siege, boolean major_ok, boolean air_units returns nothing
    local boolean   can_siege
    local real      daytime 
    local unit      hall
    local unit      mega
    local unit      creep
    local unit      common
    local integer   minexp
    local boolean   allies

    call Trace("===SingleMeleeAttack===\n") //xxx

    if TownThreatened() then
        call Trace("sleep 2, town threatened\n") //xxx
        call Sleep(2)
        return
    endif

    // purchase zeppelins
    //
    if get_zeppelin and GetGold() > 300 and GetWood() > 100 then
        call Trace("purchase zep\n") //xxx
        call PurchaseZeppelin()
        set get_zeppelin = false
        set ready_for_zeppelin = false
        return
    endif
    set ready_for_zeppelin = true

    // coordinate with allies
    //
    set allies = GetAllyCount(ai_player) > 0
    if allies and MeleeDifficulty() != MELEE_NEWBIE then
        set common = GetAllianceTarget()
        if common != null then
            call Trace("join ally force\n") //xxx
            if GetMegaTarget() != null then
                call AddSiege()
            endif
            call FormGroup(3,true)
            call AttackMoveKillA(common)
            call SetAllianceTarget(null)
            set common = null
            return
        endif
    endif

    // take expansions as needed
    //
    if needs_exp then
        call Trace("needs exp\n") //xxx
        set creep = GetExpansionFoe()
        if creep != null then
            call Trace("attack exp\n") //xxx
            call SetAllianceTarget(creep)
            call FormGroup(3,true)
            call AttackMoveKillA(creep)
            call Sleep(20)
            set take_exp = false
            set creep = null
            return
        endif
    endif

    // all-out attack if the player is weak
    //
    if MeleeDifficulty() != MELEE_NEWBIE then
        set mega = GetMegaTarget()
        if mega != null then
            call Trace("MEGA TARGET!!!\n") //xxx
            call AddSiege()
            call FormGroup(3,true)
            call AttackMoveKillA(mega)
            set mega = null
            return
        endif
    endif

    // deny player an expansion
    //
    set hall = GetEnemyExpansion()
    set daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
    set can_siege = has_siege and (air_units or (daytime>=4 and daytime<=12))

    if hall!=null and (can_siege or not IsTowered(hall)) then

        call Trace("test player town attack\n") //xxx

        if MeleeDifficulty() == MELEE_NEWBIE then
            set minexp = 3
        elseif allies and MeleeDifficulty() == MELEE_NORMAL then
            set minexp = 1
        else
            set minexp = 0 // HARD, INSANE, and NORMAL with no allies
        endif

        if exp_seen >= minexp then
            call Trace("do player town attack\n") //xxx
            set exp_seen = 0
            call AddSiege()
            call SetAllianceTarget(hall)
            call FormGroup(3,true)
            call AttackMoveKillA(hall)
            set hall = null
            return
        endif
        set hall = null
        set exp_seen = exp_seen + 1
    endif

    // attack player's main base when siege is available
    //
    if can_siege then
        call Trace("attack player's town\n") //xxx
        call AddSiege()
        call AnyPlayerAttack()
        return
    endif

    // extended, more specific method of determining creep levels
    //
    if min_creeps != -1 then
        call TraceI("custom creep attack %d\n",max_creeps) //xxx
        call CreepAttackEx()
        return
    endif

    // nothing better to do, so kill a creep camp
    //
    if major_ok then
        call Trace("major creep attack\n") //xxx
        call MajorCreepAttack()
        return
    endif

    call Trace("minor creep attack\n") //xxx
    call MinorCreepAttack()
endfunction

function GetZeppelin takes nothing returns nothing
    if ready_for_zeppelin then
        set get_zeppelin = true
    endif
endfunction

function BuildAttackers takes nothing returns nothing
    local integer index = 0
    local integer unitid
    local integer desire
    local integer count

    loop
        exitwhen index == harass_length

        set unitid = harass_units[index]
        set desire = harass_qty[index] + IgnoredUnits(unitid)
        set count  = TownCount(unitid)

        if count != desire then
            if not StartUnit(desire,unitid,-1) then
                return
            endif
        endif

        set index = index + 1
    endloop
endfunction

function BuildDefenders takes nothing returns nothing
    local integer index = 0
    local integer unitid
    local integer qty
    loop
        exitwhen index == defense_length

        set unitid = defense_units[index]
        set qty = defense_qty[index]

        call Conversions(qty,unitid)
        call AddDefenders(qty,unitid)

        set index = index + 1
    endloop
endfunction

function CampaignBasicsA takes nothing returns nothing
    local integer food_each = GetFoodMade(racial_farm)
    local integer on_wood

    call ClearHarvestAI()

    if CaptainInCombat(false) then
        set on_wood = 0
    else
        set on_wood = campaign_wood_peons
    endif

    call HarvestGold(0,campaign_gold_peons)
    call HarvestWood(0,on_wood)

    if harvest_town1 then
        call HarvestGold(1,campaign_gold_peons)
        call HarvestWood(1,on_wood)
    endif

    if harvest_town2 then
        call HarvestGold(2,campaign_gold_peons)
        call HarvestWood(2,on_wood)
    endif

    if harvest_town3 then
        call HarvestGold(3,campaign_gold_peons)
        call HarvestWood(3,on_wood)
    endif

    if do_campaign_farms and FoodUsed()+food_each-1 > food_each*(TownCount(racial_farm)+1) then
        call StartUnit(TownCount(racial_farm)+1,racial_farm,-1)
    endif

    if build_campaign_attackers then
        call BuildAttackers()
    endif

    if not CaptainInCombat(false) then
        call BuildDefenders()
    endif

    call FillGuardPosts()
    call ReturnGuardPosts()
endfunction

function CampaignBasics takes nothing returns nothing
    call Sleep(1)
    call CampaignBasicsA()
    call StaggerSleep(1,5)
    loop
        call CampaignBasicsA()
        call Sleep(campaign_basics_speed)
    endloop
endfunction

function CampaignAI takes integer farms, code heroes returns nothing
    if GetGameDifficulty() == MAP_DIFFICULTY_EASY then
        set difficulty = EASY

        call SetTargetHeroes(false)
        call SetUnitsFlee(false)

    elseif GetGameDifficulty() == MAP_DIFFICULTY_NORMAL then
        set difficulty = NORMAL

        call SetTargetHeroes(false)
        call SetUnitsFlee(false)

    elseif GetGameDifficulty() == MAP_DIFFICULTY_HARD then
        set difficulty = HARD

        call SetPeonsRepair(true)
    else
        set difficulty = INSANE
    endif

    call InitAI()
    call InitBuildArray()
    call InitAssaultGroup()
    call CreateCaptains()

    call SetNewHeroes(false)
    if heroes != null then
        call SetHeroLevels(heroes)
    endif

    call SetHeroesFlee(false)
    call SetGroupsFlee(false)
    call SetSlowChopping(true)
    call GroupTimedLife(false)
    call SetCampaignAI()
    call Sleep(0.1)

    set racial_farm = farms
    call StartThread(function CampaignBasics)
    call StartBuildLoop()
endfunction

function UnsummonAll takes nothing returns nothing
    local unit bldg
    loop
        set bldg = GetBuilding(ai_player)
        exitwhen bldg==null
        call Unsummon(bldg)
        call Sleep(2)
    endloop
endfunction

function SkillArrays takes nothing returns integer
    local integer level = GetHeroLevelAI()
    if level > max_hero_level then
        set max_hero_level = level
    endif

    if GetHeroId() == hero_id then
        return skills1[level]
    elseif GetHeroId() == hero_id2 then
        return skills2[level]
    else
        return skills3[level]
    endif
endfunction

function SetSkillArray takes integer index, integer id returns nothing
    local integer i = 1

    if index == 1 then
        if hero_id != id then
            return
        endif
        loop
            set skills1[i] = skill[i]
            exitwhen i == 10
            set i = i + 1
        endloop
    elseif index == 2 then
        if hero_id2 != id then
            return
        endif
        loop
            set skills2[i] = skill[i]
            exitwhen i == 10
            set i = i + 1
        endloop
    else
        if hero_id3 != id then
            return
        endif
        loop
            set skills3[i] = skill[i]
            exitwhen i == 10
            set i = i + 1
        endloop
    endif
endfunction

function AwaitMeleeHeroes takes nothing returns nothing
    if GetUnitCountDone(hero_id2) > 0 then
        set two_heroes = true
    endif
    loop
        exitwhen GetUnitCountDone(hero_id)>0 and (take_exp or (not two_heroes or GetUnitCountDone(hero_id2)>0))
        call Sleep(1)
    endloop
endfunction

function PickMeleeHero takes race raceid returns integer
    local integer first
    local integer second
    local integer third
    local integer last
    local integer array heroes
    local integer i
    set ver_neutral_hero_number = 0
    call InitAiUnits()  // This function makes all unit ids go back to there originals
    set i = ver_neutral_hero_number
    //------------------------------------------------------------------------
    if raceid == RACE_HUMAN then
    //------------------------------------------------------------------------

        set heroes[1] = ARCHMAGE
        set heroes[2] = MTN_KING
        set heroes[3] = PALADIN

    //------------------------------------------------------------------------
    elseif raceid == RACE_ORC then
    //------------------------------------------------------------------------
        set heroes[1] = BLADE_MASTER
        set heroes[2] = FAR_SEER
        set heroes[3] = TAUREN_CHIEF

    //------------------------------------------------------------------------
    elseif raceid == RACE_NIGHTELF then
    //------------------------------------------------------------------------
        set heroes[1] = DEMON_HUNTER
        set heroes[2] = KEEPER
        set heroes[3] = MOON_PRIESTESS

    //------------------------------------------------------------------------
    elseif raceid == RACE_UNDEAD then
    //------------------------------------------------------------------------
        set heroes[1] = DEATH_KNIGHT
        set heroes[2] = DREAD_LORD
        set heroes[3] = LICH

    else
        set hero_id = 0
    endif

    //if VersionCompatible(VERSION_FROZEN_THRONE) then
        set last = race_hero_number + i
    //else
    //    set last = race_hero_number
    //endif

    set first  = GetRandomInt(i+1,last)
    set second = GetRandomInt(i+1,last-1)
    if VersionCompatible(VERSION_FROZEN_THRONE) then
      set third  = GetRandomInt(i+1,last-2)
    else
      set third = i+1
    endif
    set hero_id        = heroes[first]
    set heroes[first]  = heroes[last]
    set hero_id2       = heroes[second]
    set heroes[second] = heroes[last-1]
    set hero_id3       = heroes[third]

    return hero_id
endfunction


   //! inject main
   //some function calls may go here

   // this places vjass initializations there, notice structs are first initialized then library initializers
   // are called
   //! dovjassinit
   //! endinject
