//==================================================================================================
//  $Id: common.ai,v 1.68 2003/05/12 02:34:18 bfitch Exp $    (the base blizzard version 1.19 - 1.20c)
//  
//  AMAI (Advanced Melee AI) common.ai by Strategy Master 
//==================================================================================================
#DEFINE $ONE$ 1
#DEFINE $ZERO$ 0

#INCLUDE <Natives.j>


globals

   //============================================================================
   // Standard Constants and Variables
   //============================================================================

    constant integer M1                 =    60
    constant integer M2                 =  2*60
    constant integer M3                 =  3*60
    constant integer M4                 =  4*60
    constant integer M5                 =  5*60
    constant integer M6                 =  6*60
    constant integer M7                 =  7*60
    constant integer M8                 =  8*60
    constant integer M9                 =  9*60
    constant integer M10                = 10*60
    constant integer M11                = 11*60
    constant integer M12                = 12*60
    constant integer M13                = 13*60
    constant integer M14                = 14*60
    constant integer M15                = 15*60

    constant integer EASY               = 1
    constant integer NORMAL             = 2
    constant integer HARD               = 3
    constant integer INSANE             = 4 // not used

    constant integer MELEE_NEWBIE       = 1
    constant integer MELEE_NORMAL       = 2
    constant integer MELEE_INSANE       = 3

    constant integer ATTACK_CAPTAIN     = 1
    constant integer DEFENSE_CAPTAIN    = 2
    constant integer BOTH_CAPTAINS      = 3

    constant integer BUILD_UNIT         = 1
    constant integer BUILD_UPGRADE      = 2
    constant integer BUILD_EXPAND       = 3

    constant integer UPKEEP_TIER1       = 50
    constant integer UPKEEP_TIER2       = 80

    //--------------------------------------------------------------------

    player  ai_player

    boolean play24 = false
    boolean skillfix = false
    integer PLAYERPASSIVE = 15
    integer PLAYERAGGRESSIVE = 12

    playercolor        PLAYER_COLOR_MAROONX             = null
    playercolor        PLAYER_COLOR_NAVYX               = null
    playercolor        PLAYER_COLOR_TURQUOISEX          = null
    playercolor        PLAYER_COLOR_VIOLETX             = null
    playercolor        PLAYER_COLOR_WHEATX              = null
    playercolor        PLAYER_COLOR_PEACHX              = null
    playercolor        PLAYER_COLOR_MINTX               = null
    playercolor        PLAYER_COLOR_LAVENDERX           = null
    playercolor        PLAYER_COLOR_COALX               = null
    playercolor        PLAYER_COLOR_SNOWX               = null
    playercolor        PLAYER_COLOR_EMERALDX            = null
    playercolor        PLAYER_COLOR_PEANUTX             = null

    integer sleep_seconds
    integer total_gold              = 0
    integer total_wood              = 0
    integer gold_buffer             = 0 // usually for potion money
    integer difficulty              = NORMAL
    integer exp_seen                = 0
    integer racial_farm             = 'hhou'
    integer hero_id                 = 'Hamg'
    integer hero_id2                = 'Hmkg'
    integer hero_id3                = 'Hpal'
    integer array skill
    integer array skills1
    integer array skills2
    integer array skills3
    integer max_hero_level          = 0

    integer array harass_qty
    integer array harass_max
    integer array harass_units
    integer harass_length           = 0

    integer array defense_qty
    integer array defense_units
    integer defense_length          = 0

    integer array build_qty
    integer array build_type
    integer array build_item
    integer array build_town
    integer build_length            = 0

    integer campaign_gold_peons     = 5
    integer campaign_wood_peons     = 3
    integer campaign_basics_speed   = 5

    integer min_creeps              = -1
    integer max_creeps              = -1

    boolean harvest_town1           = true
    boolean harvest_town2           = true
    boolean harvest_town3           = true
    boolean do_campaign_farms       = true
    boolean two_heroes              = false
    boolean allow_air_creeps        = false
    boolean take_exp                = false
    boolean allow_signal_abort      = false
    boolean ready_for_zeppelin      = true
    boolean get_zeppelin            = false

    boolean build_campaign_attackers = true

    boolean do_debug_cheats         = false
    boolean trace_on                = true
    boolean zep_next_wave           = false
    boolean form_group_timeouts     = true


    // =============================================================
    // AMAI constants
    // =============================================================



    constant integer o0                 = 0
    string array unitNames

#INCLUDETABLE <$VER$\StandardUnits.txt> #EFR
    integer %1 = %row  // Cannot be constants for VS AI support
    constant integer o%1 = '%2'
#AFTERINCLUDE
    constant integer OBJECT_NUM = %row
#ENDINCLUDE
#INCLUDETABLE <$VER$\UnitEquivalence.txt> #EFR #COND "%2" eq "AI_COMP"
    integer %3 = %1
    integer o%3 = o%1
#ENDINCLUDE

#INCLUDETABLE <$VER$\HeroAbilities.txt> #EFR
    constant integer %1 = '%2'
#ENDINCLUDE


    constant integer BUILD_ITEM         = 4

    constant integer BLOC_STD = 1
    constant integer BLOC_FRONT = 2
    constant integer BLOC_MINE = 3

    constant integer NOT_ENOUGH_RES = 1
    constant integer CANNOT_BUILD = 2
    constant integer BUILT_ALL = 3
    constant integer BUILT_SOME = 4

    constant integer SR_RANDOM = 0
    constant integer SR_ELF = 1
    constant integer SR_HUMAN = 2
    constant integer SR_ORC = 3
    constant integer SR_UNDEAD = 4

    constant integer R_RANDOM = 0
#DEFINE $RACENUM$ 0
#INCLUDETABLE <$VER$\Races.txt>
    constant integer R_%1 = %row
#DEFINE $RACENUM$ %row
#AFTERINCLUDE
    constant integer R_NEUTRAL = #EVAL{%row+1}
    constant integer RACE_NUMBER = %row
#ENDINCLUDE

#DEFINE $HEROLEVELNUM$ 0
#INCLUDETABLE <$VER$\HeroLevels.txt>
#DEFINE $HEROLEVELNUM$ %row
#AFTERINCLUDE
    constant integer HERO_LEVEL_NUMBER = %row
#ENDINCLUDE

#SEARCHTREE Jobs <Jobs.txt> %1 %2 %3 #EFR

#SEARCHLIST Jobs
    constant integer %1 = %row
#ENDSEARCHLIST

    constant integer STRATEGY_TYPE_MELEE = 0
    constant integer STRATEGY_TYPE_RANGED = 1
    constant integer STRATEGY_TYPE_AIR = 2
    constant integer STRATEGY_TYPE_CASTER = 3

    constant integer NEUTRAL_TAVERN = 0
    constant integer NEUTRAL_OBSERVATORY = 1
    constant integer NEUTRAL_MERC_CAMP = 2
    constant integer NEUTRAL_DRAGON_ROOST = 3
    constant integer NEUTRAL_HEALING_FOUNTAIN = 4
    constant integer NEUTRAL_MERCHANT = 5
    constant integer NEUTRAL_MANA_FOUNTAIN = 6
    constant integer NEUTRAL_SHIPYARD = 7
    constant integer NEUTRAL_MARKETPLACE = 8
    constant integer NEUTRAL_POWER_FOUNTAIN = 9
    constant integer NEUTRAL_HEAL_WARD = 10
    constant integer NEUTRAL_COUNT = 11

    constant integer UPKEEP_UNDECIDED = 0
    constant integer UPKEEP_NOT_ALLOWED = 1
    constant integer UPKEEP_ALLOWED = 2

#INCLUDETABLE <$VER$\Upkeep.txt> #EFR
    constant integer UPKEEP_%1 = #EVAL{%row-1}
#AFTERINCLUDE
    constant integer UPKEEP_NUM = %row
#ENDINCLUDE

    constant integer HEALER_TYPE_NO_TARGET = 0
    constant integer HEALER_TYPE_SUDDEN = 1
    constant integer HEALER_TYPE_CONTINUOUS = 2
    constant integer HEALER_TYPE_WARD = 3
    constant integer HEALER_TYPE_HERO = 4

    constant integer UPGRADED = 9999

    constant integer BT_UNIT = 0
    constant integer BT_BUILDING = 1
    constant integer BT_HERO = 2
    constant integer BT_UPGRADE = 3
    constant integer BT_ML_UPGRADE = 4
    constant integer BT_RACIAL_ITEM = 5
    constant integer BT_NEUTRAL_HERO = 6
    constant integer BT_MERC = 7
    constant integer BT_GOBLIN_MERC = 8
    constant integer BT_DRAGON = 9
    constant integer BT_MERCHANT_ITEM = 10

    constant integer COMPARE_TRUE = 0
    constant integer COMPARE_EQ = 1
    constant integer COMPARE_UNEQ = 2
    constant integer COMPARE_GREATER = 3
    constant integer COMPARE_GREATER_EQ = 4
    constant integer COMPARE_LESS = 5
    constant integer COMPARE_LESS_EQ = 6

    constant integer HEALINGITEM_MASS = 0
    constant integer HEALINGITEM_SINGLE = 1
    constant integer MERCHANTITEM_MASS = 2
    constant integer GLOBALHEALING = 3
    constant integer HEALINGITEM_HERO = 4
    constant integer MANAITEM_HERO = 5
    constant integer ITEMTYPE_SUDDEN = 0
    constant integer ITEMTYPE_CONTINUOUS = 1

    constant integer HERO_SKILL_MAJOR = 0
    constant integer HERO_SKILL_MINOR = 1
    constant integer HERO_SKILL_RARE = 2

//==============================================================
// (AMAI) Global Settings
//==============================================================
#PRAGMA START VERSION SETTINGS
    real sleep_multiplier = 1  // increases performance by checking stuff not so often
    integer slm_start = 4  // how many computer players is needed tor the sleep multiplier to start increasing
    integer slm_end = 10 // how many computer players is needed tor the sleep multiplier to stop increasing
    real slm_start_mult = 1 // how much is the sleep multiplied when it's below the slm_start codition
    real slm_end_mult = 3.2  // how much is the sleep multiplied when it's above the slm_end codition
    real hero_radius = 200  // scanning this small area around hero to detect if the hero gets surrounded by enemy or is in danger of becoming that so it should move
    boolean use_linear_upkeep_saving = false  // should the computers save the upkeep threshold gold over the time above or save it all at once when it get's to the upkeep border?
    integer repair_threshold = 6  // computers only repair buildings if they have more than this many workers
    integer repair_threshold_threatened = 8 // computers only repair buildings when the town is under attack if they got more than this many workers
    real max_follow_dist = 1000  // Max Distance behind the army a zeppelin follows
    integer neutral_hero_time = 25  // when is neutral heroes available in seconds /5
    real buy_timeout_large = 120  // time in seconds the hero goes to a shop before it gives up if it haven't reached it
    real buy_timeout_small = 15  // time in seconds a hero tries to buy items at shop before giving up
    real buy_distance = 350  // how close to a shop does a unit have to be for buying?
    integer build_array_reset_time = 100  // every this * 5 seconds, the build array is reset
    integer rp_strat_normal = 250  // normalizing strategy priorities added from strengths with this value
    integer strategy_tier_bonus = 35  // the priority bonus added to a strategy if the computer is in the same tier as specified for the strategy
    integer attacking_strategy = 4       // strategy when attacking enemy players
    real focus_fire_limit = 35	// if a enemy heros hp fall below the computers combined strength of ranged attackers in a battle * this, they will focus fire on the hero
    real focus_fire_ranged_dist = 600 // Distance from ranged units enemy units can be targeted with focus fire
    real focus_fire_melee_dist = 50 // Distance from melee units enemy units can be targeted with focus fire
    real flee_health_percentage = 0.25  // Units flee from battle if the health goes below his % value(0.25 = 25%)
    real flee_minimum_health = 100  // Units flee from battle if the health goes below this
    real statue_distance = 300  // how near the units a statue used by undead should be in the fights
    real teleport_radius = 800  // units will stay within this radius from a hero that is using town portal
    integer gold_exchange_level = 650  // computers give extra gold above this value to other computers on the same team in need of gold
    integer wood_exchange_level = 350  // computers give extra lumber above this value to other computers on the same team in need of lumber
    integer max_towns = 5  // how many towns is a computer allowed to have?
    boolean add_tag = true // Add the [AMAI] tag in front of name
    boolean add_skill = true // Add the current skill after the name
    integer fav_hero_add = 20  // priority added to heroes to be picked if they are favorites of the used profile
    integer max_harass_groups = 10  // how many different harass groups you can use
    integer attacking_aggression = -12  // the base agression value for all computers, higher value and they will play more agressive. Recomended -5 to 5
    real expansion_radius = 650  // the radius araound a mine computers check for creeps before expanding there
    real harass_radius_attack_ranged = 800  // how far away from ranged enemy units harassing units attack a inferior enemy unit
    real harass_radius_attack_melee = 400  // how far away from melee enemy units harassing units attack a inferior enemy unit
    real harass_radius_flee_ranged = 1200  // how far away from ranged enemy units harassing units turn and flee
    real harass_radius_flee_melee = 800  // how far away from melee enemy units harassing units turn and flee  
    boolean chatting	= true  // set to false to turn off computer taunts and chatting (Can still talk in observer mode)
    real full_threat_distance = 600  // a enemy army within this distance is counted as a full threat
    real no_threat_distance = 3000  // a enemy army outside this distance is counted as no threat
    real distance_threat_exponent = 0.8  // how fast the threat increases as the enemy army gets from the no_threat_distance to the full_threat_distance
    real distance_threat_mult = 540  // how much the threat vlaue goes up on a town when a enemy army aproaches, higher value means higher threat to town
    real atl_time_start = 300  // accepted threat level increase starts at this time
    real atl_time_end = 900    // and ends at that time
    real atl_time_start_val = 10  // it starts with this value
    real atl_time_end_val = 20  // and ends with that value
    real atl_enemy_start = 1 // accepted threat level multiplier increases at that enemy number
    real atl_enemy_end = 4   // until that enemy number
    real atl_enemy_start_mult = 1  // the multiplier starts for accepted threat level starts with this
    real atl_enemy_end_mult = 1.5    // and ends with this    
    real teleport_low_threat = 40  // Army uses TP to get home and defend if a threat is greater than this
    real teleport_high_threat = 80  // Army uses TP to get home and defend if a threat is greater than this
    real teleport_low_threat_distance = 6000  // Army won't use TP home if they are closer to base than this and a low threat level appears
    real teleport_high_threat_distance = 3000  // Army won't use TP home if they are closer to base than this and a high threat level appears
    real teleport_army_min_strength = 20  // how big the army need to be for use of TP to threatened town
    real teleport_min_threat = 70  // minimum threat level TP use is allowed on  
    integer shredder_peon_count = 12  // how many peons does a goblin shredder replace in lumber harvesting
    integer minimum_peon_wood = 2000 // computers don't build any workers for lumber harvesting if they have more lumber than this
    integer maximum_peon_wood = 200  // computers build all needed workers for lumber harvesting if they have lumber lower than this  
#PRAGMA END VERSION SETTINGS
                 
//==============================================================
// (AMAI) Version Properties
//==============================================================

#PRAGMA START VERSION SETTINGS
  boolean ver_neutral_heroes_available = true  // does the version have neutral heroes ?
  integer ver_neutral_hero_number = 0  // how many neutral heroes ?
  boolean ver_only_heroes_buy = false  // can only heroes buy stuff ?
  integer ver_food_limit = 100  // what is the food limit ?
  integer ver_strat_change_enemy_strength_min = 25  // don't allow strategy change unless the maximum strength of all enemy players in the game is above this.
  integer ver_hero_base_value = 4  // what is the base strength of a hero (the level number is added to get the actual strength) ?
  integer ver_hero_ultimate_level = 6  // at what level do the heroes get their ultimates ?
  integer ver_hero_ultimate_value = 4  // how much extra strength does the ultimate give to the hero ?
  real ver_creeps_attack_buildings_dist = 1000  // how far away do creeps attack buildings ?
  boolean ver_mercs_night_buy = false // can mercs be bought at night without waking up creeps ?
  real ver_tower_check_radius = 2000  // check for towers in this radius around a target
  real ver_harass_tower_check_radius = 1400  // check for towers in this radius during harassing
  integer ver_optimal_gold = 5  // The optimal number of peons that should be harvesting gold
  real ver_flee_multiple1 = 1  // Multiplier to players strength at lowest aggression to measure if amai is allowed to flee
  real ver_flee_multiple2 = 2  // Multiplier to players strength at highest aggression to measure if amai allowed to flee
  real ver_flee_multiple3 = 3  // Multipler to players strength at highest aggression to measure if amai will flee
  real ver_low_aggression = -15  // Aggression below this uses the lowest strength flee multiplier
  real ver_high_aggression = 45  // Agression above this uses the highest strength flee multiplier
#PRAGMA END VERSION SETTINGS

//==============================================================
// (AMAI) Race Properties
//==============================================================



#PRAGMA START RACIAL SETTINGS
    integer hero1_revive_prio = 200  // priority for reviving hero1
    integer hero2_revive_prio = 120  // priority for reviving hero2
    integer hero3_revive_prio = 80  // priority for reviving hero1
    integer prio_n_inc = 2  // priority increase for building needed buildings
    integer prio_t_inc = 1  // priority increase in time
    integer prio_q_inc = 2  // priority increase in quantity
    integer farm_food2 = 1 // builds another farm at the same time when this near food used to food produced
    integer farm_prio = 400 // priority for farm building
    integer peon_prio = 280 // priority for peon building
    integer ghoul_prio = 250  // priority for ghoul building
    integer expa_prio = 200 // priority for expansion building
    integer expa_emergency_prio = 300  // priority for rebuilding an expansion
    integer expa_rebuild_prio = 200 // priority for rebuilding an expansion
    integer peon_1_mine_number = 12 // maximum number of peons to build when 1 mine is owned (redundent if race uses ghouls)
    integer peon_2_mines_number = 17 // maximum number of peons to build when 2 mines are owned (redundent if race uses ghouls)
    integer peon_mines_number = 22  // maximum number of peons to build when more mines are owned (redundent if race uses ghouls)
    integer min_peon_number_single_mine = 8 // minimum number of peons when 1 mine is owned
    integer min_peon_number_double_mine = 13  // minimum number of peons when 2 mines are owned
    integer min_peon_number_multi_mine = 18 // minimum number of peons when more than 1 mine is owned
    integer strat_food_persistence = 2  // * current food use added to priority for current strategy (prevents computers from changing styrategy when having large army)
    integer relevant_strat_change_number = 3   // number of strategies with highest RPs that can be chosen when changing strategy
    integer kb_add1 = 8  // priority added to all strategies having a building the computer already got as a key building
    integer kb_add2 = 9  // priority added to all strategies having a building the computer already started to build as key building
    integer kb_add3 = 7  // priority added to all strategies having both building the computer already got as key buildings
    integer kb_add4 = 10 // value for 2 of a key buildings
    integer ku_add1 = 4  // priority added to all strategies having a upgrade the computer already got as key upgrade in first level
    integer ku_add2 = 7  // priority added to all strategies having a upgrade the computer already got as key upgrade in second level
    integer ku_add3 = 8  // priority added to all strategies having a upgrade the computer already got as key upgrade in third level
    integer fav_unit_add = 20  // priority added to strategies havign the current profiles favorite unit as key units.
    integer debug_strategy = -1  // this race is locked to this strategy number for testing.(-1 is unlocked)
    boolean race_use_fountain = true  // does the race use healing fountains ?
    boolean race_manual_loading = true  // does the race need manual loading of wisps in goldmines ?
    integer race_manual_loading_wisp = 0 //
    integer race_manual_loading_mine = 0 //
    boolean race_towerrush_available = false  // does the race have a towerrush ?
    integer race_tower_item = 0  // if the race_tower_id need Blig land (AbilityId 'Abgl'), Please set
    boolean race_tower_item_must = false  // the item is build towers is must?
    integer race_tower_item_quantity = 0  // how many items at a time , if can buy
    integer race_towerrush_requirement = 0  // what is the building required to build towers ?
    integer race_tower_id = 0  // what is the id of the races towers?
    integer race_tower_id_replace = 0  // if the race_tower_id has Blig land (AbilityId 'Abgl'), cannot create Blig land , and this build should can replace shop
    integer race_tower_upgrade1 = 0  //what is the id of the tower upgrade1 (core)?
    integer race_tower_upgrade2	= 0  //what is the id of the tower upgrade2 (secondary)?
    boolean race_tower_move = false  //tower can move , like ELF tree or StarCraft human build fly?
    string race_tower_movestartstring = ""  //what is the unitstring/name of tower start move? -- like use root to loc move
    string race_tower_moveendstring = ""  //what is the unitstring/name of tower end move?
    boolean race_tower_bypeon = false  //tower is peon become , like ELF? AI will compensate more 2 peon
    integer race_tower_repair_ability = 'Ahrp'  //what is peons repair ability ?
    integer race_tower_peon	= 2  // the peons go to build towers , how much need compensation peons , usually compensation be equal to go build peons , if build like UD , just summon ,can set less
    integer race_towerrush_probability = 5 // how high (in percent) is the probability of doing a tower rush?
    integer race_towerrush_hero_rush_level = 1  // the bonus strength value hero must have to be able to do the tower rush
    boolean race_militia_expansion_available = false  // does the race have a militia expansion ?
    integer race_hero_number = 4  // how many racial heroes ?
    integer race_simple_melee = 0  // a basic melee unit, only necessary when basic_melee is used
    integer race_advanced_melee = 0  // an advanced melee unit to replace the basic one, only necessary when basic_melee is used
    boolean race_has_ghouls = false  // has the race a ghoul-like wood harvester/fighter unit ?
    boolean race_ghouls_attack = true  // do those ghouls go with the army on attacks ?
    integer race_min_ghouls = 2  // smallest number of ghouls to build at all times
    integer race_max_ghouls = 5  // maximum number of ghouls to build in low lumber situations
    boolean race_has_power_build = false  // can multiple racial workers work on the same building ?
    boolean race_no_wood_harvest = false  // has the race no wood harvesters ?
    boolean race_ignore_injured = false  // should the race leave injured units at home ?
    boolean race_uses_mine_expansion = false  // does the race expand with a mine building like undead ?
    boolean race_uses_shredder = true  // does the race use the goblin shredder ?
    boolean race_militia_available = false  // does the race have militia ?
    real race_militia_max_distance = 1000  // how far away from the town hall are the militia allowed ?
    integer race_militia_id = 'hmil'  // what is the militia unit type id?
    integer race_militia_ability = 'Amil'  // what is the militia ability id ?
    integer race_militia_hall_ability = 'Amic'  // what is the militia ability of the hall ?
    string race_militia_unitstring = "militia"  // what is the unitstring/name of the militia ?
    string race_militiaworker_unitstring = "peasant"  // what is the string of the unit that can be turned to militia ?
    boolean race_ancient_expansion_available = false  // can the race expand with an uprooted building that also helps fighting the creeps ?
    integer race_ancient_expansion_probability = 33  // how high (in percent) is the probability of doing an ancient expansion when possible ?
    integer race_ancient_expansion_strength = 15  // up to how much expansion strength is an ancient expansion allowed ?
    integer race_ancient_expansion_help_id = 'earc'  // the unit id of the unit that should help in ancient expansion
    integer race_ancient_expansion_hero_rush_level = 2  // the bonus strength value hero must have to be able to do the ancient expansion
    boolean race_item_expansion_available = false  // can expand with item building ?
    integer race_item_expansion_probability = 5 // how high (in percent) is the probability of doing a item expansion?
    integer race_item_sale_level = 0  // buy expand item need hall level ?
    integer race_item_expansion_item_id = 0  // what is expand item name(from StandardUnits.txt) ?
    boolean race_sell_ziggurats = false  // does the race sell ziggurats that are at no more needed expansions ?
    real race_ziggurat_keep_distance = 1500  // keep ziggurat if this near another building except a ziggurat is
    boolean race_build_farms_front = false  // should the race build farms towards the front (as soon as the front is computed) ?
    integer race_farms_front_limit = 4  // limit the number of farms at the front to this number
    integer race_farms_at_mine = 0  // the first that many farms will be built at the mine
    real race_max_expa_mine_distance = 850  // the maximum distance between the mine and the expansion building
    boolean race_has_moonwells = false  // Racial farms have healing properties
    integer groundid = 'ewsp'  // Used to create path units, must be different from race peon

#PRAGMA END RACIAL SETTINGS

//==============================================================
// (AMAI) Misc Properties
//==============================================================

#PRAGMA START VERSION SETTINGS
    boolean destroy_buildings_on_defeat = true  // Should the buildings of the AI be destroyed on defeat or given to neutral player ?
    integer attack_reform_length = 20  // reform the attack group (getting new units) every that time on an attack (in seconds / 2)
    real front_base_distance = 1100  // the distance of the front locations from the start location
    boolean ver_heroes = true  // Does this version have heroes?
    boolean fixedcomputername = false  // Enable to force computers to have there fixed name instead of a profile name
    integer green_creep_camp_strength_bonus = 0  // Bonus strength added to minor creep camps
    integer orange_creep_camp_strength_bonus = 5  // Bonus strength added to mediocre creep camps
    integer red_creep_camp_strength_bonus = 10  // Bonus strength added to major creep camps
    boolean disable_surrender = false  // Set to true to stop amai from giving up early when it detects its going to lose
    real strategy_change_threshold = 1.2  // New strategy priority must be larger than this (default 1.20) multiple to the current strategy prority
    boolean debugging = false  // Can turn on for debugging mode to display debug type messages
    integer major_hero_skill_value = 60  // Priority to choose the first line of hero skills
    integer minor_hero_skill_value = 30  // Priority to choose the second line of hero skills
    integer rare_hero_skill_value = 10  // Priority to choose the third line of hero skills
#PRAGMA END VERSION SETTINGS

//==============================================================
// (AMAI)  General Stuff
//==============================================================
    boolean IsAMAI = false
    boolean leadally = false

    boolean campaign_ai = false

    string language = "English"

    string ai_id = ""

    string message_add = ""

    real command_wait = 3

    real time_of_day = 0

    boolean water_map = false

    string array digit_map


    integer array player_race
    integer array player_race_pref
    string array race_name

    boolean game_is_ffa = false
    boolean game_is_1on1 = false


    integer total_food              = 0
    integer wood_buffer             = 0
    real    gold_income             = 0
    integer income_per_mine         = 3000
    real    gold_unit_percentage    = 0.9


    integer racial_peon	= 0
    integer array racial_hall
    integer array racial_goldmine
    integer minearray = 0
    integer array racial_zigg
    integer ziggarray = 0
    integer racial_expansion = 0
    integer racial_altar = 0
    integer racial_shop = 0
    integer racial_militia = 0
    integer racial_militiahero = 0
    integer racial_ghoul = 0
    integer racial_lumber = 0
    integer racial_rushcreep = 0
    unit rushcreep_target = null
    integer neutral_shredder = 0
    integer neutral_zeppelin = 0
    integer tp_item = 0
    integer tiernum = 3
    integer mapSize = 0
    boolean firstattackhp = false  //big map or more player first attack human player?

    integer array hero
    integer array hero_skills // The skill line chosen for the hero, major, minor or rare
    integer array skills
    integer array tempskills
    integer array allskills
    integer first_choosable_hero = 0
    boolean array hero_built
    integer array hero_revive_prio
    unit array hero_unit
    integer array all_heroes
    integer array all_heroes_copy
    integer array hero_rp
    integer hero_number = 0
    integer chosen = 0

    real array action_points
    integer action_numbers = 0

    real enemy_density = 0
    location enemy_density_loc = Location(0,0)
    real ally_density = 0
    location ally_density_loc = Location(0,0)

    real nearest_enemy_range = 10000000
    player nearest_enemy = null
    player nearest_human_enemy = null

    integer array upkeep_allowed
    integer array last_upkeep_allowed
    integer array upkeep_border
    integer array upkeep_resistance
    integer array upkeep_save_time
    integer array upkeep_time
    integer array upkeep_mines_needed

    integer array attack_qty
    integer array attack_max
    integer array attack_units
    integer attack_length           = 0

//==============================================================
    // (AMAI)  Build Variables
    //==============================================================
//    integer array build_qty
//    integer array build_type
//    integer array build_item
//    integer array build_town
    integer array build_prio
    integer array build_loc
//    integer build_length            = 0

    integer array t_build_qty
    integer array t_build_type
    integer array t_build_item
    integer array t_build_town
    integer array t_build_prio
    integer array t_build_loc
    integer t_build_length            = 0

    integer array bl_req_qty
    integer array bl_req_type
    integer array bl_allow_qty
    integer array bl_allow_type
    integer array bl_expire_time
    boolean array bl_only_done
    integer bl_length = 0
    integer blocked_gold = 0
    integer blocked_wood = 0
    integer blocked_food = 0

    integer array rbl_req_gold
    integer array rbl_req_wood
    integer array rbl_req_food   // Food required before building unit
    integer array rbl_allow_qty
    integer array rbl_allow_type
    integer array rbl_expire_time
    integer rbl_length = 0

    boolean build_lock = true

    //==============================================================
    // (AMAI)  Standard Unit Variables
    //==============================================================
    integer array old_id
    integer array needed1  // needed building and factory if unit
    integer array needed2  // needed building 2
    integer array needed3  // needed for upgrade level 3
    integer array build_free // free buildings
    integer array gold_sum
    integer array build_time_sum
    integer array build_num
    real array income_percentage
    integer array prio_sum
    integer array tc_add1  // building that has to be added for TownCount
    integer array tc_add2  // building that has to be added for TownCount
    integer array available_time
    integer array regenerate_time
    integer array attacking_max_num
    integer array upgrade_time
    integer array gold_price
    integer array wood_price
    integer array hero_rush_bonus
    integer array buy_type

//==============================================================
// (AMAI)  Misc Globals
//==============================================================
    integer array building
    integer building_length = 0

    integer array campaign_defenders

    integer array creep_strength
    integer creep_strength_length = 0

    unit follow_zeppelin = null
    boolean zeppelin_following = false

    boolean array neutral_available
    unit array nearest_neutral
    group array neutral_guards
    boolean array neutral_guarded
    integer array neutral_enemy
    boolean array neutral_ordered
    unit array neutral_sent
    boolean array neutral_night_buy
    integer array neutral_id
    real array buy_time_large
    real array buy_time_small
    integer array neutral_wanted
    boolean no_sleep = false
    integer array dragons
    integer array merc_unit
    integer merc_number = 0
    integer dragon_number = 0
#INCLUDETABLE <$VER$\MercTypes.txt>
    integer merc_%1 = 0
#ENDINCLUDE

    integer minimum_attack_strength = 11

    integer max_farms = 0

    integer exp_time_count = 0
    integer exp_first_time = 30
    integer exp_second_time = 180
    real expansion_taken_radius = 1000  // the radius around a mine where enemy or allied buildings are considered as possessing that mine (it is considered taken then)

    integer creep_camp_radius = 550
    integer camp_scan_depth = 3
    integer camp_last_checked = 40

    integer air_strength = 0
    integer array p_str_cache
    integer array p_str_cache_timeout
    integer p_str_cache_valid_time = 2

    boolean ai_no_creep = false
    boolean town_threat_break = true
    //boolean captain_flee = true

//==============================================================
// (AMAI)  Strategy System Variables
//==============================================================
    integer strategy = 0
    integer chosen_strategy = 0
    integer last_strategy = 100
    string array strategy_name
    string array strategy_default_name
    string array strategy_default_report
    integer array key_building1
    integer array key_building2
    integer array key_upgrade1
    integer array key_upgrade2
    integer array key_unit
    integer array rp_strat
    integer array rp_strat_sort
    boolean array beginning_strat
    integer array strat_minimum_time
    integer rp_strat_length = 0
    integer rp_strat_sort_length = 0
    integer small_map_tier1_bonus = 20
    real k_add_start_mult = 3
    real k_add_end_mult = 1
    real k_add_start_time = 120
    real k_add_end_time = 1200
    boolean array strategy_type_used
//    integer used_strategies = 0
    integer array strategy_type
    integer strategy_type_used_penalty = 30
    integer array strategy_tier
    integer array strategy_first_exp_time
    integer array strategy_second_exp_time
    integer array strategy_first_hero
    integer array strategy_first_hero_bonus
    integer array strategy_second_hero
    integer array strategy_second_hero_bonus
    integer array strategy_third_hero
    integer array strategy_third_hero_bonus
    integer array strategy_race_aggression

    boolean attacking_expansion = false
    boolean recalculate_heros = false // Tavern heros cannot be trained so get a normal hero

    integer tier = 0
    integer own_strength = 0
    integer uncertainty = 10
    integer tower_factor = 10
    integer array race_aggression
    integer array b_race_aggression
    integer added_aggression = 0  // aggression added when upkeep becomes higher
    boolean h_siege = false
    unit alli_target = null
    integer expansion_target_bonus = 7
    integer comp_chosen_target_bonus = 5
    real comp_chosen_target_rate = 0.5

    boolean balancing = false

//==============================================================
// (AMAI)  Healing System Globals
//==============================================================
    group healer_group = CreateGroup()
    boolean ward_cast = false

    group urgent_healing_group = CreateGroup()
    group medium_healing_group = CreateGroup()
    group small_healing_group = CreateGroup()
    integer urgent_healing_count = 0
    integer medium_healing_count = 0
    integer small_healing_count = 0
    boolean fountain_available = false

    unit item_unit = null

    integer array healer_id
    integer array healer_spell
    integer array healer_type
    integer array healer_mana_cost
    integer array healer_upg_id
    integer array healer_upg_level
    integer healer_length = 0

//==============================================================
// (AMAI)  Misc Globals
//==============================================================
    integer array c_enemy  // number of enemy players of certain races or random
    integer c_enemy_total	= 0
    integer array c_ally  // number of allied players of certain races
    integer c_ally_total = 0
    integer c_enemy_user_total = 0  //number of enemy human player
    integer c_ally_user_total = 0  //number of ally human player
    integer c_ai_total = 0
    boolean enemy_revealed = false
    integer strat_prev = 0  // strategy chosen by the ai before this one
    integer hero_prev = 0  // hero chosen by the ai before this one
    integer picked_hero = 0
    boolean first_ai = true
    integer next_ai = 0
    boolean no_ai_ally = false
    boolean no_ally_ctrl = true

    boolean player_defeated	= false

#INCLUDETABLE <$VER$\Strengths.txt>
    real enemy_%1 = 0
    real ally_%1 = 0
#ENDINCLUDE


    boolean array town_built
    location array own_town_loc
    real array own_town_dist
    unit array own_town_mine
    integer first_town_mine = 0
    location array exist_town
    integer exist_town_num = 0

    integer attacking_ghouls = 0
    integer harvesting_ghouls = 0

    integer ai_time = 0

    integer tq_length = 0
    real array tq_time
    integer array tq_jid
    integer array tq_par
    unit array tq_unit_par
    group array tq_group_par
    boolean tq_lock = true
    timer tq_timer = CreateTimer()

    boolean attack_running = false
    boolean no_attack_allowed = false

    integer order_cancel = 851976
    integer order_attack = 851983

//==============================================================
// (AMAI)  Chatting variables
//==============================================================
    sound chatSound = CreateSound( "Sound\\Interface\\InGameChatWhat1.wav", false, false, false, 10, 10, "" )
    sound importantSound = CreateSound( "Sound\\Interface\\CreepAggroWhat1.wav", false, false, false, 10, 10, "" )

    boolean array chat_target_obs
    boolean array chat_target_ally
    boolean array chat_target_enemy
    boolean array chat_important
    string array chat_list
    string array chat_list_race
    integer array chat_list_eq
    integer chat_list_length = 0
    string chat_race = ""
    integer chat_eq = 0
    constant integer C_STRATEGY = 0

#INCLUDETABLE <ChatEvents.txt> #EFR
    string array chat_%1
    integer chat_%1_length = 0
    constant integer C_%1 = %row
#ENDINCLUDE

    string chat_no_unit_selected = ""
    string chat_confirm_attack_unit = ""
    string chat_towerrush = ""
    string chat_no_towerrush = ""
    string chat_unsuited_towerrush = ""
    string chat_stop_towerrush = ""
    string chat_dynamic_counter = ""
    string militia_expansion_chat = ""
    string invalid_strategy_number = ""

    //gamecache translation_map = InitGameCache("AMAI_TM.w3v")
    hashtable translation_map = InitHashtable()
    string array translation
    integer translation_length = 0

    //gamecache additional_info = InitGameCache("AMAI_AI.w3v") // Used for harrass data
    //gamecache com = InitGameCache("AMAI_Com.w3v")
    hashtable additional_info = InitHashtable()
    constant integer START_STRENGTH = 0
    constant integer AVOID_TOWERS = 1
    constant integer STRENGTH_LIMIT = 2
    constant integer STATE_ATTACKING = 3
    constant integer FLEE_PERCENT = 4
    constant integer FLEE_NUMBER = 5
    constant integer INVISIBLE_COUNT = 6
    constant integer LOCX = 7
    constant integer LOCY = 8
    constant integer STATE_RETREAT = 9
    constant integer WINDWALK_COUNT = 10
    hashtable com = InitHashtable()
    constant integer PROFILE_USED = 0
    constant integer TEAM_STATEGY_INUSE = 1
    constant integer IS_AMAI = 2
    constant integer RACE = 3
    constant integer RACE_PREF = 4
    constant integer USE_SPECIAL_RACES = 5
    constant integer PROFILE_SELECTION = 6

    gamecache amaiCache = InitGameCache("AMAI_AI.w3v")

    //gamecache settings = InitGameCache("AMAI_Set.w3v")

    string array char_table
    string array char_bug_table
    integer char_table_length = 0
    hashtable language_table = InitHashtable()
    constant integer CHAR_TABLE = 0
    constant integer CHAT_VARS_TABLE = 1
    string array chat_vars
    integer chat_vars_length = 1
    //gamecache chat_vars_map = InitGameCache("AMAI_CVM.w3v")
    //hashtable chat_vars_map = InitHashtable()

//===========================================================================
// (AMAI)  Job variables
//===========================================================================
#DEFINE GLOBAL
#INCLUDETABLE <Jobs.txt> #EFR
    #INCLUDESCRIPT <Jobs\%1.eai>
#ENDINCLUDE
#UNDEF GLOBAL

//===========================================================================
// (AMAI)  Variables for controlling the AI (different states)
//===========================================================================

    boolean creeping_only = false

    boolean break_attack 	= false
    boolean go_home		= false
    boolean attack_player	= false
    boolean attack_point	= false
    boolean attack_unit		= false
    boolean no_attack		= false
    boolean no_creep_attack	= false
    boolean no_player_attack	= false
    boolean strat_change_allowed = true
    integer attack_target_p	= 0
    integer attack_target_x	= 0
    integer attack_target_y	= 0
#INCLUDETABLE <$VER$\CommandBuilds.txt> #EFR
    integer bn_%1 = 0
#ENDINCLUDE
    unit 	target_unit = null
    integer array target_queue_x
    integer array target_queue_y
    unit    array target_queue_u
    integer queue_length	= 0
    integer queue_pointer	= 0
    boolean queue_running	= false
    boolean queue_attack_p	= false
    boolean queue_attack_u	= false
    integer queue_t_x		= 0
    integer queue_t_y		= 0
    unit	queue_t_u = null

//==============================================================
// (AMAI)  Profile system globals
//==============================================================

    integer profile_length      = 0
    integer profile            = 0
    integer debug_profile = -1

    string ai_name = "Computer"
    integer own_race = 0
    real taunt_rate = 1.00 // how man % of the time computers taunt, set by profiles. Recommended values 0.50 to 1.50
    integer taunt_start_time = 60  // the time for the computers to start taunting (in seconds * 5)
    integer farm_food = 8 // build farm when this near food used to food produced
    integer strat_persistence = 1000  // extra priority to the current strategy to make computer not change strategy too fast  

    // Profile settings
    string array profilename
    integer array fav_hero
    integer array fav_unit
    integer array p_race  // Desired race for the profile to be picked (default random)
    integer array p_aggression  // aggression modify to total attacking_aggression. reccomended -10 to 10
    integer array p_uncertainty  // adds or subtracts this value to the enemies strength every so often. reccomended 5 to 15
    integer array p_minimum_attack_strength  // How much strength required before amai can start attacking. reccomended 3 to 6
    integer array p_farm_food  // How much food to have left before building a new farm
    integer array p_exp_first_time  // Make amai build expansion earlier or later by this number of seconds. reccomended -10 to 10
    integer array p_exp_second_time
    integer array p_strat_persistence  // How persistance amai is to keep its current strategy. reccomended 1.05 to 2.00
    integer array p_expansion_target_bonus  // aggression bonus for expansion targets
    integer array p_comp_chosen_target_bonus  // aggression bonus for targets chosen by the hard coded AI
    integer array p_surrender  // How likly amai will give up, 0 being never give up and 4 being give up really easily
    integer array p_rare // Ensures the profile is rarely picked
    real array p_gold_unit_percentage  // The higher this is the more unit production buildings are constructed. reccomended 0.9 to 1
    real array p_taunt_rate // Will display a taunt every 5th second for this percent of the time. Reccomended 1 to 2
//    real taunt_rate = 1.00 // how man % of the time computers taunt, set by profiles. Recommended values 0.50 to 1.50
//    integer taunt_start_time = 60  // the time for the computers to start taunting (in seconds * 5)
    real array p_comp_chosen_target_rate  // how often the computer considers an attack target chosen by the hard coded AI
//==============================================================
// (AMAI)  Pathing variables
//==============================================================

    real path_top = GetCameraBoundMaxY()+GetCameraMargin(CAMERA_MARGIN_TOP)
    real path_bottom = GetCameraBoundMinY()-GetCameraMargin(CAMERA_MARGIN_BOTTOM)
    real path_left = GetCameraBoundMinX()-GetCameraMargin(CAMERA_MARGIN_LEFT)
    real path_right = GetCameraBoundMaxX()+GetCameraMargin(CAMERA_MARGIN_RIGHT)
    //rect playable_rect = Rect(path_left, path_bottom, path_right, path_top)

    unit array expansion_list
    location array expansion_ancient
    real array expansion_dist
    group array expansion_creeps
    integer expansion_list_length = 0

    unit array water_expansion_list
    integer water_expansion_list_length = 0
    group water_expansion = CreateGroup()
    group array water_expansion_creeps
    group far_expansion = CreateGroup()

    boolean active_expansion = false

    unit expansion_peon = null
    unit build_zeppelin = null
    location exp_loc_cache = Location(0,0)
    integer exp_loc_cache_timeout = 0

    integer exp_number = 0
    integer array exp_rp
    unit array exp_unit
    real array exp_dist
    location array exp_ancient
    group array exp_creeps

    group current_expansion_creeps = null
    unit current_expansion = null
    boolean first_expansion_chosen = false
    unit not_taken_expansion = null
    boolean pathing_done = false

    integer confirm_count = 0
    integer array ai_force
    integer ai_force_length = 0
    boolean pathing_receive_finished = false

    integer home_field = 0

    location mine_loc = null
    location array front_loc   // the locations along the frontier of the main base (on the way to the enemies and a certain distance from the base)
    integer front_loc_num = 0  // the number of front locations
    boolean front_locs_computed = false  // are the front points computed ?

//==============================================================
// (AMAI)  Debug variables
//==============================================================
    integer udg_unique_counter = 0
    gamecache udg_debug_cache = null
    string udg_current_category = null
    timer udg_debug_timer = CreateTimer()
    boolean job_debug = false  // Job system reports will be displayed (used for finding thread crashes)
    integer debug_player = 0

//==============================================================
// (AMAI)  Dynamic Strategy variables
//==============================================================
    integer chosen_counter = -1
    integer chosen_counter_unit = 0
    boolean no_counter = true
    string array strengthtext
    #INCLUDETABLE <$VER$\Strengths.txt>
    integer array dyanti_%1
    integer totalanti_%1 = 0
    integer array dychance_%1
    integer totalchance_%1 = 0
    #ENDINCLUDE

endglobals


//_________________________________________________________________________________________________________________________________________________
//_________________________________________________________________________________________________________________________________________________
  // Global Utility Functions ( A collection of functions used for debugging and
  // language utilities. Also contains the algorithm functions e.g. hashmaps etc)

//============================================================================
// (AMAI)  Debug Functions
//============================================================================
//function H2I takes handle h returns integer
//  return h
//  return 0
//endfunction

//function SetHandleHandle takes handle subject, string name, handle value returns nothing
//    if value==null then
//        call FlushStoredInteger(LocalVars(),I2S(H2I(subject)),name)
//    else
//        call StoreInteger(LocalVars(), I2S(H2I(subject)), name, H2I(value))
//    endif
//endfunction

//function SetHandleInt takes handle subject, string name, integer value returns nothing
//    if value==0 then
//        call FlushStoredInteger(LocalVars(),I2S(H2I(subject)),name)
//    else
//        call StoreInteger(LocalVars(), I2S(H2I(subject)), name, value)
//    endif
//endfunction

//function SetHandleReal takes handle subject, string name, real value returns nothing
//    if value==0 then
//        call FlushStoredReal(LocalVars(), I2S(H2I(subject)), name)
//    else
//        call StoreReal(LocalVars(), I2S(H2I(subject)), name, value)
//    endif
//endfunction

//function SetHandleString takes handle subject, string name, string value returns nothing
//    if value==null then
//        call FlushStoredString(LocalVars(), I2S(H2I(subject)), name)
//    else
//        call StoreString(LocalVars(), I2S(H2I(subject)), name, value)
//    endif
//endfunction

//function GetHandleInt takes handle subject, string name returns integer
//    return GetStoredInteger(LocalVars(), I2S(H2I(subject)), name)
//endfunction
//function GetHandleBoolean takes handle subject, string name returns boolean
//   return GetStoredBoolean(LocalVars(), I2S(H2I(subject)), name)
//endfunction
//function GetHandleReal takes handle subject, string name returns real
//    return GetStoredReal(LocalVars(), I2S(H2I(subject)), name)
//endfunction
//function GetHandleString takes handle subject, string name returns string
//    return GetStoredString(LocalVars(), I2S(H2I(subject)), name)
//endfunction

//function FlushHandleLocals takes handle subject returns nothing
//    call FlushStoredMission(LocalVars(), I2S(H2I(subject)) )
//endfunction

//============================================================================
//function String2Int takes string s returns integer
//  return s
//  return 0
//endfunction

//============================================================================
function DoNothing takes nothing returns nothing
endfunction

//============================================================================
// Properly clear the game caches to make sure they are empty on use
function InitAMAIGameCache takes nothing returns nothing
  //call FlushGameCache(InitGameCache("AMAI_TM.w3v"))
  call FlushGameCache(amaiCache)
  //call FlushGameCache(InitGameCache("AMAI_Com.w3v"))
  //call FlushGameCache(InitGameCache("AMAI_Set.w3v"))
  //call FlushGameCache(InitGameCache("AMAI_CVM.w3v"))
  //set translation_map = InitHashtable()
  //set additional_info = InitGameCache("AMAI_AI.w3v")
  //set com = InitHashtable()
  //set settings = InitGameCache("AMAI_Set.w3v")
  //set chat_vars_map = InitHashtable()
endfunction


//============================================================================
function c2s takes playercolor c returns string
if c == PLAYER_COLOR_RED then
    set c = null
    return "|CffFF0000"+ai_name+"|r: "
elseif c == PLAYER_COLOR_BLUE then
    set c = null
    return "|Cff0064FF"+ai_name+"|r: "
elseif c == PLAYER_COLOR_CYAN then
    set c = null
    return "|Cff1BE7BA"+ai_name+"|r: "
elseif c == PLAYER_COLOR_PURPLE then
    set c = null
    return "|Cff550081"+ai_name+"|r: "
elseif c == PLAYER_COLOR_YELLOW then
  set c = null
    return "|CffFFFC00"+ai_name+"|r: "
elseif c == PLAYER_COLOR_ORANGE then
    set c = null
    return "|CffFF8A0D"+ai_name+"|r: "
elseif c == PLAYER_COLOR_GREEN then
    set c = null
    return "|Cff21BF00"+ai_name+"|r: "
elseif c == PLAYER_COLOR_PINK then
    set c = null
    return "|CffE45CAF"+ai_name+"|r: "
elseif c == PLAYER_COLOR_LIGHT_GRAY then
    set c = null
    return "|Cff949696"+ai_name+"|r: "
elseif c == PLAYER_COLOR_LIGHT_BLUE then
    set c = null
    return "|Cff7EBFF1"+ai_name+"|r: "
elseif c == PLAYER_COLOR_AQUA then
    set c = null
    return "|Cff106247"+ai_name+"|r: "
else
    if PLAYERPASSIVE != 15 then
      if c == PLAYER_COLOR_MAROONX then
        set c = null
        return "|Cff9C0000"+ai_name+"|r: "
      elseif c == PLAYER_COLOR_NAVYX then
        set c = null
        return "|Cff0000C3"+ai_name+"|r: "
      elseif c == PLAYER_COLOR_TURQUOISEX then
        set c = null
        return "|Cff00EBFF"+ai_name+"|r: "
      elseif c == PLAYER_COLOR_VIOLETX then
        set c = null
        return "|Cffbd00ff"+ai_name+"|r: "
      elseif c == PLAYER_COLOR_WHEATX then
        set c = null
        return "|CffECCD87"+ai_name+"|r: "
      elseif c == PLAYER_COLOR_PEACHX then
        set c = null
        return "|CffF7A58B"+ai_name+"|r: "
      elseif c == PLAYER_COLOR_MINTX then
        set c = null
        return "|CffBFFF81"+ai_name+"|r: "
      elseif c == PLAYER_COLOR_LAVENDERX then
        set c = null
        return "|CffDBB9EB"+ai_name+"|r: "
      elseif c == PLAYER_COLOR_COALX then
        set c = null
        return "|Cff4F5055"+ai_name+"|r: "
      elseif c == PLAYER_COLOR_SNOWX then
        set c = null
        return "|CffECF0FF"+ai_name+"|r: "
      elseif c == PLAYER_COLOR_EMERALDX then
        set c = null
        return "|Cff00781E"+ai_name+"|r: "
      elseif c == PLAYER_COLOR_PEANUTX then
        set c = null
        return "|CffA57033"+ai_name+"|r: "
      endif
    endif
    set c = null
    return "|Cff4F2B05"+ai_name+"|r: "//Brown
endif
endfunction

//===========================================================================
// Converts a percentage (real, 0..100) into a scaled integer (0..max),
// clipping the result to 0..max in case the input is invalid.
//
function AMAIPercentToInt takes real percentage, integer max returns integer
  local integer result = R2I(percentage * I2R(max) * 0.01)

  if (result < 0) then
      set result = 0
  elseif (result > max) then
      set result = max
  endif

  return result
endfunction

//===========================================================================
function AMAIPercentTo255 takes real percentage returns integer
  return AMAIPercentToInt(percentage, 255)
endfunction

//===========================================================================
function SetDebugTagColor takes texttag tt returns nothing
  local playercolor c = GetPlayerColor(ai_player)
  if c == PLAYER_COLOR_RED then
    call SetTextTagColor(tt, 255, 0, 0, AMAIPercentTo255(100-0))
  elseif c == PLAYER_COLOR_BLUE then
    call SetTextTagColor(tt, 0, 100, 255, AMAIPercentTo255(100-0))
  elseif c == PLAYER_COLOR_CYAN then
    call SetTextTagColor(tt, 27, 231, 186, AMAIPercentTo255(100-0))
  elseif c == PLAYER_COLOR_PURPLE then
    call SetTextTagColor(tt, 85, 0, 129, AMAIPercentTo255(100-0))
  elseif c == PLAYER_COLOR_YELLOW then
    call SetTextTagColor(tt, 255, 252, 0, AMAIPercentTo255(100-0))
  elseif c == PLAYER_COLOR_ORANGE then
    call SetTextTagColor(tt, 255, 138, 13, AMAIPercentTo255(100-0))
  elseif c == PLAYER_COLOR_GREEN then
    call SetTextTagColor(tt, 32, 191, 0, AMAIPercentTo255(100-0))
  elseif c == PLAYER_COLOR_PINK then
    call SetTextTagColor(tt, 228, 92, 0, AMAIPercentTo255(100-0))
  elseif c == PLAYER_COLOR_LIGHT_GRAY then
    call SetTextTagColor(tt, 148, 150, 150, AMAIPercentTo255(100-0))
  elseif c == PLAYER_COLOR_LIGHT_BLUE then
    call SetTextTagColor(tt, 126, 191, 241, AMAIPercentTo255(100-0))
  elseif c == PLAYER_COLOR_AQUA then
    call SetTextTagColor(tt, 19, 98, 71, AMAIPercentTo255(100-0))
  elseif c == PLAYER_COLOR_BROWN then
    call SetTextTagColor(tt, 79, 43, 5, AMAIPercentTo255(100-0))  //Brown
  else
    if PLAYERPASSIVE != 15 then
      if c == PLAYER_COLOR_MAROONX then
        call SetTextTagColor(tt, 156, 0, 0, AMAIPercentTo255(100-0))
      elseif c == PLAYER_COLOR_NAVYX then
        call SetTextTagColor(tt, 0, 0, 195, AMAIPercentTo255(100-0))
      elseif c == PLAYER_COLOR_TURQUOISEX then
        call SetTextTagColor(tt, 0, 235, 255, AMAIPercentTo255(100-0))
      elseif c == PLAYER_COLOR_VIOLETX then
        call SetTextTagColor(tt, 189, 0, 255, AMAIPercentTo255(100-0))
      elseif c == PLAYER_COLOR_WHEATX then
        call SetTextTagColor(tt, 236, 205, 135, AMAIPercentTo255(100-0))
      elseif c == PLAYER_COLOR_PEACHX then
        call SetTextTagColor(tt, 247, 165, 139, AMAIPercentTo255(100-0))
      elseif c == PLAYER_COLOR_MINTX then
        call SetTextTagColor(tt, 191, 255, 129, AMAIPercentTo255(100-0))
      elseif c == PLAYER_COLOR_LAVENDERX then
        call SetTextTagColor(tt, 219, 185, 235, AMAIPercentTo255(100-0))
      elseif c == PLAYER_COLOR_COALX then
        call SetTextTagColor(tt, 79, 80, 85, AMAIPercentTo255(100-0))
      elseif c == PLAYER_COLOR_SNOWX then
        call SetTextTagColor(tt, 236, 240, 255, AMAIPercentTo255(100-0))
      elseif c == PLAYER_COLOR_EMERALDX then
        call SetTextTagColor(tt, 0, 120, 30, AMAIPercentTo255(100-0))
      elseif c == PLAYER_COLOR_PEANUTX then
        call SetTextTagColor(tt, 165, 112, 51, AMAIPercentTo255(100-0))
      endif
    endif
  endif
  set c = null
endfunction

function CreateDebugTagLoc takes string s, real fontsize, real posx, real posy, real lifespan, real fadespan returns nothing
	local texttag tt = null

	if debugging then
		set tt = CreateTextTag()
		call SetTextTagText(tt, s, ( fontsize * 0.023 / 10))  // *0.023/10 creates the correct font size from given real
		call SetTextTagPos(tt, posx, posy, 0)
		call SetDebugTagColor(tt)
		call SetTextTagPermanent(tt, false)
		call SetTextTagLifespan(tt, lifespan)
		call SetTextTagFadepoint(tt, fadespan)
		set tt = null
	endif
endfunction

// Create a texttag over a specific unit for a certain amount of time
function CreateDebugTag takes string s, real fontsize, unit u, real lifespan, real fadespan returns nothing
	local texttag tt = null

	if debugging then
		set tt = CreateTextTag()
		call SetTextTagText(tt, s, ( fontsize * 0.023 / 10))  // *0.023/10 creates the correct font size from given real
		call SetTextTagPosUnit(tt, u, 0)
		call SetDebugTagColor(tt)
		call SetTextTagPermanent(tt, false)
		call SetTextTagLifespan(tt, lifespan)
		call SetTextTagFadepoint(tt, fadespan)
		set tt = null
	endif
endfunction

//===========================================================================
// (AMAI)  ColorText (Converts the player color to a text version)
//===========================================================================
function ColorText takes player CPlayer returns string
  //Required Variables
  local playercolor PColor = GetPlayerColor(CPlayer)  //Gets the Player's color
  //Finds the Nicer Text Version of the Player's Color
  if (PColor == PLAYER_COLOR_RED) then
    set PColor = null
    return "Red"
  elseif (PColor == PLAYER_COLOR_BLUE) then
    set PColor = null
    return "Blue"
  elseif (PColor == PLAYER_COLOR_CYAN) then
    set PColor = null
    return "Cyan"
  elseif (PColor == PLAYER_COLOR_PURPLE) then
    set PColor = null
    return "Purple"
  elseif (PColor == PLAYER_COLOR_YELLOW) then
    set PColor = null
    return "Yellow"
  elseif (PColor == PLAYER_COLOR_ORANGE) then
    set PColor = null
    return "Orange"
  elseif (PColor == PLAYER_COLOR_GREEN) then
    set PColor = null
    return "Green"
  elseif (PColor == PLAYER_COLOR_PINK) then
    set PColor = null
    return "Pink"
  elseif (PColor == PLAYER_COLOR_LIGHT_GRAY) then
    set PColor = null
    return "Light Gray"
  elseif (PColor == PLAYER_COLOR_LIGHT_BLUE) then
    set PColor = null
    return "Light Blue"
  elseif (PColor == PLAYER_COLOR_AQUA) then
    set PColor = null
    return "Aqua"
  elseif (PColor == PLAYER_COLOR_BROWN) then
    set PColor = null
    return "Brown"
  else
    if PLAYERPASSIVE != 15 then
      if (PColor == PLAYER_COLOR_MAROONX) then
        set PColor = null
        return "Maroon"
      elseif (PColor == PLAYER_COLOR_NAVYX) then
        set PColor = null
        return "Navy"
      elseif (PColor == PLAYER_COLOR_TURQUOISEX) then
        set PColor = null
        return "Turquoise"
      elseif (PColor == PLAYER_COLOR_VIOLETX) then
        set PColor = null
        return "Violet"
      elseif (PColor == PLAYER_COLOR_WHEATX) then
        set PColor = null
        return "Wheat"
      elseif (PColor == PLAYER_COLOR_PEACHX) then
        set PColor = null
        return "Peach"
      elseif (PColor == PLAYER_COLOR_MINTX) then
        set PColor = null
        return "Mint"
      elseif (PColor == PLAYER_COLOR_LAVENDERX) then
        set PColor = null
        return "Lavender"
      elseif (PColor == PLAYER_COLOR_COALX) then
        set PColor = null
        return "Coal"
      elseif (PColor == PLAYER_COLOR_SNOWX) then
        set PColor = null
        return "Snow"
      elseif (PColor == PLAYER_COLOR_EMERALDX) then
        set PColor = null
        return "Emerald"
      elseif (PColor == PLAYER_COLOR_PEANUTX) then
        set PColor = null
        return "Peanut"
      endif
    endif
  endif
  //Returns text version
  set PColor = null
  return ""
endfunction

//============================================================================
// (AMAI)	Int2Str
//  Converts and integer number to a string (This only works for actual integer numbers)
//  Cannot use native I2S in any AI related code
//  for unit ids etc you must use common.j natives
//============================================================================
function InitDigits takes nothing returns nothing
  set digit_map[0] = "0"
  set digit_map[1] = "1"
  set digit_map[2] = "2"
  set digit_map[3] = "3"
  set digit_map[4] = "4"
  set digit_map[5] = "5"
  set digit_map[6] = "6"
  set digit_map[7] = "7"
  set digit_map[8] = "8"
  set digit_map[9] = "9"
endfunction

function Int2Str takes integer ic returns string
  local string s = ""
  local integer i = ic
  local integer ialt = 0
  local boolean neg = false

  if digit_map[0] == null then
    call InitDigits() // If called before digits has been initialized do it ourselves.
  endif

  if i == 0 then
    set s = null
    return "0"
  endif
  if i < 0 then
    set neg = true
    set i = -i
  endif
  loop
    exitwhen i == 0
    set ialt = i
    set i = i / 10
    set s = digit_map[ ialt - 10*i ] + s
  endloop
  if neg then
    return "-"+s
  endif
  return s
endfunction

function Real2Str takes real num returns string
  local string s = ""
  local real r = num

  set s = Int2Str(R2I(r))
  set r = r - R2I(r) // Remove the integer bit to leave the decimal
  if r > 0 then
    set s = s + "." // The decimal point
    set r = r * 1000 // 3 decimal places
    set s = s + Int2Str(R2I(r))
  endif
  return s
endfunction

//============================================================================
// (AMAI)	More Debug functions
//============================================================================
function B2S takes boolean b returns string
  if b then
    return "true"
  else
    return "false"
  endif
endfunction

//============================================================================
function DebugSequenceStart takes string name returns nothing
  call FlushGameCache(InitGameCache("Debug.w3v"))
  set udg_debug_cache = InitGameCache("Debug.w3v")
  set udg_current_category = Int2Str(GetRandomInt(1, 100000000))
  call TimerStart(udg_debug_timer, 1000000, false, null)
  call StoreString(udg_debug_cache, udg_current_category, "Debug0", "SequenceStart "+name)
  set udg_unique_counter = 1
endfunction

//============================================================================
function DebugSequenceEnd takes nothing returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), "SequenceEnd")
  call SaveGameCache(udg_debug_cache)
endfunction

//============================================================================
function DumpString takes string label, string s returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), s)
  set udg_unique_counter = udg_unique_counter + 2
endfunction

//============================================================================
function DumpInteger takes string label, integer i returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), Int2Str(i))
  set udg_unique_counter = udg_unique_counter + 2
endfunction

//============================================================================
function DumpReal takes string label, real r returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), Int2Str(R2I(r * 1000)))
  set udg_unique_counter = udg_unique_counter + 2
endfunction

//============================================================================
function DumpBoolean takes string label, boolean b returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), B2S(b))
  set udg_unique_counter = udg_unique_counter + 2
endfunction

//============================================================================
function DumpHandle takes string label, handle h returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), Int2Str(GetHandleId(h)))
  set udg_unique_counter = udg_unique_counter + 2
endfunction

//============================================================================
function EndDump takes string label returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), "EndDump "+label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), Int2Str(R2I(TimerGetElapsed(udg_debug_timer)*1000)))
  set udg_unique_counter = udg_unique_counter + 2
endfunction

//============================================================================
function DumpMessage takes string label, string s returns nothing
  call DumpString("Message", s)
  call EndDump(label)
endfunction

//============================================================================
// (AMAI) Language Translation/ Chat functions
//============================================================================
function AddTrans takes string lang, string key, string value returns nothing

  set translation[translation_length] = value
  call SaveInteger(translation_map, StringHash(lang), StringHash(key), translation_length)
  set translation_length = translation_length + 1

endfunction

//============================================================================
function ApplyTrans takes string s returns string
  //local integer transnum = LoadInteger(translation_map, StringHash(language), StringHash(s))
  //if transnum != null then
  local string trans = null
  if HaveSavedInteger(translation_map, StringHash(language), StringHash(s)) then
    //return translation[transnum]
    set trans = translation[LoadInteger(translation_map, StringHash(language), StringHash(s))]
  endif
  if (trans == null or trans == "") and HaveSavedInteger(translation_map, StringHash("English"), StringHash(s)) then // Backup translate to english
    set trans = translation[LoadInteger(translation_map, StringHash("English"), StringHash(s))]
  endif
  if (trans == null or trans == "") then
    //call DisplayTimedTextToPlayer(Player(0),0,0,15,message_add+s+":handle not saved")
    set trans = null
    return s
  else
    return trans
  endif
endfunction

//============================================================================
function InitTrans takes nothing returns nothing
  local string lang = ""
#INCLUDETABLE <Languages.txt> #EFR
  set lang = "%1"
  #INCLUDETABLE <Languages\%1\Translations.txt> #ENC:%4 #EFR
  call AddTrans(lang, "%1", "%2")
  #ENDINCLUDE
  #INCLUDETABLE <Languages\%1\Strengths.txt> #ENC:%4 #EFR
  call AddTrans(lang, "%1", "%2")
  #ENDINCLUDE
#ENDINCLUDE
  set lang = null
endfunction

// call SetSoundDuration( chatSound, 208 )

//============================================================================
function DisplayToAll takes string s returns nothing
  local integer i = 0
  loop
    call DisplayTimedTextToPlayer(Player(i),0,0,15,message_add+s)
    set i = i + 1
    exitwhen i == PLAYERAGGRESSIVE
  endloop
  call StartSound(chatSound)
endfunction

//============================================================================
function DisplayToAllImportant takes string s returns nothing
  local integer i = 0
  loop
    call DisplayTimedTextToPlayer(Player(i),0,0,15,message_add+s)
    set i = i + 1
    exitwhen i == PLAYERAGGRESSIVE
  endloop
  call StartSound(importantSound)
endfunction

//============================================================================
function DisplayToAllies takes string s returns nothing
  if IsPlayerAlly(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(chatSound)
  endif
endfunction

//============================================================================
function DisplayToAlliesImportant takes string s returns nothing
  if IsPlayerAlly(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(importantSound)
  endif
endfunction

//============================================================================
function DisplayToEnemy takes string s returns nothing
  if IsPlayerEnemy(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(chatSound)
  endif
endfunction

//============================================================================
function DisplayToEnemyImportant takes string s returns nothing
  if IsPlayerEnemy(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(importantSound)
  endif
endfunction

//============================================================================
function DisplayToObservers takes string s returns nothing
  if IsPlayerObserver(GetLocalPlayer()) and not IsPlayerAlly(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(chatSound)
  endif
endfunction

//============================================================================
function DisplayToObserversImportant takes string s returns nothing
  if IsPlayerObserver(GetLocalPlayer()) and not IsPlayerAlly(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(importantSound)
  endif
endfunction

//============================================================================
// Just a general debugging system.
//============================================================================

//function SAddI takes string message, integer val returns string
// Unfortunatly disabled as translation system causes substring to return incorrect values
//	local integer start = 0
//	local integer end = 2
//	local string temp = ""
//	local string newstring = ""
//	local integer length = StringLength(message)
	
//	loop
//		exitwhen end > length + 1
//		set temp = SubString(message, start, end)
//		call DisplayToAll(temp)
//		if temp == "%d" then
//			if start - 1 < 0 then
//				set start = 0
//			else
//				set start = start - 1
//			endif
//			if end + 1 > length then
//				set end = length
//			else
//				set end = end + 1
//			endif
//			set newstring = SubString(message,1,start) + I2S(val) + SubString(message,end, length) 
//			call DisplayToAll("returned full string")
//			return newstring
//		endif
//		set start = start + 1
//		set end = end + 1
//	endloop
//	return message  // So still works if you use wrong Trace function
//endfunction

//============================================================================
// Only displays messages originating from a particular ai player 
//============================================================================
function DisplayToAllFromPlayer takes string s, integer playernum, boolean important returns nothing
	local integer i = 0
	if Player(GetAiPlayer()) == Player(playernum) then
		loop
			call DisplayTimedTextToPlayer(Player(i),0,0,15,message_add+s)
			set i = i + 1
			exitwhen i == PLAYERAGGRESSIVE
		endloop
		if important then
			call StartSound(importantSound)
		else
			call StartSound(chatSound)
		endif
	endif
endfunction

function UpdateDebugPlayer takes nothing returns nothing
		if IsPlayerObserver(Player(debug_player)) == true then
			set debug_player = debug_player + 1
		endif
		if GetPlayerUnitCount(Player(debug_player), true) == 0 then
			set debug_player = debug_player + 1
		endif
		//if GetChar(GetPlayerName(Player(debug_player)), 1) != "A" then
		//	set debug_player = debug_player + 1 // If not containing AMAI in player name increment until it is
		//endif
		if GetPlayerSlotState(Player(debug_player)) != PLAYER_SLOT_STATE_PLAYING then
			set debug_player = debug_player + 1
		endif
		if debug_player > PLAYERAGGRESSIVE then
			set debug_player = PLAYERAGGRESSIVE // Do not go above PLAYERAGGRESSIVE
		endif
endfunction

function TracePlayer takes string s, integer playernum returns nothing
	if debugging then
		call DisplayToAllFromPlayer(s, playernum, false)
	endif
endfunction

//============================================================================
function Trace takes string s returns nothing
	if debugging then
		call UpdateDebugPlayer()
		call DisplayToAllFromPlayer(s, debug_player, false)
	endif
	// Blizzard ai part
	if trace_on then
		call DisplayText(GetAiPlayer(),s)
	endif
endfunction

//============================================================================
function TraceI takes string s, integer val returns nothing	
	if debugging then
		call UpdateDebugPlayer()
		call DisplayToAllFromPlayer(s+":"+Int2Str(val), debug_player, false)
	endif
	if trace_on then
		call DisplayTextI(GetAiPlayer(),s,val)
	endif
endfunction

//============================================================================
function TraceII takes string message, integer v1, integer v2 returns nothing
	if debugging then
		call UpdateDebugPlayer()
		call DisplayToAllFromPlayer(message+":"+Int2Str(v1)+":"+Int2Str(v2), debug_player, false)
	endif
	if trace_on then
		call DisplayTextII(GetAiPlayer(),message,v1,v2)
	endif
endfunction

//============================================================================
function TraceIII takes string message, integer v1, integer v2, integer v3 returns nothing
	if debugging then
		call UpdateDebugPlayer()
		call DisplayToAllFromPlayer(message+":"+Int2Str(v1)+":"+Int2Str(v2)+":"+Int2Str(v3), debug_player, false)
	endif
	if trace_on then
		call DisplayTextIII(GetAiPlayer(),message,v1,v2,v3)
	endif
endfunction

//============================================================================
//  A specialised debugging sytem. Modify the player number for work on 
//  replays where the job system crashes to display when jobs run
//============================================================================
function DisplayToAllJobDebug takes string s returns nothing
  if job_debug then
    call DisplayToAllFromPlayer(s, debug_player, false)
  endif
endfunction

//============================================================================
function DisplayToAlliesChat takes string s returns nothing
  if chatting then
    if IsPlayerAlly(ai_player,GetLocalPlayer()) then
      call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
      call StartSound(chatSound)
    endif
  endif
endfunction

//============================================================================
function DisplayToEnemyChat takes string s returns nothing
  if chatting then
    if IsPlayerEnemy(ai_player,GetLocalPlayer()) then
      call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
      call StartSound(chatSound)
    endif
  endif
endfunction

//============================================================================
function DisplayToAlliesDebug takes string s returns nothing
  if debugging then
    if IsPlayerAlly(ai_player,GetLocalPlayer()) then
      call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
      call StartSound(chatSound)
    endif
  endif
endfunction

//============================================================================
function DisplayToPlayer takes string s, player p, boolean important returns nothing
  if p == GetLocalPlayer() then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    if important then
      call StartSound(importantSound)
    else
      call StartSound(chatSound)
    endif
  endif
endfunction

//============================================================================
// (AMAI) Utility Functions
//============================================================================
// AI function
function PlayerEx takes integer slot returns player
  return Player(slot-1)
endfunction

function Abs takes integer a returns integer
  if a >= 0 then
    return a
  else
    return -a
  endif
endfunction

function RAbs takes real a returns real
  if a >= 0 then
    return a
  else
    return -a
  endif
endfunction

// Ai Function
function Min takes integer A, integer B returns integer
  if A < B then
    return A
  else
    return B
  endif
endfunction

function RMin takes real A, real B returns real
  if A < B then
    return A
  else
    return B
  endif
endfunction

// Ai Function
function Max takes integer A, integer B returns integer
  if A > B then
    return A
  else
    return B
  endif
endfunction

function RMax takes real A, real B returns real
  if A > B then
    return A
  else
    return B
  endif
endfunction

//===========================================================================
// Calculate the modulus/remainder of (dividend) divided by (divisor).
// Examples:  18 mod 5 = 3.  15 mod 5 = 0.  -8 mod 5 = 2.
//
function ModuloInteger takes integer dividend, integer divisor returns integer
  local integer modulus = dividend - (dividend / divisor) * divisor

  // If the dividend was negative, the above modulus calculation will
  // be negative, but within (-divisor..0).  We can add (divisor) to
  // shift this result into the desired range of (0..divisor).
  if (modulus < 0) then
    set modulus = modulus + divisor
  endif

  return modulus
endfunction

//===========================================================================
// Calculate the modulus/remainder of (dividend) divided by (divisor).
// Examples:  13.000 mod 2.500 = 0.500.  -6.000 mod 2.500 = 1.500.
//
function ModuloReal takes real dividend, real divisor returns real
  local real modulus = dividend - I2R(R2I(dividend / divisor)) * divisor

  // If the dividend was negative, the above modulus calculation will
  // be negative, but within (-divisor..0).  We can add (divisor) to
  // shift this result into the desired range of (0..divisor).
  if (modulus < 0) then
    set modulus = modulus + divisor
  endif

  return modulus
endfunction

//============================================================================
function GetRandomDiff takes integer maxdiff returns integer
  if GetRandomInt(0,1) == 1 then
    return GetRandomInt(0,maxdiff)
  else
    return -GetRandomInt(0,maxdiff)
  endif
endfunction

//============================================================================
function LinearInterpolation takes real x1, real x2, real y1, real y2, real p returns real
local real i = x2 - x1
  if p <= x1 then
    return y1
  elseif p >= x2 then
    return y2
  else
    if i == 0 then
      set i = 1
    endif
    return y1 + ((p - x1)/(i)) * (y2 - y1)
  endif
endfunction

//============================================================================
// These utility functions return the rescource cost correctly for upgraded units/buildings
function GetUnitGoldCost2 takes integer id returns integer
  if needed3[id] == UPGRADED then
    return GetUnitGoldCost(old_id[id]) - GetUnitGoldCost(old_id[needed1[id]])
  else
    return GetUnitGoldCost(old_id[id])
  endif
endfunction

function GetUnitWoodCost2 takes integer id returns integer
  if needed3[id] == UPGRADED then
    return GetUnitWoodCost(old_id[id]) - GetUnitWoodCost(old_id[needed1[id]])
  else
    return GetUnitWoodCost(old_id[id])
  endif
endfunction

//============================================================================
// Get a peon. Should be used if you really need a peon and GetExpansionPeon failed
  function GetExpansionPeon2 takes unit u returns unit
  local group g = CreateGroup()

  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == old_id[racial_peon] and UnitAlive(u) and (GetUnitCurrentOrder(u) == OrderId("harvest") or GetUnitCurrentOrder(u) == 0) and not IsUnitHidden(u) and not IsUnitLoaded(u) then  // and not IsUnitInGroup(u, unit_buying_tavern) and not IsUnitInGroup(u, unit_buying_merc) and not IsUnitInGroup(u, unit_buying_item) and not IsUnitInGroup(u, unit_zepplin_move))  // if too much IsUnitInGroup , the game will laggy and collapse
      call DestroyGroup(g)
      set g = null
      return u
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  return u
endfunction

//============================================================================
// (AMAI)	CharTable Functions
//============================================================================
function LookupCT takes string s returns string
  //local integer i = StringHash(s)
  local integer i = 0
  //local string storedstring = ""
  //if (i >= JASS_MAX_ARRAY_SIZE) then
  // 	set i = i - (i/(JASS_MAX_ARRAY_SIZE-1) - 1) * JASS_MAX_ARRAY_SIZE
  //set i = i - (i/JASS_MAX_ARRAY_SIZE)*JASS_MAX_ARRAY_SIZE
  //endif

  loop
    exitwhen i >= char_table_length
    if (s == char_bug_table[i]) then
      //call DisplayTimedTextToPlayer(Player(0),0,0,15,message_add+"1:Char Match:" + s + " With stored char:" + char_table[i])
      return char_table[i]
    endif
    set i = i + 1
  endloop

  return ""
  // set storedstring = LoadStr(language_table, CHAR_TABLE, StringHash(s))
  // if (storedstring == null) then
  // return ""
  // else
    // //call DisplayTimedTextToPlayer(Player(0),0,0,15,message_add+"2:Char match:" + s + " With stored char:" + storedstring)
  // return storedstring
  // endif
endfunction

//============================================================================
function AddToCT takes string s returns nothing
  local string firstchar = SubString(s,0,1)		// Substring dosn't work in AMAI and returns strange values (but is the same value so we do a comparison of the substring value then return the actual character
  local integer i = 0
  if (firstchar == null) then
    set firstchar = ""
  endif
  set i = StringHash(firstchar)
  //if (i >= JASS_MAX_ARRAY_SIZE) then
  //set i = i - (i/(JASS_MAX_ARRAY_SIZE-1) - 1) * JASS_MAX_ARRAY_SIZE
  //set i = i - (i/JASS_MAX_ARRAY_SIZE)*JASS_MAX_ARRAY_SIZE
  //endif

  set char_bug_table[char_table_length] = firstchar
  set char_table[char_table_length] = s
  set char_table_length = char_table_length + 1
  call SaveStr(language_table, CHAR_TABLE, i, s)
  //call DisplayTimedTextToPlayer(Player(0),0,0,15,message_add+s+" Hash:"+Int2Str(i)+": Returned:"+LoadStr(language_table, CHAR_TABLE, i))
  set firstchar = null
endfunction

//============================================================================
function GetChar takes string s, integer num returns string
  local string linechar = SubString(s, num, num + 1)
  return LookupCT(linechar)
endfunction

//============================================================================
function InitCT takes nothing returns nothing
  set chat_vars[0] = ""
#INCLUDETABLE <Languages\StandardCharTable.txt> #NOUTF8
  call AddToCT("%1")
#ENDINCLUDE
  call AddToCT("#")
  call AddToCT("\"")
  call AddToCT("\\")
  //call AddToCT("{")
  //call AddToCT("}")
endfunction

//============================================================================
function SetChatVar takes string key, string value returns nothing
  local integer i = 0
  //if i == 0 then
  if (HaveSavedInteger(language_table, CHAT_VARS_TABLE, StringHash(key)) == false) then
    set i = chat_vars_length
    set chat_vars_length = chat_vars_length + 1
    //call StoreInteger(chat_vars_map, ai_id, key, i)
    call SaveInteger(language_table, CHAT_VARS_TABLE, StringHash(key), i)
  else
    set i = LoadInteger(language_table, CHAT_VARS_TABLE, StringHash(key))
  endif
  set chat_vars[i] = value
endfunction

//============================================================================
function GetChatVar takes string key returns string
  //return chat_vars[GetStoredInteger(chat_vars_map, ai_id, key)]
  return chat_vars[LoadInteger(language_table, CHAT_VARS_TABLE, StringHash(key))]
endfunction

//============================================================================
function SetChatVarB takes string key, boolean value returns nothing
  //call StoreBoolean(chat_vars_map, ai_id, key, value)
  call SaveBoolean(language_table, CHAT_VARS_TABLE, StringHash(key+"B"), value)
endfunction

//============================================================================
function GetChatVarB takes string key returns boolean
  //return GetStoredBoolean(chat_vars_map, ai_id, key)
  return LoadBoolean(language_table, CHAT_VARS_TABLE, StringHash(key+"B"))
endfunction

//============================================================================
function SetChatVarR takes string key, real value returns nothing
  call SaveReal(language_table, CHAT_VARS_TABLE, StringHash(key+"R"), value)
endfunction

//============================================================================
function GetChatVarR takes string key returns real
  //return GetStoredReal(chat_vars_map, ai_id, key)
  return LoadReal(language_table, CHAT_VARS_TABLE, StringHash(key+"R"))
endfunction

//============================================================================
// Converts translational parts of text to actual text
//============================================================================
function ApplyChatVars takes string s_in returns string
  local string s = ""
  local integer i = 0
  local integer l = StringLength(s_in)
  local boolean is_cv = false
  local boolean is_wf = false
  local boolean is_cond = false
  local string key = ""
  local string wf = ""
  local string c = ""
  loop
    exitwhen i >= l
    set c = GetChar(s_in, i)
    if c == "}" then
      set is_cond = false
    elseif is_cond then
    elseif c == "{" then
      set is_cond = true
    elseif c == "[" then
      set is_cv = true
      set key = ""
      set wf = ""
    elseif c == "]" then
      set is_cv = false
      set is_wf = false
      set s = s + ApplyTrans(GetChatVar(key)+wf)
    elseif is_cv then
      if c == ":" then
        set is_cv = false
        set is_wf = true
        set wf = ":"
      else
        set key = key + c
      endif
    elseif is_wf then
      set wf = wf + c
    else
      set s = s + c
    endif
    set i = i + 1
  endloop
  set key = null
  set wf = null
  set c = null
  return s
endfunction

//============================================================================
function CompareReal takes real x, real y, integer compare returns boolean
  if compare == COMPARE_GREATER then
    return x > y
  elseif compare == COMPARE_GREATER_EQ then
    return x >= y
  elseif compare == COMPARE_LESS then
    return x < y
  else
    return x <= y
  endif
endfunction

//============================================================================
// Determines if the chat statement conditions are true
//============================================================================
// function CheckChatCondition takes string s returns boolean
  // local integer i = 1
  // local boolean is_compare = false
  // local integer compare = 0
  // local string key = ""
  // local string value = ""
  // local string c = ""
  // local boolean part_cond = true
  // local boolean not_cond = false
  // local boolean return_bool = false
  // local boolean exitloop = false

  // set chat_eq = COMPARE_TRUE
  // set c = GetChar(s, 0)
  // if c != "{" then
    // set return_bool = true
    // // call DisplayTimedTextToPlayer(Player(0),0,0,15,message_add+B2S(return_bool)+":"+c)
    // //return true
  // else
  // loop
    // exitwhen (exitloop == true)
    // set c = GetChar(s, i)
    // if c == "}" then
      // if is_compare then
        // if key == "PlayerRace" then
          // set chat_race = value
          // set chat_eq = compare
          // set return_bool = true
          // set exitloop = true
          // //return true
        // elseif compare == COMPARE_EQ then
          // set return_bool = (GetChatVar(key) == value)
          // set exitloop = true
          // //return GetChatVar(key) == value
        // elseif compare == COMPARE_UNEQ then
          // set return_bool = (GetChatVar(key) != value)
          // set exitloop = true
          // //return GetChatVar(key) != value
        // else
          // set return_bool = CompareReal(GetChatVarR(key), S2R(value), compare)
          // set exitloop = true
          // //return CompareReal(GetChatVarR(key), S2R(value), compare)
        // endif
      // else
          // set return_bool = (not_cond != GetChatVarB(key))
          // set exitloop = true
        // //return not_cond != GetChatVarB(key)
      // endif
    // elseif c == "," then
      // if is_compare then
        // if key == "PlayerRace" then
          // set chat_race = value
          // set chat_eq = compare
        // elseif compare == COMPARE_EQ then
          // set part_cond = (GetChatVar(key) == value)
        // elseif compare == COMPARE_UNEQ then
          // set part_cond = (GetChatVar(key) != value)
        // else
          // set part_cond = CompareReal(GetChatVarR(key), S2R(value), compare)
        // endif
      // else
        // set part_cond = (not_cond != GetChatVarB(key))
      // endif
      // if not part_cond then
          // set return_bool = false
          // set exitloop = true
          // //return false
      // else
          // set is_compare = false
          // set not_cond = false
          // set key = ""
          // set value = ""
          // set compare = 0
      // endif
    // elseif c == "=" then
      // if is_compare then
        // if compare == COMPARE_GREATER then
          // set compare = COMPARE_GREATER_EQ
        // elseif compare == COMPARE_LESS then
          // set compare = COMPARE_LESS_EQ
        // endif
      // else
        // set is_compare = true
        // if not_cond then
          // set compare = COMPARE_UNEQ
        // else
          // set compare = COMPARE_EQ
        // endif
      // endif
    // elseif c == "<" then
      // set is_compare = true
      // set compare = COMPARE_LESS
    // elseif c == ">" then
      // set is_compare = true
      // set compare = COMPARE_GREATER
    // elseif c == "!" then
      // set not_cond = true
    // elseif is_compare then
      // set value = value + c
    // else
      // set key = key + c
    // endif
    // set i = i + 1
  // endloop
  // endif
  // //call DisplayTimedTextToPlayer(Player(0),0,0,15,message_add+B2S(return_bool)+":"+key)
  // return return_bool
// endfunction

function CheckChatCondition takes string s returns boolean
  local integer i = 1
  local boolean is_compare = false
  local integer compare = 0
  local string key = ""
  local string value = ""
  local string c = ""
  local boolean part_cond = true
  local boolean not_cond = false
  local boolean b = false
  set chat_eq = COMPARE_TRUE
  set c = GetChar(s, 0)
  if c != "{" then
    set key = null
    set value = null
    set c = null
    return true
  endif
  loop
    set c = GetChar(s, i)
    if c == "}" then
      if is_compare then
        if key == "PlayerRace" then
          set chat_race = value
          set chat_eq = compare
          set key = null
          set value = null
          set c = null
          return true
        elseif compare == COMPARE_EQ then
          set b = GetChatVar(key) == value
          set key = null
          set value = null
          set c = null
          return b
        elseif compare == COMPARE_UNEQ then
          set b = GetChatVar(key) != value
          set key = null
          set value = null
          set c = null
          return b
        else
          set b = CompareReal(GetChatVarR(key), S2R(value), compare)
          set key = null
          set value = null
          set c = null
          return b
        endif
      else
        set b = not_cond != GetChatVarB(key)
        set key = null
        set value = null
        set c = null
        return b
      endif
    elseif c == "," then
      if is_compare then
        if key == "PlayerRace" then
          set chat_race = value
          set chat_eq = compare
        elseif compare == COMPARE_EQ then
          set part_cond = GetChatVar(key) == value
        elseif compare == COMPARE_UNEQ then
          set part_cond = GetChatVar(key) != value
        else
          set part_cond = CompareReal(GetChatVarR(key), S2R(value), compare)
        endif
      else
        set part_cond = not_cond != GetChatVarB(key)
      endif
      if not part_cond then
        set key = null
        set value = null
        set c = null
        return false
      endif
      set is_compare = false
      set not_cond = false
      set key = ""
      set value = ""
      set compare = 0
    elseif c == "=" then
      if is_compare then
        if compare == COMPARE_GREATER then
          set compare = COMPARE_GREATER_EQ
        elseif compare == COMPARE_LESS then
          set compare = COMPARE_LESS_EQ
        endif
      else
        set is_compare = true
        if not_cond then
          set compare = COMPARE_UNEQ
        else
          set compare = COMPARE_EQ
        endif
      endif
    elseif c == "<" then
      set is_compare = true
      set compare = COMPARE_LESS
    elseif c == ">" then
      set is_compare = true
      set compare = COMPARE_GREATER
    elseif c == "!" then
      set not_cond = true
    elseif is_compare then
      set value = value + c
    else
      set key = key + c
    endif
    set i = i + 1
  endloop
  set key = null
  set value = null
  set c = null
  return false
endfunction

//============================================================================
function ApplyChatConditions takes nothing returns nothing
  local integer i = 0
  local integer free = 0
  loop
    exitwhen i >= chat_list_length
    call SetChatVarR("Random",GetRandomReal(0,100))
    if CheckChatCondition(chat_list[i]) then
      set chat_list[free] = chat_list[i]
      set chat_list_race[free] = chat_race
      set chat_list_eq[free] = chat_eq
      set free = free + 1
    endif
    set i = i + 1
  endloop
  set chat_list_length = free
endfunction

//_________________________________________________________________________________________________________________________________________________
//_________________________________________________________________________________________________________________________________________________
   // Global Functions that are used in both AMAI and standard ai

//============================================================================
//  Finds the AMAI id code for when we are using normal ai
function GetAMAIId takes integer id returns integer
	local integer i = 0
	loop
		exitwhen i > OBJECT_NUM
		if old_id[i] == id then
			call Trace("Returned AMAI id - " + Int2Str(i) + ":" + UnitId2String(old_id[i]) + " for " + UnitId2String(id))
			return i
		endif
		set i = i + 1
	endloop
	call Trace("Couldn't get AMAI id - " + UnitId2String(id))
	return 0
endfunction

//============================================================================   
function GetGold takes nothing returns integer
  return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_GOLD)
endfunction

//============================================================================
function GetWood takes nothing returns integer
  return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_LUMBER)
endfunction

//============================================================================
function InitDefenseGroup takes nothing returns nothing
  set defense_length = 0
endfunction

//============================================================================
function InitAssaultGroup takes nothing returns nothing
  if IsAMAI then
    set attack_length = 0
  else
    set harass_length = 0
  endif
endfunction

//============================================================================
function GetUnitCountEx takes integer unitid, boolean only_done, integer townid returns integer

  if unitid == 0 then // can happen but lets speed up calculation a little instead of running the functions
    return 0
  endif

  if IsAMAI then
    if townid == -1 then
      if only_done then
        return GetUnitCountDone(old_id[unitid])
      else
        return GetUnitCount(old_id[unitid])
      endif
    else
      return GetTownUnitCount(old_id[unitid],townid,only_done)
    endif
  else
    if townid == -1 then
      if only_done then
        return GetUnitCountDone(unitid)
      else
        return GetUnitCount(unitid)
      endif
    else
      return GetTownUnitCount(unitid,townid,only_done)
    endif
  endif
endfunction

//============================================================================
function TownCountEx takes integer unitid, boolean only_done, integer townid returns integer
  local integer have_qty = 0
  local integer newid = 0

  if IsAMAI then
    set have_qty = GetUnitCountEx(unitid,only_done,townid) + GetUnitCountEx(tc_add1[unitid],false,townid) + GetUnitCountEx(tc_add2[unitid],false,townid)
  else
    //set newid = GetAMAIId(unitid)
    //set have_qty = GetUnitCountEx(unitid,only_done,townid) + GetUnitCountEx(tc_add1[newid],false,townid) + GetUnitCountEx(tc_add2[newid],false,townid)
    set have_qty = GetUnitCountEx(unitid,only_done,townid)
#INCLUDETABLE <$VER$\StandardUnits.txt> #EFR #COND "%10" ne "0"  or "%9" ne "0"
    if unitid == %1 then
      set have_qty = have_qty + GetUnitCountEx(%9,false,townid) + GetUnitCountEx(%10, false,townid)
    endif
#ENDINCLUDE
  endif

#INCLUDETABLE <$VER$\UnitEquivalence.txt> #EFR #COND "%2" eq "TC_ADD"
  if unitid == %1 then
    set have_qty = have_qty + GetUnitCountEx(%3, false, townid)
  endif
#ENDINCLUDE
  return have_qty

endfunction

//============================================================================
function TownCountDone takes integer base returns integer
  return TownCountEx(base,true,-1)
endfunction

//============================================================================
function TownCount takes integer base returns integer
  return TownCountEx(base,false,-1)
endfunction

//============================================================================
function TownCountTown takes integer base, integer townid returns integer
  return TownCountEx(base,false,townid)
endfunction

//============================================================================
function HallsCompleted takes integer unitid returns boolean
  if IsAMAI then
    return GetUnitCount(old_id[unitid]) == GetUnitCountDone(old_id[unitid])
  endif
  return GetUnitCount(unitid) == GetUnitCountDone(unitid)
endfunction

//============================================================================
function StaggerSleep takes real base, real spread returns nothing
  call Sleep(base + spread * I2R(GetAiPlayer()) / I2R(GetPlayers()))
endfunction

//============================================================================
function FoodUsed takes nothing returns integer
  return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_FOOD_USED)
endfunction

//============================================================================
function FoodCap takes nothing returns integer
  return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_FOOD_CAP)
endfunction

//============================================================================
function FoodSpace takes nothing returns integer
  return FoodCap() - FoodUsed()
endfunction

//============================================================================
function FoodAvail takes integer base returns integer
  return GetFoodMade(old_id[racial_farm]) * TownCount(racial_farm) + GetFoodMade(old_id[base]) * TownCount(base)
endfunction

//_________________________________________________________________________________________________________________________________________________
//_________________________________________________________________________________________________________________________________________________

//============================================================================
// AMAI Common.ai Section reworked by Strategy Master
//      - Based off code written by Aiandy and Zalamander
// 
//============================================================================

function InitMapSizeVars takes nothing returns nothing
  local real x = path_right - path_left
  local real y = path_top - path_bottom
  local real a = (x/1000)*(y/1000)
  call SetChatVarR("MapSizeX", x)
  call SetChatVarR("MapSizeY", y)
  if play24 == false then
    if a < 120 then
      call SetChatVar("MapSize", "tiny")
      set mapSize = 1
    elseif a < 240 then
      call SetChatVar("MapSize", "small")
      set mapSize = 2
    elseif a < 380 then
      call SetChatVar("MapSize", "medium")
      set mapSize = 3
    elseif a < 540 then
      call SetChatVar("MapSize", "large")
      set mapSize = 4
    else
      call SetChatVar("MapSize", "huge")
      set mapSize = 5
    endif
  else
    if a < 90 then
      call SetChatVar("MapSize", "extrasmall")
      set mapSize = 0
    elseif a < 120 then
      call SetChatVar("MapSize", "tiny")
      set mapSize = 1
    elseif a < 240 then
      call SetChatVar("MapSize", "small")
      set mapSize = 2
    elseif a < 380 then
      call SetChatVar("MapSize", "medium")
      set mapSize = 3
    elseif a < 540 then
      call SetChatVar("MapSize", "large")
      set mapSize = 4
    elseif a < 960 then
      call SetChatVar("MapSize", "extralarge")
      set mapSize = 5
    elseif a < 2048 then
      call SetChatVar("MapSize", "huge")
      set mapSize = 6
    else
      call SetChatVar("MapSize", "legendary")
      set mapSize = 7
    endif
  endif
  set raceshop_distance_limit = raceshop_distance_limit * mapSize
  set merchant_distance_limit = merchant_distance_limit * mapSize
endfunction

//============================================================================
function InitDifficultyVars takes nothing returns nothing
  if difficulty == HARD then
    call SetChatVar("Difficulty", "Insane")
  elseif difficulty == NORMAL then
    call SetChatVar("Difficulty", "Normal")
  else
    call SetChatVar("Difficulty", "Easy")
  endif
  call SetChatVarR("Handicap", GetPlayerHandicap(ai_player))
endfunction

//============================================================================
function InitChatVars takes nothing returns nothing
  call SetChatVar("Race", race_name[own_race])
  call SetChatVar("Color", ColorText(ai_player))
  call SetChatVarR("PlayerNum", c_ally_total + c_enemy_total + 1)
  call SetChatVar("PlayerNum", Int2Str(c_ally_total + c_enemy_total + 1))
  call SetChatVarB("1vs1", game_is_1on1)
  call SetChatVarB("FFA", game_is_ffa)
  call SetChatVarB("RaceChoiceRandom", player_race_pref[GetAiPlayer()] == R_RANDOM)
  call SetChatVar("MaxPlayerNum", Int2Str(GetPlayers()))
  call SetChatVarR("MaxPlayerNum", GetPlayers())
  call InitMapSizeVars()
  call InitDifficultyVars()
endfunction

//============================================================================
function SetChatVarsPlayer takes player p returns nothing
  call SetChatVar("PlayerRace", race_name[player_race[GetPlayerId(p)]])
  call SetChatVar("PlayerColor", ColorText(p))
endfunction


//==============================================================
// (AMAI) Vector utility functions
//==============================================================

//===========================================================================
// Returns a location which is (distance) away from (src) in the direction of (targ).
//
function AIGetProjectedLoc takes location src, location targ, real distance, real deltaAngle returns location
  local real srcX = GetLocationX(src)
  local real srcY = GetLocationY(src)
  local real direction = Atan2(GetLocationY(targ) - srcY, GetLocationX(targ) - srcX) + deltaAngle
  return Location(srcX + distance * Cos(direction), srcY + distance * Sin(direction))
endfunction

function GetSumLoc takes location l1, location l2 returns location
  return Location(GetLocationX(l1) + GetLocationX(l2), GetLocationY(l1) + GetLocationY(l2))
endfunction
// Set freel1 and freel2 to true to remove that location
function GetSumLoc_dd takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) + GetLocationX(l2)
  local real locY = GetLocationY(l1) + GetLocationY(l2)
  call RemoveLocation(l1)
  call RemoveLocation(l2)
  return Location(locX, locY)
endfunction
function GetSumLoc_kd takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) + GetLocationX(l2)
  local real locY = GetLocationY(l1) + GetLocationY(l2)
  call RemoveLocation(l2)
  return Location(locX, locY)
endfunction
function GetSumLoc_dk takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) + GetLocationX(l2)
  local real locY = GetLocationY(l1) + GetLocationY(l2)
  call RemoveLocation(l1)
  return Location(locX, locY)
endfunction

//============================================================================
function GetSubtractionLoc takes location l1, location l2 returns location
  return Location(GetLocationX(l1) - GetLocationX(l2), GetLocationY(l1) - GetLocationY(l2))
endfunction

function GetSubtractionLoc_dd takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) - GetLocationX(l2)
  local real locY = GetLocationY(l1) - GetLocationY(l2)
  call RemoveLocation(l1)
  call RemoveLocation(l2)
  return Location(locX, locY)
endfunction
function GetSubtractionLoc_kd takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) - GetLocationX(l2)
  local real locY = GetLocationY(l1) - GetLocationY(l2)
  call RemoveLocation(l2)
  return Location(locX, locY)
endfunction
function GetSubtractionLoc_dk takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) - GetLocationX(l2)
  local real locY = GetLocationY(l1) - GetLocationY(l2)
  call RemoveLocation(l1)
  return Location(locX, locY)
endfunction

//============================================================================
function GetMultipleLoc takes location l, real m returns location
  return Location(GetLocationX(l) * m, GetLocationY(l) * m)
endfunction

function GetMultipleLoc_d takes location l, real m returns location
  local real locX = GetLocationX(l) * m
  local real locY = GetLocationY(l) * m
  call RemoveLocation(l)
  return Location(locX, locY)
endfunction

//============================================================================
function GetDivisionLoc takes location l, real d returns location
  return Location(GetLocationX(l) / d, GetLocationY(l) / d)
endfunction

function GetDivisionLoc_d takes location l, real d returns location
  local real locX = GetLocationX(l) / d
  local real locY = GetLocationY(l) / d
  call RemoveLocation(l)
  return Location(locX, locY)
endfunction

//============================================================================
function GetLengthOfLoc takes location l returns real
  local real x = GetLocationX(l)
  local real y = GetLocationY(l)
  return SquareRoot(x * x + y * y)
endfunction

function GetLengthOfLoc_d takes location l returns real
  local real x = GetLocationX(l)
  local real y = GetLocationY(l)
  call RemoveLocation(l)
  return SquareRoot(x * x + y * y)
endfunction

//============================================================================
function GetNormalisedLoc takes location l returns location
  return GetDivisionLoc(l, RMax(GetLengthOfLoc(l),1.00))
endfunction

function GetNormalisedLoc_d takes location l returns location
  return GetDivisionLoc_d(l, RMax(GetLengthOfLoc(l),1.00))
endfunction

//============================================================================
function GetProjectedLoc takes location l, location v, real r returns location
  local location loc = GetNormalisedLoc(v)
  local location loc2 = GetMultipleLoc_d(loc, r)
  local location returnloc = GetSumLoc_kd(l, loc2)
  local real x = GetLocationX(returnloc)
  local real y = GetLocationY(returnloc)
  set loc = null
  set loc2 = null
  call RemoveLocation(returnloc)
  set returnloc = null
  return Location(x, y)
endfunction

function GetProjectedLoc_dd takes location l, location v, real r returns location
  local location loc = GetNormalisedLoc_d(v)
  local location loc2 = GetMultipleLoc_d(loc, r)
  local location returnloc = GetSumLoc_dd(l, loc2)
  local real x = GetLocationX(returnloc)
  local real y = GetLocationY(returnloc)
  set loc = null
  set loc2 = null
  call RemoveLocation(returnloc)
  set returnloc = null
  return Location(x, y)
endfunction

//============================================================================
function l_smult_kk takes location l1, location l2 returns real
  return GetLocationX(l1) * GetLocationX(l2) + GetLocationY(l1) * GetLocationY(l2)
endfunction

//============================================================================
function GetAngleBetweenLocs takes location l1, location l2 returns real
  local real i = GetLengthOfLoc(l1) * GetLengthOfLoc(l2)
  if i == 0 then
    set i = 1
  endif
  return Acos(l_smult_kk(l1, l2) / i)
endfunction

//==============================================================
// (AMAI) Profile system
//==============================================================
function set_profiles takes nothing returns nothing

#INCLUDETABLE <$VER$\Profiles.txt> #EFR
  set profilename[#EVAL{%row-1}] = "%1"
  set p_race[#EVAL{%row-1}] = R_%2
  set p_aggression[#EVAL{%row-1}] = %3
  set p_uncertainty[#EVAL{%row-1}] = %4
  set p_minimum_attack_strength[#EVAL{%row-1}] = %5
  set p_farm_food[#EVAL{%row-1}] = %6
  set p_exp_first_time[#EVAL{%row-1}] = %7
  set p_exp_second_time[#EVAL{%row-1}] = %8
  set p_strat_persistence[#EVAL{%row-1}] = %9
  set p_gold_unit_percentage[#EVAL{%row-1}] = %10
  set p_taunt_rate[#EVAL{%row-1}] = %11
  set p_expansion_target_bonus[#EVAL{%row-1}] = %12
  set p_comp_chosen_target_bonus[#EVAL{%row-1}] = %13
  set p_comp_chosen_target_rate[#EVAL{%row-1}] = %14
  set p_surrender[#EVAL{%row-1}] = %15

  #FOR $X$ FROM $ONE$ TO $RACENUM$
  set fav_hero[#EVAL{(%row-1)*($RACENUM$+1)+$X$-1}] = %#OEVAL{15+$X$}
  #ENDFOR
  set fav_hero[#EVAL{(%row-1)*($RACENUM$+1)+$RACENUM$}] = %#OEVAL{16+$RACENUM$}

  #FOR $X$ FROM $ONE$ TO $RACENUM$
  set fav_unit[#EVAL{(%row-1)*$RACENUM$+$X$-1}] = %#OEVAL{16+$RACENUM$+$X$}
  #ENDFOR
  set p_rare[#EVAL{%row-1}] = %#OEVAL{17+$RACENUM$+$RACENUM$}

#AFTERINCLUDE
  set profile_length = #EVAL{%row-1}
#ENDINCLUDE

endfunction

//============================================================================
function IsProfileUsed takes integer profile returns boolean
  //return LoadBoolean(com, PROFILE_USED, profile)
  return GetStoredBoolean(amaiCache, Int2Str(PROFILE_USED), Int2Str(profile))
endfunction

//============================================================================
function SetProfileUsed takes integer profile returns nothing
  call SaveBoolean(com, PROFILE_USED, profile, true)
  call StoreBoolean(amaiCache, Int2Str(PROFILE_USED), Int2Str(profile), true) // Profile selection has to use gamecaches as hashtables are not saved between AI's
endfunction

function SetProfileNotUsed takes integer profile returns nothing
  call SaveBoolean(com, PROFILE_USED, profile, false)
  call StoreBoolean(amaiCache, Int2Str(PROFILE_USED), Int2Str(profile), false)
endfunction

function GetUnusedProfile takes player p returns integer
  local integer i = 0
  local integer array unusedProfiles
  local integer unusedCount = 0
  local integer array unusedRareProfiles
  local integer unusedRareCount = 0
  local integer profile = 0
  local integer p_sum = 0
  loop
    if p_rare[i] == 0 and (p_race[i] == R_RANDOM or p_race[i] == own_race) and (not IsProfileUsed(i)) then
       set unusedProfiles[unusedCount] = i
       set unusedCount = unusedCount + 1
    elseif p_rare[i] == 1 and (p_race[i] == R_RANDOM or p_race[i] == own_race) and (not IsProfileUsed(i)) then
       set unusedRareProfiles[unusedRareCount] = i
       set unusedRareCount = unusedRareCount + 1
    endif
    set i = i + 1
    exitwhen i >= profile_length
  endloop
  if (unusedRareCount > 0 and GetRandomInt(0,9) == 0) then
    set profile = GetRandomInt(0, unusedRareCount - 1)
    set profile = unusedRareProfiles[profile]
    call TracePlayer("Rare Profile select " + Int2Str(profile), GetPlayerId(ai_player))
  elseif unusedCount > 0 then // pick from unused profiles
    set profile = GetRandomInt(0, unusedCount - 1)
    set profile = unusedProfiles[profile]
    call TracePlayer("Profile select " + Int2Str(profile), GetPlayerId(ai_player))
  else // fail safe - pick anything as no valid profile available
    set profile = GetRandomInt(0, profile_length - 1)
    call TracePlayer("FAILSAFE Profile Selection " + Int2Str(profile), GetPlayerId(ai_player))
  endif
  call SetProfileUsed(profile)
  return profile
endfunction

//============================================================================
function InitProfile takes nothing returns nothing
  local integer i = 0
  local integer countplayers = 0

  call set_profiles()

  if debug_profile != -1 then
    set profile = debug_profile
  else

    call Sleep((GetPlayerId(ai_player)*0.02)) // Staggered entry into method for thread safety with profile cache

    loop
      exitwhen not IsProfileUsed(-1)
      call Sleep(0.01)
    endloop

    call SetProfileUsed(-1) // current AI locks to ensure only it is processing profiles
    call TracePlayer("Has locked profile selection ID:" + Int2Str(GetPlayerId(ai_player)), GetPlayerId(ai_player))

    set profile = GetUnusedProfile(ai_player)
    call SetProfileNotUsed(-1)
  endif

  if not fixedcomputername then
    set ai_name = profilename[profile]
  elseif add_tag then
    set ai_name = "AMAI"
  else
    set ai_name = "Computer"
  endif

  call SetChatVar("Name", ai_name)

  if add_tag == true and not fixedcomputername and not add_skill then
    set ai_name = "[AMAI]"+ai_name
  elseif add_tag == true and not fixedcomputername and add_skill then
    if difficulty == EASY then
      set ai_name = "[AMAI Easy]"+ai_name
    elseif difficulty == HARD then
      set ai_name = "[AMAI Insane]"+ai_name
    else
      set ai_name = "[AMAI Normal]"+ai_name
    endif
  elseif add_skill == true then
    if difficulty == EASY then
      set ai_name = ai_name+" (Easy)"
    elseif difficulty == HARD then
      set ai_name = ai_name+" (Insane)"
    else
      set ai_name = ai_name+" (Normal)"
    endif
  endif

  call SetPlayerName(ai_player, ai_name)
  set message_add = c2s(GetPlayerColor(ai_player))

  set attacking_aggression = attacking_aggression + p_aggression[profile]
  set uncertainty = p_uncertainty[profile]
  set area_uncertainty = uncertainty / 2
  set minimum_attack_strength = p_minimum_attack_strength[profile]
  set farm_food = p_farm_food[profile]
  set exp_first_time = p_exp_first_time[profile]
  set exp_second_time = p_exp_second_time[profile]
  set strat_persistence = p_strat_persistence[profile]
  set gold_unit_percentage = p_gold_unit_percentage[profile]
  set taunt_rate = p_taunt_rate[profile]
  set expansion_target_bonus = p_expansion_target_bonus[profile]
  set comp_chosen_target_bonus = p_comp_chosen_target_bonus[profile]
  set comp_chosen_target_rate = p_comp_chosen_target_rate[profile]

endfunction

//============================================================================
function AddFavoriteUnitRP takes nothing returns nothing
  local integer i = 0
  local string team = "Team" + Int2Str(GetPlayerTeam(ai_player)) + "StratUsed"
  if debug_strategy != -1 then
    set rp_strat[debug_strategy] = 100000000
  endif
  loop
    exitwhen i >= rp_strat_length
    if key_unit[i] == fav_unit[profile*RACE_NUMBER+own_race-1] then
      set rp_strat[i] = rp_strat[i] + fav_unit_add
    endif
    set i = i + 1
  endloop
  if ai_time < 10 then
    set i = 0
    loop
      exitwhen i >= 4
      set strategy_type_used[i] = LoadBoolean(com, TEAM_STATEGY_INUSE, i)
      set i = i + 1
    endloop
    set i = 0
    loop
      exitwhen i >= rp_strat_length
      if strategy_type_used[strategy_type[i]] then
        set rp_strat[i] = rp_strat[i] - strategy_type_used_penalty
      endif
      set i = i + 1
    endloop
  endif
  set team = null
endfunction

//============================================================================
function AddFavoriteHeroRP takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= hero_number
    if all_heroes[i] == fav_hero[profile*(RACE_NUMBER+1)+own_race-1] or all_heroes[i] == fav_hero[profile*(RACE_NUMBER+1)+R_NEUTRAL-1] then
      set hero_rp[i] = hero_rp[i] + fav_hero_add
    endif
    set i = i + 1
  endloop
endfunction

//============================================================================
// (AMAI)	InitArrays
//============================================================================
function InitAiUnits takes nothing returns nothing
	if IsAMAI then
	else
	// Set the unit ids to that of the original ai for compatability with non AMAI scripts

#INCLUDETABLE <$VER$\StandardUnits.txt> #EFR
		set %1 = o%1
#ENDINCLUDE

#INCLUDETABLE <$VER$\UnitEquivalence.txt> #EFR #COND "%2" eq "AI_COMP"
		set %3 = %1
#ENDINCLUDE
	endif
endfunction

function InitArrays takes nothing returns nothing

#INCLUDETABLE <$VER$\StandardUnits.txt> #EFR
  set old_id[%1] = o%1
  set buy_type[%1] = BT_%5
  set needed1[%1] = %6
  set needed2[%1] = %7
  set needed3[%1] = %8
  set tc_add1[%1] = %9
  set tc_add2[%1] = %10
  set available_time[%1] = %12
  set regenerate_time[%1] = %13
  set gold_price[%1] = %14
  set wood_price[%1] = %15
  set hero_rush_bonus[%1] = %16

#ENDINCLUDE
  //    call RLHashSet(o%1, %1)
endfunction

//============================================================================
// (AMAI) Chat arrays
//============================================================================
#INCLUDETABLE <Languages.txt> #EFR
function InitChatArrays%1 takes nothing returns nothing
#DEFINE $lang$ %1
#DEFINE $enc$ %4

  #INCLUDETABLE <ChatEvents.txt> #EFR
  #DEFINE $chatevent$ %1
    #INCLUDETABLE <Languages\$lang$\Chat$chatevent$.txt> #ENC:$enc$
  set chat_$chatevent$[#EVAL{%row-1}] = "%1"
    #AFTERINCLUDE
  set chat_$chatevent$_length = %row
    #ENDINCLUDE

  #ENDINCLUDE

  #INCLUDETABLE <Languages\%1\ChatMisc.txt> #ENC:%4
  set %1 = "%2"
  #ENDINCLUDE

  #INCLUDETABLE <Languages\English\ChatMisc.txt> #ENC:%4
  if %1 == null or %1 == "" then
    set %1 = "%2"
  endif
  #ENDINCLUDE

endfunction

#ENDINCLUDE

//============================================================================
#INCLUDETABLE <ChatEvents.txt> #EFR
function CopyChat%1 takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_%1_length
  loop
    exitwhen i >= chat_%1_length
    set chat_list[i] = chat_%1[i]
    set i = i + 1
  endloop
endfunction
#ENDINCLUDE

//============================================================================
function CommonStratsDefault takes nothing returns nothing
#INCLUDETABLE <$VER$\CommandBuilds.txt> #EFR
  set strategy_name[#EVAL{49+%row}] = "%1"
  set strategy_default_name[#EVAL{49+%row}] = "%6"
  set strategy_default_report[#EVAL{49+%row}] = "%7"
#ENDINCLUDE
endfunction

//============================================================================
function InitChatArrays takes nothing returns nothing
  if false then
#INCLUDETABLE <Languages.txt> #EFR
  elseif language == "%1" then
    call InitChatArrays%1()
#ENDINCLUDE
  endif
endfunction

//============================================================================
function InitChatEvents takes nothing returns nothing
#INCLUDETABLE <ChatEvents.txt> #EFR
  set chat_target_ally[%row] = %2
  set chat_target_enemy[%row] = %3
  set chat_target_obs[%row] = %4
  set chat_important[%row] = %5
#ENDINCLUDE
endfunction

//============================================================================
function AddTranslation takes string lang, string strat_name, string trans_name, string trans_report returns nothing
  set translation[translation_length] = trans_name
  call SaveInteger(translation_map, StringHash(lang), StringHash("Name"+strat_name), translation_length)
  set translation_length = translation_length + 1
  set translation[translation_length] = trans_report
  call SaveInteger(translation_map, StringHash(lang), StringHash("Report"+strat_name), translation_length)
  set translation_length = translation_length + 1
endfunction

//============================================================================
function InitTranslations takes nothing returns nothing
  local string lang = ""
#INCLUDETABLE <Languages.txt> #EFR
  set lang = "%1"
  #INCLUDETABLE <Languages\%1\Strategy.txt> #ENC:%4 #EFR
  call AddTranslation(lang, "%1", "%2", "%3")
  #ENDINCLUDE
#ENDINCLUDE
  set lang = null
endfunction

//============================================================================
function GetStrategyTxt takes integer stratnum, string txt returns string
  local string trans = null
  if HaveSavedInteger(translation_map, StringHash(language), StringHash(txt+strategy_name[stratnum])) then
    set trans = translation[LoadInteger(translation_map, StringHash(language), StringHash(txt+strategy_name[stratnum]))]
  endif
  if (trans == "" or trans == null) and HaveSavedInteger(translation_map, StringHash("English"), StringHash(txt+strategy_name[stratnum])) then
    set trans = translation[LoadInteger(translation_map, StringHash("English"), StringHash(txt+strategy_name[stratnum]))]
  endif
  if (trans == "" or trans == null) then
    set trans = null
    return strategy_default_name[stratnum]
  else
    return trans
  endif
endfunction

//============================================================================
function GetStrategyName takes integer stratnum returns string
  return GetStrategyTxt(stratnum, "Name")
endfunction

//============================================================================
function GetStrategyReport takes integer stratnum returns string
  return GetStrategyTxt(stratnum, "Report")
endfunction

//============================================================================
function GetCurrentStrategyName takes nothing returns string
  return GetStrategyName(strategy)
endfunction

//============================================================================
function GetCurrentStrategyReport takes nothing returns string
  return GetStrategyReport(strategy)
endfunction

function GetCurrentDynamicReport takes nothing returns string
  if strengthtext[chosen_counter] != null and no_counter == false then 
    return " " + chat_dynamic_counter + " " + ApplyTrans(strengthtext[chosen_counter])
  endif
  return ""
endfunction

//============================================================================
//  (AMAI)    Chat function
//============================================================================
function DisplayChat takes boolean ally, boolean enemy, boolean obs, boolean important returns nothing
  local integer i = 0
  local integer std_rand = 0
  local integer rand = 0
  local player p = null
  call ApplyChatConditions()
  if chat_list_length == 0 then
    return
  endif
  set std_rand = GetRandomInt(0, chat_list_length - 1)
  loop
    exitwhen i >= PLAYERAGGRESSIVE
    set p = Player(i)
    if (GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(p) != MAP_CONTROL_COMPUTER and ((ally and IsPlayerAlly(p, ai_player)) or (enemy and IsPlayerEnemy(p, ai_player)) and not IsPlayerObserver(p))) or (obs and IsPlayerObserver(p)) then
      set rand = std_rand
      loop
        exitwhen (chat_list_eq[rand] == COMPARE_TRUE) or (chat_list_eq[rand] == COMPARE_EQ and chat_list_race[rand] == race_name[player_race[i]]) or (chat_list_eq[rand] == COMPARE_UNEQ and chat_list_race[rand] != race_name[player_race[i]])
        set rand = GetRandomInt(0, chat_list_length - 1)
      endloop
      call SetChatVarsPlayer(p)
      call DisplayToPlayer(ApplyChatVars(chat_list[rand]), p, important)
    endif
    set i = i + 1
  endloop
  set p = null
endfunction

//============================================================================
function Chat takes integer c returns nothing
  local real chance = 0
  if campaign_ai then
    return
  endif

  if c == C_STRATEGY then
    call DisplayToAlliesImportant( GetCurrentStrategyReport() + GetCurrentDynamicReport() )
    call DisplayToObserversImportant( GetCurrentStrategyReport() + GetCurrentDynamicReport() )
  else
    if not (chatting or chat_important[c]) then
      return
    endif
    if false then
  #INCLUDETABLE <ChatEvents.txt> #EFR
    elseif c == C_%1 then
      set chance = %6
      call CopyChat%1()
  #ENDINCLUDE
    else
      return
    endif
    if chance >= GetRandomReal(0.00,100.00) then
      call DisplayChat(chat_target_ally[c], chat_target_enemy[c], chat_target_obs[c], chat_important[c])
    endif
  endif
endfunction

//============================================================================
function GetPlayerStartLocationLoc takes player whichPlayer returns location
  return GetStartLocationLoc(GetPlayerStartLocation(whichPlayer))
endfunction

//============================================================================
function DisplayStratNames takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= rp_strat_length
    call DisplayToAllies(Int2Str(i) + ". " + GetStrategyName(i))
    set i = i + 1
  endloop
endfunction

//===========================================================================
// (AMAI) Neutral Heroes skill array
//===========================================================================

function InitNeutralSkills takes nothing returns nothing
#INCLUDETABLE <$VER$\NeutralHeroSkills.txt> #EFR
  #FOR $X$ FROM $ONE$ TO $HEROLEVELNUM$
  set allskills[#EVAL{%row*$HEROLEVELNUM$ + $X$ - 10}] = %$X$
  #ENDFOR

#ENDINCLUDE
endfunction

//============================================================================
// (AMAI) Utility Functions
//============================================================================

function TownCountExForUpgrade takes integer unitid, integer unitid_upgr, boolean only_done, integer townid returns integer
  local integer count = 0
  if tc_add1[unitid] != unitid_upgr then
    set count = count + GetUnitCountEx(tc_add1[unitid],false,townid)
  endif
  if tc_add2[unitid] != unitid_upgr then
    set count = count + GetUnitCountEx(tc_add2[unitid],false,townid)
  endif
#INCLUDETABLE <$VER$\UnitEquivalence.txt> #EFR #COND "%2" eq "TC_ADD"
  if unitid == %1 and unitid_upgr != %1 then
    set count = count + GetUnitCountEx(%3, false, townid)
  endif
#ENDINCLUDE
  return count

endfunction

//===========================================================================
// (AMAI)  functions for coordination and choice of strategies
//===========================================================================
function DistanceBetweenPoints takes location locA, location locB returns real
  local real distance = GetLengthOfLoc_d(GetSubtractionLoc(locB, locA))
  return distance
endfunction
function DistanceBetweenPoints_kd takes location locA, location locB returns real
  local real distance = GetLengthOfLoc_d(GetSubtractionLoc_dk(locB, locA))
  return distance
endfunction
function DistanceBetweenPoints_dk takes location locA, location locB returns real
  local real distance = GetLengthOfLoc_d(GetSubtractionLoc_kd(locB, locA))
  return distance
endfunction
function DistanceBetweenPoints_dd takes location locA, location locB returns real
  local real distance = GetLengthOfLoc_d(GetSubtractionLoc_dd(locB, locA))
  return distance
endfunction

//============================================================================
function DistanceBetweenUnits takes unit unitA, unit unitB returns real
  local real r = DistanceBetweenPoints_dd(GetUnitLoc(unitA), GetUnitLoc(unitB))
  return r
endfunction

//============================================================================
function GetTimeToReachUnit takes unit u, unit target returns real
	local real distance = DistanceBetweenUnits(target, u)
	local real movespeed = GetUnitMoveSpeed(u)
	local real time = 15

	if movespeed != 0 then
		set time = distance / movespeed
	endif

	return time

endfunction

//============================================================================
//  (AMAI) Gets the time for a unit to travel to a specific location
//   This is based only on distance between two respective points
//============================================================================
function GetTimeToReachLoc takes unit u, location target returns real
	local real movespeed = GetUnitMoveSpeed(u)
	local real time = 15
	local real distance = DistanceBetweenPoints_kd(target, GetUnitLoc(u))
	//call DisplayToAllJobDebug("gettime: before")
	if movespeed != 0 then
		set time = distance / movespeed
	endif
	//call DisplayToAllJobDebug("gettime: after")
	return time
endfunction

//============================================================================
function EstimatedTimeToReachUnit_d takes location locA, unit target, real movespeed returns real
  local real time = 15
  local real distance = DistanceBetweenPoints_dd(locA, GetUnitLoc(target))

  if movespeed != 0 then
    set time = distance / movespeed
  endif
  return time

endfunction

//============================================================================
function GetLocationBetweenLoc takes location locA, location locB, real d returns location
  local location locC = GetSubtractionLoc(locA, locB)
  local location locD = GetMultipleLoc(locC, d)
  local location l = GetSumLoc(locA, locD)
  local real x = GetLocationX(l)
  local real y = GetLocationY(l)
  call RemoveLocation(locC)
  set locC = null
  call RemoveLocation(locD)
  set locD = null
  call RemoveLocation(l)
  set l = null
  return Location(x,y)
endfunction

//============================================================================
function GetLocationBetweenUnits takes unit u1, unit u2, real d returns location
  local location loc1 = GetUnitLoc(u1)
  local location loc2 = GetUnitLoc(u2)
  local location l = GetLocationBetweenLoc(loc1, loc2, d)
  local real x = GetLocationX(l)
  local real y = GetLocationY(l)
  call RemoveLocation(loc1)
  set loc1 = null
  call RemoveLocation(loc2)
  set loc2 = null
  call RemoveLocation(l)
  set l = null
  return Location(x,y)
endfunction

//============================================================================
function GetTeleportLandPoint takes location l returns location
  local group g = CreateGroup()
  local unit u = null
  local real x = GetLocationX(l)
  local real y = GetLocationY(l)
  call GroupEnumUnitsInRangeOfLoc(g, l, 900, null)
  call RemoveLocation(teleportloc)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null  //Find a enemy unit , land to unit loc , prevent army land to hall , cannot expand
    if not IsUnitType(u, UNIT_TYPE_FLYING) and not IsUnitInvisible(u, ai_player) and IsPlayerEnemy(ai_player,GetOwningPlayer(u)) and not IsUnitHidden(u) then
      set x = GetUnitX(u)
      set y = GetUnitY(u)
      set teleportloc = Location(x,y)
      call DestroyGroup(g)
      set g = null
      set u = null
      return Location(x,y)
    endif
    call GroupRemoveUnit(g, u)
  endloop
  set teleportloc = Location(x,y)
  call DestroyGroup(g)
  set g = null
  return Location(x,y)
endfunction

//============================================================================
function GetNearestEnemyToLoc_k takes location l returns player
  local integer i = 0
  local integer min_p = 30
  local real nr = 0
  local real min_nr = 1000000

  loop
    exitwhen i >= c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set nr = DistanceBetweenPoints_dk(GetPlayerStartLocationLoc(enemy_force[i]), l)
      if nr < min_nr then
        set min_nr = nr
        set min_p = i
      endif
    endif
    set i = i + 1
  endloop
  if min_p != 30 then
    return enemy_force[min_p]
  endif
  return null
endfunction

function GetNearestEnemyToLoc_d takes location l returns player
  local integer i = 0
  local integer min_p = 30
  local real nr = 0
  local real min_nr = 1000000

  loop
    exitwhen i >= c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set nr = DistanceBetweenPoints_dk(GetPlayerStartLocationLoc(enemy_force[i]), l)
      if nr < min_nr then
        set min_nr = nr
        set min_p = i
      endif
    endif
    set i = i + 1
  endloop
  call RemoveLocation(l)
  if min_p != 30 then
    return enemy_force[min_p]
  endif
  return null
endfunction

//============================================================================
function SetNearestEnemy takes nothing returns nothing
  local integer i = 0
  local real nr = 0
  local real humanrange = 20000  // preventing long-distance attacks
  loop
    exitwhen i >= c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set nr = DistanceBetweenPoints_dk(GetPlayerStartLocationLoc(enemy_force[i]), home_location)
      if nr < nearest_enemy_range then
        set nearest_enemy_range = nr
        set nearest_enemy = enemy_force[i]
        if GetPlayerController(enemy_force[i]) != MAP_CONTROL_COMPUTER and nr < humanrange then
          set humanrange = nr
          set nearest_human_enemy = enemy_force[i]
        endif
      endif
    endif
    set i = i + 1
  endloop
endfunction

//============================================================================
function countAllyEnemy takes nothing returns nothing
  local integer i = 0
  local boolean self_came = false
  local boolean next_came = false
  local player p = null

  loop
    exitwhen i > RACE_NUMBER
    set c_ally[i] = 0
    set c_enemy[i] = 0
    set i = i + 1
  endloop

  set i = 0
  loop
    exitwhen i >= PLAYERAGGRESSIVE
    set p = Player(i)
    if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING and not IsPlayerObserver(p) then
      if GetPlayerController(p) == MAP_CONTROL_COMPUTER then
        set c_ai_total = c_ai_total + 1
      endif
      if IsPlayerAlly(ai_player,p) then
        if i == GetAiPlayer() then
          set self_came = true
          set next_came = true
          set own_force[force_number] = p
          set force_number = force_number + 1
        else
          if GetPlayerController(p) == MAP_CONTROL_COMPUTER then
            if not self_came then
              set first_ai = false
            elseif next_came then
              set next_ai = i
              set next_came = false
            endif
            set own_force[force_number] = p
            set force_number = force_number + 1
          else
            set no_ally_ctrl = false
            set c_ally_user_total = c_ally_user_total + 1
          endif
          set c_ally[player_race[i]] = c_ally[player_race[i]] + 1
          set ally_force[c_ally_total] = p
          set c_ally_total = c_ally_total + 1
        endif
      elseif IsPlayerEnemy(ai_player,p) then
        if GetPlayerController(p) != MAP_CONTROL_COMPUTER then
          set c_enemy_user_total = c_enemy_user_total + 1
        endif
        set c_enemy[player_race_pref[i]] = c_enemy[player_race_pref[i]] + 1
        set enemy_force[c_enemy_total] = p
        set c_enemy_total = c_enemy_total + 1
      endif
    endif
    set i = i + 1
  endloop
  set p = null
  set no_ai_ally = first_ai and next_ai == 0
endfunction

//==========================================================================
// (AMAI)	CopyGroup
//==========================================================================
function CopyGroup takes group sg , group copyg returns group
  local group gtemp = null
  local unit u = null
  set copyg = CreateGroup()
  if FirstOfGroup(sg) != null then
    set gtemp = CreateGroup()
    loop
      set u = FirstOfGroup(sg)
      exitwhen u == null
      call GroupAddUnit(copyg,u)
      call GroupAddUnit(gtemp,u)
      call GroupRemoveUnit(sg,u)
    endloop
    loop
      set u = FirstOfGroup(gtemp)
      exitwhen u == null
      call GroupAddUnit(sg,u)
      call GroupRemoveUnit(gtemp,u)
    endloop
    call DestroyGroup(gtemp)
    set gtemp = null
  endif
  return copyg
endfunction

//==========================================================================
// (AMAI)	AreUnitsOfType
//==========================================================================
function AreUnitsOfType takes group g, integer id returns boolean
  local group cg = null
  local unit u = null
  set cg = CopyGroup(g,cg)
  loop
    set u = FirstOfGroup(cg)
    exitwhen u == null
    if GetUnitTypeId(u) != id then
      call DestroyGroup(cg)
      set cg = null
      set u = null
      return false
    endif
    call GroupRemoveUnit(cg, u)
  endloop
  call DestroyGroup(cg)
  set cg = null
  return true
endfunction

//==========================================================================
// (AMAI)	AddAbilityToGroup
//==========================================================================
function AddAbilityToGroup takes group g, integer abil returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitAbilityLevel(u, abil) <= 0 then
      call UnitAddAbility(u, abil)
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
endfunction

//==========================================================================
// (AMAI)	SelectNumberOfId
//==========================================================================
function SelectNumberOfId takes group rg, integer n, integer id returns group
  local integer c = 0
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    exitwhen c == n
    if GetUnitTypeId(u) == id then
      set c = c + 1
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  set u = null
  return rg
endfunction

//==========================================================================
// (AMAI)	SelectById
//==========================================================================
function SelectById takes group rg, integer id, boolean is_id returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if (GetUnitTypeId(u) == id) == is_id then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

//==========================================================================
// (AMAI)	SelectByIdOr
//==========================================================================
function SelectByIdOr takes group rg, integer id1, integer id2, boolean is_id returns group
  local integer id = 0
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set id = GetUnitTypeId(u)
    if (id == id1 or id == id2) == is_id then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

//==========================================================================
// (AMAI)	SelectUnittype
//==========================================================================
function SelectUnittype takes group rg, unittype typ, boolean is_of_type returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitType(u, typ) == is_of_type then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

//==========================================================================
// (AMAI)	SelectByIllusion
//==========================================================================
function SelectByIllusion takes group rg, boolean is_illusion returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitIllusion(u) == is_illusion then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

//==========================================================================
// (AMAI)	SelectByLoaded
//==========================================================================
function SelectByLoaded takes group rg, boolean is_loaded returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitLoaded(u) == is_loaded then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByHidden takes group rg, boolean is_visible returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitHidden(u) == is_visible then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

//==========================================================================
// (AMAI)	SelectByAlive
//==========================================================================
function SelectByAlive takes group rg, boolean is_alive returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) == is_alive then
    //if not IsUnitType(u, UNIT_TYPE_DEAD) == is_alive then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByAlive2 takes group rg, boolean is_alive returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if (GetUnitState(u, UNIT_STATE_LIFE) > 0) == is_alive then
    //if not IsUnitType(u, UNIT_TYPE_DEAD) == is_alive then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

// This function is used in the harrass code and only affects units (not heroes)
function SelectByFullHealth takes group rg, boolean is_healed returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if (GetUnitState(u, UNIT_STATE_LIFE) >= GetUnitState(u, UNIT_STATE_MAX_LIFE)) == is_healed or IsUnitType(u, UNIT_TYPE_HERO) then
    //if not IsUnitType(u, UNIT_TYPE_DEAD) == is_alive then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

//==========================================================================
// (AMAI)	SelectByPlayer
//==========================================================================
function SelectByPlayer takes group rg, player p, boolean is_owner returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if (GetOwningPlayer(u) == p) == is_owner then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByInvisible takes group rg, player enemy, boolean is_visible returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitInvisible(u, enemy) == is_visible then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByVisible takes group rg, player enemy, boolean is_visible returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitVisible(u, enemy) == is_visible then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByDetected takes group rg, player enemy, boolean is_detected returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitDetected(u, enemy) == is_detected then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction 

//==========================================================================
// (AMAI)	SelectByEnemy
//==========================================================================
function SelectByEnemy takes group rg, player p, boolean is_enemy returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsPlayerEnemy(p, GetOwningPlayer(u)) == is_enemy then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

//==========================================================================
// (AMAI)	SelectByUserData
//==========================================================================
function IsStandardUnit takes unit u returns boolean
  if IsUnitInGroup(u, unit_healing) then
    return false
  elseif IsUnitInGroup(u, unit_rescueing) then
    return false
  elseif IsUnitInGroup(u, unit_harassing) then
    return false
  elseif IsUnitInGroup(u, unit_zepplin_move) then
    return false
  endif
  return true
endfunction

function IsUnitBuying takes unit u returns boolean
  if IsUnitInGroup(u, unit_buying_item) then
    return true
  elseif IsUnitInGroup(u, unit_buying_merc) then
    return true
  elseif IsUnitInGroup(u, unit_buying_tavern) then
    return true
  endif
  return false
endfunction

function SelectByUnitStandard takes group rg, boolean has_data returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsStandardUnit(u) == has_data then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByUnitFree takes group rg, boolean has_data returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if not IsUnitBuying(u) == has_data then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

//==========================================================================
// (AMAI)	SelectByOrder
//==========================================================================
function SelectByOrder takes group rg, integer my_order, boolean has_order returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if (GetUnitCurrentOrder(u) == my_order) == has_order then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

//============================================================================
function SelectByOrderOr takes group rg, integer my_order1, integer my_order2, boolean has_order returns group
  local integer order = 0
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set order = GetUnitCurrentOrder(u)
    if ((order == my_order1) or (order == my_order2)) == has_order then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

function SelectByOrderOr2 takes group rg, integer my_order1, integer my_order2, integer my_order3, boolean has_order returns group
  local integer order = 0
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set order = GetUnitCurrentOrder(u)
    if ((order == my_order1) or (order == my_order2) or (order == my_order3)) == has_order then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

//==========================================================================
// (AMAI)	SelectByLocation
//==========================================================================
function SelectByLocation takes group rg, location l, real dist, boolean is_near returns group
  local unit u = null
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if (DistanceBetweenPoints_dk(GetUnitLoc(u), l) <= dist) == is_near then
      call GroupAddUnit(rg, u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

//==========================================================================
// (AMAI)	GroupRemoveGroup
//==========================================================================
function GroupRemoveGroupAM takes group sourcegroup , group removegroup returns nothing
  local unit u = null
  local group ug = null
  set ug = CopyGroup(sourcegroup,ug)
  loop
    set u = FirstOfGroup(ug)
    exitwhen u == null
    call GroupRemoveUnit(removegroup,u)
    call GroupRemoveUnit(ug,u)
  endloop
  call DestroyGroup(ug)
  set ug = null
endfunction

//==========================================================================
// (AMAI)	GroupAddGroup
//==========================================================================
function GroupAddGroup takes group g, group to_add returns group
  local unit u = null
  loop
    set u = FirstOfGroup(to_add)
    exitwhen u == null
    call GroupAddUnit(g, u )
    call GroupRemoveUnit(to_add, u )
  endloop
  return g
endfunction


//==========================================================================
// (AMAI)	GroupAddType
//==========================================================================
function GroupAddType takes group g, integer id, player p returns nothing
  local group ag = CreateGroup()
  call GroupEnumUnitsOfPlayer(ag, p, null)
  set ag = SelectNumberOfId(ag, 100, id)
  call GroupAddGroup(g, ag)
  call DestroyGroup(ag)
  set ag = null
endfunction

//==========================================================================
// (AMAI)	GroupAddTypeAndRemoveGuard
//==========================================================================
function GroupAddTypeAndRemoveGuard takes group g, integer id, player p returns nothing
  local unit u = null
  local group ag = CreateGroup()
  call GroupEnumUnitsOfPlayer(ag, p, null)
  loop
    set u = FirstOfGroup(ag)
    exitwhen u == null
    if GetUnitTypeId(u) == id then
      call RemoveGuardPosition(u)
      call GroupAddUnit(g,u)
    endif
    call GroupRemoveUnit(ag, u)
  endloop
  call DestroyGroup(ag)
  set ag = null
endfunction

//==========================================================================
// (AMAI)	GroupRemoveGuardPositionInstant
//==========================================================================
function GroupRemoveGuardPositionInstant takes group g returns nothing
  local unit u = null
  local group ug = null
  set ug = CopyGroup(g,ug)

  loop
    set u = FirstOfGroup(ug)
    exitwhen u == null
    call RemoveGuardPosition(u)
    call GroupRemoveUnit(ug,u)
  endloop
  call DestroyGroup(ug)
  set ug = null
endfunction

//==========================================================================
// (AMAI)	GroupRecycleGuardPositionInstant
//==========================================================================
function GroupRecycleGuardPositionInstant takes group g returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call RecycleGuardPosition(u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
endfunction

function GroupRecycleHarrassPositionInstant takes group g returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call RecycleGuardPosition(u)
    call AddAssault(1, GetUnitTypeId(u))
    call GroupRemoveUnit(unit_harassing, u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
endfunction

function GroupRecycleGuardPositionByStandard takes group g returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsStandardUnit(u) then
      call RecycleGuardPosition( u )
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
endfunction

//==========================================================================
// (AMAI)	RemoveSentUnits
//     NOT CURRENTLY USED
//==========================================================================
function RemoveSentUnits takes group g returns group
  local integer i = 0
  loop
    exitwhen i > 3
    call GroupRemoveUnit(g, neutral_sent[i] )
    set i = i + 1
  endloop
//  call GroupRemoveUnit(g, follow_zeppelin )
  return SelectById(g, 'nzep', false)
endfunction

//==========================================================================
// (AMAI)	GetOneOfId
//==========================================================================
function GetOneOfId takes unit u, player p, integer id returns unit
  local group g = CreateGroup()
  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectByHidden(g, false)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == id then
      call DestroyGroup(g)
      set g = null
      return u
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return u
endfunction

//==========================================================================
// (AMAI)	GetOneOfIdNearLoc
//==========================================================================
function GetOneOfIdNearLoc takes unit u, player p, integer id, location l, real dist returns unit
  local group g = CreateGroup()
  call GroupEnumUnitsInRangeOfLoc(g, l, dist, null)
  set g = SelectByPlayer(g, p, true)
  set g = SelectByHidden(g, false)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == id then
      call DestroyGroup(g)
      set g = null
      return u
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  set g = null
  return u
endfunction

//==========================================================================
// (AMAI)	GetMineNearLoc
//==========================================================================
function GetMineNearLoc takes unit u, location l, real dist returns unit
  local group g = null
  local integer i = 0
  local real distance = 1500
  if DistanceBetweenPoints(l , home_location) < 500 then
    if own_town_mine[0] != null and GetResourceAmount(own_town_mine[0]) > 0 then
      return own_town_mine[0]
    endif
  endif
  set g = CreateGroup()
  call GroupEnumUnitsInRangeOfLoc(g, l, dist, null)
  //set g = SelectByAlive(g, true)
  loop
    if minearray == 0 then
      call DisplayToAll("Warning - No standard gold mine set in standardunits.slk")
      call Sleep(3)
    endif
    set u = FirstOfGroup(g)
    exitwhen u == null
    set i = 0
    loop
      exitwhen i >= minearray
      if GetUnitTypeId(u) == racial_goldmine[i] and GetResourceAmount(u) > 0 then
        //if SetHasEntry(ver_gold_mines, GetUnitTypeId(u)) then
        //if GetUnitTypeId(u) =='ngol' or GetUnitTypeId(u) =='egol' or GetUnitTypeId(u) == 'ugol' then
        call Trace("GetMineNearLOC: A Mine match found")
        call DestroyGroup(g)
        set g = null
        return u
      endif
      set i = i + 1
    endloop
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return u
endfunction

//==========================================================================
// (AMAI Addition by SM) Get Nearest Neutral
//==========================================================================
// function CanPathToLoc takes location locA, location target, pathingtype path returns real 

// // This function returns the time to path to a location. If positive its pathable, if negative
// // its unpathable.

    // local integer groundid = 'ewsp'
    // local integer seaid = 'hdes'
    // local integer amphibiousid = 'nsnp'
    // local integer flyid = 'hgyr'
    // local unit u = null
    // local real distance = 0
    // local location l = null
    // local real checktime = 0
    // local real totaltime = 0
	// local boolean exitloop = false
	// local location prev_loc = null
	// local integer checks = 0	// Number of times unit has stayed at same position

    // if path == PATHING_TYPE_WALKABILITY then
        // set u = CreateUnit(Player(PLAYERPASSIVE), groundid, GetLocationX(locA), GetLocationY(locA), 270.00)
    // elseif path == PATHING_TYPE_FLOATABILITY then
        // set u = CreateUnit(Player(PLAYERPASSIVE), seaid, GetLocationX(locA), GetLocationY(locA), 270.00)
    // elseif path == PATHING_TYPE_AMPHIBIOUSPATHING then
        // set u = CreateUnit(Player(PLAYERPASSIVE), amphibiousid, GetLocationX(locA), GetLocationY(locA), 270.00)
    // elseif path == PATHING_TYPE_FLYABILITY then
        // set u = CreateUnit(Player(PLAYERPASSIVE), flyid, GetLocationX(locA), GetLocationY(locA), 270.00)
    // else
        // set totaltime = -1
    // endif

	// if totaltime == 0 then
	    // call SetUnitInvulnerable(u, true)
        // call ShowUnit(u, false)
        // call SetUnitUseFood(u, false)
        // call SetUnitMoveSpeed(u, 520)
        // call RemoveGuardPosition(u)
        // call IssuePointOrder(u, "move", GetLocationX(target), GetLocationY(target))

    // set checktime =  GetTimeToReachLoc(u, target)
    // set totaltime = checktime
    // //call UnitApplyTimedLife(u, 'BTLF', checktime * 5)
    // //call Sleep(checktime)
    // set checktime = 2.00

    // loop
		// exitwhen (exitloop == true)
		// //	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "pathing loop")
        // set l = GetUnitLoc(u)
        // set distance = DistanceBetweenPoints(l,target)
        // if distance <= buy_distance then
		// //	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Tavern is pathable")
			// call CreateDebugTag("Target Destination is pathable", 10, u, 3.00, 1.50)
			// call RemoveUnit(u)
			// set u = null
			// set exitloop = true
            // //return totaltime
		// //elseif GetUnitCurrentOrder(u) == OrderId("stop") then
            // //return (totaltime * -1)
        // elseif GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
			// call RemoveUnit(u)
			// set u = null
			// set exitloop = true
			// set totaltime = totaltime * -1
            // //return (totaltime * -1)
        // elseif GetUnitCurrentOrder(u) == OrderId("stop") or GetUnitCurrentOrder(u) != OrderId("move") then
			// set checks = checks + 1
			// call CreateDebugTag("Invisible Path unit has stopped", 10, u, 3.00, 1.50)
			// if checks > 1 then
				// call CreateDebugTag("Target Destination was not reached", 10, u, 3.00, 1.50)
				// call RemoveUnit(u)
				// set u = null
				// set exitloop = true
				// set totaltime = totaltime * -1
				// //return (totaltime * -1)
			// endif
		// else
			// set checks = 0	// means unit is moving and not standing still
			// call CreateDebugTag("Invisible Path Unit Here", 10, u, 3.00, 1.50)
        // endif
		// call RemoveLocation(l)
		// set l = null
        // set totaltime = totaltime + checktime
        // call Sleep(checktime)

    // endloop
	// endif

    // return (totaltime)

// endfunction

function CreatePathingUnitFull takes unit u, player p, integer id, real x, real y returns unit
  set u = CreateUnit(ai_player, id, x, y, 270.00)
  call SetUnitInvulnerable(u, true)
  if (not debugging) then
    call ShowUnit(u, false)
  endif
  call SetUnitUseFood(u, false)
  call SetUnitMoveSpeed(u, 522)
  call RemoveGuardPosition(u)
  return u
endfunction

function CreatePathingUnit takes unit u returns unit
  // local integer groundid = 'ewsp'
  // if GetPlayerRace(ai_player) == RACE_NIGHTELF then
  //   set groundid = 'uaco' // alternative for night elf players to avoid it counting for players peon count
  // endif
  // Have to use ai_player as larger maps the passive player ai is restricted at such large numbers of units with orders being paused for seconds then continuing. Appears to be hardcoded into the warcraft 3 engine.
  set u = CreatePathingUnitFull(u, ai_player, groundid, GetLocationX(home_location), GetLocationY(home_location))
  return u
endfunction

function CanPathToLoc takes location locA, location target, pathingtype path returns real 

// This function returns the time to path to a location. If positive its pathable, if negative
// its unpathable.

  //local integer groundid = 'ewsp'
  local integer seaid = 'hdes'
  local integer amphibiousid = 'nsnp'
  local integer flyid = 'hgyr'
  local unit u = null
  local real distance = 0
  //local location l = null
  local real checktime = 0
  local real totaltime = 0
  //local location prev_loc = null
  local integer checks = 0	// Number of times unit has stayed at same position
  // if GetPlayerRace(ai_player) == RACE_NIGHTELF then
  //   set groundid = 'uaco' // alternative for night elf players to avoid it counting for players peon count
  // endif
  if path == PATHING_TYPE_WALKABILITY then
    set u = CreatePathingUnitFull(u, Player(PLAYERPASSIVE), groundid, GetLocationX(locA), GetLocationY(locA))
  elseif path == PATHING_TYPE_FLOATABILITY then
    set u = CreatePathingUnitFull(u, Player(PLAYERPASSIVE), seaid, GetLocationX(locA), GetLocationY(locA))
  elseif path == PATHING_TYPE_AMPHIBIOUSPATHING then
    set u = CreatePathingUnitFull(u, Player(PLAYERPASSIVE), amphibiousid, GetLocationX(locA), GetLocationY(locA))
  elseif path == PATHING_TYPE_FLYABILITY then
    set u = CreatePathingUnitFull(u, Player(PLAYERPASSIVE), flyid, GetLocationX(locA), GetLocationY(locA))
  else
    return -1.0
  endif

  call IssuePointOrder(u, "move", GetLocationX(target), GetLocationY(target))
//	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Path Unit Created")

  set checktime =  GetTimeToReachLoc(u, target)
  set totaltime = checktime
  //call UnitApplyTimedLife(u, 'BTLF', checktime * 5)
  //call Sleep(checktime)
  set checktime = 2.00

  loop
  //	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "pathing loop")
    set distance = DistanceBetweenPoints_dk(GetUnitLoc(u),target)
    if distance <= buy_distance then
  //	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Tavern is pathable")
        call CreateDebugTag("Target Destination is pathable", 10, u, 3.00, 1.50)
        call RemoveUnit(u)
        set u = null
        return totaltime
  //elseif GetUnitCurrentOrder(u) == OrderId("stop") then
        //return (totaltime * -1)
    elseif GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
      call RemoveUnit(u)
      set u = null
      return (totaltime * -1)
    elseif GetUnitCurrentOrder(u) == OrderId("stop") or GetUnitCurrentOrder(u) != OrderId("move") then
      set checks = checks + 1
      call CreateDebugTag("Invisible Path unit has stopped", 10, u, 3.00, 1.50)
      if checks > 1 then
        call CreateDebugTag("Target Destination was not reached", 10, u, 3.00, 1.50)
        call RemoveUnit(u)
        set u = null
        return (totaltime * -1)
      endif
    else
      set checks = 0	// means unit is moving and not standing still
      call CreateDebugTag("Invisible Path Unit Here", 10, u, 3.00, 1.50)
    endif
    set totaltime = totaltime + checktime
    call Sleep(checktime)
  endloop
  return (totaltime * -1)

endfunction

//==========================================================================
// (AMAI) Finds nearest neutral quick without checking if it is passable
//        this is used so computer dosn't get stuck waiting for the longer
//        method to compute
//==========================================================================
function GetNearestNeutralQuick takes unit ru, integer id returns unit
  local group g = CreateGroup()
  local unit u = null
  local real distance = 10000000
  local real newdistance = 0
  call GroupEnumUnitsOfPlayer(g, Player(PLAYERPASSIVE), null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == id then
      set newdistance = DistanceBetweenPoints_kd(home_location, GetUnitLoc(u))
      if newdistance < distance then
        set distance = newdistance
        set ru = u
      endif
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  if GetUnitTypeId(u) == neutral_id[NEUTRAL_HEAL_WARD] and ru != null and IsUnitType(ru, UNIT_TYPE_SUMMONED) then
    set ru = null
  endif
  return ru
endfunction

//==========================================================================
// (AMAI) Finds nearest neutral that is passable
//==========================================================================
function GetNearestNeutral takes unit ru, integer id returns unit
  local group g = CreateGroup()
  local unit u = null
//    local unit homepeon = GetExpansionPeon() //Is to be used for checking pathability again
  local real distance = 0
//    local real newdistance = 0
//    local location l = null
  local group tempg = null
  local unit array pather
  local integer i = 0
  local integer checks = 0
  local boolean pathingdone = true
  //local real totaltime = 0
  //local integer groundid = 'ewsp'
//call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "get nearest neutral start")


//call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "neutral start loop")

//----- initial loop to get the nearest neutral

//----- check if it really is passable
//set l = GetUnitLoc(unit_nearest)
//set newdistance = CanPathToLoc(start_loc, l, PATHING_TYPE_WALKABILITY)
//call RemoveLocation(l)
//set l = null

//----- closest not passable so try others
//call GroupClear(g)
  call GroupEnumUnitsOfPlayer(g, Player(PLAYERPASSIVE), null)
//call GroupRemoveUnit(g, unit_nearest)
  set ru = null
  set tempg = CopyGroup(g,tempg)
  loop
    set u = FirstOfGroup(tempg)
    exitwhen u == null
    if GetUnitTypeId(u) == id and not IsUnitType(ru, UNIT_TYPE_SUMMONED) then  //prevent neutral_id[NEUTRAL_HEAL_WARD]
      set pather[i] = CreatePathingUnit(pather[i])
      call IssuePointOrder(pather[i], "move", GetUnitX(u), GetUnitY(u))
      if (ModuloInteger(i,10) == 0) then
        call Sleep(0.3 * sleep_multiplier)
      endif
      set i = i + 1
    else
      call GroupRemoveUnit(g, u)
    endif
    call GroupRemoveUnit(tempg, u)
  endloop
  call DestroyGroup(tempg)
  //set distance = 10000000

  loop
    //set totaltime = totaltime + 3
    set pathingdone = true
    set tempg = CopyGroup(g,tempg)
    set i = 0
    loop
      set u = FirstOfGroup(tempg)
      exitwhen u == null
      if pather[i] != null then
        set distance = DistanceBetweenUnits(pather[i],u)
        if ru != null then
          call RemoveUnit(pather[i])
          set pather[i] = null
        elseif distance <= buy_distance then
        //call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Tavern is pathable")
          call CreateDebugTag("Target Destination is pathable", 10, pather[i], 3.00, 1.50)
          call RemoveUnit(pather[i])
          set pather[i] = null
          if ru == null then
            set ru = u
          endif
        //elseif GetUnitCurrentOrder(u) == OrderId("stop") then
          //return (totaltime * -1)
        elseif GetUnitState(pather[i], UNIT_STATE_LIFE) <= 0 then
          //call Trace("DIED")
          call RemoveUnit(pather[i])
          set pather[i] = null
        elseif GetUnitCurrentOrder(pather[i]) == OrderId("stop") or GetUnitCurrentOrder(pather[i]) != OrderId("move") then
          set checks = checks + 1
          call CreateDebugTag("Invisible Path unit has stopped", 10, pather[i], 3.00, 1.50)
          if checks > 1 then
            call CreateDebugTag("Target Destination was not reached", 10, pather[i], 3.00, 1.50)
            //call Trace("GOT STUCK")
            call RemoveUnit(pather[i])
            set pather[i] = null
          endif
        else
          set checks = 0	// means unit is moving and not standing still
          call CreateDebugTag("Invisible Path Unit Here", 10, pather[i], 3.00, 1.50)
        endif
        set pathingdone = false
      endif
      call GroupRemoveUnit(tempg, u)
      set i = i + 1
    endloop
    call DestroyGroup(tempg)
    exitwhen pathingdone
    call Sleep(1 * sleep_multiplier)
  endloop
  set tempg = null
  call DestroyGroup(g)
  set g = null
  return ru
	//loop
	//	set u = FirstOfGroup(g)
	//	exitwhen u == null
	//	set l = GetUnitLoc(u)
	//	if GetUnitTypeId(u) == id then
	//	//set newdistance = DistanceBetweenPoints(start_loc, l )
	//	  	set newdistance = CanPathToLoc(start_loc, l, PATHING_TYPE_WALKABILITY)
	//		if newdistance > 0 and newdistance < distance then
	//		 set distance = newdistance
	//		 set ru = u
	//	     endif
	//     endif

    //    call GroupRemoveUnit(g, u)
	//	call RemoveLocation(l)
	//	set l = null
	//endloop

	//	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "neutral out loop")
	//call DestroyGroup(g)
	//set g = null
	//call RemoveLocation(start_loc)
	//set start_loc = null

endfunction

//==========================================================================
// (AMAI)	GetNearestOfGroup
// NOTE: Function will remove units from the group passed to it
//==========================================================================
function GetNearestOfGroup takes unit ru, group g, location l returns unit
  local real d = 0
  local unit u = null
  local real sd = 1000000
  set ru = null
  if l != null then
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      set d = DistanceBetweenPoints_dk(GetUnitLoc(u), l)
      if d < sd then
        set sd = d
        set ru = u
      endif
      call GroupRemoveUnit(g, u )
    endloop
  endif
  return ru
endfunction

//==========================================================================
// (AMAI)	GetNearestSubGroupOfGroup
// NOTE: Function will remove units from the group passed to it
//==========================================================================
function GetNearestSubGroupOfGroup takes group rg, location l, integer n returns group
  local unit array ua
  local real array da
  local integer size = 0
  local integer i = 0
  local integer ru = 0
  local unit u = null
  local real d = 0
  local group g = rg
  set rg = CreateGroup()
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set d = DistanceBetweenPoints_dk(GetUnitLoc(u), l)
    set i = size - 1
    loop
      exitwhen i < 0 or da[i] >= d
      set ua[i+1] = ua[i]
      set da[i+1] = da[i]
      set i = i - 1
    endloop
    set i = i + 1
    set ua[i] = u
    set da[i] = d
    set size = size + 1
    call GroupRemoveUnit(g,u)
  endloop
  set i = size - Min(n, size)
  loop
    exitwhen ru > size
    if ru == i and i < size then
      call GroupAddUnit(rg, ua[i])
      set i = i + 1
    endif
    set ua[ru] = null
    set ru = ru + 1
  endloop
  call DestroyGroup(g)
  set g = null
  return rg
endfunction

//==========================================================================
// (AMAI)	GetFarestOfGroup
//==========================================================================
function GetFarestOfGroup takes unit ru, group g, location l returns unit
  local real d = 0
  local unit u = null
  local real sd = 0
  set ru = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set d = DistanceBetweenPoints_dk(GetUnitLoc(u), l)
    if d > sd then
      set sd = d
      set ru = u
    endif
    call GroupRemoveUnit(g, u )
  endloop
  return ru
endfunction

//==========================================================================
// (AMAI)	GetFastestToPointOfGroup
//==========================================================================
function GetFastestToPointOfGroup takes unit ru, group g, location l returns unit
  local real d = 0
  local unit u = null
  local real sd = 1000000
  local real ms = 0
  set ru = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set ms = RMax(GetUnitMoveSpeed(u),0.01)
    set d = DistanceBetweenPoints_dk(GetUnitLoc(u), l) / ms
    if d < sd then
      set sd = d
      set ru = u
    endif
    call GroupRemoveUnit(g, u )
  endloop
  return ru
endfunction

//==========================================================================
// (AMAI)	GetLeastHPUnitOfGroup
//==========================================================================
function GetLeastHPUnitOfGroup takes unit ru, group g returns unit
  local real hp = 0
  local unit u = null
  local real lhp = 1000000
  set ru = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set hp = GetUnitState(u, UNIT_STATE_LIFE)
    if hp < lhp then
      set lhp = hp
      set ru = u
    endif
    call GroupRemoveUnit(g, u )
  endloop
  call DestroyGroup(g)
  return ru
endfunction

//==========================================================================
// (AMAI)	UnitAliveInGroup
//==========================================================================
function UnitAliveInGroup takes group g returns boolean
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    if u == null then
      call DestroyGroup(g)
      return false
    endif
    if UnitAlive(u) then
      set u = null
      return true
    endif
    call GroupRemoveUnit(g,u)
  endloop
  set u = null
  return true // never reached
endfunction

//==========================================================================
// (AMAI)	GetUnitToBuy
//==========================================================================
function GetUnitToBuy takes unit ru, unit buy_place returns unit
  local group g = CreateGroup()
  local unit u = null
  local real distance = 10000
  local real newdistance = 0
  set ru = null
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, false)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, false)
  set g = SelectUnittype(g, UNIT_TYPE_SUMMONED, false)
  set g = SelectByIllusion(g, false)
  set g = SelectByHidden(g, false)
  set g = SelectByAlive2(g, true)
  set g = SelectByUnitFree(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsStandardUnit(u) then  //and not IsUnitBuying(u) and IsUnitType(u, UNIT_TYPE_STRUCTURE) == false and IsUnitType(u, UNIT_TYPE_PEON) == false and IsUnitType(u, UNIT_TYPE_SUMMONED) == false and not IsUnitIllusion(u) and GetUnitState(u, UNIT_STATE_LIFE) > 0 and not IsUnitInGroup(u, unit_buying_item) and not IsUnitInGroup(u, unit_buying_merc) then
      set newdistance = DistanceBetweenUnits(buy_place, u)
      if newdistance < distance then
        set distance = newdistance
        set ru = u
      endif
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  if ru == null then
    set ru = GetExpansionPeon()
    if ru == null then
      set ru = GetExpansionPeon2(ru)
    endif
  endif
  return ru
endfunction

//==========================================================================
// (AMAI)	GetUnitOfTypeNearUnit
//==========================================================================
function GetUnitOfTypeNearUnit takes integer ut, unit nu, unit ru returns unit
  local group g = CreateGroup()
  local location unitloc = GetUnitLoc(nu)

  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectById(g, ut, true)
  set ru = GetNearestOfGroup(ru, g, unitloc)
  call DestroyGroup(g)
  set g = null
  call RemoveLocation(unitloc)
  set unitloc = null
  return ru
endfunction

//==========================================================================
// (AMAI)	GetUnusedZeppelin
//==========================================================================
function GetUnusedZeppelinNearUnit takes unit ru, unit nu returns unit
  local group g = CreateGroup()
  local location unitloc = GetUnitLoc(nu)

  call GroupEnumUnitsOfType(g, "goblinzeppelin", null)
  set g = SelectByPlayer(g, ai_player, true)
  set g = SelectByOrderOr(g, 0, order_cancel, true)
  set g = SelectByUnitStandard(g, true)
  set ru = GetNearestOfGroup(ru, g, unitloc)
  call DestroyGroup(g)
  set g = null
  call RemoveLocation(unitloc)
  set unitloc = null
  return ru
endfunction

//==========================================================================
// (AMAI)	RemoveUnitsOfType
//==========================================================================
function RemoveUnitsOfType takes string ut returns nothing
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsOfType(g, ut, null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call GroupRemoveUnit(g, u)
    call RemoveUnit(u)
  endloop
  call DestroyGroup(g)
  set g = null
endfunction

//==========================================================================
// (AMAI)	Hero Utility Functions
//==========================================================================
function GetHeroNumber takes integer id returns integer
  local integer i = 1
  loop
    exitwhen i > 3
    if id == old_id[hero[i]] then
      return i
    endif
    set i = i + 1
  endloop
  return 1
endfunction

//==========================================================================
function GetHeroNumberOfUnit takes unit u returns integer
  local integer i = 1
  loop
    exitwhen i > 3
    if u == hero_unit[i] then
      return i
    endif
    set i = i + 1
  endloop
  return 1
endfunction

//==========================================================================
// (AMAI)	GetMajorHero
//==========================================================================

// gets a unit that can act as a hero for versions without heroes
function GetUnitHero takes unit u returns unit
  local group g = CreateGroup()
  call GroupEnumUnitsOfPlayer(g,ai_player,null)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, false)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, false)
  set g = SelectByHidden(g, false)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsStandardUnit(u) then
    //if IsUnitType(u, UNIT_TYPE_STRUCTURE) == false and IsUnitType(u, UNIT_TYPE_PEON) == false then
      call DestroyGroup(g)
      set g = null
      return u
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return u
endfunction

function GetUnitHeroReplacement takes unit u , location l returns unit
  local group g = CreateGroup()
  call GroupEnumUnitsOfPlayer(g,ai_player,null)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, false)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, false)
  set g = SelectByHidden(g, false)
  set g = SelectByAlive(g, true)
  set g = SelectByUnitStandard(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitInRangeLoc(u, l, battle_radius) then  //IsUnitType(u, UNIT_TYPE_STRUCTURE) == false and IsUnitType(u, UNIT_TYPE_PEON) == false and 
      call DestroyGroup(g)
      set g = null
      return u
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return u
endfunction

function GetMajorHero takes unit u returns unit
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] and UnitAlive(hero_unit[i]) and not IsUnitInGroup(hero_unit[i], unit_healing) then
      return hero_unit[i]
    endif
    set i = i + 1
  endloop
  return GetUnitHero(u)
  //return null
endfunction

//==========================================================================
function GetMajorHeroReplacement_d takes unit u, location l returns unit
  local integer i = 1

  loop
    exitwhen i > 3
    if hero_built[i] and UnitAlive(hero_unit[i]) and IsUnitInRangeLoc(hero_unit[i], l, battle_radius) and not IsUnitInGroup(hero_unit[i], unit_healing) then
      call RemoveLocation(l)
      return hero_unit[i]
    endif
    set i = i + 1
  endloop
  set u = GetUnitHeroReplacement(u,l)
  call RemoveLocation(l)
  return u
endfunction

function GetMajorHeroReplacement_k takes unit u, location l returns unit
  local integer i = 1

  loop
    exitwhen i > 3
    if hero_built[i] and UnitAlive(hero_unit[i]) and IsUnitInRangeLoc(hero_unit[i], l, battle_radius) and not IsUnitInGroup(hero_unit[i], unit_healing) then
      return hero_unit[i]
    endif
    set i = i + 1
  endloop
  return GetUnitHeroReplacement(u,l)
endfunction

//==========================================================================
// (AMAI)	GetNeutralNumber
//==========================================================================
function GetNeutralNumber takes integer id returns integer
  if buy_type[id] == BT_NEUTRAL_HERO then
    return NEUTRAL_TAVERN
  elseif buy_type[id] == BT_GOBLIN_MERC then
    return NEUTRAL_OBSERVATORY
  elseif buy_type[id] == BT_MERC then
    return NEUTRAL_MERC_CAMP
  else
    return NEUTRAL_DRAGON_ROOST
  endif
endfunction

//==========================================================================
// (AMAI)	GetDensities
//==========================================================================
function GetDensities takes location l, player p, real r returns nothing
  local group g = CreateGroup()
  local unit u = null
  local real ur = 0
  local real xe = 0
  local real ye = 0
  local real xa = 0
  local real ya = 0
  local location ul = null
  local location loc = null

  set enemy_density = 0
  set ally_density = 0
  call GroupEnumUnitsInRangeOfLoc(g, l, r, null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) then
      set ul = GetUnitLoc(u)
      set ur = 1 - (DistanceBetweenPoints(ul, l) / r)
      set loc = GetMultipleLoc(ul, ur)
      //if ur == 1 then
      if IsPlayerEnemy(p, GetOwningPlayer(u)) then
        set enemy_density = enemy_density + ur
        set xe = xe + GetLocationX(loc)  // Prevent loc exceeding map range
        set ye = ye + GetLocationY(loc)
        //set enemy_density_loc = GetSumLoc_dd(enemy_density_loc, GetMultipleLoc(ul, ur))
      elseif IsPlayerAlly(p, GetOwningPlayer(u)) then
        set ally_density = ally_density + ur
        set xa = xa + GetLocationX(loc)
        set ya = ya + GetLocationY(loc)
        //set ally_density_loc = GetSumLoc_dd(ally_density_loc, GetMultipleLoc(ul, ur))
      endif
      call RemoveLocation(loc)
      call RemoveLocation(ul)
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call RemoveLocation(ally_density_loc)
  if ally_density > 0 then
    set xa = xa / ally_density
    set ya = ya / ally_density
    set ally_density_loc = Location(xa,ya)
    //set ally_density_loc = GetDivisionLoc_d(ally_density_loc, ally_density)
  else
    set ally_density_loc = Location(0,0)
  endif
  call RemoveLocation(enemy_density_loc)
  if enemy_density > 0 then
    set xe = xe / enemy_density
    set ye = ye / enemy_density
    set enemy_density_loc = Location(xe,ye)
    //set enemy_density_loc = GetDivisionLoc_d(enemy_density_loc, enemy_density)
  else
    set enemy_density_loc = Location(0,0)
  endif
  call DestroyGroup(g)
  set g = null
  set ul = null
  set loc = null
endfunction

//==========================================================================
// (AMAI)	Action List Utility functions
//==========================================================================
function ActionListInit takes integer an returns nothing
  local integer i = 0
  set action_numbers = an
  loop
    exitwhen i >= an
    set action_points[i] = 0.0
    set i = i + 1
  endloop
endfunction

//==========================================================================
function ActionRule takes boolean b, integer chn, real cha returns nothing
  if b then
    set action_points[chn] = action_points[chn] + cha
  endif
endfunction

//==========================================================================
function ActionRule2 takes boolean b, integer chn, real cha, integer chn2, real cha2 returns nothing
  if b then
    set action_points[chn] = action_points[chn] + cha
    set action_points[chn2] = action_points[chn2] + cha2
  endif
endfunction

//==========================================================================
function ActionRule3 takes boolean b, integer chn, real cha, integer chn2, real cha2, integer chn3, real cha3 returns nothing
  if b then
    set action_points[chn] = action_points[chn] + cha
    set action_points[chn2] = action_points[chn2] + cha2
    set action_points[chn3] = action_points[chn3] + cha3
  endif
endfunction

//==========================================================================
function ActionListEval takes nothing returns integer
  local integer i = 0
  local integer max_i = -1
  local real max_val = -10000000.0
  loop
    exitwhen i >= action_numbers
    if action_points[i] > max_val then
      set max_i = i
      set max_val = action_points[i]
    endif
    set i = i + 1
  endloop
  return max_i
endfunction

//==========================================================================
// (AMAI) Get Strength of a Player
//==========================================================================
function GetPlayerStrengthHandicap takes player p returns real
  return SquareRoot(GetPlayerHandicap(p))
endfunction

//============================================================================
function GetPlayerHeroBonusStrength takes player p returns integer
  local integer strength = 0
  #INCLUDETABLE <$VER$\StandardUnits.txt> #EFR #COND %#OEVAL{16} != 0
  set strength = strength + %#OEVAL{16} * GetPlayerUnitTypeCount(p, o%1 )
  #ENDINCLUDE
  return strength
endfunction
//============================================================================
function GetHeroStrength takes unit u returns integer
  local integer lvl = GetHeroLevel(u)
  if not IsUnitInGroup(u, unit_healing) then
    if lvl >= ver_hero_ultimate_level then
      return R2I((ver_hero_base_value + lvl + ver_hero_ultimate_value)/2 + 0.5)
    else
      return R2I((ver_hero_base_value + lvl)/2 + 0.5)
    endif
  else
    return 0
  endif
endfunction

//============================================================================
function GetPlayerHeroStrengthMod takes player p returns integer
  local group g = CreateGroup()
  local unit u = null
  local integer sum = 0
  local real handicap = GetPlayerStrengthHandicap(p)
  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectUnittype(g, UNIT_TYPE_HERO, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) then
      set sum = sum + R2I(GetHeroStrength(u) * handicap * (GetUnitState(u, UNIT_STATE_LIFE) / GetUnitState(u, UNIT_STATE_MAX_LIFE)))
    endif
    call GroupRemoveUnit(g,u)
  endloop
  set sum = sum + GetPlayerHeroBonusStrength(p)
  call DestroyGroup(g)
  set g = null
  return sum
endfunction

//============================================================================
function GetUnitStrengthEx takes unit u returns integer
  local integer f = GetUnitLevel(u)
  if GetOwningPlayer(u) != Player(PLAYERAGGRESSIVE) then
    if IsUnitType(u, UNIT_TYPE_HERO) then
      return GetHeroStrength(u)
    else
      return R2I((GetUnitFoodUsed(u) + f) / 2 + 0.5)
    endif
  else
    if f >= ver_hero_ultimate_level then
      return R2I((GetUnitFoodUsed(u)+ f + ver_hero_ultimate_value) / 2 + 0.5)
    else
      return R2I((GetUnitFoodUsed(u) + f)/2 + 0.5)
    endif
  endif
  return 0
endfunction

//============================================================================
function GetUnitStrength takes unit u returns real
  if GetUnitState(u, UNIT_STATE_MAX_LIFE) == 0 then
    call DisplayToAll("ERROR: Major error has occured and caused amai system to crash at function GetUnitStrength")
    call DisplayToAll("Please contact the creator and provide this replay to them")
  endif
  return RMax(GetUnitStrengthEx(u) * GetPlayerStrengthHandicap(GetOwningPlayer(u)) * (GetUnitState(u, UNIT_STATE_LIFE) / GetUnitState(u, UNIT_STATE_MAX_LIFE)), 1.00)
endfunction

//============================================================================
function GetPlayerStrength takes player p returns real
//  local integer peon_count = 0
// #INCLUDETABLE <$VER$\StandardUnits.txt> #EFR #COND "%4" =~ /\bpeon\b/
//  set peon_count = peon_count + GetPlayerUnitTypeCount(p, o%1)
// #ENDINCLUDE
//  return R2I((I2R(GetPlayerState(p, PLAYER_STATE_RESOURCE_FOOD_USED) - peon_count)*2 + GetPlayerHeroStrengthMod(p) ) * GetPlayerStrengthHandicap(p))

  local group g = CreateGroup()
  local unit u = null
  local real sum = 0

  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, false)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, false)
  set g = SelectUnittype(g, UNIT_TYPE_HERO, false)
  set g = SelectByHidden(g, false)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    //if UnitAlive(u) and not IsUnitType(u, UNIT_TYPE_HERO) and not IsUnitType(u, UNIT_TYPE_PEON) and not IsUnitType(u, UNIT_TYPE_STRUCTURE) and not IsUnitHidden(u) then
    //call Trace("A Unit strength added: " + Int2Str(R2I(GetUnitStrength(u))))
      set sum = sum + GetUnitStrength(u)
    //endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  //call Trace("A HERO strength added: " + Int2Str(GetPlayerHeroStrengthMod(p)))
  return sum + I2R(GetPlayerHeroStrengthMod(p))


endfunction

//============================================================================
function GetUnexactPlayerStrength takes player p returns integer
  local integer pid = GetPlayerId(p)
  if p_str_cache_timeout[pid] < ai_time then
    set p_str_cache[pid] = Max(0, R2I(GetPlayerStrength(p) * GetRandomReal(1 - I2R(uncertainty)/50, 1 + I2R(uncertainty)/50)) + GetRandomDiff(uncertainty/5))
    set p_str_cache_timeout[pid] = ai_time + p_str_cache_valid_time
  endif
  return p_str_cache[pid]
endfunction

//============================================================================
function GetMaximumEnemyStrength takes nothing returns integer
  local integer i = 0
  local integer max = 0
  local player p = null
  loop
    exitwhen i >= c_enemy_total
    set p = enemy_force[i]
    if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING then
      set max = Max(max, R2I(GetPlayerStrength(p)))
    endif
    set i = i + 1
  endloop
  set p = null
  return max
endfunction

//==========================================================================
// (AMAI) Get Player Strength in certain areas
//==========================================================================
#INCLUDETABLE <$VER$\Strengths.txt>
function GetPlayer%1Strength takes player p returns real
  local real strength = 0
  #DEFINE $STRENGTHNUM$ %row
  #INCLUDETABLE <$VER$\StandardUnits.txt> #EFR #COND %#OEVAL{16+$STRENGTHNUM$} != 0
  set strength = strength + %#OEVAL{16+$STRENGTHNUM$} * GetPlayerUnitTypeCount(p, o%1 )
  #ENDINCLUDE
  #DEFINE $CSTRENGTH$ %1
  #INCLUDETABLE <$VER$\StrengthPredictionRules.txt> #EFR #COND '%1' eq '$CSTRENGTH$'
  if ai_time >= %2 and ai_time <= %3 and %4 then
    set strength = strength + %5
  endif
  #ENDINCLUDE
  return strength
endfunction
#ENDINCLUDE

//============================================================================
function GetPlayerAntiAirStrength takes player p returns integer
  local group g = CreateGroup()
  local unit u = null
  local real sum = 0

  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectUnittype(g, UNIT_TYPE_ATTACKS_FLYING, true)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, false)
  set g = SelectByHidden(g, false)
  //set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) then  //and IsUnitType(u, UNIT_TYPE_ATTACKS_FLYING) and not IsUnitType(u, UNIT_TYPE_STRUCTURE) and not IsUnitHidden(u) then
      set sum = sum + GetUnitStrength(u)
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return R2I(sum)
endfunction

//============================================================================
function IsCreepsAwake takes real x, real y, real radius returns boolean
  local group g = CreateGroup()
  local unit u = null
  local boolean awake_creeps = false

  call GroupEnumUnitsInRange(g,x,y,radius,null)
  set g = SelectByPlayer(g, Player(PLAYERAGGRESSIVE), true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null or awake_creeps
    if UnitAlive(u) then
      set awake_creeps = not IsUnitType(u, UNIT_TYPE_SLEEPING)
    endif
    call GroupRemoveUnit(g,u)
  endloop

  call DestroyGroup(g)
  set g = null
  set u = null
  return awake_creeps
endfunction

//============================================================================
function GetLocationCreepStrength takes real x, real y, real radius returns integer
  local group g = CreateGroup()
  local real sum = 0
  local real strength = 0
  local unit u = null
  local real airsum = 0
  set no_sleep = false
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  set g = SelectByPlayer(g, Player(PLAYERAGGRESSIVE), true)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if not IsUnitHidden(u) then
      //call Trace("Getting unit strength begin")
      set strength = GetUnitStrength(u)
      set sum = sum + strength
      if IsUnitType(u, UNIT_TYPE_FLYING) then
        set airsum = airsum + strength
      endif
      if not UnitCanSleep(u) then
        set no_sleep = true
      endif
      //call Trace("Getting unit strength end")
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  set air_strength = R2I(airsum + 0.5)
  return R2I(sum + 0.5)
endfunction

//============================================================================
function GetLocationCreepAirStrength takes real x, real y, real radius returns integer
  local group g = CreateGroup()
  local unit u = null
  local real airsum = 0
  set no_sleep = false
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  set g = SelectByPlayer(g, Player(PLAYERAGGRESSIVE), true)
  set g = SelectByAlive(g, true)
  set g = SelectByHidden(g, false)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitType(u, UNIT_TYPE_FLYING) then
        set airsum = airsum + GetUnitStrength(u)
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return R2I(airsum + 0.5)
endfunction

//============================================================================
function GetLocationNonCreepStrength takes real x, real y, real radius returns integer
  local group g = CreateGroup()
  local real sum = 0
  local real strength = 0
  local unit u = null
  local real airsum = 0
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, false)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, false)
  set g = SelectByAlive(g, true)
  set g = SelectByHidden(g, false)
  set g = SelectByPlayer(g, Player(PLAYERAGGRESSIVE), false)
  set g = SelectByPlayer(g, Player(PLAYERPASSIVE), false)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsPlayerEnemy(ai_player, GetOwningPlayer(u)) and not (UnitInvis(u) and not IsUnitDetected(u, ai_player)) then
      set strength = GetUnitStrength(u)
      set sum = sum + strength
      if IsUnitType(u, UNIT_TYPE_FLYING) then
        set airsum = airsum + strength
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  set air_strength = R2I(airsum + 0.5)
  return R2I(sum + 0.5)
endfunction

//============================================================================
function GetLocationEnemyStructures takes real x, real y, real radius returns integer
  local group g = CreateGroup()
  local integer sum = 0
  local unit u = null
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  set g = SelectByPlayer(g, Player(PLAYERAGGRESSIVE), false)
  set g = SelectByPlayer(g, Player(PLAYERPASSIVE), false)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  set g = SelectByAlive2(g, true)
  set g = SelectByHidden(g, false)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsPlayerEnemy(ai_player, GetOwningPlayer(u)) then
      set sum = sum + 1
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return sum
endfunction

//============================================================================
function IsUnitTower takes unit u returns boolean
  if IsUnitType(u, UNIT_TYPE_STRUCTURE) == true and IsUnitType(u, UNIT_TYPE_RANGED_ATTACKER) == true and not IsUnitHidden(u) then
    return true
  endif
  return false
endfunction

//============================================================================
function GetLocationTowerStrength takes real x, real y, real radius returns integer
  local group g = CreateGroup()
  local unit u = null
  local integer sum = 0
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  set g = SelectByAlive(g, true)
  set g = SelectByHidden(g, false)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsPlayerEnemy(ai_player, GetOwningPlayer(u)) and IsUnitTower(u) then
      set sum = sum + 1
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return sum
endfunction

//============================================================================
function GetLocationStrength takes real x, real y, real radius returns real
  local group g = CreateGroup()
  local real sum = 0
  local real strength = 0
  local unit u = null
  local real airsum = 0
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, false)
  set g = SelectByAlive(g, true)
  set g = SelectByHidden(g, false)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if not (UnitInvis(u) and not IsUnitDetected(u, ai_player)) then
      set strength = GetUnitStrength(u)
      set sum = sum + strength
      if IsUnitType(u, UNIT_TYPE_FLYING) then
        set airsum = airsum + strength
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  set air_strength = R2I(airsum + 0.5)
  return sum
endfunction

//============================================================================
// Adds the global setting bonuses to the creep camp depending on if its green, orange or red
function GetCreepBonus takes unit u, real radius returns integer
  local integer i = GetLocationCreepStrength(GetUnitX(u), GetUnitY(u), radius)
  //call Trace("Got bonus")
  if i >= 20 then
    return i + red_creep_camp_strength_bonus
  elseif i >= 10 then
    return i + orange_creep_camp_strength_bonus
  else
    return i + green_creep_camp_strength_bonus
  endif
endfunction

//============================================================================
function GetExpansionStrength takes nothing returns integer
  //call Trace("Getting expansion strength")
  return GetCreepBonus(current_expansion, expansion_radius)
endfunction

//============================================================================
function GetCreepCampStrength takes unit u returns integer
  return GetCreepBonus(u, creep_camp_radius)
endfunction

//============================================================================
function GetOwnStrength takes nothing returns integer
  local real sum = 0
  local group g = CreateGroup()
  local unit u = null
  local integer max_ghouls = attacking_ghouls
  local integer ghoul_num = 0
  local real airsum = 0
  local real strength = 0
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectByHidden(g, false)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, false)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, false)
  set g = SelectUnittype(g, UNIT_TYPE_HERO, false)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if not IsUnitInGroup(u, unit_healing) then
    //if UnitAlive(u) and not IsUnitType(u, UNIT_TYPE_PEON) and not IsUnitType(u, UNIT_TYPE_HERO) and not IsUnitType(u, UNIT_TYPE_STRUCTURE) and not IsUnitInGroup(u, unit_healing) and not IsUnitHidden(u) then
      set strength = GetUnitStrength(u)
      if GetUnitTypeId(u) == old_id[racial_ghoul] then
        if ghoul_num < max_ghouls then
          set sum = sum + strength
          set ghoul_num = ghoul_num + 1
        endif
      else
        set sum = sum + strength
      endif
      if IsUnitType(u, UNIT_TYPE_ATTACKS_FLYING) then
        set airsum = airsum + strength
      endif
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  set air_strength = R2I(airsum + 0.5)
  return R2I(sum) + GetPlayerHeroStrengthMod(ai_player)
endfunction

//============================================================================
// (AMAI) Time Priority Queue (Controls Job Timings)
//============================================================================
function GetTQLock takes nothing returns nothing
  loop
    exitwhen tq_lock
    call Sleep(0.5)
  endloop
  set tq_lock = false
endfunction

//============================================================================
function ReleaseTQLock takes nothing returns nothing
  set tq_lock = true
endfunction

//============================================================================
function TQDisplay takes nothing returns nothing
  local integer i = 1
  call DisplayToAll("Displaying heap")
  loop
    exitwhen i > tq_length
    call DisplayToAll(Int2Str(R2I(tq_time[i])) + " " + Int2Str(tq_jid[i]))
    set i = i + 1
  endloop
endfunction

//============================================================================
function TQCopy takes integer spos, integer tpos returns nothing
  set tq_time[tpos] = tq_time[spos]
  set tq_jid[tpos] = tq_jid[spos]
  set tq_par[tpos] = tq_par[spos]
  set tq_unit_par[tpos] = tq_unit_par[spos]
  set tq_group_par[tpos] = tq_group_par[spos]
endfunction

//============================================================================
function TQExchange takes integer pos1, integer pos2 returns nothing
  call TQCopy(pos2, tq_length+1)
  call TQCopy(pos1, pos2)
  call TQCopy(tq_length+1, pos1)
endfunction

//============================================================================
function TQUpHeap takes integer pos returns nothing
  if tq_time[pos] < tq_time[pos/2] then
    call TQExchange(pos, pos/2)
    call TQUpHeap(pos/2)
  endif
endfunction

//============================================================================
function TQFillPos takes integer pos returns integer
  local integer lpos = 2*pos
  local integer rpos = 2*pos + 1
  if lpos > tq_length then
    return pos
  elseif rpos > tq_length then
    call TQCopy(lpos, pos)
    return lpos
  elseif tq_time[lpos] <= tq_time[rpos] then
    call TQCopy(lpos, pos)
    return TQFillPos(lpos)
  else
    call TQCopy(rpos, pos)
    return TQFillPos(rpos)
  endif
endfunction

//============================================================================
function TQRemoveRoot takes nothing returns nothing
  local integer pos = 0
  call GetTQLock()
  set pos = TQFillPos(1)
  set tq_length = tq_length - 1
  if pos <= tq_length then
    call TQCopy(tq_length + 1, pos)
    call TQUpHeap(pos)
  endif
  call ReleaseTQLock()
endfunction

//============================================================================
function TQAddJobEx takes real time, integer jid, integer par, unit unit_par, group group_par returns nothing
  call GetTQLock()
  set tq_length = tq_length + 1
  set tq_time[tq_length] = time
  set tq_jid[tq_length] = jid
  set tq_par[tq_length] = par
  set tq_unit_par[tq_length] = unit_par
  set tq_group_par[tq_length] = group_par
  call TQUpHeap(tq_length)
  call ReleaseTQLock()
endfunction

//============================================================================
function TQAddJob takes real time, integer jid, integer par returns nothing
  call TQAddJobEx(TimerGetElapsed(tq_timer) + time, jid, par, null, null)
endfunction

//============================================================================
function TQAddUnitJob takes real time, integer jid, integer par, unit unit_par returns nothing
  call TQAddJobEx(TimerGetElapsed(tq_timer) + time, jid, par, unit_par, null)
endfunction

//============================================================================
function TQAddGroupJob takes real time, integer jid, integer par, unit unit_par, group group_par returns nothing
  call TQAddJobEx(TimerGetElapsed(tq_timer) + time, jid, par, unit_par, group_par)
endfunction

//==============================================================
// (AMAI) Scanning functions
//==============================================================

//  OLD SCANNING FUNCTIONS REMOVED

//==============================================================
// (AMAI) Pathing functions
//==============================================================

// OLD PATHING FUNCTIONS REMOVED

//============================================================================
function GetLocationInDistanceFromLoc takes location loc, real dist returns location
  //local integer groundid = 'ewsp'
  local real distance = 0
  local real x = 0
  local real y = 0
  local unit u = null
  //local real checktime = 0
  local boolean exitloop = false
  if loc == null then
    return null
  endif 
  // if GetPlayerRace(ai_player) == RACE_NIGHTELF then
  //   set groundid = 'uaco' // alternative for night elf players to avoid it counting for players peon count
  // endif
  set u = CreatePathingUnitFull(u,Player(PLAYERPASSIVE), groundid, GetLocationX(loc),GetLocationY(loc))
  call IssuePointOrder(u, "move", GetLocationX(home_location), GetLocationY(home_location))
  //set checktime = GetTimeToReachLoc(u, home_location)
  loop
    exitwhen (exitloop == true)
    set x = GetUnitX(u)
    set y = GetUnitY(u)
    set distance = DistanceBetweenPoints_dk(Location(x,y), loc)
    if distance >= dist then
      //call DisplayToAll("loc found")
      call RemoveUnit(u)
      set u = null
      return Location(x,y)
    elseif GetUnitState(u, UNIT_STATE_LIFE) <= 0 or GetUnitCurrentOrder(u) == OrderId("stop") or GetUnitCurrentOrder(u) != OrderId("move") then
      set exitloop = true
      //return null
    endif
    call Sleep(0.2)
  endloop
  call RemoveUnit(u)
  set u = null
  return null
endfunction


//============================================================================
function GetLocationInDistanceFromBaseToLoc takes location loc, real d returns location
  local real distance = 0
  local real x = 0
  local real y = 0
  local unit u = null
  //local real checktime = 0

// call DisplayToAll("Checking")
// call PingMinimap(GetLocationX(start_loc), GetLocationY(start_loc), 20)
  set u = CreatePathingUnit(u)
  call IssuePointOrderLoc(u, "move", loc)
  //set checktime = GetTimeToReachLoc(u, loc)
  loop
    set x = GetUnitX(u)
    set y = GetUnitY(u)
    set distance = DistanceBetweenPoints_dk(Location(x,y), home_location)
    if distance >= d then
//        call DisplayToAll("loc found")
//        call PingMinimap(GetLocationX(l), GetLocationY(l), 20)
      call RemoveUnit(u)
      set u = null
      return Location(x,y)
    elseif GetUnitState(u, UNIT_STATE_LIFE) <= 0 or GetUnitCurrentOrder(u) == OrderId("stop") or GetUnitCurrentOrder(u) != OrderId("move") then
      call RemoveUnit(u)
      set u = null
//        call DisplayToAll("loc not found")
      return null
    endif
    call Sleep(0.2)
  endloop
  call RemoveUnit(u)
  set u = null
  return null
endfunction

//============================================================================
function GetBuildLocationInDistanceFromLoc_d takes integer id, location loc, real distance returns location
  local location buildloc = GetLocationInDistanceFromLoc(loc, distance)
  local unit u = null
  local real x = 0
  local real y = 0

  call RemoveLocation(loc)
  if buildloc != null then
    set u = CreateUnit(Player(PLAYERPASSIVE), id, GetLocationX(buildloc), GetLocationY(buildloc), 270.0)
    call RemoveLocation(buildloc)
    set buildloc = null
    set x = GetUnitX(u)
    set y = GetUnitY(u)
    call RemoveUnit(u)
    set u = null
    return Location(x,y)
  endif
  return null
endfunction

//============================================================================
// Gets the best location to build a lumber mill building
//============================================================================
function GetLumberLocationAtBase takes nothing returns location
  local integer ground_id = old_id[racial_peon]	//human peasant
  local real distance = 0
  local real x = 0
  local real y = 0
  local unit u = null
  if race_has_ghouls then
    set ground_id = old_id[racial_ghoul]
  endif
  set u = CreatePathingUnitFull(u, Player(PLAYERPASSIVE), ground_id, GetLocationX(home_location), GetLocationY(home_location))
  call IssueImmediateOrder(u, "autoharvestlumber")
  call Sleep(5.00)
  set x = GetUnitX(u)
  set y = GetUnitY(u)
  call RemoveUnit(u)
  set u = null
  return Location(x,y)
endfunction

function BuildLumberMillAtBase takes nothing returns boolean
  local location buildloc = GetLumberLocationAtBase()
  local unit u = null
  local unit peon = GetExpansionPeon()
  local boolean b = false
  if buildloc != null then
    if peon == null then
      set peon = GetExpansionPeon2(peon)
    endif
    set u = CreateUnitAtLoc(Player(PLAYERPASSIVE), old_id[racial_lumber], buildloc, 270.0)
    call RemoveLocation(buildloc)
    set buildloc = GetUnitLoc(u)
    call RemoveUnit(u)
    set u = null
    set b = IssuePointOrderByIdLoc(peon, old_id[racial_lumber], buildloc)
    call RemoveLocation(buildloc)
    set buildloc = null
  endif
  set peon = null
  if TownCount(racial_hall[2]) > 0 and GetUnitCount(racial_lumber) == 0 then
    set racial_lumber = -1  //Prevent always cannot build
  endif
  return b
endfunction

//============================================================================
// Gets the best location to build a RushCreep building , if use GetCreepCamp , then location cannot control
//============================================================================
function BuildBRAtCreep takes nothing returns nothing
  local integer i = 0
  local integer r = 0
  local integer s = 0
  local integer ru = 0
  local real distance = 3200
  local group g = CreateGroup()
  local unit u = null
  local unit array ua
  local unit array ub
  local unit array uc
  local location loc = null
  call GroupEnumUnitsInRange(g,GetLocationX(home_location), GetLocationY(home_location),distance,null)
  set g = SelectByPlayer(g, Player(PLAYERAGGRESSIVE), true)
  set g = SelectUnittype(g, UNIT_TYPE_FLYING, false)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null or i >= 7  //7 shoul have 2 creepcamp
    if GetUnitLevel(u) < 5 and (uc[0] == null or (uc[0] != null and DistanceBetweenUnits(u, uc[0]) > 600) or (uc[1] != null and DistanceBetweenUnits(u, uc[1]) > 600)) then  //maybe have same camp creep unit not cleaned up
      set ua[i] = CreatePathingUnit(ua[i])
      call IssuePointOrder(ua[i], "move", GetUnitX(u), GetUnitY(u))
      set ub[i] = CreatePathingUnitFull(ub[i],ai_player,groundid,GetUnitX(u), GetUnitY(u))
      call IssueTargetOrder(ub[i], "smart", ua[i])  //go in opposite directions , save time
      set uc[i] = u
      set i = i + 1
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  set u = null
  if i == 0 then
    return
  endif
  set ru = i
  loop
    if i == ru then
      set i = 0
    endif
    exitwhen loc != null or s == ru
    if (DistanceBetweenUnits(ua[i], ub[i]) < 200 or DistanceBetweenUnits(ua[i], uc[i]) < 600) and GetUnitState(uc[i], UNIT_STATE_LIFE) > 0 then
      set loc = GetUnitLoc(uc[i])
      set rushcreep_target = uc[i]
    elseif GetUnitState(ua[i], UNIT_STATE_LIFE) <= 0 or GetUnitCurrentOrder(ua[i]) == OrderId("stop") or GetUnitCurrentOrder(ua[i]) != OrderId("move") or DistanceBetweenPoints_kd(home_location,GetUnitLoc(ua[i])) > 3200 then
      set s = s + 1
    elseif GetUnitState(ub[i], UNIT_STATE_LIFE) <= 0 or DistanceBetweenPoints_kd(home_location,GetUnitLoc(ub[i])) > 3200 then
      set s = s + 1
    elseif GetUnitState(uc[i], UNIT_STATE_LIFE) <= 0 then
      set s = s + 1
    endif
    set i = i + 1
    call Sleep(0.05)
  endloop
  set i = 0
  loop
    exitwhen i == ru
    call RemoveUnit(ua[i])
    set ua[i] = null
    call RemoveUnit(ub[i])
    set ub[i] = null
    set uc[i] = null
    set i = i + 1
  endloop
  if s == ru or loc == null then  // fail , not found creep
    return
  endif
  set loc = GetBuildLocationInDistanceFromLoc_d(old_id[racial_rushcreep], loc, 600)
  if loc != null and DistanceBetweenPoints(loc, home_location) < distance then  //Prevent some islands/shallow water terrain from creating u on the other side of the map
    set g = CreateGroup()
    call GroupEnumUnitsInRangeOfLoc(g, loc, 510, null)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null or s == -2
      if IsPlayerEnemy(GetOwningPlayer(u), ai_player) then  //if have enemy , cannot build (if use getlocationstrength need judge twice -- creep and player)
        set s = -2
      endif
      call GroupRemoveUnit(g,u)
    endloop
    if s != -2 then
      set u = GetExpansionPeon2(u)
      if u == null or GetUnitCurrentOrder(u) != OrderId("harvest") then
        call GroupClear(g)
        call GroupEnumUnitsOfPlayer(g, ai_player, null)
        set g = SelectUnittype(g, UNIT_TYPE_PEON, true)
        set g = SelectByLoaded(g, true)
        set u = FirstOfGroup(g)
        call IssueTargetOrder(own_town_mine[0], "unload", u)
        call Sleep(0.01)
      endif
      call RemoveGuardPosition(u)  // no need reset guard , the tree can train
      call IssuePointOrderByIdLoc(u, old_id[racial_rushcreep], loc)
    endif
    call DestroyGroup(g)
    set g = null
    set u = null
  endif
  call RemoveLocation(loc)
  set loc = null
endfunction

//home_location have multiple mine
function MultipleMinefix takes nothing returns boolean
  local real i = 0
  local real c = 0
  local real distance = 1500
  local group g = null
  local unit mine = null
  local unit u = null
  local boolean b = true
  if town_threatened or not hero_built[1] or (GetGold() < 600 and GetWood() < 400) or (not race_manual_loading and not race_uses_mine_expansion) or (race_manual_loading and TownCount(race_manual_loading_mine) > 1) or (race_uses_mine_expansion and TownCount(racial_expansion) > 1) then
    return b  //no first hero priority build army , human and orc just harvest
  endif
  call Trace("Check Multiple Mine")
  set g = CreateGroup()
  call GroupEnumUnitsInRangeOfLoc(g, home_location, 1500, null)
  set g = SelectById(g, old_id[GOLD_MINE], true)
  set g = SelectByAlive(g, true)
  set u = FirstOfGroup(g)
  call GroupRemoveUnit(g, u)  //remove one mine
  if (FirstOfGroup(g) == null and not race_manual_loading and not race_uses_mine_expansion) or u == null then
    call DestroyGroup(g)  // prevent now still have one mine(if gorup first unit now not null , have two mine , still need fix) , but human and orc can return to normal
    set g = null
    set u = null
    if not race_manual_loading then
      set first_town_mine = -1  //home_location only one or no mine , if not ELF , need end HARVEST CHECK job
    else
      set first_town_mine = 0
    endif
    return false
  endif
  call GroupAddUnit(g, u)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetResourceAmount(u) > 0 then
      set i = DistanceBetweenPoints_kd(home_location,GetUnitLoc(u))
      if i <= distance then
        set distance = i
        set mine = u
      endif
      set c = c + 1
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  if race_manual_loading and TownCount(race_manual_loading_mine) < 1 then
    set u = GetOneOfIdNearLoc(u,ai_player,old_id[racial_expansion],home_location,1500)
    if u != null then
      call IssueTargetOrder(u, "entangle", mine)  // first entangle , no need build
      set u = null
    else
      set b = false
    endif
  elseif c > 2 then  //prevent build too much TOWNHALL
    set current_expansion = mine  //expansion mine
    set not_taken_expansion = mine
    set b = false
  endif
  set mine = null
  return b
endfunction

//============================================================================
function CheckExpansionTaken takes unit expa returns boolean
  local group g = null
  local unit u = null
  if expa == null then
    return false
  elseif expa == not_taken_expansion then // Used in the ancient expansion and item expansion system
    return true
  endif
  set g = CreateGroup()
  call GroupEnumUnitsInRange(g, GetUnitX(expa), GetUnitY(expa), expansion_taken_radius, null)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  set g = SelectByPlayer(g, Player(PLAYERPASSIVE), false)
  //set g = SelectByAlive(g, true)
  set g = SelectByAlive2(g, true)
  call GroupRemoveUnit(g, expa)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == old_id[racial_expansion] or IsUnitType(u,UNIT_TYPE_TOWNHALL) then
      call DestroyGroup(g)
      set g = null
      set u = null
      if not IsUnitHidden(u) then
        call GroupRemoveUnit(far_expansion, expa)
      endif
      return true
    elseif GetOwningPlayer(u) != ai_player and GetOwningPlayer(u) != Player(PLAYERAGGRESSIVE) then		// Creeps dosn't mean expansion is taken
      call DestroyGroup(g)
      set g = null
      set u = null
      return true
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  return false
endfunction

// Prevent some map creeps too far away
function CheckCreepsByRadius takes group g , unit u , real n returns group
  call GroupClear(g)
  call GroupEnumUnitsInRange(g, GetUnitX(u), GetUnitY(u), n, null)
  set g = SelectByPlayer(g, Player(PLAYERAGGRESSIVE), true)
  set g = SelectByAlive(g, true)
  return g
endfunction

//  Gets the groups of creeps guarding the specified mine (or other structure)
function GetExpFoeGroup takes group g , unit mine returns group
  set g = CreateGroup()
  call GroupEnumUnitsInRange(g, GetUnitX(mine), GetUnitY(mine), expansion_radius, null)
  set g = SelectByPlayer(g, Player(PLAYERAGGRESSIVE), true)
  set g = SelectByAlive(g, true)
  if FirstOfGroup(g) == null then
    set g = CheckCreepsByRadius(g, mine, expansion_radius * 1.5)
  endif
  return g
endfunction

function GetCreepGuardGroup takes group g , integer nn returns group
  if g != null then
    call DestroyGroup(g)
  endif
  set g = CreateGroup()
  if nearest_neutral[nn] == null then
    return g
  endif
  call GroupEnumUnitsInRange(g, GetUnitX(nearest_neutral[nn]), GetUnitY(nearest_neutral[nn]), 750, null)
  set g = SelectByPlayer(g, Player(PLAYERAGGRESSIVE), true)
  set g = SelectByAlive(g, true)
  if FirstOfGroup(g) == null and nn != NEUTRAL_TAVERN then
    set g = CheckCreepsByRadius(g, nearest_neutral[nn], 750 * 1.5)
  endif
  return g
endfunction

//==============================================================
function AddExpansion takes unit u, real d returns nothing

  set expansion_list[expansion_list_length] = u
  set expansion_dist[expansion_list_length] = d
  if race_ancient_expansion_available then
    set expansion_ancient[expansion_list_length] = GetBuildLocationInDistanceFromLoc_d(old_id[racial_expansion], GetUnitLoc(u), ver_creeps_attack_buildings_dist + 500)
  endif
  set expansion_creeps[expansion_list_length] = GetExpFoeGroup(expansion_creeps[expansion_list_length],u)  // group of the the creeps that guard this mine
  if first_expansion_chosen == false then
    set first_expansion_chosen = (expansion_creeps[expansion_list_length] != null) or (CheckExpansionTaken(u) == false)
  endif
  set expansion_list_length = expansion_list_length + 1
endfunction

//==============================================================
function AddWaterExpansion takes unit u returns nothing
  set water_expansion_list[water_expansion_list_length] = u
  call GroupAddUnit(water_expansion, u)
  set water_expansion_creeps[water_expansion_list_length] = GetExpFoeGroup(water_expansion_creeps[water_expansion_list_length],u)  // group of the the creeps that guard this mine
  set water_expansion_list_length = water_expansion_list_length + 1
endfunction

//==============================================================
function GetExpNearestMin takes unit ru returns unit
// Return the nearest mine, uses old system so computer has a mine as new system can take a while to calculate

local real distance = 0
local real seconddistance = 0
local unit u = null
local real mindistance = 10000  // max distance away the first mine can be
local real secMaxDistance = 6000  // max distance range second mine must be in
local unit nearmine = null
local unit secondmine = null
local group g = CreateGroup()
local integer rand = GetRandomInt(1,4)
call GroupEnumUnitsOfType(g, "goldmine", null)
loop
  set u = FirstOfGroup(g)
  exitwhen u == null
  if not CheckExpansionTaken(u) and GetLocationCreepStrength(GetUnitX(u), GetUnitY(u), expansion_radius) < 40 then
    set distance = DistanceBetweenPoints_dk(GetUnitLoc(u), home_location)
    if distance < mindistance then
      if mindistance < secMaxDistance then
        set secondmine = nearmine
        set seconddistance = mindistance
      endif
      set mindistance = distance
      set nearmine = u
    elseif distance < seconddistance and distance <= secMaxDistance then
      set seconddistance = distance
      set secondmine = u
    endif
  endif
  call GroupRemoveUnit(g, u)
endloop
call DestroyGroup(g)
set g = null

if secondmine != null then
	if rand <= 3 then
		set secondmine = null
		set ru = nearmine
		set nearmine = null
		return ru
	else
		set nearmine = null
		set ru = secondmine
		set secondmine = null
		return ru
	endif
else
	set secondmine = null
	set ru = nearmine
	set nearmine = null
	return ru
endif
endfunction

//==============================================================
function MakeExpansionList takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  local unit array pather
  local integer array traveltime
  local boolean array patherdone
  local integer i = 0
  local group tempg = null
  local integer checks = 0	// Number of times unit has stayed at same position
  local boolean pathingdone = true
  local real totaltime = 0
  //local integer groundid = 'ewsp'
  //local real distance = 0

  call GroupEnumUnitsOfType(g, "goldmine", null)
//  call GroupRemoveUnit(g, current_expansion) // because quick expansion adds mine already

  call Trace("Find Expansions Create Units")
  set tempg = CopyGroup(g,tempg)
  loop
    set u = FirstOfGroup(tempg)
    exitwhen u == null
    set pather[i] = CreatePathingUnit(pather[i])
    call IssuePointOrder(pather[i], "move", GetUnitX(u), GetUnitY(u))
    call GroupRemoveUnit(tempg, u)
    if (ModuloInteger(i,10) == 0) then
      call Sleep(0.3 * sleep_multiplier) // help spread start lag
    endif
    set i = i + 1
  endloop
  call DestroyGroup(tempg)
  call Trace("Find Expansions Created")
  loop
    set totaltime = totaltime + 3 * (sleep_multiplier)
    set pathingdone = true
    set tempg = CopyGroup(g,tempg)
    set i = 0
    loop
      set u = FirstOfGroup(tempg)
      exitwhen u == null
      if pather[i] != null then
        if DistanceBetweenUnits(pather[i],u) <= buy_distance then
          //call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Tavern is pathable")
          call CreateDebugTag("Target Destination is pathable", 10, pather[i], 3.00, 1.50)
          call RemoveUnit(pather[i])
          set pather[i] = null
          set patherdone[i] = true
          call AddExpansion(u, totaltime)
        //elseif GetUnitCurrentOrder(u) == OrderId("stop") then
          //return (totaltime * -1)
        elseif GetUnitState(pather[i], UNIT_STATE_LIFE) <= 0 then
          call RemoveUnit(pather[i])
          set pather[i] = null
          set patherdone[i] = true
        elseif GetUnitCurrentOrder(pather[i]) == OrderId("stop") or GetUnitCurrentOrder(pather[i]) != OrderId("move") then
          set checks = checks + 1
          call CreateDebugTag("Invisible Path unit has stopped", 10, pather[i], 3.00, 1.50)
          if checks > 1 then
            call CreateDebugTag("Target Destination was not reached", 10, pather[i], 3.00, 1.50)
            call RemoveUnit(pather[i])
            set pather[i] = null
            set patherdone[i] = true
            call AddWaterExpansion(u)
          endif
        else
          set checks = 0	// means unit is moving and not standing still
          call CreateDebugTag("Invisible Path Unit Here", 10, pather[i], 3.00, 1.50)
          //call IssuePointOrder(pather[i], "move", GetUnitX(u), GetUnitY(u))
        endif
        set pathingdone = false
      endif
      call GroupRemoveUnit(tempg, u)
      set i = i + 1
    endloop
    call DestroyGroup(tempg)
    exitwhen pathingdone
    call Sleep(1 * sleep_multiplier)
  endloop
  call DestroyGroup(g)
  set g = null
  set tempg = null
  call Trace("Expansion number: " + Int2Str(expansion_list_length))

//  loop
//    set u = FirstOfGroup(g)
//    exitwhen u == null
//    set l = GetUnitLoc(u)
//    set timeaway = CanPathToLoc(start_loc, l, PATHING_TYPE_WALKABILITY)
//    if timeaway > 0 then
//      call AddExpansion(u, timeaway)
//    else
//  This requires use of transports to work
//  NYI
//      call AddWaterExpansion(u)
//    endif
//    call GroupRemoveUnit(g, u)
//    call RemoveLocation(l)
//    set l = null
//  endloop

endfunction

//============================================================================
// (AMAI) ChooseExpansion
//============================================================================
function make_exp_rp_positive takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= exp_number
    if exp_rp[i] < 0 then
      set exp_rp[i] = 0
    endif
    set i = i + 1
  endloop
endfunction

//============================================================================
function sum_exp_rp takes nothing returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i >= exp_number
    set sum = sum + exp_rp[i]
    set i = i + 1
  endloop
//  call DisplayToAll("Sum is " + Int2Str(sum))
//  call DisplayToAll("exp_number is " + Int2Str(exp_number))
  return sum
endfunction

//============================================================================
function ChooseExp takes nothing returns integer
// This function returns a mine to expand to.

  local integer i = 1
  local integer sum = 0
  local integer exp_roll = GetRandomInt(1,100)
  local integer first = 0
  local integer second = 0
  local integer third = 0
  local integer riskyexp = GetRandomInt(1, exp_number - 1)
  loop
    exitwhen i >= exp_number
    if exp_rp[i] < exp_rp[first] then
      set third = second
      set second = first
      set first = i
    else
      if exp_rp[i] < exp_rp[second] then
        set third = second
        set second = i
      else
        if exp_rp[i] < exp_rp[third] then
          set third = i
        endif
      endif
    endif
    set i = i + 1
  endloop
  if (exp_roll <= 80) then
    return first  // The closest expansion choice
  elseif (exp_roll <= 100) then
    return second // The second closest expansion choice
  else
    return riskyexp  // Complete Random choice (effectively disabled at the moment)
  endif
  return 0
endfunction

//============================================================================
function remove_exp takes integer h returns nothing
  local integer i = h
  set exp_number = exp_number - 1
  loop
    exitwhen i >= exp_number
    set exp_rp[i] = exp_rp[i + 1]
    set exp_unit[i] = exp_unit[i + 1]
    set exp_dist[i] = exp_dist[i + 1]
    set i = i + 1
  endloop
endfunction

//============================================================================
function add_exp takes unit u, real dist, location ancient, group creeps returns nothing
  set exp_unit[exp_number] = u
  set exp_dist[exp_number] = dist
  set exp_ancient[exp_number] = ancient
  set exp_creeps[exp_number] = creeps
  set exp_number = exp_number + 1
endfunction

//============================================================================
function GetNearestEnemyDistance takes nothing returns real
local integer i = 0
local real dist = 0
local real mindistance = 1000000
local real humandistance = 0
local player nearplayer = null
local player nearhumanplayer = null
local group g = CreateGroup()
local unit u = null
local unit tempu = null
local unit temphumanu = null
//loop
//    exitwhen i >= c_enemy_total
//    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
//    set loc = GetPlayerStartLocationLoc(enemy_force[i])
//		set dist = DistanceBetweenPoints_kd(home_location, loc)
//    call RemoveLocation(loc)
//    set loc = null
//		if dist < mindistance then
//			set mindistance = dist
//			set nearplayer = p
//		endif
//    endif
//    set i = i + 1
//endloop

loop
	exitwhen i >= c_enemy_total
	if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
		call GroupEnumUnitsOfPlayer(g, enemy_force[i], null)
		set g = SelectUnittype(g, UNIT_TYPE_TOWNHALL, true)
		set g = SelectByAlive(g, true)
		set g = SelectByHidden(g, false)
		if FirstOfGroup(g) == null and GetPlayerRace(enemy_force[i]) == RACE_UNDEAD then
			call GroupClear(g)
			call GroupEnumUnitsOfPlayer(g, enemy_force[i], null)
			set g = SelectById(g, 'ugol', true)  //some human UD player donot build TOWNHALL
			set g = SelectByAlive(g, true)
			set g = SelectByHidden(g, false)
		endif
		loop
			set u = FirstOfGroup(g)
			exitwhen u == null
			set dist = DistanceBetweenPoints_kd(home_location, GetUnitLoc(u))  //GetNearestEnemy base from all base, no longer GetPlayerStartLocationLoc
			if dist < mindistance then
				set mindistance = dist
				set nearplayer = enemy_force[i]
				set tempu = u
				if GetPlayerController(enemy_force[i]) != MAP_CONTROL_COMPUTER then
					set humandistance = dist
					set nearhumanplayer = enemy_force[i]
					set temphumanu = u
				endif
			endif
			call GroupRemoveUnit(g, u)
		endloop
		call GroupClear(g)
	endif
	set i = i + 1
endloop
if c_enemy_user_total == 1 then
	set builder[10] = temphumanu
	set rushedplayer = nearhumanplayer
	set mindistance = humandistance
else
	set builder[10] = tempu
	set rushedplayer = nearplayer
endif
call DestroyGroup(g)
set g = null
set nearplayer = null
set nearhumanplayer = null
set tempu = null
set temphumanu = null
return mindistance
endfunction

//============================================================================
function MinRangeToEnemy takes location l returns real
  local integer i = 0
  local real d = 0
  local real min_d = 1000000

  loop
    exitwhen i >= c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set d = DistanceBetweenPoints_kd(l, GetPlayerStartLocationLoc(enemy_force[i]))
      if d < min_d then
        set min_d = d
      endif
    endif
    set i = i + 1
  endloop
  return min_d
endfunction

//============================================================================
//function WayMinRangeToEnemy takes location l returns real
//  local integer i = GetReachableNearby(GetGridField_k(l), 5)
//  local integer h = home_field
//  local real m = 10000000
//  loop
//    set m = r_minimum(MinRangeToEnemy_d(GetFieldLoc(i)), m)
//    exitwhen i == h
//    set i = path_from[i]
//    exitwhen i == h
//    set i = path_from[i]
//    exitwhen i == h
//    set i = path_from[i]
//  endloop
//  return m
//endfunction
// THESE FUNCTIONS ARE AWAITING require rework to use new pathing method
//============================================================================

//============================================================================
function GetRushFactor takes nothing returns integer
  return R2I(MinRangeToEnemy(home_location)) + (1000*(GetPlayers() - (c_enemy_total + c_ally_total + 1)))
endfunction

//============================================================================
// Returns true if we need to rebuild an expansion and no enemies are around
function CheckExpansionRebuild takes nothing returns boolean
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsInRange(g, GetUnitX(current_expansion), GetUnitY(current_expansion), expansion_taken_radius, null)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  //set g = SelectByPlayer(g, Player(PLAYERPASSIVE), false)  // no need the Select
  set g = SelectByPlayer(g, ai_player, true)
  set g = SelectByAlive(g, true)

  if FirstOfGroup(g) != null then
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      if GetUnitTypeId(u) == old_id[racial_expansion] or IsUnitType(u,UNIT_TYPE_TOWNHALL) == true then
        call DestroyGroup(g)
        set g = null
        set u = null
        return false
      endif
      call GroupRemoveUnit(g, u)
    endloop
    if GetResourceAmount(current_expansion) > 2 * GetUnitGoldCost2(racial_expansion) and GetLocationNonCreepStrength(GetUnitX(current_expansion),GetUnitY(current_expansion),expansion_taken_radius) <= 0 then
      call DestroyGroup(g)
      set g = null
      return true
    endif
  endif
  call DestroyGroup(g)
  set g = null
  return false

endfunction

//============================================================================
function ExpansionFormula takes integer exp_d, unit exp_u returns integer
// Lower Result back is better
  local group g = CreateGroup()
  local unit u = null
// AMAI EDITORS NOTE:- May move into the actual choose_exp function to always rebuild damaged expansion
// -----------------------------------------------------------------------------------------------------

  call GroupEnumUnitsInRange(g, GetUnitX(exp_u), GetUnitY(exp_u), expansion_taken_radius, null)
  //set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  set g = SelectByPlayer(g, ai_player, true)
  set g = SelectByAlive(g, true)

  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitType(u, UNIT_TYPE_STRUCTURE) == true or IsUnitType(u, UNIT_TYPE_PEON) then
      call DestroyGroup(g)
      set g = null
      set u = null
      return R2I(exp_d*0.5)      // Increased likelyhood to build if was once owned by player
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
// -----------------------------------------------------------------------------------------------------

  //return exp_d + R2I(I2R(GetLocationCreepStrength(GetUnitX(exp_u), GetUnitY(exp_u), expansion_radius)) / 2)
  return exp_d

endfunction

//============================================================================
function add_exp_rp takes nothing returns nothing
  local integer i = 0
  local real way_dist = 0.0
  local integer max = 0
  local integer min = 1000000
  local real sv = 0.7
  local integer red = 0
  loop
    exitwhen i >= exp_number
//    set way_dist = WayMinRangeToEnemy_d(GetUnitLoc(exp_unit[i]))
    set exp_rp[i] = ExpansionFormula(R2I(exp_dist[i]), exp_unit[i])
    if exp_rp[i] > max then
      set max = exp_rp[i]
    endif
    if exp_rp[i] < min then
      set min = exp_rp[i]
    endif
//    if way_dist < 1500 then
//      set exp_rp[i] = Max(exp_rp[i] - 30, 1)
//    endif
    set i = i + 1
  endloop
//  if min < 1000000 and max > 0 then
//    set red = Max(R2I(((0.3) * max - min) / sv), -min)
//    if red < 0 then
//      set i = 0
//      loop
//        exitwhen i >= exp_number
//        set exp_rp[i] = Max(exp_rp[i] + red, 1)
//        set i = i + 1
//      endloop
//    endif
//  endif
endfunction

//============================================================================
function IsRacialHall takes unit u, integer min_tier returns boolean
  local integer i = Max(min_tier, 1)
  loop
    exitwhen i > tiernum
    if GetUnitTypeId(u) == old_id[racial_hall[i]] then
      return true
    endif
    set i = i + 1
  endloop
  return false
endfunction

//============================================================================
function IsRacialHallId takes integer id, integer min_tier returns boolean
  local integer i = Max(min_tier, 1)
  loop
    exitwhen i > tiernum
    if id == racial_hall[i] then
      return true
    endif
    set i = i + 1
  endloop
  return false
endfunction

//============================================================================
function ChooseExpansion takes nothing returns nothing
  local integer i = 0
  local integer exp_chosen = 0
  set exp_number = 0
  loop
    exitwhen i >= expansion_list_length
    if GetResourceAmount(expansion_list[i]) > 2 * GetUnitGoldCost2(racial_expansion) and not CheckExpansionTaken(expansion_list[i]) and DistanceBetweenPoints_kd(home_location,GetUnitLoc(expansion_list[i])) > 1500 then
      call add_exp(expansion_list[i], expansion_dist[i], expansion_ancient[i], expansion_creeps[i])
    endif
    set i = i + 1
  endloop
  if exp_number < 3 then  //first taken normal mine
    set i = 0
    loop
      exitwhen i >= water_expansion_list_length
      if not CheckExpansionTaken(water_expansion_list[i]) then
        call add_exp(water_expansion_list[i], 60, null, water_expansion_creeps[i])
      endif
      set i = i + 1
    endloop
  endif
  if active_expansion and exp_number < c_enemy_total + c_ally_total + 1 then
    set active_expansion = false
  endif
  call add_exp_rp()
//  call make_exp_rp_positive()
  if exp_number == 0 then
    set current_expansion = null
    call Trace("No valid expansions")
  else
    set exp_chosen = ChooseExp()
    set current_expansion = exp_unit[exp_chosen]
    set ancient_exp_loc = exp_ancient[exp_chosen]
    set current_expansion_creeps = exp_creeps[exp_chosen]
//    call PingMinimap(GetUnitX(current_expansion), GetUnitY(current_expansion), 20)
  endif
endfunction

//============================================================================
function GetExpFoe takes unit u returns unit
  local group g = null
  local location l = GetUnitLoc(current_expansion)
  //call Trace("Copy group")
  set g = CopyGroup(current_expansion_creeps,g)
  set g = SelectByAlive(g, true)
  set u = GetNearestOfGroup(u, g, l)
  call RemoveLocation(l)
  set l = null
  call DestroyGroup(g)
  set g = null
  //call Trace("Have a foe")
  return u
endfunction

function GetNeutralGuard takes integer nn returns boolean
  local group g = null
  local location l = null
  local unit u = null
  local boolean b = false
  if nearest_neutral[nn] == null or FirstOfGroup(neutral_guards[nn]) == null then
    return b
  endif
  set g = CopyGroup(neutral_guards[nn],g)
  set g = SelectByAlive(g, true)
  set l = GetUnitLoc(nearest_neutral[nn])
  set u = GetNearestOfGroup(u, g, l)
  call RemoveLocation(l)
  set l = null
  call DestroyGroup(g)
  set g = null
  set b = (u != null)
  set u = null
  return b
endfunction

function CanCreepGuardsSleep takes integer nn returns boolean
  local group g = null
  local unit u = null
  local boolean b = false
  if nearest_neutral[nn] == null then
    return b
  endif
  if FirstOfGroup(neutral_guards[nn]) == null then
    return true
  endif
  set g = CopyGroup(neutral_guards[nn],g)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    exitwhen not UnitCanSleep(u)
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  set b = (u == null)
  set u = null
  return b
endfunction

//============================================================================
function SetAIArray takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= PLAYERAGGRESSIVE
    if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(Player(i)) == MAP_CONTROL_COMPUTER and LoadBoolean(com, IS_AMAI, i) then
      set ai_force[ai_force_length] = i
      set ai_force_length = ai_force_length + 1
    endif
    set i = i + 1
  endloop
endfunction

//============================================================================
function CheckFastExpansion takes nothing returns nothing
  local integer es = 0
  //local location expanloc = null
  local real timeaway = 0
  //local location l = null
  //local unit firstexp = null

//  call GetExpNearestMin(firstexp)
//  set l = GetUnitLoc(firstexp)
//  set timeaway = CanPathToLoc(start_loc, l, PATHING_TYPE_WALKABILITY)
//  if timeaway > 0 then
//	set current_expansion = firstexp
//  	call AddExpansion(current_expansion, timeaway)
//	call Trace("CheckFastExpansion: Quick Mine Calculated")
//	set ancient_exp_loc = expansion_ancient[expansion_list_length - 1]
//	set current_expansion_creeps = expansion_creeps[expansion_list_length - 1]
//  endif

  //set firstexp = null

  if current_expansion != null then
    set es = GetExpansionStrength()
    //MinRangeToEnemy(l) > 7000
    if GetRandomInt(1,2) == 1 and GetPlayers() > 2 and MinRangeToEnemy(home_location) > 7000 and es <= 0 then
      set exp_time_count = -exp_first_time
    endif
    //call RemoveLocation(l)
    //set l = null
  endif
endfunction

//============================================================================
function AddFrontPoint takes location l returns nothing
  local real x = GetLocationX(l)
  local real y = GetLocationY(l)
  local unit pathable = CreateUnit(Player(PLAYERPASSIVE), groundid, x, y, 270.00)
  if DistanceBetweenPoints_dk(GetUnitLoc(pathable), l) <= 200 then
    call CreateDebugTagLoc("Front Point Added", 10, x, y, 60.00, 55.00)
    set front_loc[front_loc_num] = l
    set front_loc_num = front_loc_num + 1
  else
    //call CreateDebugTagLoc("Front Point : Not Buildable", 10, x, y, 60.00, 55.00)
    call RemoveLocation(l)
  endif
  call RemoveUnit(pathable)
  set pathable = null
endfunction

//============================================================================
function ComputeFrontPoints takes nothing returns nothing
  local integer i = 0
  local integer n = 0
  local player p = null
  local unit array u
  local location loc = null
  local player mainplayer = Player(GetAiPlayer())
  local boolean pathingdone = true
  local boolean array patherdone
  local location l = null
  local real distance = 0
  loop
    exitwhen i >= c_enemy_total
    set p = enemy_force[i]
    if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING then
      set loc = GetPlayerStartLocationLoc(p)
      set u[n] = CreatePathingUnit(u[n])
      call IssuePointOrder(u[n], "move", GetLocationX(loc), GetLocationY(loc))
      call RemoveLocation(loc)
      set n = n + 1
    endif
    set i = i + 1
  endloop

  loop
    set pathingdone = true
    set i = 0
    loop
      exitwhen i >= n
      if patherdone[i] == false then
        if u[i] != null then
          set l = GetUnitLoc(u[i])
          set distance = DistanceBetweenPoints(l, home_location)
          if distance >= front_base_distance then
            call CreateDebugTag("Front Point Found", 10, u[i], 10.00, 8.00)
            call RemoveUnit(u[i])
            set u[i] = null
            set patherdone[i] = true
            call AddFrontPoint(Location(GetLocationX(l),GetLocationY(l)))
            call AddFrontPoint(AIGetProjectedLoc(l, home_location, 100, 90))
            call AddFrontPoint(AIGetProjectedLoc(l, home_location, 100, -90))
            call AddFrontPoint(AIGetProjectedLoc(l, home_location, 200, 80))
            call AddFrontPoint(AIGetProjectedLoc(l, home_location, 200, -80))
          elseif GetUnitState(u[i], UNIT_STATE_LIFE) <= 0 or GetUnitCurrentOrder(u[i]) == OrderId("stop") or GetUnitCurrentOrder(u[i]) != OrderId("move") then
            set patherdone[i] = true
            call RemoveUnit(u[i])
            set u[i] = null
          //else
            //call RemoveLocation(l)
          endif
          call RemoveLocation(l)
          set pathingdone = false
        endif
      endif
      set i = i + 1
    endloop
    exitwhen pathingdone
    call Sleep(0.1)
  endloop

  set front_locs_computed = true
  set l = null
  set loc = null
  set p = null
  set mainplayer = null

endfunction

//============================================================================
function PingFrontPoints takes nothing returns nothing
  local integer i = 0
  local location l = null
  loop
    exitwhen i >= front_loc_num
    set l = front_loc[i]
    call PingMinimap(GetLocationX(l), GetLocationY(l), 20)
    set i = i + 1
  endloop
  set l = null
endfunction

//==========================================================================
// (AMAI) Resource utility functions
//==========================================================================
function GetPlayerGold takes player p returns integer
    return GetPlayerState(p,PLAYER_STATE_RESOURCE_GOLD)
endfunction

function GetPlayerWood takes player p returns integer
    return GetPlayerState(p,PLAYER_STATE_RESOURCE_LUMBER)
endfunction

//============================================================================
// (AMAI) set_aggression
//============================================================================
function set_aggression takes nothing returns nothing
  local integer f = FoodUsed()
  if false then
#INCLUDETABLE <$VER$\AddedAggression.txt> #EFR
  elseif f >= %1 then
    set added_aggression = %2
#ENDINCLUDE
  else
    set added_aggression = 0
  endif

  if GetUnitCountDone(old_id[hero[1]]) == 0 then
    set added_aggression = added_aggression - 10
  endif
endfunction

//============================================================================
// (AMAI) expansion_distance
//============================================================================
function GetExpansionDistance takes nothing returns real
  return DistanceBetweenPoints_kd(home_location,GetUnitLoc(current_expansion))
endfunction

//============================================================================
// (AMAI) Items
//============================================================================
function GetItemNumberOnUnit takes integer id, unit u returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i > 5
    if GetItemTypeId(UnitItemInSlot(u, i)) == old_id[id] then
      set sum = sum + 1
    endif
    set i = i + 1
  endloop
  return sum
endfunction

//============================================================================
function GetItemNumber takes integer id returns integer
  local integer sum = 0
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] then
      set sum = sum + GetItemNumberOnUnit(id, hero_unit[i])
    endif
    set i = i + 1
  endloop
  return sum
endfunction

//============================================================================
function GetItemOfTypeOnUnit takes integer id, unit u returns item
  local integer i = 0
  loop
    exitwhen i > 5
    if GetItemTypeId(UnitItemInSlot(u, i)) == old_id[id] then
      set item_unit = u
      return UnitItemInSlot(u, i)
    endif
    set i = i + 1
  endloop
  return null
endfunction

//============================================================================
function GetItemOfType takes item t, integer id returns item
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] then
      set t = GetItemOfTypeOnUnit(id, hero_unit[i])
      if t != null then
        return t
      endif
    endif
    set i = i + 1
  endloop
  return null
endfunction

//============================================================================
function GetSlotsFreeOnUnit takes unit u returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i > 5
    if UnitItemInSlot(u, i) == null then
      set sum = sum + 1
    endif
    set i = i + 1
  endloop
  return sum
endfunction

//============================================================================
function GetSlotsFree takes nothing returns integer
  local integer sum = 0
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] then
      set sum = sum + GetSlotsFreeOnUnit(hero_unit[i])
    endif
    set i = i + 1
  endloop
  return sum
endfunction

//============================================================================
function GetHeroToBuyItem takes unit shop, real limit, boolean is_healing_included returns unit
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] and UnitAlive(hero_unit[i]) then
      if GetSlotsFreeOnUnit(hero_unit[i]) > 0 and DistanceBetweenUnits(hero_unit[i], shop) < limit and not IsUnitInGroup(hero_unit[i], unit_buying_tavern) and not IsUnitInGroup(hero_unit[i], unit_buying_merc) and not IsUnitInGroup(hero_unit[i], unit_harassing) then
        if IsUnitInGroup(hero_unit[i], unit_healing) == is_healing_included then
        else
          return hero_unit[i]
        endif
      endif
    endif
    set i = i + 1
  endloop
  return null
endfunction

//============================================================================
function GetItemHero takes item it returns unit
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] and UnitAlive(hero_unit[i]) then
      if UnitHasItem(hero_unit[i], it) then
        return hero_unit[i]
      endif
    endif
    set i = i + 1
  endloop
  return null
endfunction

//============================================================================
// (AMAI) Save Unit (Attempts to heal or rescue unit from imminent harm)
//============================================================================
function AddHealer takes integer id, integer spell, integer mana_cost,integer t, integer upg_id, integer upg_level returns nothing
  set healer_id[healer_length] = id
  set healer_spell[healer_length] = spell
  set healer_mana_cost[healer_length] = mana_cost
  set healer_type[healer_length] = t
  set healer_upg_id[healer_length] = upg_id
  set healer_upg_level[healer_length] = upg_level
  set healer_length = healer_length + 1
endfunction

//============================================================================
function InitHealers takes nothing returns nothing
#INCLUDETABLE <$VER$\Healers.txt> #EFR #COND "%2" ne "NEUTRAL"
  if own_race == R_%2 then
    call AddHealer(o%1, %4, %5, HEALER_TYPE_%3, o%6, %7)
  endif
#ENDINCLUDE
  if false then
#INCLUDETABLE <$VER$\Healers.txt> #EFR #COND "%2" eq "NEUTRAL"
  elseif merc_healer == %1 then
    call AddHealer(o%1, %4, %5, HEALER_TYPE_%3, o%6, %7)
#ENDINCLUDE
  endif
endfunction

//============================================================================
function GetHealerId takes integer id returns integer
  local integer i = 0
  loop
    exitwhen i >= healer_length
    if healer_id[i] == id then
      return i
    endif
    set i = i + 1
  endloop
  return -1
endfunction

//============================================================================
function IsUnitHealer takes unit u returns boolean
  if GetUnitState(u, UNIT_STATE_MAX_MANA) <= 0 then
    return false
  else
    if GetHealerId(GetUnitTypeId(u)) >= 0 then
      return true
    endif
  endif
  return false
endfunction

//============================================================================
function HealUnit takes unit healer, unit to_heal, boolean hero_heal returns nothing
  local integer id = GetHealerId(GetUnitTypeId(healer))
  if id == -1 then
    return
  endif
  if healer_type[id] != HEALER_TYPE_NO_TARGET then
    if healer_type[id] == HEALER_TYPE_WARD then
      if not ward_cast then
        call IssuePointOrderById(healer, healer_spell[id], GetUnitX(healer), GetUnitY(healer))
      endif
    else
      if healer_type[id] != HEALER_TYPE_HERO or hero_heal then
        call IssueTargetOrderById(healer, healer_spell[id], to_heal)
      endif
    endif
  endif
endfunction

//============================================================================
function GetHealer takes unit u returns unit
  local integer id = 0
  loop
    set u = FirstOfGroup(healer_group)
    exitwhen u == null
    set id = GetHealerId(GetUnitTypeId(u))
    if id != -1 and GetUnitState(u, UNIT_STATE_MANA) >= healer_mana_cost[id] and ((healer_upg_id[id] == 0) or (GetUpgradeLevel(healer_upg_id[id]) >= healer_upg_level[id])) then
      return u
    endif
    call GroupRemoveUnit(healer_group, u)
  endloop
  return u
endfunction

//============================================================================
function GetArmyOfUnit takes unit u returns integer
  local integer i = 0
  loop
    exitwhen i >= army_num
    if IsUnitInGroup(u, army_group[i]) then
      return i
    endif
    set i = i + 1
  endloop
  return -1
endfunction

//============================================================================
function GroupRecycleGuardPosition takes group g returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call TQAddUnitJob(30, RESET_GUARD_POSITION, 0, u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
endfunction

function GroupRecycleGuardPositionDelay takes group g, real delay returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call TQAddUnitJob(delay, RESET_GUARD_POSITION, 0, u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
endfunction

//============================================================================
//  Get Specialized items
function GetHealingItem takes nothing returns integer
	if false then
#INCLUDETABLE <$VER$\HealingItems.txt> #EFR #COND "%3" eq "HEALINGITEM_SINGLE"
	elseif %2 and available_time[%1] <= ai_time then
		return %1
#ENDINCLUDE
	endif
	return 0
endfunction

//============================================================================
function GetMassHealingItem takes nothing returns integer
  if false then
#INCLUDETABLE <$VER$\HealingItems.txt> #EFR #COND "%3" eq "HEALINGITEM_MASS"
  elseif %2 and available_time[%1] <= ai_time then
    return %1
#ENDINCLUDE
  endif
  return 0
endfunction

//============================================================================
function GetMerchantMassHealingItem takes nothing returns integer
	if false then
#INCLUDETABLE <$VER$\HealingItems.txt> #EFR #COND "%3" eq "MERCHANTITEM_MASS"
	elseif %2 and available_time[%1] <= ai_time then
		return %1
#ENDINCLUDE
	endif
	return 0
endfunction

//============================================================================
//   Items that do not heal units directly
function GetGlobalHealingItem takes nothing returns integer
	if false then
#INCLUDETABLE <$VER$\HealingItems.txt> #EFR #COND "%3" eq "GLOBALHEALING"
	elseif %2 and available_time[%1] <= ai_time then
		return %1
#ENDINCLUDE
	endif
	return 0
endfunction

//============================================================================
//   Items that re-gain the heros mana
function GetHeroManaItem takes nothing returns integer
	if false then
#INCLUDETABLE <$VER$\HealingItems.txt> #EFR #COND "%3" eq "MANAITEM_HERO"
	elseif %2 and available_time[%1] <= ai_time then
		return %1
#ENDINCLUDE
	endif
	return 0
endfunction

//============================================================================
function GetItemHealingTime takes integer id returns integer
  if false then
#INCLUDETABLE <$VER$\HealingItems.txt> #EFR #COND "%4" eq "CONTINUOUS" or "%4" eq "NO_TARGET"
  elseif %1 == id then
    return %5
#ENDINCLUDE
  endif
  return 0
endfunction

// Is the item an instant healing or a heal over time 
function GetItemInstantType takes integer id returns integer
  if false then
#INCLUDETABLE <$VER$\HealingItems.txt> #EFR #COND "%4" eq "SUDDEN"
  elseif %1 == id then
    return ITEMTYPE_SUDDEN
#ENDINCLUDE
#INCLUDETABLE <$VER$\HealingItems.txt> #EFR #COND "%4" eq "CONTINUOUS"
  elseif %1 == id then
    return ITEMTYPE_CONTINUOUS
#ENDINCLUDE
  endif
  return 0
endfunction

//    Gets items that the hero can use to heal itself. Otherwise tries the racial items.
function GetHeroHealingItem takes nothing returns integer
	if false then
#INCLUDETABLE <$VER$\HealingItems.txt> #EFR #COND "%3" eq "HEALINGITEM_HERO"
	elseif %2 and available_time[%1] <= ai_time then
		return %1
#ENDINCLUDE
	elseif GetHealingItem() != 0 then
		return GetHealingItem()
	elseif GetGlobalHealingItem() != 0 then
		return GetGlobalHealingItem()
	elseif GetMassHealingItem() != 0 then
		return GetMassHealingItem()
	elseif GetMerchantMassHealingItem() != 0 then
		return GetMerchantMassHealingItem()
	endif
	return 0
endfunction

//============================================================================
// (AMAI) Jobs Listing (Custom Job Scripts are placed here)
//============================================================================

#INCLUDETABLE <Jobs.txt> #EFR
  #INCLUDESCRIPT <Jobs\%1.eai>
#ENDINCLUDE

//============================================================================
function TQDoJob takes integer jid, integer par, unit unit_par, group group_par returns nothing
  #SEARCHCODE Jobs jid
endfunction

//============================================================================
function TQHandleOnce takes nothing returns boolean
  local integer jid = tq_jid[1]
  local integer par = tq_par[1]
  local unit unit_par = tq_unit_par[1]
  local group group_par = tq_group_par[1]
//  call DisplayToAll(Int2Str(R2I(TimerGetElapsed(tq_timer))))
//  call TQDisplay()
  if TimerGetElapsed(tq_timer) >= tq_time[1] then
    call TQRemoveRoot()
    call TQDoJob(jid, par, unit_par, group_par)
    set unit_par = null
    set group_par = null
    return true
  endif
  set unit_par = null
  set group_par = null
  return false
endfunction

//============================================================================
function TQInitJobs takes nothing returns nothing
  call TQAddJob(GetRandomReal(20, 35), TIMED_CHAT, C_Greet)
  call TQAddJob(GetRandomReal(40, 60), TIMED_CHAT, C_STRATEGY)
#INCLUDETABLE <Jobs.txt> #EFR #COND '%4' eq 'true'
  call TQAddJob(GetRandomReal(%5, %6), %1, 0)
#ENDINCLUDE

#INCLUDETABLE <Jobs.txt> #EFR #COND '%4' ne 'true' and '%4' ne 'false'
  if %4 then
    call TQAddJob(GetRandomReal(%5, %6), %1, 0)
  endif
#ENDINCLUDE
endfunction

//============================================================================
function TQLoop takes nothing returns nothing
  local real i = 0
  local texttag t = null
  if debugging then
    set t = CreateTextTag()
    call SetTextTagText(t, null, 0.1)
    call SetTextTagPos(t, GetLocationX(home_location) + 300, GetLocationY(home_location) + 300, 0)
    call SetDebugTagColor(t)
    call SetTextTagPermanent(t, true)
  endif
  set tq_time[0] = 0
  call TimerStart(tq_timer, 1000000, false, null)
  //call Trace("Starting Job Loop Thread")
  call TQInitJobs()
  //call Trace("Job Initialisation done")
  loop
    exitwhen player_defeated
    if tq_length > 0 then
      if not TQHandleOnce() then
        if debugging then
          call SetTextTagText(t, Int2Str(tq_jid[1]), 0.1)
        endif
        set i = tq_time[1] - TimerGetElapsed(tq_timer) + 0.05
        if i > 0 then
          call Sleep(RMin(i ,1))
        endif
      else
        call Sleep(0.05)
      endif
    else
      call Trace("TQLOOP: No job is ready to fire")
      call Sleep(sleep_multiplier)
    endif
  endloop
  if debugging then
    call SetTextTagText(t, "Shutting down Job Thread", 0.1)
  endif
  call Trace("Shutting down Job Thread")
  loop
    call ExchangeOnce()
    call Sleep(30)
  endloop
endfunction

//==========================================================================
// (AMAI)	CheckNeutral
//==========================================================================
function CheckNeutral takes integer nn returns nothing
  if neutral_available[nn] == true then
    set neutral_ordered[nn] = false
    set neutral_sent[nn] = null
    set buy_time_large[nn] = -1
    set buy_time_small[nn] = -1

    //call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "checkneutral")
    set nearest_neutral[nn] = GetNearestNeutral(nearest_neutral[nn],neutral_id[nn])
    //call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "finished check")
    set neutral_guards[nn] = GetCreepGuardGroup(neutral_guards[nn],nn)
    set neutral_guarded[nn] = GetNeutralGuard(nn)
    set neutral_night_buy[nn] = CanCreepGuardsSleep(nn)
    // set neutral_night_buy[nn] = not no_sleep

    if nearest_neutral[nn] != null then
      call Trace("Neutral Pathing ID done: " + Int2Str(nn))
    else
      call Trace("Neutral Pathing ID done (no pathable neutral): " + Int2Str(nn))
    endif
  endif

endfunction

//==========================================================================
function InitNeutralBuildings takes nothing returns nothing
  local group g = CreateGroup()
  local integer i = 0
  local integer j = 0
  local integer k = 0
  local integer m = 0
  local integer array camp
  local integer array roost
  local integer array merc_types
  local boolean mercfound = false
  local boolean roostfound = false
  local boolean tavernfound = false
  local unit u = null

#INCLUDETABLE <$VER$\NeutralShops.txt> #EFR
  set neutral_id[%1] = '%2'
#ENDINCLUDE

#DEFINE $MERCTYPENUM$ 0
#INCLUDETABLE <$VER$\MercTypes.txt>
  #DEFINE $MERCTYPENUM$ %row
#ENDINCLUDE

#INCLUDETABLE <$VER$\Mercs.txt> #EFR
  set camp[%row] = '%2'
#AFTERINCLUDE
  set j = %row
#ENDINCLUDE

#DEFINE $DRAGONTYPENUM$ 0
#INCLUDETABLE <$VER$\DragonTypes.txt>
  #DEFINE $DRAGONTYPENUM$ %row
#ENDINCLUDE

#INCLUDETABLE <$VER$\Dragons.txt> #EFR
  set roost[%row] = '%2'
#AFTERINCLUDE
  set m = %row
#ENDINCLUDE

  call GroupEnumUnitsOfPlayer(g, Player(PLAYERPASSIVE), null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == neutral_id[NEUTRAL_TAVERN] then
      set neutral_available[NEUTRAL_TAVERN] = true
    elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_MERCHANT] then
      set neutral_available[NEUTRAL_MERCHANT] = true
    elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_OBSERVATORY] then
      set neutral_available[NEUTRAL_OBSERVATORY] = true
    elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_HEALING_FOUNTAIN] then
      set neutral_available[NEUTRAL_HEALING_FOUNTAIN] = true
    elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_MANA_FOUNTAIN] then
      set neutral_available[NEUTRAL_MANA_FOUNTAIN] = true
    elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_POWER_FOUNTAIN] then
      set neutral_available[NEUTRAL_POWER_FOUNTAIN] = true
    elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_HEAL_WARD] and not IsUnitType(u, UNIT_TYPE_SUMMONED) then
      set neutral_available[NEUTRAL_HEAL_WARD] = true
    elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_SHIPYARD] then
      set neutral_available[NEUTRAL_SHIPYARD] = true
    elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_MARKETPLACE] then
      set neutral_available[NEUTRAL_MARKETPLACE] = true
    else
      if not mercfound then
        set i = 0
        loop
          set i = i + 1
          if GetUnitTypeId(u) == camp[i] then
            set mercfound = true
          endif
          exitwhen mercfound or i >= j
        endloop
      endif
      if not roostfound then
        set k = 0
        loop
          set k = k + 1
          if GetUnitTypeId(u) == roost[k] then
            set roostfound = true
          endif
          exitwhen roostfound or k >= m
        endloop
      endif
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null

if mercfound then

  if not mercfound then
#INCLUDETABLE <$VER$\Mercs.txt> #EFR
  elseif i == %row then
    set merc_unit[0] = %3
    set merc_unit[1] = %4
    set merc_unit[2] = %5
    set merc_unit[3] = %6
  #FOR $X$ FROM $ONE$ TO $MERCTYPENUM$
    set merc_types[$X$] = %#OEVAL{6+$X$}
  #ENDFOR
#ENDINCLUDE
  endif

#INCLUDETABLE <$VER$\MercTypes.txt>
  set merc_%1 = merc_types[%row]
#ENDINCLUDE

  set merc_number = 0
  set j = 0
  loop
    exitwhen j >= 4
    if merc_unit[j] != 0 then
      set merc_number = merc_number + 1
    endif
    set j = j + 1
  endloop

  set neutral_id[NEUTRAL_MERC_CAMP] = camp[i]
  set neutral_available[NEUTRAL_MERC_CAMP] = true
endif

if roostfound then
  if not roostfound then
#INCLUDETABLE <$VER$\Dragons.txt> #EFR
  elseif k == %row then
  #FOR $X$ FROM $ONE$ TO $DRAGONTYPENUM$
    set dragons[$X$] = %#OEVAL{2+$X$}
  #ENDFOR
#AFTERINCLUDE
  endif
  set dragon_number = $DRAGONTYPENUM$
#ENDINCLUDE

  set neutral_id[NEUTRAL_DRAGON_ROOST] = roost[k]
  set neutral_available[NEUTRAL_DRAGON_ROOST] = true
endif

endfunction

//==========================================================================
function CheckAllNeutrals takes nothing returns nothing
  local integer i = 0

  loop
    exitwhen i >= NEUTRAL_COUNT
    call CheckNeutral(i)
    set i = i + 1
    call Sleep(0.1)
  endloop

endfunction

//============================================================================
function CheckNeutralQuick takes integer nn returns nothing
if neutral_available[nn] == true then
  set neutral_ordered[nn] = false
  set neutral_sent[nn] = null
  set buy_time_large[nn] = -1
  set buy_time_small[nn] = -1

//	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "checkneutral")
  set nearest_neutral[nn] = GetNearestNeutralQuick(nearest_neutral[nn],neutral_id[nn])
  set neutral_guards[nn] = GetCreepGuardGroup(neutral_guards[nn],nn)
//	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "finished check")
  set neutral_guarded[nn] = GetNeutralGuard(nn)
  set neutral_night_buy[nn] = CanCreepGuardsSleep(nn)
  if neutral_guarded[nn] then
    call TQAddJob(30 * sleep_multiplier, NEUTRAL_GUARDED, nn)
    if nn == NEUTRAL_TAVERN and hero[1] != 0 and buy_type[hero[1]] == BT_NEUTRAL_HERO then  //guarantee to train Ownrace hero at the first time
      set recalculate_heros = true
    endif
  endif
endif
endfunction

//============================================================================
function CheckAllNeutralsQuick takes nothing returns nothing
  local integer i = 0

  loop
    exitwhen i >= NEUTRAL_COUNT
    call CheckNeutralQuick(i)
    set i = i + 1
  endloop

  if nearest_neutral[NEUTRAL_HEALING_FOUNTAIN] != null then
    call TQAddJob(10, NEUTRAL_ENEMY_CHECK, NEUTRAL_HEALING_FOUNTAIN)
  endif
  if nearest_neutral[NEUTRAL_MANA_FOUNTAIN] != null then
    call TQAddJob(10, NEUTRAL_ENEMY_CHECK, NEUTRAL_MANA_FOUNTAIN)
  endif
  if nearest_neutral[NEUTRAL_POWER_FOUNTAIN] != null then
    call TQAddJob(10, NEUTRAL_ENEMY_CHECK, NEUTRAL_POWER_FOUNTAIN)
  endif
  if nearest_neutral[NEUTRAL_HEAL_WARD] != null then
    call TQAddJob(10, NEUTRAL_ENEMY_CHECK, NEUTRAL_HEAL_WARD)
  endif
endfunction
//============================================================================
function PathingThread takes nothing returns nothing
  local integer i = 0
  local integer t = 0
  call SetAIArray()
//  set command_wait = 0.5
//  set command_wait = 3
  if race_towerrush_available then
    call TowerRushCheck(5)
  endif
  call ComputeFrontPoints()
//  call Sleep(3)
  if debugging then
    call PingFrontPoints()
  endif 
  //set current_expansion = GetExpNearestMin(current_expansion)  // Rough guide to what first expansion should be
  call CheckAllNeutralsQuick() // Old system check
  call MakeExpansionList()
  set water_map = water_expansion_list_length >= expansion_list_length
  set active_expansion = water_expansion_list_length + expansion_list_length > c_enemy_total + c_ally_total + 1  // have more mine , should positive Expansion
  set first_expansion_chosen = first_expansion_chosen == true or (water_expansion_list_length > 0)  // no expansion but have water expansion , can take expansion
  call ChooseExpansion()
  call CheckFastExpansion()
  call CheckAllNeutrals() // The more advanced new system check
  set pathing_done = true
  loop // no need repeated run
    call Sleep(6 * sleep_multiplier)
    if t == 5 then
      loop
        exitwhen i >= NEUTRAL_COUNT
        if neutral_guarded[i] then
          call NeutralGuardedJob(i)
        endif
        set i = i + 1
      endloop
      set t = 0
      set i = 0
    endif
    if nearest_neutral[NEUTRAL_HEALING_FOUNTAIN] != null then
      call NeutralEnemyCheckJob(NEUTRAL_HEALING_FOUNTAIN)
    endif
    if nearest_neutral[NEUTRAL_MANA_FOUNTAIN] != null then
      call NeutralEnemyCheckJob(NEUTRAL_MANA_FOUNTAIN)
    endif
    if nearest_neutral[NEUTRAL_POWER_FOUNTAIN] != null then
      call NeutralEnemyCheckJob(NEUTRAL_POWER_FOUNTAIN)
    endif
    if nearest_neutral[NEUTRAL_HEAL_WARD] != null then
      call NeutralEnemyCheckJob(NEUTRAL_HEAL_WARD)
    endif
    set t = t + 1
  endloop

endfunction

//============================================================================
// (AMAI) Queue utility functions
//============================================================================
function QueueReset takes nothing returns nothing
  set queue_length 	= 0
  set queue_pointer	= 0
endfunction

//============================================================================
function QueueRestart takes nothing returns nothing
  set queue_pointer	= 0
endfunction

//============================================================================
function QueueGetNextUnit takes nothing returns unit
  return target_queue_u[queue_pointer]
endfunction

//============================================================================
function QueueGetNextX takes nothing returns integer
  return target_queue_x[queue_pointer]
endfunction

//============================================================================
function QueueGetNextY takes nothing returns integer
  return target_queue_y[queue_pointer]
endfunction

//============================================================================
function QueuePopCommand takes nothing returns nothing
  set queue_pointer = queue_pointer + 1
endfunction

//============================================================================
function QueueFinished takes nothing returns boolean
  return queue_pointer >= queue_length
endfunction

//============================================================================
function QueueGetNextCommand takes nothing returns boolean
  if QueueFinished() then
    set queue_running = false
    call QueueReset()
    return false
  else
    set queue_t_u = QueueGetNextUnit()
    if queue_t_u == null then
      set queue_t_x = QueueGetNextX()
      set queue_t_y = QueueGetNextY()
      set queue_attack_p = true
      set queue_attack_u = false
    else
      set queue_attack_u = true
      set queue_attack_p = false
    endif
    call QueuePopCommand()
    return true
  endif
endfunction

//============================================================================
function QueueSetCommand takes integer x, integer y, unit u returns nothing
  set target_queue_x[queue_length] = x
  set target_queue_y[queue_length] = y
  set target_queue_u[queue_length] = u
  set queue_length = queue_length + 1
endfunction

//============================================================================
function QueueRemoveCommand takes nothing returns nothing
  set queue_length = queue_length - 1
endfunction

//===========================================================================
// (AMAI) Command recieving loop
//===========================================================================
function cmd_cancel takes integer cmd, integer data returns nothing
  if cmd == 0 then		// Cancel all orders
    set break_attack = false
    set go_home = false
    set strategy = chosen_strategy
    set attack_player = false
    set attack_point = false
    set no_attack = false
    set no_creep_attack = false
    set no_player_attack = false
    set queue_running	= false
    call Trace("Cancel All command" )

  elseif cmd == 1 then	// Cancel build orders
    set strategy = chosen_strategy
    call Trace("Cancel Build Command" )

  elseif cmd == 2 then	// Cancel attacking orders
    set attack_player = false
    set attack_point = false
    set no_attack = false
    set no_creep_attack = false
    set no_player_attack = false
    set queue_running = false
    call Trace("Cancel Attack Command" )

  endif
endfunction

//============================================================================
function cmd_attack takes integer cmd, integer data returns nothing
  local group gr = null
  if cmd == 10 then	// Stop the current attack
    set break_attack = true
    set go_home = true
    set queue_running = false
    set attack_player = false
    set attack_point = false
    call Trace("Stop Attack Command" )

  elseif cmd == 11 then	// Start no attacks
    set break_attack = true
    set no_attack = true
    call Trace("No Attacks Command" )
  elseif cmd == 12 then	// Attack specific player
    set break_attack = true
    set go_home = false
    set attack_target_p = data
    set attack_player = true
    set attack_point = false
    call Trace("Attack Player Command" )

  elseif cmd == 13 then	// Attack specific point
    call Trace("Attack Point Command" )
    loop
      exitwhen CommandsWaiting()!=0
      call Sleep(0.5)
    endloop
    set attack_target_x = GetLastCommand()
    set attack_target_y = GetLastData()
    set break_attack = true
    set go_home = false
    set attack_point = true
    set attack_player = false
    call PopLastCommand()
    call Trace("Attack Coordinates received" )

  elseif cmd == 14 then	// No attacks on creeps
    set no_creep_attack = true
    call Trace("Attack No Creeps" )

  elseif cmd == 15 then	// No attack on players
    set no_player_attack = true
    call Trace("Attack No Player" )

  elseif cmd == 16 then	// Attack selected unit
    set gr = CreateGroup()
    call GroupEnumUnitsSelected(gr, Player(data), null)
    set target_unit	= FirstOfGroup(gr)
    call DestroyGroup(gr)
    set gr = null
    if target_unit == null then
      call DisplayToAllies(chat_no_unit_selected)
    endif
    set attack_point = false
    set attack_player = false
    set attack_unit = true
    set break_attack = true
    set go_home = false
    call DisplayToAllies(chat_confirm_attack_unit)

  elseif cmd == 17 then // Towerrush
    if race_towerrush_available then
      if not towerrush then
        call TowerRushCheck(1)
        //call DisplayToAllies(chat_towerrush)
        return
      endif
    else
      call DisplayToAllies(chat_no_towerrush)
      call DisplayToObserversImportant( chat_no_towerrush )
    endif

  endif
endfunction

//============================================================================
function cmd_build takes integer cmd, integer data returns nothing
  if false then
#INCLUDETABLE <$VER$\CommandBuilds.txt> #EFR
  elseif cmd == #EVAL{19+%row} then
    set strategy = #EVAL{49+%row}
    set bn_%1 = data
#ENDINCLUDE
  endif
endfunction

//============================================================================
function cmd_queue takes integer cmd, integer data returns nothing
  local group gr = null
  if cmd == 30 then	// Cancel queue
    call QueueReset()
    set queue_running = false
    call Trace("Cancel Queue Command" )

  elseif cmd == 31 then	// Queue Attack specific point
    call Trace("Queue Attack Point Command" )
    loop
      exitwhen CommandsWaiting()!=0
      call Sleep(0.5)
    endloop
    call QueueSetCommand(GetLastCommand(), GetLastData(), null)
    call PopLastCommand()
    call Trace("Attack Coordinates received" )

  elseif cmd == 32 then	// Queue Attack selected unit
    set gr = CreateGroup()
    call GroupEnumUnitsSelected(gr, Player(data), null)
    if FirstOfGroup(gr) == null then
      call DisplayToAllies(chat_no_unit_selected)
    else
      call QueueSetCommand(0,0, FirstOfGroup(gr))
      call DisplayToAllies(chat_confirm_attack_unit)
    endif
    call DestroyGroup(gr)
    set gr = null

  elseif cmd == 33 then	// Starting or Restarting queue
    call QueueRestart()
    if QueueGetNextCommand() then
      set queue_running = true
      set no_attack = false
      call Trace("Queue started" )
    else
      call Trace("Queue is empty" )
    endif

  elseif cmd == 34 then	// Pausing queue
    set queue_running = false

  elseif cmd == 35 then	// Unpausing queue
    set queue_running = true

  elseif cmd == 36 then	// Removing last command
    call QueueRemoveCommand()

  endif
endfunction

//============================================================================
function cmd_misc takes integer cmd, integer data returns nothing
  if cmd == 50 then	// Triggering chat
    set chatting = not chatting

  elseif cmd == 51 then	// Triggering debug
    set debugging = not debugging

  elseif cmd == 52 then	// Triggering balancing
    set balancing = not balancing

  elseif cmd == 53 then
    set strat_change_allowed = not strat_change_allowed

  elseif cmd == 60 then // Show strat name
    call DisplayToAllies(GetCurrentStrategyReport() + GetCurrentDynamicReport())

  elseif cmd == 61 then // Show all strats
    call DisplayStratNames()

  elseif cmd == 70 then // change strategy
    if data < rp_strat_length then
      set strategy = data
      set chosen_strategy = strategy
    else
      call DisplayToAllies(invalid_strategy_number)
    endif

  elseif cmd == 71 then // change language
    if false then
  #INCLUDETABLE <Languages.txt> #EFR
    elseif data == #EVAL{%row-1} then
      set language = "%1"
  #ENDINCLUDE
    endif
    call InitChatArrays()
  endif
endfunction

//============================================================================
function cmd_loop takes nothing returns nothing
  local integer cmd = 0
  local integer data = 0
  call StaggerSleep(0,3)
  call Trace("Starting Commander Thread Loop" )

  loop
    loop
      exitwhen CommandsWaiting()!=0
      exitwhen player_defeated
      call Sleep(command_wait * sleep_multiplier)
    endloop
    exitwhen player_defeated
    set cmd = GetLastCommand()
    set data = GetLastData()
    call PopLastCommand()
    call Trace("Receiving command" )

    if cmd < 10 then
      call cmd_cancel(cmd, data)

    elseif cmd < 20 then
      call cmd_attack(cmd, data)

    elseif cmd < 30 then
      call cmd_build(cmd, data)

    elseif cmd < 40 then
      call cmd_queue(cmd, data)

    else
      call cmd_misc(cmd, data)

    endif

  endloop
//call DisplayToAll("shutting down cmd_loop")

endfunction

//===========================================================================
function InitCheckHarvest takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  local integer i = GOLD_MINE
  local integer c = 0
  local integer p = 1
  local real check = 0
  local real distance = 0
  if race_manual_loading then
    set i = race_manual_loading_mine
  elseif race_uses_mine_expansion then
    set i = racial_expansion
  endif
  call GroupEnumUnitsInRangeOfLoc(g, home_location, 1600, null)
  set g = SelectByAlive(g,true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetResourceAmount(u) > 0 then
      if GetUnitTypeId(u) == old_id[GOLD_MINE] then
        set check = DistanceBetweenPoints_kd(home_location,GetUnitLoc(u))  // human and orc need find closest mine
        if check <= distance then
          set distance = check
          set own_town_mine[0] = u  // fix home_location mine
        endif
        set c = c + 1
      else
        if i != GOLD_MINE and GetUnitTypeId(own_town_mine[0]) == old_id[GOLD_MINE] then
           set own_town_mine[0] = u  // fix home_location mine
        endif
      endif
    endif
    if (IsUnitType(u, UNIT_TYPE_TOWNHALL) or GetUnitTypeId(u) == old_id[racial_expansion]) and GetOwningPlayer(u) != ai_player then
      set p = p + 1  // have more player , need fix harvest , but maybe no need fix expensive
    endif
    call GroupRemoveUnit(g, u)
  endloop
  if p > 1 then  // more mine and more player
    if c == p and i != GOLD_MINE then
      set first_town_mine = 1 // mode one , one player have one mine , and this mine too close (like (4)synergybigpaved.w3x) , just fix UD and ELF harvest
    elseif c > p then
      set first_town_mine = 2  // mode two , one player have more mine , fix UD and ELF harvest and all race expensive - prior take closest home_location mine
    endif
  elseif c > p then // more mine and one player
    set first_town_mine = 3 // mode three , one player have this mine , fix all race harvest and expensive - prior take closest home_location mine
  endif
  if first_town_mine == 0 and i != GOLD_MINE then
    set first_town_mine = 1  // just one mine , but now cannot harvest , need fix UD harvest
    // some map home_location 1500 radius just one mine , but old war3 (maybe 1.24~1.28 , 1.36 no this bug) UD and ELF still cannot harvest(maybe need 2300 radius no more mine)
  endif
  call DestroyGroup(g)
  set g = null
  call HarvestGold(0,3)
  call HarvestWood(0,2)  // Early triggering Harvest , convenient HARVEST_CHECK job check peon
endfunction

//===========================================================================
function InitTownBuilt takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i >= max_towns
    set town_built[i] = false
    set i = i + 1
  endloop
  set town_built[0] = true
  set own_town_loc[0] = Location(GetLocationX(home_location), GetLocationY(home_location))
  set exist_town[0] = home_location
  set own_town_dist[0] = 0
  set own_town_mine[0] = GetMineNearLoc(own_town_mine[0] ,home_location, 1500)
endfunction

//============================================================================
function GetBuildLock takes nothing returns nothing
  loop
    exitwhen build_lock
    //call Trace("Build Lock not received")
    call Sleep(0.5)
  endloop
  set build_lock = false
endfunction

//============================================================================
function ReleaseBuildLock takes nothing returns nothing
  set build_lock = true
endfunction

//===========================================================================
// (AMAI) Upkeep utility functions
//===========================================================================
function InitUpkeep takes nothing returns nothing
#INCLUDETABLE <$VER$\Upkeep.txt> #EFR
  set upkeep_allowed[UPKEEP_%1] = UPKEEP_UNDECIDED
  set upkeep_border[UPKEEP_%1] = %2
  set upkeep_resistance[UPKEEP_%1] = %3
  set upkeep_save_time[UPKEEP_%1] = %4
  set upkeep_mines_needed[UPKEEP_%1] = %5
  set upkeep_time[UPKEEP_%1] = -1
#ENDINCLUDE
endfunction

//===========================================================================
function InitLastUpkeep takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    set last_upkeep_allowed[i] = UPKEEP_UNDECIDED
    set i = i + 1
  endloop
endfunction

//===========================================================================
function CheckUpkeepAllowed takes integer food returns nothing
  local integer mines = GetMinesOwned()
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    if food > upkeep_border[i] then
      set upkeep_allowed[i] = UPKEEP_ALLOWED
    elseif mines < upkeep_mines_needed[i] then
      set upkeep_allowed[i] = UPKEEP_NOT_ALLOWED
      set last_upkeep_allowed[i] = UPKEEP_NOT_ALLOWED
      set upkeep_time[i] = -1
    else
      set upkeep_allowed[i] = UPKEEP_UNDECIDED
    endif
    set i = i + 1
  endloop
endfunction

//===========================================================================
function ApplyUpkeepCheck takes integer afford_food, integer food, integer food_cost, integer cost_qty, integer need_qty returns integer
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    if food + food_cost * cost_qty > upkeep_border[i] then
      if upkeep_allowed[i] == UPKEEP_UNDECIDED then
        if total_gold > upkeep_resistance[i] then
          set upkeep_allowed[i] = UPKEEP_ALLOWED
        else
          set upkeep_allowed[i] = UPKEEP_NOT_ALLOWED
        endif
      endif
      if upkeep_allowed[i] == UPKEEP_NOT_ALLOWED then
        if food_cost == 0 then
          set afford_food = need_qty
        else
          set afford_food = Max(upkeep_border[i] - food, 0) / food_cost
        endif
      endif
    endif
    set i = i + 1
  endloop
  return afford_food
endfunction

//===========================================================================
function ApplyUpkeepSaving takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    if upkeep_allowed[i] == UPKEEP_ALLOWED then
      set upkeep_time[i] = -1
    elseif last_upkeep_allowed[i] == UPKEEP_UNDECIDED and upkeep_allowed[i] == UPKEEP_NOT_ALLOWED then
      if upkeep_time[i] == -1 then
        if total_gold > 0 and total_wood > 0 then
          set upkeep_time[i] = ai_time
        endif
      elseif use_linear_upkeep_saving then
        set total_gold = total_gold - R2I(LinearInterpolation(upkeep_time[i], upkeep_time[i] + upkeep_save_time[i], 0, upkeep_resistance[i], ai_time))
      elseif ai_time >= upkeep_time[i] + upkeep_save_time[i] then
//        call DisplayToAll("Saving "+Int2Str(upkeep_resistance[i])+" from "+Int2Str(total_gold))
        set total_gold = total_gold - upkeep_resistance[i]
      endif
    endif
    set i = i + 1
  endloop
endfunction

//===========================================================================
function UpdateLastUpkeep takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    set last_upkeep_allowed[i] = upkeep_allowed[i]
    set i = i + 1
  endloop
endfunction

//===========================================================================
function ResetUpkeepSaveTime takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    if upkeep_allowed[i] == UPKEEP_UNDECIDED then
      set upkeep_time[i] = -1
    endif
    set i = i + 1
  endloop
endfunction

//===========================================================================
// (AMAI) Function Initializations
//===========================================================================
function InitBuildArrayAM takes nothing returns nothing
  local integer i = 0
  call GetBuildLock()
  set build_length = 0
  loop
    exitwhen i >= building_length
    set income_percentage[building[i]] = 1 / I2R(building_length)
    set i = i + 1
  endloop
  call ReleaseBuildLock()
endfunction

//===========================================================================
function InitUpgradeTimeArray takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > OBJECT_NUM
    set upgrade_time[i] = -1
    set i = i + 1
  endloop
endfunction

//===========================================================================
function InitPlayerStrengthCache takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= PLAYERAGGRESSIVE
    set p_str_cache[i] = 0
    set p_str_cache_timeout[i] = 0
    set i = i + 1
  endloop
endfunction

//===========================================================================
function InitHeroArrays takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > 3
    set hero[i] = 0
    set hero_built[i] = false
    set hero_unit[i] = null
    set i = i + 1
  endloop
  set hero_revive_prio[1] = hero1_revive_prio
  set hero_revive_prio[2] = hero2_revive_prio
  set hero_revive_prio[3] = hero3_revive_prio
endfunction

//===========================================================================
function InitNeutralSpecial takes nothing returns nothing
#INCLUDETABLE <$VER$\StandardUnits.txt> #EFR #COND "%4" =~ /\btransporter\b/
  set neutral_zeppelin = %1
#ENDINCLUDE
#INCLUDETABLE <$VER$\StandardUnits.txt> #EFR #COND "%4" =~ /\bshredder\b/
  set neutral_shredder = %1
#ENDINCLUDE
#INCLUDETABLE <$VER$\StandardUnits.txt> #EFR #COND "%4" =~ /\btp\b/
  set tp_item = %1
#ENDINCLUDE
endfunction

//===========================================================================
function InitCreepStrengthArray takes nothing returns nothing
//#INCLUDETABLE <$VER$\LevelStrengthMap.txt> #EFR
//  set creep_strength[%1] = %2
//#AFTERINCLUDE
//  set creep_strength_length = %row
//#ENDINCLUDE
endfunction

//===========================================================================
function GetPatchVersion takes nothing returns nothing
  if (JASS_MAX_ARRAY_SIZE > 8192) then  //1.29 ~ 1.32 or higher
    set skillfix = true
  endif

  if GetPlayerController(Player(12)) != MAP_CONTROL_CREEP then  // old ver WE make map , the Player(12) is MAP_CONTROL_CREEP , Even running in higher war3
    set play24 = true
    set PLAYERPASSIVE = 27
    set PLAYERAGGRESSIVE = 24
    set PLAYER_COLOR_MAROONX             = ConvertPlayerColor(12)
    set PLAYER_COLOR_NAVYX               = ConvertPlayerColor(13)
    set PLAYER_COLOR_TURQUOISEX          = ConvertPlayerColor(14)
    set PLAYER_COLOR_VIOLETX             = ConvertPlayerColor(15)
    set PLAYER_COLOR_WHEATX              = ConvertPlayerColor(16)
    set PLAYER_COLOR_PEACHX              = ConvertPlayerColor(17)
    set PLAYER_COLOR_MINTX               = ConvertPlayerColor(18)
    set PLAYER_COLOR_LAVENDERX           = ConvertPlayerColor(19)
    set PLAYER_COLOR_COALX               = ConvertPlayerColor(20)
    set PLAYER_COLOR_SNOWX               = ConvertPlayerColor(21)
    set PLAYER_COLOR_EMERALDX            = ConvertPlayerColor(22)
    set PLAYER_COLOR_PEANUTX             = ConvertPlayerColor(23)
  endif
endfunction

function InitGlobalSettings takes nothing returns nothing
  call GetPatchVersion()
#INCLUDETABLE <$VER$\GlobalSettings.txt> #EFR
  set %1 = %2
#ENDINCLUDE
  if play24 == true then
    set slm_start = 4
    set slm_end = 18
  endif
  if racial_lumber == 0 or race_no_wood_harvest then
    set front_base_distance = front_base_distance + 100
  endif
endfunction

//===========================================================================
function IsGameFFA takes nothing returns boolean
  local boolean array team_exists
  local integer i = 0
  local integer tc = 0
  loop
    exitwhen i >= PLAYERAGGRESSIVE
    set team_exists[i] = false
    set i = i + 1
  endloop
  set i = 0
  loop
    exitwhen i >= PLAYERAGGRESSIVE
    if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then
      set team_exists[GetPlayerTeam(Player(i))] = true
    endif
    set i = i + 1
  endloop
  set i = 0
  loop
    exitwhen i >= PLAYERAGGRESSIVE
    if team_exists[i] then
      set tc = tc + 1
    endif
    set i = i + 1
  endloop
  return tc > 3
endfunction

//===========================================================================
//function GetEnemyFoodUse takes nothing returns integer
//  local integer p = 0
//  local integer food = 0
//
//  GetPlayerState(p, PLAYER_STATE_RESOURCE_FOOD_USED)
//
//
//endfunction

//===========================================================================
function InitRaceNames takes nothing returns nothing
#INCLUDETABLE <$VER$\Races.txt>
  set race_name[%row] = "%1"
#ENDINCLUDE
endfunction

//===========================================================================
function InitSpecialRaces takes nothing returns nothing
  local integer i = 0
  local string s = null
  loop
    exitwhen i >= PLAYERAGGRESSIVE
    set s = Int2Str(i)
    set player_race[i] = LoadInteger(com, RACE, i)
    set player_race_pref[i] = LoadInteger(com, RACE_PREF, i)
    set i = i + 1
  endloop
  set s = null
endfunction

//===========================================================================
function InitStandardRaces takes nothing returns nothing
  local integer i = 0
  local player p = null
  loop
    exitwhen i >= PLAYERAGGRESSIVE
    set p = Player(i)
    if GetPlayerRace(p) == RACE_NIGHTELF then
      set player_race[i] = SR_ELF
      if IsPlayerRacePrefSet(p, RACE_PREF_NIGHTELF) then
        set player_race_pref[i] = SR_ELF
      else
        set player_race_pref[i] = SR_RANDOM
      endif
    elseif GetPlayerRace(p) == RACE_HUMAN then
      set player_race[i] = SR_HUMAN
      if IsPlayerRacePrefSet(p, RACE_PREF_HUMAN) then
        set player_race_pref[i] = SR_HUMAN
      else
        set player_race_pref[i] = SR_RANDOM
      endif
    elseif GetPlayerRace(p) == RACE_ORC then
      set player_race[i] = SR_ORC
      if IsPlayerRacePrefSet(p, RACE_PREF_ORC) then
        set player_race_pref[i] = SR_ORC
      else
        set player_race_pref[i] = SR_RANDOM
      endif
    else
      set player_race[i] = SR_UNDEAD
      if IsPlayerRacePrefSet(p, RACE_PREF_UNDEAD) then
        set player_race_pref[i] = SR_UNDEAD
      else
        set player_race_pref[i] = SR_RANDOM
      endif
    endif
    set i = i + 1
  endloop
  set p = null
endfunction

//===========================================================================
function InitRaces takes nothing returns nothing
  if LoadBoolean(com, USE_SPECIAL_RACES, StringHash("Special")) then
    call InitSpecialRaces()
  else
    call InitStandardRaces()
  endif
endfunction

//===========================================================================
function GetMaxFarms takes nothing returns integer
  local integer fm = GetFoodMade(old_id[racial_farm])
  local integer div = ver_food_limit / fm
  if div * fm < ver_food_limit then
    set div = div + 1
  endif
  return div
endfunction

//===========================================================================


//============================================================================
// AMAI Code
//============================================================================
function InitAMAI takes nothing returns nothing
  if debugging and IsPlayerObserver(GetLocalPlayer()) then
    call SetPlayerAlliance(ai_player, GetLocalPlayer(), ALLIANCE_HELP_REQUEST,  true)
    call SetPlayerAlliance(ai_player, GetLocalPlayer(), ALLIANCE_HELP_RESPONSE, true)
    call SetPlayerAlliance(ai_player, GetLocalPlayer(), ALLIANCE_SHARED_XP,     true)
    call SetPlayerAlliance(ai_player, GetLocalPlayer(), ALLIANCE_SHARED_SPELLS, true)
    call SetPlayerAlliance(ai_player, GetLocalPlayer(), ALLIANCE_SHARED_VISION, true)
    call SetPlayerAlliance(ai_player, GetLocalPlayer(), ALLIANCE_SHARED_CONTROL, true)
    call SetPlayerAlliance(ai_player, GetLocalPlayer(), ALLIANCE_SHARED_ADVANCED_CONTROL, true)
  endif
#INCLUDETABLE <$VER$\StandardUnits.txt> #EFR
  set unitNames[%row] = "%1"
#ENDINCLUDE
  set message_add = c2s(GetPlayerColor(ai_player))
  if race_militia_available then
    set militia_hall = GetMilitiaHall(militia_hall)
  endif
  call InitDigits()
  set ai_id = Int2Str(GetAiPlayer())
  call SaveBoolean(com, IS_AMAI, GetAiPlayer(), true)
  call InitRaces()
  if IsGameFFA() then
    set game_is_ffa = true
    set attacking_strategy = 5
  endif
  call countAllyEnemy()
  if c_enemy_total == 1 and c_ally_total == 0 then
    set game_is_1on1 = true
  endif
  set sleep_multiplier = sleep_multiplier * LinearInterpolation(I2R(slm_start), I2R(slm_end), slm_start_mult, slm_end_mult, I2R(c_ai_total))
  set difficulty = MeleeDifficulty()
  set income_per_mine = income_per_mine * Max(difficulty - 1, 1)
  call Trace("Init AMAI step 1")
  call InitNeutralSpecial()
  call InitHeroArrays()
  call InitArrays()  // Has been moved to be set before all other code as is only variable declaration
  call InitChatArrays()
  call InitChatEvents()
  call InitTrans()
  call InitTranslations()
  call InitRaceNames()
  call InitCT()
//    call TestCT()
  call InitChatVars()
  call InitCreepStrengthArray()
  call StopGathering()
  call InitBuildArrayAM()
  call InitUpkeep()
  call InitNeutralBuildings()
  call StartThread(function PathingThread)
  //call StartThread(function ExpansionThread)
  //call StartThread(function CheckAllNeutrals)
  call InitHealers()
  call InitUpgradeTimeArray()
  call InitPlayerStrengthCache()
  call SetNearestEnemy()
  call InitTownBuilt()
  set max_farms = GetMaxFarms()
  set mine_loc = GetUnitLoc(own_town_mine[0])
  if (c_ally_total + c_enemy_total >= 10 or mapSize > 3 or (mapSize < 3 and c_enemy_user_total < 3)) and c_enemy_user_total > 0 then
    set firstattackhp = true
  endif
//    call DebugSequenceStart("DebugRun")

endfunction

//============================================================================
function AMAI takes code heroes, code peons, code attacks returns nothing
    local boolean isNewbie = (difficulty == EASY)

    // call sendToNextAI()
    call SaveBoolean(com, TEAM_STATEGY_INUSE, strategy_type[chosen_strategy], true)
    set last_strategy = strategy

    call SetMeleeAI()

#INCLUDETABLE <$VER$\StandardAiSettings.txt> #EFR
    call %1(%2)
#ENDINCLUDE

    call CreateCaptains()
    call Trace("Setting hero levels")
    call SetHeroLevels(heroes)
    call Trace("heros set")
    if GetMinesOwned() > 1 then
      call InitCheckHarvest()  // now home_location distance 1500 have more mine , ELF and UD cannot harvest (old war3 version distance need 2200+ ), this can fix
    endif
    call Sleep(0.1)
      // Job Thread
    call StartThread(function TQLoop)
    //call Trace("TQLoop")
    call StartThread(peons)
    //call Trace("peons")
    call StartThread(attacks)
    //call Trace("attacks")
    call StartThread(function cmd_loop)
    //call Trace("cmd_loop")
endfunction

//============================================================================
function InitCampaignDefenders takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > 200
    set campaign_defenders[i] = 0
    set i = i + 1
  endloop
endfunction

//============================================================================
// (AMAI) KeyBuildingAdd
//============================================================================
function KeyAddTimeModify takes integer k_add returns integer
  local real t = TimerGetElapsed(tq_timer)
  return R2I(LinearInterpolation(k_add_start_time, k_add_end_time, k_add_start_mult, k_add_end_mult, t) * I2R(k_add))
endfunction

//============================================================================
function GetKeyBuildingAddExt takes integer kb returns integer
  if TownCountDone(kb) > 1 then
    return kb_add4
  elseif TownCountDone(kb) > 0 then
    return kb_add1
  elseif TownCount(kb) > 0 then
    return kb_add2
  elseif TownCountDone(needed1[kb]) > 0 and TownCountDone(needed2[kb]) > 0 then
    return kb_add3
  endif
  return 0
endfunction

//============================================================================
function GetKeyBuildingAdd takes integer sn returns integer
  return KeyAddTimeModify(GetKeyBuildingAddExt(key_building1[sn]) + GetKeyBuildingAddExt(key_building2[sn]))
endfunction

//============================================================================
function KeyBuildingAdd takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i>= rp_strat_length
    set rp_strat[i] = rp_strat[i] + GetKeyBuildingAdd(i)
    set i = i + 1
  endloop
endfunction

//============================================================================
// (AMAI) KeyUpgradeAdd
//============================================================================
function GetKeyUpgradeAddExt takes integer kb returns integer
  local integer ul = GetUpgradeLevel(old_id[kb])
  if ul >= 3 then
    return ku_add3
  elseif ul == 2 then
    return ku_add2
  elseif ul == 1 then
    return ku_add1
  endif
  return 0
endfunction

//============================================================================
function GetKeyUpgradeAdd takes integer sn returns integer
  return KeyAddTimeModify(GetKeyUpgradeAddExt(key_upgrade1[sn]) + GetKeyUpgradeAddExt(key_upgrade2[sn]))
endfunction

//============================================================================
function KeyUpgradeAdd takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i>= rp_strat_length
    set rp_strat[i] = rp_strat[i] + GetKeyUpgradeAdd(i)
    set i = i + 1
  endloop
endfunction

//============================================================================
// (AMAI) KeyUnitAdd
//============================================================================
function GetKeyUnitAddExt takes integer kb returns integer
  if kb != 0 then
    return TownCountDone(kb) * GetFoodUsed(old_id[kb])
  endif
  return 0
endfunction

//============================================================================
function GetKeyUnitAdd takes integer sn returns integer
  return KeyAddTimeModify(GetKeyUnitAddExt(key_unit[sn]))
endfunction

//============================================================================
function KeyUnitAdd takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i>= rp_strat_length
    set rp_strat[i] = rp_strat[i] + GetKeyUnitAdd(i)
    set i = i + 1
  endloop
endfunction

//============================================================================
// (AMAI) SmallMapsAdd (Bonus to strategies at tier 1 on small maps)
//============================================================================
function SmallMapsAdd takes nothing returns nothing
  local integer i = 0
  if GetPlayers() > 3 or mapSize >= 3 then
    return
  endif
  loop
    exitwhen i >= rp_strat_length
    if strategy_tier[i] == 1 then
      set rp_strat[i] = rp_strat[i] + small_map_tier1_bonus
    endif
    set i = i + 1
  endloop
endfunction

//============================================================================
// (AMAI) rp_strat functions (Strategy and Priority functions)
//============================================================================
function sum_rp_strat takes integer num returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i >= num
    set sum = sum + rp_strat[i]
    set i = i + 1
  endloop
  return sum
endfunction

//============================================================================
function choose_strategy takes nothing returns integer
  local integer i = 1
  local integer rp_sum = sum_rp_strat(rp_strat_length)
  local integer strategy_roll = GetRandomInt(1, rp_sum)
  if rp_sum <= 0 then
    return 0
  endif
  loop
    exitwhen strategy_roll <= sum_rp_strat(i)
    set i = i + 1
  endloop

  return i - 1
endfunction

//============================================================================
function mult_rp_strat takes integer m returns nothing
  local integer i = 0
  loop
    exitwhen i >= rp_strat_length
    set rp_strat[i] = rp_strat[i] * m
    set i = i + 1
  endloop
endfunction

//============================================================================
function div_rp_strat takes integer d returns nothing
  local integer i = 0
  loop
    exitwhen i >= rp_strat_length
    set rp_strat[i] = rp_strat[i] / d
    set i = i + 1
  endloop
endfunction

//============================================================================
function make_rp_strat_positive takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= rp_strat_length
    if rp_strat[i] < 0 then
      set rp_strat[i] = 0
    endif
    set i = i + 1
  endloop
endfunction

//============================================================================
function normalize_rp_strat takes nothing returns nothing
  local integer i = 0
  local integer sum = sum_rp_strat(rp_strat_length)
  if sum == 0 then
set sum = 1
  endif
  loop
    exitwhen i >= rp_strat_length
    set rp_strat[i] = (rp_strat[i] * rp_strat_normal) / sum
    set i = i + 1
  endloop
endfunction

//============================================================================
function add_tier_bonus takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= rp_strat_length
    if tier == strategy_tier[i] then
      set rp_strat[i] = rp_strat[i] + strategy_tier_bonus
    endif
    set i = i + 1
  endloop
endfunction

//============================================================================
function display_rp_strat takes nothing returns nothing
  local integer i = 0
  local integer sum = 0
  if balancing then
    set sum = sum_rp_strat(rp_strat_length)
if sum == 0 then
      set sum = 1
    endif
    loop
      exitwhen i >= rp_strat_length
      call DisplayToAll(GetStrategyName(i)+": "+Int2Str(R2I(I2R(100 * rp_strat[i]) / I2R(sum)))+" %")
      set i = i + 1
    endloop
  endif
endfunction

//============================================================================
function init_rp_strat_sort takes nothing returns nothing
  set rp_strat_sort_length = 0
endfunction

//============================================================================
function sum_rp_strat_sort takes integer num returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i >= num
    set sum = sum + rp_strat[rp_strat_sort[i]]
    set i = i + 1
  endloop
  return sum
endfunction

//============================================================================
function display_rp_strat_sort takes nothing returns nothing
  local integer i = 0
  local integer sum = 0
  if balancing then
    set sum = sum_rp_strat_sort(relevant_strat_change_number)
    loop
      exitwhen i >= relevant_strat_change_number
      call DisplayToAll(GetStrategyName(rp_strat_sort[i])+": "+Int2Str(R2I(I2R(100 * rp_strat[rp_strat_sort[i]]) / I2R(sum)))+" %")
      set i = i + 1
    endloop
  endif
endfunction

//============================================================================
function sort_rp_strat takes nothing returns nothing
  local integer i = 0
  local integer j = 0
  loop
    exitwhen i >= rp_strat_length
    set j = rp_strat_sort_length - 1
    loop
      exitwhen j < 0
      exitwhen rp_strat[rp_strat_sort[j]] > rp_strat[i]
      set rp_strat_sort[j + 1] = rp_strat_sort[j]
      set j = j - 1
    endloop
    set rp_strat_sort[j + 1] = i
    set rp_strat_sort_length = rp_strat_sort_length + 1
    set i = i + 1
  endloop
endfunction

//============================================================================
function nullify_bad_strats takes nothing returns nothing
  local integer i = 0
  loop
    if rp_strat[i] < (rp_strat[strategy] - (strat_persistence + (FoodUsed() * strat_food_persistence))) * strategy_change_threshold then
      set rp_strat[i] = 0
    endif
    set i = i + 1
    exitwhen i >= rp_strat_length
  endloop
endfunction

//============================================================================
function finish_strategy_change takes nothing returns nothing
  local integer strategy_roll = 0
  local integer sum = 0
  local integer i = 0

  call KeyBuildingAdd()
  call KeyUpgradeAdd()
  call KeyUnitAdd()
  call add_tier_bonus()
  set rp_strat[strategy] = rp_strat[strategy] + strat_persistence + strat_food_persistence * FoodUsed() // Add the bonuses to persistance
  call nullify_bad_strats()

  set rp_strat[strategy] = R2I(I2R(rp_strat[strategy]) * Pow(c_enemy_total,0.75))
  call make_rp_strat_positive()
  call init_rp_strat_sort()
  call sort_rp_strat()
//  call display_rp_strat_sort()
  set sum = sum_rp_strat_sort(relevant_strat_change_number)
  if sum < 1 then
    return
  endif
  set strategy_roll = GetRandomInt(1,sum)
  set sum = 0
  loop
    set sum = sum + rp_strat[rp_strat_sort[i]]
    if strategy_roll <= sum then
      //if rp_strat[rp_strat_sort[i]] / Max(rp_strat[strategy], 1) > strategy_change_threshold then
      set strategy = rp_strat_sort[i]
      set chosen_strategy = strategy
      call SetChatVar("Strategy", GetCurrentStrategyName())
      //endif
      return
    endif
    set i = i + 1
  endloop
endfunction

//============================================================================
function removeNonBeginningStrats takes nothing returns nothing
  local integer i = 0
  if nearest_enemy_range < 5000 or not ((game_is_ffa and c_enemy_total > 3) or (c_ally_total > 2 and c_enemy_total > 3)) then
    loop
      exitwhen i >= rp_strat_length
      if not beginning_strat[i] and (debug_strategy != i) then
        set rp_strat[i] = 0
      endif
      set i = i + 1
    endloop
  endif
endfunction

//============================================================================
function AddStrategyHeroRP takes integer h, integer to_add returns nothing
  local integer i = 0
  loop
    exitwhen i >= hero_number
    if all_heroes[i] == h then
      set hero_rp[i] = hero_rp[i] + to_add
    endif
    set i = i + 1
  endloop
endfunction

//============================================================================
// (AMAI) Race Aggression
//============================================================================
function ApplyStrategyRaceAggression takes nothing returns nothing
  local integer i = 0
  local integer l = tiernum * RACE_NUMBER
  loop
    exitwhen i >= l
    set race_aggression[i] = b_race_aggression[i] + strategy_race_aggression[strategy*l + i]
    set i = i + 1
  endloop
endfunction

//============================================================================
// (AMAI) Hero Choice
//============================================================================
function make_hero_rp_positive takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= hero_number
    if hero_rp[i] < 0 then
      set hero_rp[i] = 0
    endif
    set i = i + 1
  endloop
endfunction

//============================================================================
function sum_hero_rp takes nothing returns integer
  local integer i = first_choosable_hero
  local integer sum = 0
  loop
    exitwhen i >=hero_number
    set sum = sum + hero_rp[i]
    set i = i + 1
  endloop
  return sum
endfunction

//============================================================================
function ChooseHero takes nothing returns integer
  local integer i = first_choosable_hero
  local integer sum = 0
  local integer rp_sum = sum_hero_rp()
  local integer hero_roll = GetRandomInt(1,Max(rp_sum,1))
  if rp_sum <= 0 then
    return 0
  endif
  loop
    set sum = sum + hero_rp[i]
    if hero_roll <= sum then
      return i
    endif
    set i = i + 1
  endloop
  return 0
endfunction

//============================================================================
function remove_hero takes integer h returns nothing
  local integer i = h
  set hero_number = hero_number - 1
  loop
    exitwhen i >= hero_number
    set hero_rp[i] = hero_rp[i + 1]
    set all_heroes[i] = all_heroes[i + 1]
    set i = i + 1
  endloop
endfunction

//============================================================================
//
//============================================================================
function GetExistingHero takes nothing returns integer
  local group g = CreateGroup()
  local unit u = null
  local integer oid = 0
  local integer i = 0
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectUnittype(g, UNIT_TYPE_HERO, true)
  set u = FirstOfGroup(g)
  call DestroyGroup(g)
  set g = null
  if u == null then
    call DisplayToAll("Hero not found")
    return 0
  endif
  set oid = GetUnitTypeId(u)
  set u = null
  loop
    exitwhen i >= hero_number
    if old_id[all_heroes[i]] == oid then
      set chosen = i
      return all_heroes[i]
    endif
    set i = i + 1
  endloop
  call DisplayToAll("Unknown hero")
  return 0
endfunction

//============================================================================
function ChooseFirstHero takes nothing returns integer
  //if ver_neutral_heroes_available and neutral_available[NEUTRAL_TAVERN] and neutral_guarded[NEUTRAL_TAVERN] then
  //call remove_hero(7)
  //set first_choosable_hero = ver_neutral_hero_number
  //endif
  if IsMapFlagSet(MAP_RANDOM_HERO) then
//    call DisplayToAll("Map flag set")
    set hero[1] = GetExistingHero()
  else
    call make_hero_rp_positive()
    set chosen = ChooseHero()
    set hero[1] = all_heroes[chosen]
  endif
  return chosen
endfunction

//============================================================================
function ChooseSecondHero takes nothing returns nothing
  call make_hero_rp_positive()
  call remove_hero(chosen)
  set chosen = ChooseHero()
  set hero[2] = all_heroes[chosen]
endfunction

//============================================================================
function ChooseRestHeroes takes nothing returns nothing
  call make_hero_rp_positive()
  call remove_hero(chosen)
  set hero[3] = all_heroes[ChooseHero()]
endfunction

//============================================================================
// (AMAI) Building Functions
//============================================================================
function GetMinesHarvested takes nothing returns integer
  local integer twm = TownWithMine()
  local integer i = twm
  local integer sum = 0
  local integer mine = racial_expansion
  if race_manual_loading then
    set mine = race_manual_loading_mine
  endif
  if first_town_mine > 0 or race_manual_loading or race_uses_mine_expansion then  //home_location have multiple mine or just one mine but UD and ELF cannot harvested
    set twm = TownCountDone(mine)
    set i = twm
  endif
  if twm < 0 then
    return 0
  endif
  if race_manual_loading or race_uses_mine_expansion then
    return i
  else
    loop
      exitwhen i > twm + 3
      if TownHasMine(i) and TownCountEx(mine,true,i) > 0 then
        set sum = sum + 1
      endif
      set i = i + 1
    endloop
  endif
  return sum
endfunction

//============================================================================
function GetGoldIncome takes nothing returns real
  local integer inc = GetMinesHarvested()*income_per_mine
  if inc > GetGoldOwned() then
    set inc = GetGoldOwned()
  endif
  return I2R(inc + GetGold())/300
endfunction

//============================================================================
function GetIncomePercentage takes integer qty returns real
  if qty == 0 then
    return 0.0
  endif
  return 1 - 1/I2R(qty)
endfunction

//============================================================================
function GetFactoryQty takes integer qty, integer build_time, integer gold_cost, real in_percentage returns integer
  local real gip = GetIncomePercentage(qty) * gold_income * in_percentage
  local real gic = I2R(Max(gold_cost,1))/I2R(Max(build_time, 1))
//  call DisplayToAll("factory number returned: "+Int2Str(Max(Min(R2I(gip/gic), difficulty),1)))
  return Max(Min(R2I(gip/gic), difficulty),1)
endfunction

//============================================================================
function IsOneOnlyBuilding takes integer unitid returns boolean
  if false then
#INCLUDETABLE <$VER$\StandardUnits.txt> #EFR #COND "%4" =~ /\boneonly\b/
  elseif unitid == %1 then
    return true
#ENDINCLUDE
  endif
  return false
endfunction

//============================================================================
function Get_f_qty takes integer qty, integer unitid, integer town  returns integer
  if buy_type[unitid] != BT_UNIT or unitid == racial_peon or IsOneOnlyBuilding(needed1[unitid]) then
    return 1
  endif
  return GetFactoryQty(qty - TownCountTown(unitid, town), GetUnitBuildTime(old_id[unitid]), GetUnitGoldCost2(unitid), income_percentage[needed1[unitid]])
endfunction

//============================================================================
function AddBlock takes integer req_qty, integer req_type, boolean only_done, integer allow_qty, integer allow_type, integer expire_time returns nothing
  set bl_req_qty[bl_length] = req_qty
  set bl_req_type[bl_length] = req_type
  set bl_only_done[bl_length] = only_done
  set bl_allow_qty[bl_length] = allow_qty
  set bl_allow_type[bl_length] = allow_type
  set bl_expire_time[bl_length] = expire_time
  set bl_length = bl_length + 1
endfunction

function InitBlockList takes nothing returns nothing
  set bl_length = 0
endfunction

function BlockListCheck takes integer qty, integer t returns integer
  local integer i = 0
  local integer max_qty = qty
  loop
    exitwhen i >= bl_length
    if ai_time < bl_expire_time[i] and bl_allow_type[i] == t then
      if TownCountEx(bl_req_type[i], bl_only_done[i], -1) < bl_req_qty[i] then
        set max_qty = Min(max_qty, bl_allow_qty[i])
      endif
    endif
    set i = i + 1
  endloop
  return max_qty
endfunction

//============================================================================
function AddRBlock takes integer req_gold, integer req_wood, integer req_food, integer allow_qty, integer allow_type, integer expire_time returns nothing
  set rbl_req_gold[rbl_length] = req_gold
  set rbl_req_wood[rbl_length] = req_wood
  set rbl_req_food[rbl_length] = req_food
  set rbl_allow_qty[rbl_length] = allow_qty
  set rbl_allow_type[rbl_length] = allow_type
  set rbl_expire_time[rbl_length] = expire_time
  set rbl_length = rbl_length + 1
endfunction

function InitRBlockList takes nothing returns nothing
  set rbl_length = 0
endfunction

function RBlockListCheck takes integer qty, integer t returns integer
  local integer i = 0
  local integer max_qty = qty
  loop
    exitwhen i >= rbl_length
    if ai_time < rbl_expire_time[i] and rbl_allow_type[i] == t then
      if total_gold < rbl_req_gold[i] or total_wood < rbl_req_wood[i] or FoodUsed() < rbl_req_food[i] then
        set max_qty = Min(max_qty, rbl_allow_qty[i])
        set blocked_gold = Max(blocked_gold, rbl_req_gold[i])
        set blocked_wood = Max(blocked_wood, rbl_req_wood[i])
        set blocked_food = Max(blocked_food, rbl_req_food[i])
      endif
    endif
    set i = i + 1
  endloop
  return max_qty
endfunction

//============================================================================
//AMAI Build Code
//============================================================================

function SetBuildAllAMCore takes integer t, integer qty, integer unitid, integer town, integer bloc, integer prio returns nothing
  local integer i = 0
  local integer j = 0
  if unitid == 0 or qty == 0 then
    return
  endif
  if t == BUILD_UPGRADE then
    if GetUpgradeLevel(old_id[unitid]) >= qty then
      return
    endif
  elseif t == BUILD_ITEM then
    if GetItemNumber(unitid) >= qty then
      return
    endif
  elseif TownCountTown(unitid, town) >= qty or (buy_type[unitid] > BT_RACIAL_ITEM and not neutral_available[GetNeutralNumber(unitid)]) then
    return
  endif
  call GetBuildLock()
  set j = Max(build_length - 1,0)
  loop
    exitwhen i >= build_length
    exitwhen build_prio[i] < prio
    if build_item[i] == unitid and build_qty[i] >= qty and build_town[i] == town then
      call ReleaseBuildLock()
      return
    endif
    set i = i + 1
  endloop
  loop
    exitwhen j < i
    set build_qty[j+1] = build_qty[j]
    set build_type[j+1] = build_type[j]
    set build_item[j+1] = build_item[j]
    set build_town[j+1] = build_town[j]
    set build_loc[j+1] = build_loc[j]
    set build_prio[j+1] = build_prio[j]
    set j = j - 1
  endloop
  set build_qty[i] = qty
  set build_type[i] = t
  set build_item[i] = unitid
  set build_town[i] = town
  set build_loc[i] = bloc
  set build_prio[i] = prio
  set build_length = build_length + 1
  call ReleaseBuildLock()

  if qty > 1 then
    call SetBuildAllAMCore(t, qty - 1, unitid, town, bloc, prio + prio_q_inc )
  endif

endfunction

function RefreshNeeded takes integer t, integer qty, integer unitid, integer town, integer bloc, integer prio returns nothing
  if buy_type[unitid] == BT_ML_UPGRADE then
    if qty == 1 then
      if needed1[unitid] != 0 then
        call SetBuildAllAMCore(BUILD_UNIT, Get_f_qty(qty, unitid, town), needed1[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    elseif qty == 2 then
      call SetBuildAllAMCore(BUILD_UPGRADE, 1, unitid, town, BLOC_STD, prio + prio_n_inc)
      if needed2[unitid] != 0 then
        call SetBuildAllAMCore(BUILD_UNIT, 1, needed2[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    else
      call SetBuildAllAMCore(BUILD_UPGRADE, 1, unitid, town, BLOC_STD, prio + prio_n_inc + prio_n_inc)
      call SetBuildAllAMCore(BUILD_UPGRADE, 2, unitid, town, BLOC_STD, prio + prio_n_inc)
      if needed3[unitid] != 0 then
        call SetBuildAllAMCore(BUILD_UNIT, 1, needed3[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    endif
  elseif buy_type[unitid] == BT_HERO or buy_type[unitid] == BT_NEUTRAL_HERO then
    if unitid == hero[1] or unitid == hero[2] or unitid == hero[3] then
      if needed1[unitid] != 0 then
        call SetBuildAllAMCore(BUILD_UNIT, 1, needed1[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    endif
    if (unitid == hero[2] and not hero_built[2]) or (unitid == hero[3] and not hero_built[3]) then
      if needed2[unitid] != 0 then
        call SetBuildAllAMCore(BUILD_UNIT, 1, needed2[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    endif
    if unitid == hero[3] and not hero_built[3] then
      if needed3[unitid] != 0 then
        call SetBuildAllAMCore(BUILD_UNIT, 1, needed3[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    endif
  else
    if needed1[unitid] != 0 then
      if needed3[unitid] == UPGRADED then
        call SetBuildAllAMCore(BUILD_UNIT, qty + TownCountExForUpgrade(needed1[unitid],unitid,false,town), needed1[unitid], town, bloc, prio + prio_n_inc)
      else
        call SetBuildAllAMCore(BUILD_UNIT, Get_f_qty(qty, unitid, town), needed1[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    endif
    if needed2[unitid] != 0 then
      call SetBuildAllAMCore(BUILD_UNIT, 1, needed2[unitid], -1, BLOC_STD, prio + prio_n_inc)
    endif
    if needed3[unitid] != 0 and needed3[unitid] != UPGRADED then
      call SetBuildAllAMCore(BUILD_UNIT, 1, needed3[unitid], -1, BLOC_STD, prio + prio_n_inc)
    endif
  endif
  #INCLUDETABLE <$VER$\NeededExtra.txt> #EFR
  if unitid == %1 then
    call SetBuildAllAMCore(BUILD_%2, %3, %4, -1, BLOC_STD, prio + prio_n_inc)
  endif
  #ENDINCLUDE
endfunction

function SetBuildAllAM takes integer t, integer mqty, integer unitid, integer town, integer bloc, integer prio returns nothing
  set mqty = BlockListCheck(mqty, unitid)
  if unitid != 0 and mqty != 0 then
    call SetBuildAllAMCore(t, mqty, unitid, town, bloc, prio)
    call RefreshNeeded(t, mqty, unitid, town, bloc, prio)
  endif
endfunction

//============================================================================
function CanBuildUnit takes integer unitid returns boolean
  local boolean b = (needed1[unitid] == 0 or TownCountDone(needed1[unitid]) > 0) and (needed2[unitid] == 0 or TownCountDone(needed2[unitid]) > 0) and (needed3[unitid] == 0 or needed3[unitid] == UPGRADED or TownCountDone(needed3[unitid]) > 0)
#INCLUDETABLE <$VER$\NeededExtra.txt> #EFR #COND "%2" eq "UNIT"
  set b = b and (unitid != %1 or TownCountDone(%4) > 0)
#ENDINCLUDE
#INCLUDETABLE <$VER$\NeededExtra.txt> #EFR #COND "%2" eq "UPGRADE"
  set b = b and (unitid != %1 or GetUpgradeLevel(old_id[%4]) >= %3)
#ENDINCLUDE
  return b
endfunction

//============================================================================
function BuildUnit takes integer qty, integer unitid, integer prio returns nothing
  local integer i = BLOC_STD
  if buy_type[unitid] == BT_BUILDING and not IsRacialHallId(unitid , 1) then
    if minebuild then
      set i = BLOC_MINE
    elseif not homebuild and not shredderbuild then
      set i = BLOC_FRONT
    endif
  endif
  call SetBuildAllAM(BUILD_UNIT,qty,unitid,-1, i, prio)
endfunction

//============================================================================
function SetBuildUnitIfAvailable takes integer qty, integer unitid, integer prio returns nothing
  if CanBuildUnit(unitid) then
    call BuildUnit(qty, unitid, prio)
  endif
endfunction

//============================================================================
function SetBuildUnitExAM takes integer easy, integer med, integer hard, integer unitid, integer prio returns nothing
  if difficulty == EASY then
    call SetBuildAllAM(BUILD_UNIT,easy,unitid,-1, BLOC_STD, prio)
  elseif difficulty == NORMAL then
    call SetBuildAllAM(BUILD_UNIT,med,unitid,-1, BLOC_STD, prio)
  else
    call SetBuildAllAM(BUILD_UNIT,hard,unitid,-1, BLOC_STD, prio)
  endif
endfunction

//============================================================================
function SecondaryTownAM takes integer town, integer qty, integer unitid, integer prio returns nothing
  call SetBuildAllAM(BUILD_UNIT,qty,unitid,town, BLOC_STD, prio)
endfunction

//============================================================================
function BuildUpgr takes integer qty, integer unitid, integer prio returns nothing
  call SetBuildAllAM(BUILD_UPGRADE,qty,unitid,-1, BLOC_STD, prio)
endfunction

//============================================================================
// Makes upgrades have a dynamic priority that changes based on the number of
// units that have been built. 
// Param : quantity-num to build, unitid-the upgrade, start tier- must be at this tier to research, unitcount- number of units (NOTE must calculate yourself and then pass)
//              maxunits - number of units needed to make priority 100% the value given, 
//              prio - Base priority, this actually starts at priority of 1 and steadily increases as number of units goes up
//              tierbonus - adds or subtracts a bonus when you reach later tiers
//============================================================================

function BuildAdvUpgr takes integer qty, integer unitid, integer starttier, integer unitcount, integer maxunits, integer tierprio, integer prio returns nothing
  if tier >= starttier then
    if unitcount > 0 then
      if qty >= tier-starttier+1 then
        call BuildUpgr(tier-starttier + 1, unitid, R2I(LinearInterpolation(0, maxunits, 1, prio + ((tier-starttier)* tierprio) , unitcount)))
      else
        // If tier greater than the start tier and qty is less than the difference between the two
        call BuildUpgr(qty, unitid, R2I(LinearInterpolation(0, maxunits, 1, prio + ((tier-starttier)* tierprio), unitcount)))
      endif
    endif
  endif
endfunction

//============================================================================
// Makes upgrades be built by chance based on number of relevant units. Unlike BuildAdvUpgr the priority of the upgrade stays at the value specified if the random element succeeds.
// Note the random element is re-run very often.
// Note tier bonus priority is a fixed bonus.
// Param : quantity-num to build, unitid-the upgrade,  start tier- must be at this tier to research, unitcount- number of units (NOTE must calculate yourself and then pass)
//              unitper - Number of units to give a 1% chance of building upgrade,
//              max - Maximum chance to research
//              prio - Base priority
//============================================================================

function BuildAdvUpgr2 takes integer qty, integer upgid, integer starttier, integer unitcount, real unitper, integer max, integer prio returns nothing
//set num = (R2I((100 - FoodUsed())/GetFoodUsed(old_id[])) - 1) * prio_q_inc   // build upgrade priority at priority of unit
  if tier >= starttier then
    if unitcount > 0 then
      if GetRandomInt(1, 100) <= Min(R2I(unitcount/unitper), max) then
        if qty >= tier-starttier+1 then
          call BuildUpgr(tier-starttier + 1, upgid, prio + ((tier-starttier)*4))
        else
          // If tier greater than the start tier and qty is less than the difference between the two
          call BuildUpgr(qty, upgid, prio + ((tier-starttier)*4))
        endif
      endif
    endif
  endif
endfunction
//============================================================================
function SetBuildUpgrExAM takes integer easy, integer med, integer hard, integer unitid, integer prio returns nothing
  if difficulty == EASY then
    call SetBuildAllAM(BUILD_UPGRADE,easy,unitid,-1, BLOC_STD, prio)
  elseif difficulty == NORMAL then
    call SetBuildAllAM(BUILD_UPGRADE,med,unitid,-1, BLOC_STD, prio)
  else
    call SetBuildAllAM(BUILD_UPGRADE,hard,unitid,-1, BLOC_STD, prio)
  endif
endfunction

//============================================================================
function BuildExpa takes integer qty, integer unitid, integer prio returns nothing
  call SetBuildAllAM(BUILD_EXPAND,qty,unitid,-1, BLOC_STD, prio)
endfunction

//============================================================================
function BuildItem takes integer qty, integer unitid, integer prio returns nothing
  call SetBuildAllAM(BUILD_ITEM,qty,unitid,-1, BLOC_STD, prio)
endfunction

//============================================================================
function BuildFront takes integer qty, integer unitid, integer prio returns nothing
  call SetBuildAllAM(BUILD_UNIT, qty, unitid, -1, BLOC_FRONT, prio)
endfunction

//============================================================================
function BuildAtMine takes integer qty, integer unitid, integer prio returns nothing
  call SetBuildAllAM(BUILD_UNIT, qty, unitid, -1, BLOC_MINE, prio)
endfunction

//============================================================================
function SetBuildReact takes integer food, integer min1, integer unit1, integer min2, integer unit2, real enemy_strength, real strength1, real strength2, integer prio returns nothing
  local integer num1 = R2I(LinearInterpolation(strength1, strength2, I2R(food), 0, enemy_strength))/GetFoodUsed(old_id[unit1])
  local integer num2 = (food - num1 * GetFoodUsed(old_id[unit1]))/GetFoodUsed(old_id[unit2])
  local integer prio1 = 0
  local integer prio2 = 0
  local integer food1 = food/GetFoodUsed(old_id[unit1])
  local integer food2 = food/GetFoodUsed(old_id[unit2])

  if food1 > food2 then
    set prio1 = prio+(food1-1)*2 - (min1+num1-1)*2        // So builds starting at the max priority possible
    set prio2 = prio+(food1-1)*2 - (min2+num2-1)*2        // i.e build 6 footmen instead of 12 but will build those 6 starting at same proirity of 12
  else                                                    // This is so it builds less than the max it still builds at same priority.
    set prio1 = prio+(food2-1)*2 - (min1+num1-1)*2 - 4    // I assuming the second unit id is less common so make sure it has smaller prioity so that first unit gets its requirements first
    set prio2 = prio+(food2-1)*2 - (min2+num2-1)*2 - 4
  endif

//  if min1+num1 > min2 + num2 then
//    set prio2 = prio+(min1+num1-1)*2 - (min2+num2-1)*2		// So it builds at same priority as the first unit does
//  elseif min1+num1 < min2+num2 then
//    set prio1 = prio+(min2+num2-1)*2 - (min1+num1-1)*2
//  endif
  if min1 + num1 > 0 then
    call BuildUnit(min1 + num1, unit1, prio1)
  endif
  if min2 + num2 > 0 then
    call BuildUnit(min2 + num2, unit2, prio2)
  endif
endfunction

//============================================================================
function GetTier takes nothing returns integer
  local integer i = tiernum
  loop
    exitwhen i <= 1
    exitwhen TownCountDone(racial_hall[i]) >= 1
    set i = i - 1
  endloop
  return i
endfunction

//============================================================================
// Dynamic Strategy Functions
//============================================================================
function DetermineCounterForce takes nothing returns integer
  local integer strength = 0
  local integer total_strength = 0
  local integer array tstrength
  local integer num_strengths
  local integer j
  local integer random
  local integer maxstr = 0
  local integer secondstr = -1
  local integer thirdstr = -1
  local integer array temps
  local real ally_null = 0    // Blank point
  local string strdebug = " Counter Strengths: "

  set num_strengths = 0
  set j = 0
#INCLUDETABLE <$VER$\Strengths.txt>
  set tstrength[num_strengths] = R2I(RMax(enemy_%1 - (ally_%2/20) - (ally_%3/20),0)*10)
  //set strength = strength + tstrength[num_strengths]
  set strengthtext[num_strengths] = "%1"
  set num_strengths = num_strengths + 1
#ENDINCLUDE

  loop
    exitwhen j >= num_strengths
    if tstrength[j] > tstrength[maxstr] then
      set thirdstr = secondstr
      set secondstr = maxstr
      set maxstr = j
    elseif secondstr == -1 or tstrength[j] > tstrength[secondstr] then
      set thirdstr = secondstr
      set secondstr = j
    elseif thirdstr == -1 or tstrength[j] > tstrength[thirdstr] then
      set thirdstr = j
    endif
    set j = j + 1
  endloop
  if chosen_counter >= 0 then
    if tstrength[chosen_counter] > 0 then
      call Trace("Persistence counter bonus:" + Int2Str(R2I(strat_persistence/20)))
      set tstrength[chosen_counter] = tstrength[chosen_counter] + R2I(strat_persistence/20) // Bonus to current counter
      //set strength = strength + R2I(strat_persistence/200)
    endif
  endif
  //call Trace("Highest Enemy Unit Strength is:" + strengthtext[maxstr] + " with total:" + Int2Str(tstrength[maxstr]))
  set j = 0
  // Remove bad strats to not affect calculations with really low amounts of strength
  loop
    exitwhen j >= num_strengths
    if tstrength[j] < 3 then
      set tstrength[j] = 0
    endif
    set total_strength = total_strength + tstrength[j]
    set strdebug = strdebug + strengthtext[j] + ":" + Int2Str(tstrength[j]) + " - "
    set j = j+1
  endloop

  // No strength so just use a random option
  if total_strength == 0 then
    set no_counter = true
    set j = GetRandomInt(0, num_strengths - 1)
    call Trace("Chosen counter:" + Int2Str(j) + strdebug)
  else
    set no_counter = false
    set j = 0
    set random =GetRandomInt(1, total_strength)
    set strength = 0
    loop
      if j < num_strengths then
        set strength = strength + tstrength[j]
      endif
      exitwhen random <= strength or j >= num_strengths
      set j = j + 1	// Will be the the chosen strength to build units against
    endloop
    if (j == 11) then
      call Trace("!ERROR: Should not get a counter that is not within the strength range!")
    endif
    call Trace("Random Num:" + Int2Str(random) + " Chosen counter:" + Int2Str(j) + strdebug)
  endif
  set strdebug = null
  return j
endfunction

// Resets variables to 0
function ResetDynamicSystem takes nothing returns nothing
#INCLUDETABLE <$VER$\Strengths.txt>
	set totalanti_%1 = 0
	set totalchance_%1 = 0
#ENDINCLUDE
endfunction

#INCLUDETABLE <$VER$\Strengths.txt>
function AddUnitToAnti%1 takes integer u, integer percent returns nothing
	set dyanti_%1[totalanti_%1]= u
	set dychance_%1[totalanti_%1]= percent
	set totalanti_%1 = totalanti_%1 + 1
	set totalchance_%1 = totalchance_%1 + percent
endfunction
#ENDINCLUDE

#INCLUDETABLE <$VER$\Strengths.txt>
function BuildAnti%1Strength takes nothing returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer chance = 0

	if totalchance_%1 > 0 then
		set choice = GetRandomInt(0,totalchance_%1) // Build this unit
		loop
			set chance = chance + dychance_%1[i]
			exitwhen choice <= chance or i >= totalanti_%1
			set i = i + 1
		endloop
		if i >= totalanti_%1 and i > 0 then
			set u = dyanti_%1[i-1]
		else
			set u = dyanti_%1[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_%1 then
			//set food1 = food/GetFoodUsed(old_id[units[choice]])
			call Trace("Dynamic building Unit:" + unitNames[u] + " " +Int2Str(u))
			set chosen_counter_unit = u
		endif
	endif

endfunction
#ENDINCLUDE

function DynamicBuildUnit takes integer count, integer prio returns nothing
	local integer num
	if chosen_counter_unit > 0 then
		if IsUnitIdType(old_id[chosen_counter_unit], UNIT_TYPE_STRUCTURE) == false and not (buy_type[chosen_counter_unit] > BT_RACIAL_ITEM and buy_type[chosen_counter_unit] < BT_MERCHANT_ITEM) then // Normal units/upgrades
			set num = R2I((count - FoodUsed())/GetFoodUsed(old_id[chosen_counter_unit]))
			if num > 0 and GetUnitCount(old_id[chosen_counter_unit]) < num then
				call BuildUnit(Min(num, GetUnitCountDone(old_id[chosen_counter_unit]) + 10), chosen_counter_unit, prio)
			endif
		elseif buy_type[chosen_counter_unit] > BT_RACIAL_ITEM and buy_type[chosen_counter_unit] < BT_MERCHANT_ITEM then // A neutral mercenary
			set num = R2I((count - FoodUsed())/GetFoodUsed(old_id[chosen_counter_unit]))
			if num > 0 then
				call BuildUnit(GetUnitCountDone(old_id[chosen_counter_unit]) + 1, chosen_counter_unit, prio)
			endif
		else // structure
			call BuildUnit(1, chosen_counter_unit, prio*2)
		endif
	endif
endfunction

function DynamicStrategySelector takes nothing returns nothing
	local integer strength_count = 0

	#INCLUDETABLE <$VER$\Strengths.txt>
	if chosen_counter == strength_count then
		//call Trace("I'm building anti %1 units")
		call BuildAnti%1Strength()
	endif
	set strength_count = strength_count + 1
	#ENDINCLUDE

endfunction

//============================================================================
// (AMAI) Harrass Functions
//============================================================================
function InitHarass takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > max_harass_groups
    set harass_size[i] = 0
    set harass_time[i] = -1000000
    set i = i + 1
  endloop
  set distraction_group = 0
endfunction

function AddHarass takes integer groupnum, integer qty, integer unitid returns nothing
  set harass_qty[harass_size[groupnum]*max_harass_groups + groupnum] = qty
  set harass_units[harass_size[groupnum]*max_harass_groups + groupnum] = unitid
  set harass_size[groupnum] = harass_size[groupnum] + 1
endfunction

function RemoveHarass takes nothing returns nothing
  local integer i = 0
  loop
    set harass_size[i] = 0
    set i = i + 1
    exitwhen i >= 5
  endloop
endfunction

function AddHarassUnittype takes integer groupnum, integer harassnum, group g, group harasser, integer key returns group
  local group cg = null
  local unit u = null
  local real player_sum = 0
  set cg = CopyGroup(g,cg)
  set cg = SelectNumberOfId(cg, harass_qty[harassnum*max_harass_groups + groupnum], old_id[harass_units[harassnum*max_harass_groups + groupnum]])
  loop
    set u = FirstOfGroup(cg)
    exitwhen u == null
    call GroupAddUnit(unit_harassing, u)
    call RemoveGuardPosition(u)
    call GroupAddUnit(harasser,u)
    set player_sum = player_sum + GetUnitStrength(u)
    call GroupRemoveUnit(cg,u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(cg)
  set cg = null
  call SaveReal(additional_info, key, START_STRENGTH, player_sum)
  return harasser
endfunction

function StartHarass takes integer groupnum, integer harass_target, boolean avoid_towers, real strength_limit, real flee_percent, integer flee_number, real lx, real ly returns nothing
  local integer i = 0
  local integer t = 0
  local group harasser = CreateGroup()
  local group g = CreateGroup()
  local integer key = GetHandleId(harasser)
  local real strength = 0
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectByHidden(g, false)
  set g = SelectByAlive(g, true)
  set g = SelectByFullHealth(g, true)
  set g = SelectByUnitStandard(g, true)
  set g = SelectByUnitFree(g, true)
  loop
    exitwhen i >= harass_size[groupnum] or FirstOfGroup(g) == null or t >= 12
    set t = t + harass_qty[i*max_harass_groups + groupnum]
    if t > 12 then  // Group Order max control 12 unit
      set harass_qty[i*max_harass_groups + groupnum] = 12 - harass_qty[i*max_harass_groups + groupnum]
      set t = 12
    endif
    if harass_qty[i*max_harass_groups + groupnum] > 0 then
      set harasser = AddHarassUnittype(groupnum, i , g, harasser, key)
      set strength = strength + LoadReal(additional_info, key, START_STRENGTH)
    endif
    set i = i + 1
  endloop
  call DestroyGroup(g)
  set g = null
  if FirstOfGroup(harasser) == null or strength <= 0 then
    call GroupRecycleHarrassPositionInstant(harasser)
    set harasser = null
    return
  endif
  call SaveReal(additional_info, key, START_STRENGTH, strength)
  set harass_time[groupnum] = ai_time
  call SaveBoolean(additional_info, key, AVOID_TOWERS, avoid_towers)
  //if avoid_towers and GetLocationTowerStrength(GetUnitX(target), GetUnitY(target), ver_tower_check_radius) > 0
  call SaveReal(additional_info, key, STRENGTH_LIMIT, strength_limit)
  call SaveBoolean(additional_info, key, STATE_ATTACKING, true)
  call SaveReal(additional_info, key, FLEE_PERCENT, flee_percent)
  call SaveInteger(additional_info, key, FLEE_NUMBER, flee_number)
  call SaveInteger(additional_info, key, INVISIBLE_COUNT, 0)
  call SaveReal(additional_info, key, LOCX, lx)
  call SaveReal(additional_info, key, LOCY, ly)
  call TQAddGroupJob(0, HARASS, harass_target, null, harasser)
  set harasser = null
endfunction

function GetHarassGroupStrength takes integer groupnum returns real
  local real sum = 0
  local real p = GetPlayerHandicap(ai_player)
  local integer id = 0
  local unit u = null
  local group g = null
  set g = CopyGroup(unit_harassing,g)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set id = GetUnitTypeId(u)
    set sum = TownCountDone(id) * GetFoodUsed(id) * p
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  return sum
endfunction

function Harass takes integer groupnum, integer harass_target, boolean avoid_towers, real strength_limit, real flee_percent, integer flee_number, boolean cond, integer min_time, integer time returns nothing
  if cond and ai_time - harass_time[groupnum] >= time and ai_time >= min_time then
    call StartHarass(groupnum, harass_target, avoid_towers, strength_limit, flee_percent, flee_number, 0, 0)
  endif
  call RemoveHarass()
endfunction

//============================================================================
// (AMAI) StartUpgrade
//============================================================================

function StartUpgradeAM takes integer level, integer upgid returns integer
  local integer gold_cost = 0
  local integer wood_cost = 0
  local integer upg_level = GetUpgradeLevel(old_id[upgid])

  if upg_level >= level or ai_time < upgrade_time[upgid] then
    return BUILT_ALL
  endif

  if town_threatened then
    return BUILT_SOME // ignore upgrades and build units instead
  endif

  set gold_cost = GetUpgradeGoldCost(old_id[upgid])
  set wood_cost = GetUpgradeWoodCost(old_id[upgid])

  set build_free[needed1[upgid]] = build_free[needed1[upgid]] - 1
  if build_free[needed1[upgid]] >= 0 then
    set total_gold = total_gold - gold_cost
    set total_wood = total_wood - wood_cost
    if total_gold < 0 then
      set total_gold = 0
    endif
    if total_wood < 0 then
      set total_wood = 0
    endif
  endif

  if total_gold <= 0 and not (gold_cost == 0) then
    return NOT_ENOUGH_RES
  endif

  if total_wood <= 0 and not (wood_cost == 0) then
    return NOT_ENOUGH_RES
  endif

  if SetUpgrade(old_id[upgid]) then
    set upgrade_time[upgid] = ai_time + 10
    return BUILT_ALL
  else
    return CANNOT_BUILD
  endif
  return BUILT_SOME
endfunction



//============================================================================
// (AMAI) Utility Functions
//============================================================================

function GuardSecondaryAM takes integer townid, integer qty, integer unitid, integer prio returns nothing
  if TownHasHall(townid) and TownHasMine(townid) then
    call SecondaryTownAM( townid, qty, unitid, prio )
  endif
endfunction

//============================================================================
function DefendTownsEx takes boolean only_done, integer qty, integer unitid, integer prio returns nothing
  local integer twm = Max(TownWithMine(),1)
  local integer i = twm
  loop
    exitwhen i > twm + 2
    if TownHasMine(i) and TownCountEx(racial_expansion,only_done,i) > 0 then
      call SecondaryTownAM(i, qty, unitid, prio)
    endif
    set i = i + 1
  endloop
endfunction

//============================================================================
function DefendTowns takes integer qty, integer unitid, integer prio returns nothing
  call DefendTownsEx(false, qty, unitid, prio)
endfunction

//============================================================================
function DefendTownsDone takes integer qty, integer unitid, integer prio returns nothing
  call DefendTownsEx(true, qty, unitid, prio)
endfunction

//============================================================================
function DefendTownsCond takes integer qty, integer unitid, integer min_dist, integer max_dist, integer min_gold, integer prio returns nothing
  local integer twm = Max(TownWithMine(),1)
  local integer i = twm
  loop
    exitwhen i > twm + 2
    if TownHasMine(i) and town_built[i] and own_town_dist[i] >= min_dist and own_town_dist[i] <= max_dist and GetResourceAmount(own_town_mine[i]) >= min_gold then
      call SecondaryTownAM(i, qty, unitid, prio)
    endif
    set i = i + 1
  endloop
endfunction

//============================================================================
function BasicExpansionAM takes boolean build_it, integer unitid, integer prio returns nothing
  if build_it and HallsCompleted(unitid) then
    call BuildExpa( TownCount(unitid)+1, unitid, prio )
  endif
endfunction

//============================================================================
function UpgradeAllAM takes integer baseid, integer newid, integer prio returns nothing
  call BuildUnit( TownCountDone(baseid), newid, prio )
endfunction

//============================================================================
//  FoodPool
//============================================================================

function FoodPoolAM takes integer food, boolean weak, integer id1, integer use1, boolean strong, integer id2, integer use2, integer prio returns nothing
  if strong then
    call BuildUnit( (food - use1 * TownCount(id1)) / use2, id2, prio )
  elseif weak then
    call BuildUnit( (food - use2 * TownCount(id2)) / use1, id1, prio )
  endif
endfunction

//============================================================================
//  MeleeTownHall
//============================================================================

function MeleeTownHallAM takes integer townid, integer unitid, integer prio returns nothing
  if TownHasMine(townid) and not TownHasHall(townid) then
    call SecondaryTownAM( townid, 1, unitid, prio )
  endif
endfunction

//============================================================================
// (AMAI) Refresh and Builds
//============================================================================
function AddRefresh takes integer t, integer qty, integer unitid, integer town, integer bloc, integer prio returns nothing
  set t_build_qty[t_build_length] = qty
  set t_build_type[t_build_length] = t
  set t_build_item[t_build_length] = unitid
  set t_build_town[t_build_length] = town
  set t_build_loc[t_build_length] = bloc
  set t_build_prio[t_build_length] = prio
  set t_build_length = t_build_length + 1
endfunction

//============================================================================
function RefreshAllNeeded takes nothing returns nothing
  local integer index = 0
  loop
    exitwhen index >= t_build_length
    call RefreshNeeded(t_build_type[index], t_build_qty[index], t_build_item[index], t_build_town[index], t_build_loc[index], t_build_prio[index])
    set index = index + 1
  endloop
endfunction

//============================================================================
function GetNeutralHero takes integer unitid returns integer
  local integer i = 0

  call Trace("I Want a Tavern Hero")

  if not neutral_available[NEUTRAL_TAVERN] then
    call Trace("No Tavern Available")
    return BUILT_ALL
  endif
  if nearest_neutral[NEUTRAL_TAVERN] == null or neutral_guarded[NEUTRAL_TAVERN] then
    // Returns null if it cannot path to a tavern succesfully
    // Should switch to using transportation to get to it
    // Not Yet Implemented - will instead just build standard heroes
    call Trace("Tavern not usable: Getting standard hero")
    set recalculate_heros = true
    //set first_choosable_hero = ver_neutral_hero_number
    //loop
    //	exitwhen i > hero_number
    //	set all_heroes[i] = all_heroes_copy[i]
    //	set i = i + 1
    //endloop	
    //if hero[1] == unitid then
    //	set picked_hero = ChooseFirstHero()
    //elseif hero[2] == unitid then
    //	set hero[1] = GetExistingHero()
    //	call ChooseSecondHero()
    //else
    //	call ChooseRestHeroes()
    //endif
    //if nearest_neutral[NEUTRAL_TAVERN] == null then
    //	call DisplayToAll("No Tavern Reachable")
    //else
    //	call DisplayToAll("Tavern is guarded")
    //endif

    // call set_skills()       NOT YET IMPLEMENTED - if tavern is not passable it just chooses a normal hero, unfortunately it at moment has no skills
    return CANNOT_BUILD
  endif


  if (unitid == hero[1] and hero_built[1]) or (unitid == hero[2] and hero_built[2]) or (unitid == hero[3] and hero_built[3]) then
    call Trace("Try To Resurrect Tavern Hero")
    if SetProduce(1,old_id[unitid],-1) then
      return BUILT_ALL
    else
      return CANNOT_BUILD
    endif
  endif

//   if neutral_sent[NEUTRAL_TAVERN] == null then
//   	set neutral_sent[NEUTRAL_TAVERN] = GetUnitToBuy(nearest_neutral[NEUTRAL_TAVERN])
//   	if neutral_sent[NEUTRAL_TAVERN]  == null then
//		return CANNOT_BUILD
//	endif
//    endif

//	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "check requirements")
  if TownCountDone(needed1[unitid]) < 1 or (unitid == hero[2] and TownCountDone(needed2[unitid]) < 1) or (unitid == hero[3] and TownCountDone(needed3[unitid]) < 1) then
    call Trace("Requirements failed to get hero")
    return CANNOT_BUILD
  endif


  if not neutral_ordered[NEUTRAL_TAVERN] then
    call Trace("Prepare to Do Tavern Job")
    set neutral_ordered[NEUTRAL_TAVERN] = true
    set neutral_wanted[NEUTRAL_TAVERN] = 1
    call TQAddJob(0, BUY_NEUTRAL_HERO, unitid)
  endif
  return BUILT_SOME
endfunction

//============================================================================
function CheckNotBuiltFrom takes integer unitid returns boolean
#INCLUDETABLE <$VER$\UnitEquivalence.txt> #EFR #COND "%2" eq "BUILT_FROM"
  if unitid == %1 then
    return false
  endif
#ENDINCLUDE
  return true
endfunction

//============================================================================
function GetBuildLocation takes integer bloc returns location
  if bloc == BLOC_MINE then
    return mine_loc
  endif
  if front_loc[0] != null then
    return front_loc[GetRandomInt(0, front_loc_num - 1)]
  endif
  return home_location
endfunction

//============================================================================
function UpgradeBuilding takes integer qty, integer unitid, integer town, integer bloc returns integer
  local unit u = null
  local group g = CreateGroup()
  local integer current_town = town
  local integer num = 0
  if town == -1 then
    set current_town = 0
  endif
  if bloc != BLOC_STD then
    call GroupEnumUnitsInRangeOfLoc(g, GetBuildLocation(bloc), 800, null)
    set g = SelectByPlayer(g, ai_player, true)
    set g = SelectByAlive(g, true)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      if GetUnitTypeId(u) == old_id[needed1[unitid]] then
        if IssueImmediateOrderById(u, old_id[unitid]) then
          set num = num + 1
          if num >= qty then
            call DestroyGroup(g)
            set g = null
            set u = null
            return BUILT_ALL
          endif
        endif
      endif
      call GroupRemoveUnit(g,u)
    endloop
  endif
  if own_town_loc[current_town] != null then
    call GroupClear(g)
    call GroupEnumUnitsInRangeOfLoc(g, own_town_loc[current_town], 2000, null)
    set g = SelectByPlayer(g, ai_player, true)
    set g = SelectByAlive(g, true)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      if GetUnitTypeId(u) == old_id[needed1[unitid]] then
        if IssueImmediateOrderById(u, old_id[unitid]) then
          set num = num + 1
          if num >= qty then
            call DestroyGroup(g)
            set g = null
            set u = null
            return BUILT_ALL
          endif
        endif
      endif
      call GroupRemoveUnit(g,u)
    endloop
  endif
  call DestroyGroup(g)
  set g = null
  if town != -1 then
    if num == 0 then
      return CANNOT_BUILD
    else
      return BUILT_SOME
    endif
  endif
  set g = CreateGroup()
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == old_id[needed1[unitid]] then
      if IssueImmediateOrderById(u, old_id[unitid]) then
        set num = num + 1
        if num >= qty then
          call DestroyGroup(g)
          set g = null
          set u = null
          return BUILT_ALL
        endif
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  if num == 0 then
    return CANNOT_BUILD
  else
    return BUILT_SOME
  endif
endfunction

//============================================================================
function BuildAtSpecialLoc takes integer unitid, integer town, integer bloc returns integer
  local unit peon = GetExpansionPeon()
  local unit utemp1 = CreateUnitAtLoc(Player(PLAYERPASSIVE), old_id[unitid], home_location, 270.0)  //utemp is seat, leave a passage , unit can ensure correct position
  local unit utemp2 = null
  local unit u = null
  local location l = null
  if front_loc[0] != null then
    set utemp2 = CreateUnitAtLoc(Player(PLAYERPASSIVE), old_id[unitid], front_loc[0], 270.0)
  else
    set utemp2 = CreateUnitAtLoc(Player(PLAYERPASSIVE), old_id[unitid], home_location, 270.0)
  endif
  set u = CreateUnitAtLoc(Player(PLAYERPASSIVE), old_id[unitid], GetBuildLocation(bloc), 270.0)
  set l = GetUnitLoc(u)
  call RemoveUnit(utemp1)
  set utemp1 = null
  call RemoveUnit(utemp2)
  set utemp2 = null
  call RemoveUnit(u)
  set u = null
  if peon == null then
    set peon = GetExpansionPeon2(peon)  // In case we can't get the expansion peon
  endif
  if l == null then
    //call Trace("BuildatspecialLoc: No location found")
    //call RemoveLocation(l)
    //set l = null
    set peon = null
    return CANNOT_BUILD
  elseif peon == null then
    call Trace("BuildatspecialLoc: No peon available")
    call RemoveLocation(l)
    set l = null
    return CANNOT_BUILD
  else
    if bloc == BLOC_FRONT and DistanceBetweenPoints(l,home_location) >= front_base_distance + 400 then
      call Trace("BuildatspecialLoc: Build loc too far , fix build loc")
      if front_loc[0] != null then
        call RemoveLocation(l)
        set l = AIGetProjectedLoc(front_loc[GetRandomInt(0, front_loc_num - 1)], home_location, 200, 0)
      endif
    endif
    if not IssuePointOrderByIdLoc(peon, old_id[unitid], l) then
      //call Trace("Building at special point")
    //else
      // call Trace("BuildatspecialLoc: Not able to build here")
      call RemoveLocation(l)
      set l = null
      set peon = null
      return CANNOT_BUILD
    endif
  endif
  call RemoveLocation(l)
  set l = null
  set peon = null
  return BUILT_SOME
endfunction

//============================================================================
// AMAI Build Codes
//============================================================================
function StartUnitAM takes integer ask_qty, integer unitid, integer town, integer bloc, integer prio, integer max_order returns integer
    local integer have_qty = 0
    local integer need_qty = 0
    local integer afford_gold = 0
    local integer afford_wood = 0
    local integer afford_food = 0
    local integer afford_qty = 0
    local integer gold_cost = 0
    local integer wood_cost = 0
    local integer food_cost = 0
    local integer cost_qty = 0
    local integer n1 = needed1[unitid]
    local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
    local integer nn = GetNeutralNumber(unitid)

    if town != -1 and (not town_built[town] or (unitid != racial_expansion and TownCountTown(racial_expansion, town) <= 0)) then
      return BUILT_ALL
    endif

    if buy_type[unitid] > BT_RACIAL_ITEM and (ai_time < available_time[unitid] or (neutral_guarded[nn] and ((daytime >= 5 and daytime < 18) or not neutral_night_buy[nn] or (buy_type[unitid] != BT_NEUTRAL_HERO and not ver_mercs_night_buy)))) then
      return BUILT_SOME
    endif

    if needed3[unitid] == UPGRADED and town != -1 and ai_time < available_time[unitid] then
      return BUILT_SOME
    endif

    //------------------------------------------------------------------------
    // if we have all we're asking for then make nothing
    //
    set have_qty = Max(TownCountTown(unitid,town),max_order)

    if have_qty >= ask_qty then
      return BUILT_ALL
    endif
    set need_qty = ask_qty - have_qty

    //------------------------------------------------------------------------
    // limit the qty we're requesting to the amount of resources available
    //
    set gold_cost = GetUnitGoldCost2(unitid)
    set wood_cost = GetUnitWoodCost2(unitid)
    set food_cost = GetFoodUsed(old_id[unitid])

    if gold_cost == 0 then
      set afford_gold = need_qty
    else
      set afford_gold = total_gold / gold_cost
    endif
    if afford_gold < need_qty then
      set afford_qty = afford_gold
    else
      set afford_qty = need_qty
    endif

    if wood_cost == 0 then
      set afford_wood = need_qty
    else
      set afford_wood = total_wood / wood_cost
    endif
    if afford_wood < afford_qty then
      set afford_qty = afford_wood
    endif

    if food_cost == 0 then
      set afford_food = need_qty
    else
      set afford_food = total_food / food_cost
    endif
    if afford_food < afford_qty then
      set afford_qty = afford_food
    endif

    //------------------------------------------------------------------------
    // whether we make right now what we're requesting or not, assume we will
    // and deduct the cost of the units from our fake gold total right away
    //
    if (buy_type[unitid] == BT_UNIT or buy_type[unitid] == BT_HERO) and CheckNotBuiltFrom(unitid) then
      set cost_qty = build_free[n1]
      if cost_qty > need_qty then
        set cost_qty = need_qty
      endif
      if cost_qty < 0 then
        set cost_qty = 0
      endif
      set build_free[n1] = build_free[n1] - need_qty
      if unitid != racial_peon then
        set gold_sum[n1] = gold_sum[n1] + need_qty * gold_cost
        set build_time_sum[n1] = build_time_sum[n1] + need_qty * GetUnitBuildTime(old_id[unitid])
        set build_num[n1] = build_num[n1] + need_qty
        set prio_sum[n1] = prio_sum[n1] + need_qty * prio
      endif
    else
      set cost_qty = need_qty
    endif

    set cost_qty = Min(cost_qty, afford_food)

    set afford_food = ApplyUpkeepCheck(afford_food, ver_food_limit - total_food, food_cost, cost_qty, need_qty)

    set cost_qty = Min(cost_qty, afford_food)
    set afford_qty = Min(afford_qty, cost_qty)

    set total_gold = total_gold - gold_cost * cost_qty
    set total_wood = total_wood - wood_cost * cost_qty
    set total_food = total_food - food_cost * cost_qty

    if total_gold < 0 then
      set total_gold = 0
    endif
    if total_wood < 0 then
      set total_wood = 0
    endif
    if total_food < 0 then
      set total_food = 0
    endif

    // if we're waiting on gold and wood; pause build orders
    if total_gold <= 0 and not (gold_cost == 0) then
      return NOT_ENOUGH_RES
    elseif total_wood <= 0 and not (wood_cost == 0) then
      return NOT_ENOUGH_RES
    elseif afford_qty <= 0 then
      return BUILT_SOME
    endif

    //------------------------------------------------------------------------
    // give the AI a chance to make the units (it may not be able to right now
    // but that doesn't stop us from trying other units after this as long
    // as we have enough money to make this AND the needed, unbuilt ones)
    //

    if needed3[unitid] == UPGRADED then
      if (needed1[unitid] != 0 and GetUnitCountEx(needed1[unitid],true,town) < 1) or (needed2[unitid] != 0 and TownCountDone(needed2[unitid]) < 1) then
        return CANNOT_BUILD
      endif
    endif

  #INCLUDETABLE <$VER$\UnitEquivalence.txt> #EFR #COND "%2" eq "UPGRADED_TO"
    if unitid == %1 and GetUpgradeLevel(o%4) >= %5 then
      if SetProduce(afford_qty,o%3,town) then
        if (afford_qty == need_qty) and (need_qty == cost_qty) then
          return BUILT_ALL
        else
          return BUILT_SOME
        endif
      else
        return CANNOT_BUILD
      endif
    endif
  #ENDINCLUDE

  #INCLUDETABLE <$VER$\UnitEquivalence.txt> #EFR #COND "%2" eq "BUILT_FROM"
    if unitid == %1 then
      if GetUpgradeLevel(o%4) >= %5 then
        if ConvertUnits(afford_qty + have_qty, o%3) then
          if (afford_qty == need_qty) and (need_qty == cost_qty) then
            return BUILT_ALL
          else
            return BUILT_SOME
          endif
        else
          return CANNOT_BUILD
        endif
      else
        return CANNOT_BUILD
      endif
    endif
  #ENDINCLUDE

    if buy_type[unitid] == BT_NEUTRAL_HERO then
      return GetNeutralHero(unitid)
    endif

    if unitid == racial_rushcreep then
      if CreepsOnMap() and not towerrush then
        call BuildBRAtCreep()
      endif
      set racial_rushcreep = -1  //just run once
      return BUILT_SOME
    endif

    if buy_type[unitid] > BT_RACIAL_ITEM and buy_type[unitid] <= BT_MERCHANT_ITEM then
      if not (neutral_ordered[nn] or attack_running) and nearest_neutral[nn] != null then
        set neutral_ordered[nn] = true
        set neutral_wanted[nn] = afford_qty + have_qty
        call TQAddJob(0, BUY_NEUTRAL, unitid)
      endif
      return BUILT_SOME
    endif

    if needed3[unitid] == UPGRADED and buy_type[unitid] == BT_BUILDING then
      return UpgradeBuilding(afford_qty, unitid, town, bloc)
    endif

    if unitid == racial_lumber and TownCount(racial_lumber) < 1 then
      if BuildLumberMillAtBase() then
        return BUILT_SOME
      else
        return CANNOT_BUILD
      endif
    endif

    if bloc != BLOC_STD then
      if not CanBuildUnit(unitid) then
        return CANNOT_BUILD
      endif
      if bloc == BLOC_FRONT and not front_locs_computed then
        return BUILT_SOME
      endif
      if BuildAtSpecialLoc(unitid, town, bloc) != CANNOT_BUILD then   // This only occurs if no peon could be obtained
        return BUILT_SOME
      endif
    endif

    if SetProduce(afford_qty,old_id[unitid],town) then
      if town != -1 and unitid == racial_expansion then
        set town_built[town] = false
      endif
      if needed3[unitid] == UPGRADED then
        set available_time[unitid] = ai_time + GetUnitBuildTime(old_id[unitid]) / 5 + 1
      endif
      if (afford_qty == need_qty) and (need_qty == cost_qty) then
        return BUILT_ALL
      else
        return BUILT_SOME
      endif
    else
      return CANNOT_BUILD
    endif
endfunction

//============================================================================
function ConstructExpansion takes unit peon, integer unitid returns boolean
  local unit u = null
  if ai_time > exp_loc_cache_timeout then
    set u = CreateUnit(Player(PLAYERPASSIVE), unitid, GetUnitX(current_expansion), GetUnitY(current_expansion), 270.0)
    if DistanceBetweenUnits(u, current_expansion) > race_max_expa_mine_distance then
      call RemoveUnit(u)
      set u = null
      return false
    endif
    call RemoveLocation(exp_loc_cache)
    set exp_loc_cache = GetUnitLoc(u)
    set exp_loc_cache_timeout = ai_time + 4
  //  call SetUnitExploded(u, true)
  //  call KillUnit(u)
    call RemoveUnit(u)
    set u = null
  endif
  call TQAddUnitJob(2 * sleep_multiplier, BUILD_EXPANSION, 0, peon)
  return IssuePointOrderByIdLoc(peon, unitid, exp_loc_cache)
endfunction

//============================================================================
function IsWaterExpansion takes unit u returns boolean
  //local integer i = 0
  // loop
  //   exitwhen i == water_expansion_list_length
  //   if water_expansion_list[i] == u then
  //     return true
  //   endif
  //   set i = i + 1
  // endloop
  return IsUnitInGroup(u,water_expansion)
endfunction

//============================================================================
function BuildMovePeonZeppelin takes unit peon, unit target returns boolean
  if expansion_peon == null or not UnitAlive(expansion_peon) then
    set expansion_peon = peon
  endif
  // Disabled just in case
  if build_zeppelin == null or not UnitAlive(build_zeppelin) then
    if not UnitAlive(build_zeppelin) then
      call GroupRemoveUnit(unit_zepplin_move, build_zeppelin)
    endif
    set build_zeppelin = GetUnusedZeppelinNearUnit(build_zeppelin, expansion_peon)
    if build_zeppelin == null then
      call Trace("No Zeppelin found for transporting peon")
      return false
    endif
    call GroupAddUnit(unit_zepplin_move, build_zeppelin)
  endif
  if IsUnitInTransport(expansion_peon, build_zeppelin) then
    if DistanceBetweenUnits(build_zeppelin, target) > 300 then
      call IssuePointOrder(build_zeppelin, "move", GetUnitX(target) + GetRandomReal(-200,200), GetUnitY(target) + GetRandomReal(-200,200))
    else
      call IssueTargetOrder(build_zeppelin, "unload", expansion_peon)
      call Sleep(1.2)  //unload time
      call GroupRemoveUnit(unit_zepplin_move, build_zeppelin)
      return true
    endif
  else
    if DistanceBetweenUnits(expansion_peon, target) < 400 then
      call GroupRemoveUnit(unit_zepplin_move, build_zeppelin)
      return true
    else
      call IssueTargetOrder(expansion_peon, "smart", build_zeppelin)
    endif
  endif
  return false
endfunction

//============================================================================
function StartExpansionAM takes integer qty, integer hall returns integer
  local integer count = TownCount(hall)
  local integer countdone = TownCountDone(hall)
  local unit    peon = null
  local unit    u = null
  local integer gold_cost = 0
  local integer wood_cost = 0

  if countdone >= qty then
    return BUILT_ALL
  endif
  if (count > countdone) or town_threatened then
    return BUILT_SOME
  endif

  if first_town_mine > 1 then
    if MultipleMinefix() then
      return BUILT_ALL
    endif
  endif

  if current_expansion == null or CheckExpansionTaken(current_expansion) then
    call ChooseExpansion()
    if current_expansion == null then
      call Trace("AMAIStartexpa: Expansion Not Found")
      return BUILT_ALL
    endif
  endif
  if CheckExpansionTaken(current_expansion) then
    set current_expansion = null
    return BUILT_ALL
  endif
  // call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Expansion Taken Checked")

  // call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Expansion choosen")

  set gold_cost = GetUnitGoldCost2(hall)
  set wood_cost = GetUnitWoodCost2(hall)

  set total_gold = total_gold - gold_cost
  set total_wood = total_wood - wood_cost

  if total_gold < 0 then
    set total_gold = 0
  endif
  if total_wood < 0 then
    set total_wood = 0
  endif

  if total_gold <= 0 and not (gold_cost == 0) then
    return NOT_ENOUGH_RES
  endif

  if total_wood <= 0 and not (wood_cost == 0) then
    return NOT_ENOUGH_RES
  endif
  set take_exp = (GetExpFoe(u) != null)
  set u = null
  if take_exp or total_gold <= 0 or total_wood <= 0 then
    return BUILT_SOME
  endif

  // call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Expansion rescources sorted")

  set peon = GetExpansionPeon()
  if peon == null then
    set peon = GetExpansionPeon2(peon)
  endif

//  call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Peon Got")
  if not IsUnitInGroup(current_expansion, water_expansion) and DistanceBetweenUnits(peon,current_expansion) > 6000 and not IsUnitInGroup(current_expansion, far_expansion) then
    call GroupAddUnit(far_expansion, current_expansion)
  endif

  if peon != null then
    if IsWaterExpansion(current_expansion) or IsUnitInGroup(current_expansion, far_expansion) then
      if not BuildMovePeonZeppelin(peon, current_expansion) then
        call Trace("AMAIStartexpa: Is a water or far expansion")
        set peon = null
        return BUILT_SOME
      endif
      set peon = expansion_peon
    endif
    set exp_time_count = ai_time	// This sets time to next expansion to current time so it waits enough time before starting another expansion 
    if race_uses_mine_expansion then
      call TQAddUnitJob(2 * sleep_multiplier, BUILD_EXPANSION, 0, peon)
      call IssueTargetOrderById(peon, old_id[hall], current_expansion)
    else
      call ConstructExpansion(peon,old_id[hall])
    endif
    set peon = null
  endif
//  call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Expansion Finished")
  return BUILT_SOME
endfunction

//============================================================================
// Set up to buy an item
function BuyItem takes integer qty, integer id returns boolean
  if attack_running then
    return false
  endif
  if shop_ordered then
    //call Trace("Already ordered to get an item")
    return true
  endif
  set shop_wanted = qty
  if buy_type[id] == BT_RACIAL_ITEM then
    set shop_unit = GetOneOfId(shop_unit, ai_player, old_id[racial_shop])
    set shop_distance_limit = raceshop_distance_limit
  else
    set shop_unit = nearest_neutral[NEUTRAL_MERCHANT]
    set shop_distance_limit = merchant_distance_limit
  endif
  if shop_unit != null then
    set shop_ordered = true
    call TQAddJob(0, BUY_ITEM, id)
    return true
  endif
  return false
endfunction

function BuyAllyShopItem takes integer qty, integer id returns boolean
  local group g = null
  local unit u = null
  local integer i = 0
  local integer m = 0
  local integer array per
  if attack_running then
    return false
  endif
  if shop_ordered then
    //call Trace("Already ordered to get an item")
    return true
  endif
  loop
    exitwhen i >= c_ally_total
    if GetPlayerSlotState(ally_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set per[m] = i
      set m = m + 1
    endif
    set i = i + 1
  endloop
  set shop_unit = null
  if m > 1 then
    set g = CreateGroup()
    call GroupEnumUnitsOfPlayer(g, Player(per[GetRandomInt(0,m-1)]), null)
    set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      if GetUnitAbilityLevel(u, 'Aall') > 0 and UnitAlive(u) then  // select ally shop , use JOB TrackTown record ally shop is best, but worried about affecting efficiency , if use new JOB then too wasteful
        if shop_unit == null or GetRandomInt(0,1) == 1 then
          set shop_unit = u  // get Random shop
        endif
      endif
      call GroupRemoveUnit(g, u)
    endloop
    call DestroyGroup(g)
    set g = null
  endif
  if shop_unit == null then
    return false
  endif
  set shop_wanted = qty
  set shop_distance_limit = raceshop_distance_limit
  set shop_ordered = true
  call TQAddJob(0, BUY_ITEM, id)
  return true
endfunction

//============================================================================
// Buy item but ignore all buffer changes to players gold. Buy as fast as possible
function StartEmergencyItem takes integer ask_qty, integer itemid returns integer
  local integer gold_cost = gold_price[itemid]
  local integer wood_cost = wood_price[itemid]
  local integer have_qty = GetItemNumber(itemid)
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  local integer gold = GetGold()
  local integer wood = GetWood()

  if have_qty >= ask_qty or (buy_type[itemid] == BT_MERCHANT_ITEM and not neutral_available[NEUTRAL_MERCHANT]) then
    return BUILT_ALL
  endif

  if nearest_neutral[NEUTRAL_MERCHANT] == null and buy_type[itemid] == BT_MERCHANT_ITEM then
    call Trace("No merchant available to buy emergency item")
    // Cannot path so will require transporter
    // NYI
    return BUILT_ALL
  endif

  if available_time[itemid] > ai_time or (buy_type[itemid] == BT_MERCHANT_ITEM and neutral_guarded[NEUTRAL_MERCHANT] and ((daytime >= 5 and daytime < 18) or not neutral_night_buy[NEUTRAL_MERCHANT])) then
    return BUILT_SOME
  endif

  if (needed1[itemid] != 0 and TownCountDone(needed1[itemid]) < 1) or (needed2[itemid] != 0 and TownCountDone(needed2[itemid]) < 1) or (needed3[itemid] != 0 and TownCountDone(needed3[itemid]) < 1) then
    call Trace("Emergency item not enough requirements to buy item")
    return CANNOT_BUILD
  endif

  set gold = gold - gold_cost
  set wood = wood - wood_cost

  if gold < 0 then
    set gold = 0
  endif
  if wood < 0 then
    set wood = 0
  endif

  if gold <= 0 and not (gold_cost == 0) then
    return NOT_ENOUGH_RES
  endif

  if wood <= 0 and not (wood_cost == 0) then
    return NOT_ENOUGH_RES
  endif

  if BuyItem(have_qty + 1, itemid) then
    call Trace("Buying emergency item")
    return BUILT_SOME
  else
    return CANNOT_BUILD
  endif
  return BUILT_SOME
endfunction

//============================================================================
function StartItem takes integer ask_qty, integer itemid returns integer
  local integer gold_cost = gold_price[itemid]
  local integer wood_cost = wood_price[itemid]
  local integer have_qty = GetItemNumber(itemid)
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)


  if have_qty >= ask_qty or (buy_type[itemid] == BT_MERCHANT_ITEM and not neutral_available[NEUTRAL_MERCHANT]) then
    return BUILT_ALL
  endif

  if nearest_neutral[NEUTRAL_MERCHANT] == null and buy_type[itemid] == BT_MERCHANT_ITEM then
     // Cannot path so will require transporter
     // NYI
     return BUILT_ALL
  endif

  if available_time[itemid] > ai_time or GetSlotsFree() <= 0 or (buy_type[itemid] == BT_MERCHANT_ITEM and neutral_guarded[NEUTRAL_MERCHANT] and ((daytime >= 5 and daytime < 18) or not neutral_night_buy[NEUTRAL_MERCHANT])) then
    return BUILT_SOME
  endif

  if (needed1[itemid] != 0 and TownCountDone(needed1[itemid]) < 1) or (needed2[itemid] != 0 and TownCountDone(needed2[itemid]) < 1) or (needed3[itemid] != 0 and TownCountDone(needed3[itemid]) < 1) then
    return CANNOT_BUILD
  endif

  set total_gold = total_gold - gold_cost
  set total_wood = total_wood - wood_cost

  if total_gold < 0 then
    set total_gold = 0
  endif
  if total_wood < 0 then
    set total_wood = 0
  endif

  if total_gold <= 0 and not (gold_cost == 0) then
    return NOT_ENOUGH_RES
  endif

  if total_wood <= 0 and not (wood_cost == 0) then
    return NOT_ENOUGH_RES
  endif

  if BuyItem(have_qty + 1, itemid) then
    return BUILT_SOME
  else
    if IsHealingItem(itemid) and buy_type[itemid] == BT_RACIAL_ITEM and GetGold() > 1000 and c_ally_total > 0 then
      if BuyAllyShopItem(have_qty + 1,itemid) then  //return false just run next time
        return BUILT_SOME
      else
        return CANNOT_BUILD
      endif
    endif
  endif
  return BUILT_SOME
endfunction

//============================================================================
function BuildFarms takes integer qty returns nothing
  if TownCount(racial_farm) < race_farms_at_mine then
    call BuildAtMine(Min(TownCountDone(racial_farm) + qty, max_farms), racial_farm, farm_prio)
  elseif race_build_farms_front and front_locs_computed and TownCountDone(racial_farm) <= race_farms_front_limit + 1 and TownCountDone(racial_farm) >= 1 then
    call BuildFront(Min(TownCountDone(racial_farm) + qty, max_farms), racial_farm, farm_prio)
  else
    call BuildUnit(Min(TownCountDone(racial_farm) + qty, max_farms), racial_farm, farm_prio)
  endif
endfunction

//============================================================================
function FarmBuilder takes nothing returns nothing
  if FoodCap() >= ver_food_limit then
    return
  endif
  if FoodSpace() <= farm_food2 then
    call BuildFarms(2)
  elseif FoodSpace() <= farm_food then
    call BuildFarms(1)
  endif
endfunction

//============================================================================
function ShredderBuilder takes nothing returns nothing
  local real g = GetGold()
  local real w = Max(GetWood(),1)
  local real gdivw = g / w
  if neutral_available[NEUTRAL_OBSERVATORY] and gdivw > 4 and g - w > 500 and w < 550 and ai_time - available_time[neutral_shredder] >= -1 then
    call BuildUnit(1, neutral_shredder, peon_prio)
  endif
endfunction

//============================================================================
function BuildPeons takes integer number returns nothing
  if towerrush and (TownCount(hero[1]) + TownCount(hero[2]) + TownCount(hero[3])) != 0 then  // towerrush compensate
    if not race_has_ghouls and TownCount(racial_peon) < 14 then
      set number = number + race_tower_peon
    elseif race_has_ghouls and TownCount(racial_peon) < 5 + race_tower_peon then
      set number = number + race_tower_peon
    endif
    if race_tower_bypeon == true then
      set number = number + 2
    endif
  endif
  if first_town_mine == 2 and not towerrush then  // startloc have more mine compensate
    if not race_manual_loading and not race_uses_mine_expansion and not race_has_ghouls then
      set number = number + 3
    endif
  endif
  call BuildUnit(number, racial_peon, peon_prio)
endfunction

function BuildGhouls takes integer number returns nothing
  if towerrush and TownCount(racial_ghoul) < 8 then  // towerrush compensate
    set number = number + 1
  endif
  call BuildUnit(number, racial_ghoul, ghoul_prio)
endfunction

//============================================================================
function PeonBuilder takes nothing returns nothing
  local integer mo = GetMinesHarvested()
  local integer sc = TownCount(neutral_shredder)
  local real w = GetWood()
  if race_uses_shredder then
    call ShredderBuilder()
  else
    set sc = 0
  endif
  //if w <= maximum_peon_wood then
  /// call BuildPeons( peon_1_mine_number * mo + Max(max_lumber_peons - shredder_peon_count*sc, 1 )  )  // number of peons per mine + wood peons
  //elseif w >= minimum_peon_wood then
  // call BuildPeons( peon_1_mine_number * mo + Max(min_lumber_peons - shredder_peon_count*sc, 1 )  )
 // else
 //  call BuildPeons( peon_1_mine_number * mo + Max(Max(min_lumber_peons, R2I(I2R(max_lumber_peons) / 2)) - shredder_peon_count*sc, 1 )  )
 // endif

  if race_has_ghouls then
    if mo <= 1 then
      call BuildPeons(min_peon_number_single_mine)
    elseif mo <= 2 then
      call BuildPeons(min_peon_number_double_mine)
    else
      call BuildPeons(min_peon_number_multi_mine)
    endif
  else
    if mo <= 1 then
      // call BuildPeons(Max(min_peon_number_single_mine, R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_1_mine_number, 5, w)) - shredder_peon_count*sc))
      call BuildPeons(Max(R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_1_mine_number, min_peon_number_single_mine, w) - shredder_peon_count*sc),min_peon_number_single_mine))  // the Max condition prevents having loads of shredders stoping amai getting peons for gold
    elseif mo <= 2 then
      // call BuildPeons(Max(min_peon_number_double_mine, R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_2_mines_number, 10, w)) - shredder_peon_count*sc))
      call BuildPeons(Max(R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_2_mines_number, min_peon_number_double_mine, w) - shredder_peon_count*sc),min_peon_number_double_mine))
    else
      // call BuildPeons(Max(min_peon_number_multi_mine, R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_mines_number, 10, w)) - shredder_peon_count*sc))
      call BuildPeons(Max(R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_mines_number, min_peon_number_multi_mine, w) - shredder_peon_count*sc),min_peon_number_multi_mine))
    endif
  endif
  if race_has_ghouls then
    call BuildGhouls(Max(R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, race_max_ghouls, race_min_ghouls, w) - R2I(shredder_peon_count/2)*sc),2))
  endif
endfunction

//============================================================================
function SetBuildFree takes nothing returns nothing
local integer i = 0
local integer j = 0
loop
  exitwhen i >= building_length
  set j = building[i]
  set build_free[j] = TownCountDone(j)
  set gold_sum[j] = 0
  set build_time_sum[j] = 0
  set build_num[j] = 0
  set prio_sum[j] = 0
  set i = i + 1
endloop
endfunction

//============================================================================
function ExpansionBuilder takes nothing returns nothing
local integer mines = GetMinesOwned()
local integer gold_left = GetGoldOwned()
local integer i = racial_expansion
local boolean exp_prepared = false
local boolean rebuild = false
local unit u = null

if first_expansion_chosen and (current_expansion == null or CheckExpansionTaken(current_expansion)) then
  call ChooseExpansion()
  if current_expansion == null then
    call Trace("ExpansionBuilder: No mine available")
    return
  endif
endif
if CheckExpansionTaken(current_expansion) then
  set current_expansion = null
  return
endif
set exp_prepared = false
if first_town_mine > 0 and (race_uses_mine_expansion or race_manual_loading) then  //home_location have multiple mine , fix GetMinesOwned bug(ELF and UD)
  if race_manual_loading then
    set i = race_manual_loading_mine
  endif
  set mines = Min(TownCount(i),GetMinesOwned())  // check actual number of gold mines
endif

set i = 2
if active_expansion == true then
  set i = 3
endif
set u = GetExpFoe(u)
if mines < i and ai_time - exp_time_count > exp_first_time then
  if u != null then
    set take_exp = true
    //if attacking_expansion then
    //  set exp_prepared = true
    //  call Trace("ExpansionBuilder: Ready to expand to mine 2 - odd")
    //endif
  else
    set take_exp = false
    set exp_prepared = true
    call Trace("ExpansionBuilder:Ready to expand to mine 2")
  endif
endif

if mines < 3 and ai_time - exp_time_count > exp_second_time then
  if u != null then
    set take_exp = true
  else
    set take_exp = false
    set exp_prepared = true
    call Trace("ExpansionBuilder:Ready to expand to mine 3")
  endif
endif

if not exp_prepared and u == null then
  set rebuild = CheckExpansionRebuild()
  if rebuild then
    set exp_prepared = true
  endif
endif
set u = null
if mines < 1 or gold_left < 2000 or exp_prepared then
  call Trace("ExpansionBuilder: Putting mine on build list")
  if mines < 1 or gold_left < 2000 then
    call BuildExpa(TownCount(racial_expansion) + 1, racial_expansion, expa_emergency_prio)
  elseif rebuild then
    call BuildExpa(TownCount(racial_expansion) + 1, racial_expansion, expa_rebuild_prio)
  else
    call BuildExpa(TownCount(racial_expansion) + 1, racial_expansion, expa_prio)
  endif
endif

endfunction

//============================================================================
function InitHeroInfo takes integer hn returns nothing
  if hero_loc[hn] != null then
    call RemoveLocation(hero_loc[hn])
  endif
  set hero_loc[hn] = GetUnitLoc(hero_unit[hn])
  if hero_enemy_loc[hn] != null then
    call RemoveLocation(hero_enemy_loc[hn])
  endif
  if hero_ally_loc[hn] != null then
    call RemoveLocation(hero_ally_loc[hn])
  endif
  set hero_enemy_loc[hn] = Location(0,0)
  set hero_ally_loc[hn] = Location(0,0)
  set hero_hp[hn] = 1
endfunction

function HeroReviver takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > 3
    if GetUnitCountDone(old_id[hero[i]]) > 0 then
      if not hero_built[i] then
        set hero_unit[i] = GetOneOfId(hero_unit[i], ai_player, old_id[hero[i]])
        if hero_unit[i] != null then
          set hero_built[i] = true
          call InitHeroInfo(i)
          call TQAddJob(1, MICRO_HERO, i)
        endif
      endif
    elseif hero_built[i] then
      call BuildUnit(1, hero[i], hero_revive_prio[i])
    endif
    set i = i + 1
  endloop
endfunction

//============================================================================
function CheckUnitNewTown takes unit u, integer num returns boolean
  local integer i = 0
  local location l = GetUnitLoc(u)
  loop
    exitwhen i >= num
    if town_built[i] and own_town_loc[i] != null and DistanceBetweenPoints(l, own_town_loc[i]) < town_radius then
      call RemoveLocation(l)
      set l = null
      return false
    endif
    set i = i + 1
  endloop
  call RemoveLocation(l)
  set l = null
  return true
endfunction

//============================================================================
function LocalizeOldTown takes integer num returns boolean
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsInRangeOfLoc(g, own_town_loc[num], 2000, null)
  set g = SelectByPlayer(g,ai_player,true)
  set g = SelectByHidden(g,false)
  set g = SelectByAlive(g,true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    exitwhen IsUnitType(u, UNIT_TYPE_STRUCTURE)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  if u == null then
    if num != 0 then  //Prevent moving away from the starting loc
      set exist_town[exist_town_num] = home_location
    endif
    return false
  endif
  set exist_town_num = exist_town_num + 1
  set u = null
  return true
endfunction

function LocalizeNewTown takes integer num returns boolean
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectByHidden(g,false)
  set g = SelectByAlive(g,true)
  set g = SelectById(g, old_id[racial_expansion], true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    exitwhen CheckUnitNewTown(u, num)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  if own_town_loc[num] != null then
    call RemoveLocation(own_town_loc[num])
  endif
  if u == null then
//    call DisplayToAll("Debug: New town not found")
    set own_town_loc[num] = null
    set own_town_mine[num] = null
    set own_town_dist[num] = 0
    return false
  endif
  set own_town_loc[num] = GetUnitLoc(u)
  set own_town_mine[num] = GetMineNearLoc(own_town_mine[num], own_town_loc[num], 1500)
  set own_town_dist[num] = DistanceBetweenPoints(home_location, own_town_loc[num])
  set exist_town[exist_town_num] = own_town_loc[num]
  set exist_town_num = exist_town_num + 1
  if debugging then
    call PingMinimap(GetUnitX(u), GetUnitY(u), 20)
  endif
  set u = null
  return true
endfunction

//============================================================================
function CheckTownBuilt takes nothing returns nothing
  local integer i = 0
  set exist_town_num = 0
  loop
    exitwhen i >= max_towns
    if not town_built[i] then
      if (TownCountEx(racial_expansion, true, i) > 0 and not (TownCountEx(racial_expansion, true, 50) > 0)) then
        set town_built[i] = LocalizeNewTown(i)
      endif
    else
        set town_built[i] = LocalizeOldTown(i)
    endif
    set i = i + 1
  endloop
endfunction

//============================================================================
function TimeKeeper takes nothing returns nothing
  //local real new_time_of_day = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  //if new_time_of_day < time_of_day then
  //  call Chat(C_NewYear)
  //endif
  //set time_of_day = new_time_of_day
  set ai_time = R2I(TimerGetElapsed(tq_timer)/5)
  if ai_time >= taunt_start_time then
    call Chat(C_Taunt)
  endif
endfunction

//============================================================================
function FactoryNumberUpdate takes nothing returns nothing
  local integer g_sum = 0
  local integer i = 0
  local integer j = 0
  set gold_income = GetGoldIncome() * gold_unit_percentage
  loop
    exitwhen i >= building_length
    set g_sum = g_sum + gold_sum[building[i]]
    set i = i + 1
  endloop
  if g_sum == 0 then
    return
  endif
  set i = 0
  loop
    exitwhen i >= building_length
    set j = building[i]
    set income_percentage[j] = I2R(gold_sum[j]) / I2R(g_sum)
    if build_num[j] > 0 then
      call BuildUnit(GetFactoryQty(build_num[j], build_time_sum[j] / build_num[j], gold_sum[j] / build_num[j], income_percentage[j]), j, prio_sum[j] / build_num[j])
    endif
    set i = i + 1
  endloop
endfunction

//============================================================================
function OneBuildLoopAM takes nothing returns nothing
    local integer index = 0
    local integer index_free = 0
    local integer qty = 0
    local integer id = 0
    local integer tp = 0
    local integer ret = 0
    local integer town = 0
    local integer array max_order
    local integer mo = 0
    local integer traced = 0
    local integer tracedsome = 0
    local integer tracednoresources = 0
    local integer tracedall = 0
    local string logtype = ""

    call InitLastUpkeep()

    call TimeKeeper()
    call CheckTownBuilt()
    call SetBuildFree()
    call FarmBuilder()
    call PeonBuilder()
    if not campaign_ai then
      call ExpansionBuilder()
      call HeroReviver()
    endif
    set total_gold   = GetGold() - gold_buffer
    set total_wood   = GetWood() - wood_buffer
    set total_food   = ver_food_limit - FoodUsed()

    call CheckUpkeepAllowed(ver_food_limit - total_food)

    set blocked_gold = 0
    set blocked_wood = 0
    set blocked_food = 0
    set t_build_length = 0

    call GetBuildLock()
    loop
      exitwhen index >= build_length
      call Sleep(0.01)
      set id = build_item[index]
      set qty = RBlockListCheck(build_qty[index], id)
      set tp = build_type[index]
      set town = Max(build_town[index],0)
      set mo = max_order[id + town*OBJECT_NUM]
//        call DumpInteger("ID"+Int2Str(index),id)
//        call DumpInteger("Qty"+Int2Str(index),qty)
//        call DumpInteger("Gold"+Int2Str(index),total_gold)
//        call DumpInteger("Prio"+Int2Str(index),build_prio[index])

      if build_qty[index] > mo then
        if tp == BUILD_UNIT then
          set logtype = "unit "
          set ret = StartUnitAM(qty,id,build_town[index], build_loc[index], build_prio[index], mo)
        elseif tp == BUILD_UPGRADE then
          set logtype = "upgrade "
          set ret = StartUpgradeAM(qty,id)
        elseif tp == BUILD_EXPAND then
          set logtype = "expand "
          set ret = StartExpansionAM(qty,id)
        elseif tp == BUILD_ITEM then
          set logtype = "item "
          set ret = StartItem(qty,id)
        else
          set logtype = "unknown:" + Int2Str(tp)
        endif

        if qty > mo then
          set max_order[id + town*OBJECT_NUM] = qty
        endif

        if ret == CANNOT_BUILD then
          if (traced == 0) then
            call Trace("CANNOT BUILD " + logtype + unitNames[id] + " " + Int2Str(id))
            set traced = id
          endif
          call AddRefresh(tp, qty, id, build_town[index], build_loc[index], build_prio[index])
        elseif ret == BUILT_SOME and tracedsome == 0 then
          //call Trace("BUILT SOME " + logtype + unitNames[id] + " " + Int2Str(id))
          set tracedsome = id
        elseif ret == BUILT_ALL and tracedall == 0 then
          //call Trace("BUILT ALL " + logtype + unitNames[id] + " " + Int2Str(id))
          set tracedall = id
        elseif ret == NOT_ENOUGH_RES and tracednoresources == 0 then
          call Trace("NO RESOURCES " + logtype + unitNames[id] + " " + Int2Str(id))
          set tracednoresources = id
        endif
        exitwhen ret == NOT_ENOUGH_RES // Don't try and build anything else as thing we trying to buy is too expensive
        if ret == CANNOT_BUILD or ret == BUILT_SOME or ret == NOT_ENOUGH_RES or (ret == BUILT_ALL and qty < build_qty[index]) then
          set build_qty[index_free] = build_qty[index]
          set build_type[index_free] = build_type[index]
          set build_item[index_free] = build_item[index]
          set build_loc[index_free] = build_loc[index]
          set build_town[index_free] = build_town[index]
          set build_prio[index_free] = build_prio[index] + prio_t_inc
          set index_free = index_free + 1
        endif
        call ApplyUpkeepSaving()
      endif

      set index = index + 1
      set total_gold = total_gold - blocked_gold
      set total_wood = total_wood - blocked_wood
      //set total_food = total_food - blocked_food
      set blocked_gold = 0
      set blocked_wood = 0
      set blocked_food = 0
      call UpdateLastUpkeep()
    endloop

//    call EndDump(Int2Str(ai_time))

    if ret == NOT_ENOUGH_RES and gold_buffer + wood_buffer == 0 and not hero_built[1] then  // beginning of the game , if no resources build , build next unit , maybe next is peon
      set index = index + 1
    endif
    loop
      exitwhen index >= build_length
      set build_qty[index_free] = build_qty[index]
      set build_type[index_free] = build_type[index]
      set build_item[index_free] = build_item[index]
      set build_town[index_free] = build_town[index]
      set build_loc[index_free] = build_loc[index]
      set build_prio[index_free] = build_prio[index] + prio_t_inc
      set index_free = index_free + 1
      set index = index + 1
    endloop
    set build_length = index_free

    call ResetUpkeepSaveTime()
    call ReleaseBuildLock()
    call RefreshAllNeeded()
    call FactoryNumberUpdate()
    set logtype = null

endfunction


//============================================================================
// AMAI Build Loop
//============================================================================
function BuildLoopAM takes nothing returns nothing
  local integer blc = 0
  call OneBuildLoopAM()
  call StaggerSleep(1,5)
  loop
    //call Trace("Build Loop")
    set blc = blc + 1
    call OneBuildLoopAM()
    exitwhen player_defeated
    if blc > build_array_reset_time then
      call InitBuildArrayAM()
      set blc = 0
    endif
    call Sleep(5 * sleep_multiplier)
  endloop
//    call DisplayToAll("Shutting down BuildLoopAM")
//    call DebugSequenceEnd()
endfunction

//============================================================================
function PlayGameAM takes nothing returns nothing
  call BuildLoopAM()
endfunction

//============================================================================
// AMAI Attack Functions
//============================================================================
function ConversionsAM takes integer desire, integer unitid returns nothing
#INCLUDETABLE <$VER$\UnitConversions.txt> #EFR
  if unitid == %1 then
    call MergeUnits(desire,o%2,o%3,o%1)
  endif
#ENDINCLUDE
endfunction

//============================================================================
function SetAssaultGroupAM takes integer qty, integer max, integer unitid returns nothing
  call ConversionsAM(max,unitid)

  set attack_qty[attack_length] = qty
  set attack_max[attack_length] = max
  set attack_units[attack_length] = unitid
  set attack_length = attack_length + 1
endfunction

//============================================================================
function SetMeleeGroupAM takes integer unitid returns nothing
  call SetAssaultGroupAM(0,60,unitid)
endfunction

//============================================================================
function AttackGroupAddNeutrals takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= merc_number
    call SetMeleeGroupAM(merc_unit[i])
    set i = i + 1
  endloop
  set i = 1
  loop
    exitwhen i >= dragon_number
    call SetMeleeGroupAM(dragons[i])
    set i = i + 1
  endloop
endfunction

function AttackGroupAddUnknown takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  local integer id = 0
  local integer i = 0
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, false)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, false)
  set g = SelectUnittype(g, UNIT_TYPE_SUMMONED, false)
  set g = SelectByHidden(g,false)
  set g = SelectByAlive(g,true)
  loop
    exitwhen i >= attack_length or FirstOfGroup(g) == null
    set g = SelectById(g, old_id[attack_units[i]], false)
    set i = i + 1
  endloop
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set id = GetUnitTypeId(u)
    if (IsUnitType(u, UNIT_TYPE_ATTACKS_FLYING) or IsUnitType(u, UNIT_TYPE_ATTACKS_GROUND)) and id != 'ngir' then
      call AddAssault(60,id)  //other hero and unit , like other race and custom
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
endfunction

//============================================================================
function FormGroupAM takes integer seconds returns nothing
  local integer index = 0
  local integer count = 0
  local integer unitid = 0
  local integer desire = 0

  call InitAssault()

  loop
    exitwhen index == attack_length

    set unitid = attack_units[index]

    #INCLUDETABLE <$VER$\UnitEquivalence.txt> #EFR #COND "%2" eq "UPGRADED_TO"
    if unitid == %1 and GetUpgradeLevel(o%4) >= %5 then
      set unitid = %3
    endif
    #ENDINCLUDE

    set desire = attack_max[index]
    set count  = TownCountDone(unitid)

    if unitid == racial_ghoul then
      set desire = attacking_ghouls
    endif

    call ConversionsAM(desire,unitid)

    if count >= desire then
      call AddAssault(desire,old_id[unitid])
    else
      set desire = attack_qty[index]

      if count < desire then
        call AddAssault(desire,old_id[unitid])
      else
        call AddAssault(count,old_id[unitid])
      endif
    endif

    set index = index + 1
  endloop
  call Sleep(seconds)
endfunction

//============================================================================
function DoAttackJobs takes nothing returns nothing
  if major_hero == null or not UnitAlive(major_hero) then
    set major_hero = GetMajorHero(major_hero)
  endif
  set battle_radius = normal_battle_radius
  set break_attack = false
  //if major_hero != null and UnitAlive(major_hero) then
    if not retreat_controlled then
      call Trace("===Retreat control started===")
      set retreat_controlled = true
      call SetGroupsFlee(false)
      call SetTargetHeroes(false)
      call TQAddJob(2 * sleep_multiplier, RETREAT_CONTROL, 0)
    endif
  //endif
endfunction

//============================================================================
function GetDistractionTarget takes unit ru, unit target returns unit
  local group g = CreateGroup()
  local location unitloc = GetUnitLoc(target)
  call GroupEnumUnitsOfPlayer(g, GetOwningPlayer(target), null)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  set g = SelectByLocation(g, unitloc, 3000, false)
  set ru = GetFarestOfGroup(ru, g, unitloc)
  call RemoveLocation(unitloc)
  set unitloc = null
  call DestroyGroup(g)
  set g = null
  return ru
endfunction

//============================================================================
function DoDistractionAttack takes unit target returns nothing
  local unit d_target = null
  set d_target = GetDistractionTarget(d_target, target)
  if d_target == null then
    return
  endif
  call StartHarass(distraction_group, HARASS_TARGET_LOCATION, false, 15, 0.25, 1, GetUnitX(d_target), GetUnitY(d_target))
  set d_target = null
  call RemoveHarass()
  call Sleep(15)
endfunction

//============================================================================
function SleepInCombatAM takes nothing returns nothing
  local integer count = 0
  //local integer attack_length_counter = 0
  call Trace("SleepInCombat")
  loop
    exitwhen town_threatened
    exitwhen break_attack
    exitwhen not CaptainInCombat(true)  // goal is cleared
    exitwhen CaptainIsEmpty()// duh
    exitwhen town_threat_break
    exitwhen R2I(count/sleep_multiplier) >= 900 // Took longer than 15 mins to attack something is wrong
    //loop
      //exitwhen captain_flee and CaptainRetreating()
      //exitwhen isfleeing and CaptainRetreating()
      //call CaptainAttack(GetLocationX(last_ally_loc), GetLocationY(last_ally_loc))
      //call Sleep(1 * sleep_multiplier)
      //set attack_length_counter = attack_length_counter + 1
      //if attack_length_counter > attack_reform_length then
        //set attack_length_counter = 0
        //call FormGroupAM(2)
      //endif
    //endloop
    //call Sleep(1)
    set count = count + 1
    call Sleep(1 * sleep_multiplier)
  endloop
  set count = 0
  loop
    exitwhen count >= 8 or town_threatened
    set count = count + 1
    call Sleep(1)
  endloop
  call Trace("exit SleepInCombat")
endfunction

//============================================================================
function GetNearAlliedStrength takes unit target returns real
  local integer i = 0
  local real sum = 0
  local location unitloc = GetUnitLoc(target)
  local real dist = DistanceBetweenPoints(unitloc, ally_loc) + 600
  loop
    exitwhen i >= army_num
    if Player(army_owner[i]) != ai_player and IsPlayerAlly(ai_player, Player(army_owner[i])) then
      if DistanceBetweenPoints(unitloc, army_loc[i]) > dist and DistanceBetweenPoints(unitloc, army_future[i]) < 1300 then
        set sum = sum + army_strength[i]
      endif
    endif
    set i = i + 1
  endloop
  call RemoveLocation(unitloc)
  set unitloc = null
  return sum
endfunction

//============================================================================
function GetNearerAlliedStrength takes unit target returns real
  local integer i = 0
  local real sum = 0
  local location unitloc = GetUnitLoc(target)
  local real dist = DistanceBetweenPoints(unitloc, ally_loc) + 600
  loop
    exitwhen i >= army_num
    if Player(army_owner[i]) != ai_player and IsPlayerAlly(ai_player, Player(army_owner[i])) then
      if DistanceBetweenPoints(unitloc, army_loc[i]) <= dist and DistanceBetweenPoints(unitloc, army_future[i]) < 1600 then
        set sum = sum + army_strength[i]
      endif
    endif
    set i = i + 1
  endloop
  call RemoveLocation(unitloc)
  set unitloc = null
  return sum
endfunction

//============================================================================
function CheckAttackWait takes unit target returns boolean
  local real target_strength = GetLocationStrength(GetUnitX(target), GetUnitY(target), battle_radius)
  local real strength = GetOwnStrength()
  local real nearer_strength = GetNearerAlliedStrength(target)
  if strength + nearer_strength > target_strength * 1.1 then
    return false
  endif
  return GetNearAlliedStrength(target) > 10.0
endfunction

//============================================================================
function DesperationAssault takes nothing returns nothing
  local group g = null
  local unit u = null
  local integer i = 0
  if not player_defeated then
    call Trace("Adding desperation troops")
    set g = CreateGroup()
    call GroupEnumUnitsOfPlayer(g, ai_player, null)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      if (IsUnitType(u, UNIT_TYPE_ANCIENT) or not IsUnitType(u, UNIT_TYPE_STRUCTURE)) then
        call AddAssault(60, GetUnitTypeId(u))
      endif
      call GroupRemoveUnit(g, u )
    endloop
    call DestroyGroup(g)
    set g = null
  endif
endfunction

function CommonSleepUntilTargetDeadAM takes unit target, boolean iscreeping, boolean reform returns nothing
  local real dist = 0
  local integer attack_length_counter = 0
  local integer combat_length_counter = 0
  local group g = null

  if race_has_ghouls and race_ghouls_attack then
    set attack_length_counter = 5000  // Force army to regroup to try and get ghouls to go along
  endif
  loop
    exitwhen town_threat_break and town_threatened and most_threatened_town >= 0 and town_threat[most_threatened_town] >= teleport_low_threat and not desperation_assault
    exitwhen break_attack and not desperation_assault
    //exitwhen captain_flee and CaptainRetreating()
    exitwhen isfleeing and CaptainRetreating() and not desperation_assault
    exitwhen CaptainIsEmpty() and not desperation_assault
    //exitwhen not UnitAlive(target) and CaptainIsHome()  // A fail safe mechanism if getlocationnoncreepstrength malfunctions: not needed as issue now fixed
    if GetOwningPlayer(target) == ai_player or not UnitAlive(target) or (UnitInvis(target) and not IsUnitDetected(target, ai_player)) then
      set g = CreateGroup()
      call GroupEnumUnitsInRange(g,GetUnitX(target), GetUnitY(target),battle_radius,null)
      set g = SelectByAlive(g,true)
      set g = SelectByEnemy(g,ai_player, true)
      if not UnitAlive(target) or UnitInvis(target) then
        set g = SelectByVisible(g,ai_player,true)  // to find enemies that ai has noticed
      endif
      if iscreeping then
        set g = SelectByPlayer(g, Player(PLAYERAGGRESSIVE), true)  // if creeping and unit invisible see if any other creeps targetable
      endif
      set target = FirstOfGroup(g)
      call DestroyGroup(g)
      exitwhen target == null
    endif
    //if not iscreeping then
      //	exitwhen GetLocationNonCreepStrength(unitx, unity, battle_radius) <= 0 and not UnitAlive(target) and GetLocationEnemyStructures(unitx, unity, battle_radius) <= 0 // enemies are dead and target dead
    //else
      //call Trace("Units, Creeps: " + Int2Str(GetLocationNonCreepStrength(unitx, unity, battle_radius)) + "," + Int2Str(GetLocationCreepStrength(unitx, unity, 500)))
      //	exitwhen GetLocationNonCreepStrength(unitx, unity, battle_radius) <= 0 and not UnitAlive(target) and GetLocationCreepStrength(unitx, unity, 500) <= 0
    //endif
    set dist = DistanceBetweenPoints_kd(ally_loc, GetUnitLoc(target))
    if c_ally_total > 0 and dist > 1300 and dist < 2500 then
      if CheckAttackWait(target) then
        call AttackMoveXY(R2I(GetLocationX(ally_loc)), R2I(GetLocationY(ally_loc)))
      else
        call AttackMoveKill(target)
      endif
    else
      call AttackMoveKill(target)
    endif

    call Sleep(2 * sleep_multiplier)
    call CreateDebugTag("Reform until target dead", 10, target, 1.00, 0.80)
    //set attack_length_counter = attack_length_counter + 1
        //if reform and attack_length_counter > attack_reform_length then
    //  if CaptainInCombat(true) then
    //	set attack_length_counter = attack_length_counter - 2
    //  else
    //	set attack_length_counter = 0
    //	call FormGroupAM(2)
    //  endif
        //endif

    if desperation_assault and attack_length_counter > attack_reform_length * 5 then
      call DesperationAssault()
      set attack_length_counter = 0
    else
      set attack_length_counter = attack_length_counter + 1
    endif
    if not desperation_assault then // Do not bother reforming in desperation mode, full attack speed
      if reform and CaptainInCombat(true) then
        set combat_length_counter = combat_length_counter + 1
      elseif reform then
        set attack_length_counter = attack_length_counter + 1
        set combat_length_counter = 0
      endif
      if reform and CaptainInCombat(true) and combat_length_counter > attack_reform_length * 3 then
        set combat_length_counter = 0
        call FormGroupAM(2)
      elseif reform and not CaptainInCombat(true) and attack_length_counter > attack_reform_length then
        set attack_length_counter = 0
        set combat_length_counter = 0
        call FormGroupAM(2)
      endif
    endif
  endloop
  set g = null
endfunction

//============================================================================
function ReformUntilTargetDeadAM takes unit target, boolean iscreeping returns nothing
	call CommonSleepUntilTargetDeadAM(target,iscreeping,true)
endfunction

//============================================================================
function SleepUntilTargetDeadAM takes unit target, boolean iscreeping returns nothing
	call CreateDebugTag("Sleep until target dead", 10, target, 3.00, 1.50)
	call CommonSleepUntilTargetDeadAM(target,iscreeping,false)
endfunction

//============================================================================
function SleepUntilAtGoalAM takes nothing returns nothing
  local integer lcount = 0
  loop
    exitwhen town_threatened and most_threatened_town >= 0 and town_threat[most_threatened_town] >= teleport_low_threat
    set lcount = lcount + 1
    call Sleep(sleep_multiplier)
    exitwhen break_attack
    exitwhen CaptainRetreating() and isfleeing
    if lcount >= 6 then
      exitwhen CaptainAtGoal()        // reached goal
      exitwhen CaptainIsHome()        // failed to path and returned home
    endif
    exitwhen CaptainIsEmpty()       // all units died
    //call Trace("Sleeping until target reached")
    call Sleep(2 * sleep_multiplier)
  endloop
endfunction

//============================================================================
function BRRush takes nothing returns nothing
  local location buildloc = null
  local location loc = null
  local unit u = null
  local unit utemp = null
  local group g = CreateGroup()
  local integer i = 0
  call GroupEnumUnitsInRange(g,GetUnitX(rushcreep_target), GetUnitY(rushcreep_target),800,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null or i == 1
    if UnitAlive(u) and GetOwningPlayer(u) != Player(PLAYERAGGRESSIVE) and IsPlayerEnemy(ai_player,GetOwningPlayer(u)) then
      set i = 1  // have other player
    elseif GetOwningPlayer(u) == ai_player and GetUnitTypeId(u) == 'eaom' then
      set utemp = u
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  set attack_running = true
  if i != 1 and GetUnitState(utemp, UNIT_STATE_LIFE) >= GetUnitState(utemp, UNIT_STATE_MAX_LIFE) * 0.65 then
    set buildloc = GetUnitLoc(utemp)
    call RemoveGuardPosition(utemp)
    call IssueImmediateOrder(utemp, "unroot")  //try unroot
    call Sleep(2.8)  //unroot time
    set loc = GetUnitLoc(rushcreep_target)
    call IssuePointOrderLoc(utemp, "attack", loc)
    call RemoveLocation(loc)
    set loc = null
    call AttackMoveKill(rushcreep_target)
    call ReformUntilTargetDeadAM(rushcreep_target, true)
    call Chat(C_Done)
    call SleepInCombatAM()
    call Trace("===BR Finished===")
    call IssuePointOrderLoc( utemp, "move", buildloc)  //prevent inability cannot root
    call Sleep(0.02)
    call IssuePointOrderLoc( utemp, "root", buildloc)  //root tree
    call TQAddUnitJob(GetTimeToReachLoc(utemp, buildloc) + 2, RESET_GUARD_POSITION, 0, u)
    call RemoveLocation(buildloc)
    set buildloc = null
  else
    call AttackMoveKill(rushcreep_target)
    call ReformUntilTargetDeadAM(rushcreep_target, true)
    call Chat(C_Done)
    call SleepInCombatAM()
    call Trace("===BR Finished , no tree ===")
  endif
  set attack_running = false
  if not UnitAlive(rushcreep_target) then
    set rushcreep_target = null
  endif
  set utemp = null
endfunction

//============================================================================
function AttackMoveKillAAM takes unit target returns nothing
  if target == null or not UnitAlive(target) then
    call Trace("Bad target passed to AttackMoveKillAAM")
    call Sleep(3 * sleep_multiplier)
    return
  endif
  set attack_running = true
  call DoAttackJobs()
  if distraction_group != 0 and GetOwningPlayer(target) != Player(PLAYERAGGRESSIVE) and GetRandomInt(1,10) < 5 then
    if GetHarassGroupStrength(distraction_group) < GetOwnStrength() / 3 then
      call DoDistractionAttack(target)
    endif
  endif
  call AttackMoveKill(target)
  call ReformUntilTargetDeadAM(target, false)
  call Chat(C_Done)
  call SleepInCombatAM()
  call Trace("===Attack Fully Finished===")
  set attack_running = false
  call Sleep(2.5)
endfunction

//============================================================================
// Attack target code without the battle radius set so uses the creep radius
// and without distraction attack
function AttackMoveKillCreep takes unit target returns nothing
  if target == null or not UnitAlive(target) then
    call Trace("Bad target passed to AttackMoveKillCreep")
    call Sleep(3 * sleep_multiplier)
    return
  endif
  set attack_running = true
  set break_attack = false
  if not retreat_controlled then
    call Trace("===Retreat control started===")
    set retreat_controlled = true
    call SetGroupsFlee(false)
    call SetTargetHeroes(false)
    call TQAddJob(2 * sleep_multiplier, RETREAT_CONTROL, 0)
  endif
  call AttackMoveKill(target)
  call ReformUntilTargetDeadAM(target, true)
  call Chat(C_Done)
  call SleepInCombatAM()
  call Trace("===Attack Fully Finished===")
  set attack_running = false
endfunction

//============================================================================
function AttackMoveKillXYAAM takes integer x, integer y returns nothing
  set attack_running = true
  call DoAttackJobs()
  if zep_next_wave then
    call LoadZepWave(x,y)
    set zep_next_wave = false
  endif
  call AttackMoveXY(x,y)
  call SleepUntilAtGoalAM()
  call SleepInCombatAM()
  set attack_running = false
endfunction

//============================================================================
function AttackMoveTowerRush takes nothing returns nothing
	local integer attack_length_counter = 0
	local group g = CreateGroup()

	set attack_running = true

	loop
		exitwhen not towerrush
		exitwhen town_threatened and most_threatened_town >= 0 and town_threat[most_threatened_town] >= teleport_low_threat + 60
		exitwhen break_attack
		exitwhen CaptainIsEmpty()       // all units died
		if (builder[20] == null or GetUnitState(builder[20], UNIT_STATE_LIFE) <= 0) then
			call GroupEnumUnitsInRange(g, enemy_point_x, enemy_point_y, 1200, null)
			set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
			set builder[20] = FirstOfGroup(g)
			call GroupClear(g)
		endif
		call SetAllianceTarget(builder[20])
		if towers_built <= 1 then
			call AttackMoveKill(builder[1])
			call SetAllianceTarget(builder[1])
		elseif towers_built <= 4 then
			call AttackMoveXY(R2I(first_tower_point_x), R2I(first_tower_point_y))
		elseif towers_built <= 6 then
			call AttackMoveXY(R2I(second_attack_point_x), R2I(second_attack_point_y))
		else
			call AttackMoveXY(R2I(enemy_point_x),R2I(enemy_point_y))
		endif
		//call AttackMoveKill(builder[20])
		//if towers_built == 0 then
			//call CreateDebugTag("Reform protect peon", 10, builder[1], 2.00, 1.50)
			//call AttackMoveKill(builder[1])
		//else
			//call SetCaptainHome(BOTH_CAPTAINS,R2I(((enemy_point_x - first_tower_point_x)/ 4) + first_tower_point_x),R2I(((enemy_point_y - first_tower_point_y)/ 4) + first_tower_point_y))
			//call SetCaptainHome(BOTH_CAPTAINS, R2I(enemy_point_x), R2I(enemy_point_y))
			//if towers_built < 3 then
				//call AttackMoveXY(R2I(enemy_point_x), R2I(enemy_point_y))
				//call AttackMoveXY(R2I(((enemy_point_x - first_tower_point_x)/ 6) + first_tower_point_x), R2I(((enemy_point_y - first_tower_point_y)/ 6) + first_tower_point_y))
			//elseif towers_built < 6 then
				//call AttackMoveXY(R2I(((enemy_point_x - first_tower_point_x)/ 3) + first_tower_point_x), R2I(((enemy_point_y - first_tower_point_y)/ 3) + first_tower_point_y))
			//elseif towers_built <= 9 then
				//call AttackMoveXY(R2I(enemy_point_x), R2I(enemy_point_y))
			//endif
		//endif
		call Sleep(2*sleep_multiplier)
		set attack_length_counter = attack_length_counter + 1
		if attack_length_counter > attack_reform_length then
			set attack_length_counter = 0
			call FormGroupAM(2)
		endif
	endloop
	call SleepInCombatAM()
	call DestroyGroup(g)
	set g = null
	set attack_running = false
	call SetAllianceTarget(null)
endfunction

//============================================================================
function GetIntervalCreep takes unit u, integer lower, integer upper, integer str, integer anti_air_strength, boolean allow_air, integer sd returns unit
  local integer creepstrength = 0
  local integer middle = (lower + upper) / 2

  if sd < 0 then
    return null
  endif
  set u = GetCreepCamp(1, middle, allow_air)
  if u == null then
    return GetIntervalCreep(u, middle, upper, str, anti_air_strength, allow_air, sd - 1)
  else
    set creepstrength = GetCreepCampStrength(u) + 1
    if balancing then
      //call Trace("Creep strength: " + Int2Str(creepstrength))
      call PingMinimap(GetUnitX(u), GetUnitY(u), 1)
    endif
    if creepstrength < str then
      if air_strength <= anti_air_strength then
        return u
      else
        return GetIntervalCreep(u, lower, upper, str, anti_air_strength, false, sd)
      endif
    else
      return GetIntervalCreep(u, lower, middle, str, anti_air_strength, allow_air, sd - 1)
    endif
  endif
endfunction

//============================================================================
function GetFittingCreep takes unit u, integer str returns unit
  local integer anti_air_strength = GetPlayerAntiAirStrength(ai_player)
  local integer creepstrength = 0
  local boolean allow_air = false      //anti_air_strength > 25
  local integer lvl = str

  set u = GetCreepCamp(1, lvl, true)
  if u != null then
    set air_strength = GetLocationCreepAirStrength(GetUnitX(u), GetUnitY(u), creep_camp_radius)
  endif
  set allow_air = air_strength <= anti_air_strength

  if (not allow_air) then
    set u = GetCreepCamp(1, lvl, false)
  endif

  if u == null then
    return u
  endif

  //call Trace("Our strength: " + Int2Str(str))
  set creepstrength = GetCreepCampStrength(u)
  if creepstrength < str and air_strength <= anti_air_strength then
    //call Trace("Creep match")
    call Trace("Creeping strength: " + Int2Str(creepstrength))
    set air_strength = creepstrength
    return u
  else
    //call Trace("No Creep ")
    return GetIntervalCreep(u, 1,100,str, anti_air_strength, allow_air, camp_scan_depth)
  endif
  return u

//    set creep = GetCreepCamp(1, camp_last_checked, allow_air)

//    if balancing then
//      call DisplayToAll("Creep strength: " + Int2Str(creepstrength))
//      call PingMinimap(GetUnitX(creep), GetUnitY(creep), 1)
//    endif

endfunction

//============================================================================
function CreepAttack takes integer str returns nothing
  local unit target = null
  set target = GetFittingCreep(target,str)
// Creep camp small is level 1 - 9
// Creep camp medium is level 10 - 19
// Creep camp strong is level 20 - 100

  if target == null then
    call Trace("No creep target found")
    call Sleep(20)
    return
  endif
  call Chat(C_Creep)
  if air_strength > 15 then
    call SetAllianceTarget(target)
  endif
  call FormGroupAM(3)
  call AttackMoveKillCreep(target)
  call SetAllianceTarget(null)
  set target = null
endfunction

//============================================================================
function QueueAttackMoveXY takes integer x, integer y returns nothing
  set attack_running = true
  call DoAttackJobs()
  loop
    call Sleep(sleep_multiplier)
    call AttackMoveXY(x,y)
    exitwhen break_attack
    exitwhen CaptainRetreating()
    exitwhen CaptainAtGoal()
    call Sleep(sleep_multiplier)
  endloop
  call SleepInCombatAM()
  if CaptainAtGoal() then
    call QueueGetNextCommand()
  endif
  set attack_running = false
endfunction

//============================================================================
// (AMAI)  ChooseAttackTarget
//============================================================================
function GetRangePenalty takes unit target returns integer
  if major_hero == null then
    return 0
  elseif UnitAlive(target) == false then
    return 0
  else
    return R2I(DistanceBetweenUnits(major_hero, target)/1400)
  endif
endfunction

//============================================================================
function GetWeakestEnemy takes nothing returns player
  local integer i = 0
  local integer pmin = 30
  local integer minstr = 1000
  local integer cstr = 0
  loop
    exitwhen i == c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set cstr = GetUnexactPlayerStrength(enemy_force[i])
      if cstr < minstr and GetBuilding(enemy_force[i]) != null then
        set pmin = i
        set minstr = cstr
      endif
    endif
    set i = i + 1
  endloop
  if pmin != 30 then
    return enemy_force[pmin]
  endif
  return null
endfunction

//============================================================================
function GetStrongestEnemy takes nothing returns player
  local integer i = 0
  local integer pmax = 30
  local integer maxstr = 0
  local integer cstr = 0
  loop
    exitwhen i == c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set cstr = GetUnexactPlayerStrength(enemy_force[i])
      if cstr > maxstr then
        set pmax = i
        set maxstr = cstr
      endif
    endif
    set i = i + 1
  endloop
  if pmax != 30 then
    return enemy_force[pmax]
  endif
  return null
endfunction

//============================================================================
function GetWeakAndNearEnemy takes nothing returns player
  local integer i = 0
  local integer pmin = -1
  local integer minstr = 10000
  local integer cstr = 0
  local unit cbuilding = null
  loop
    exitwhen i == c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set cbuilding = GetBuilding(enemy_force[i])
      if cbuilding != null and UnitAlive(cbuilding) then
        set cstr = GetUnexactPlayerStrength(enemy_force[i]) + GetRangePenalty(cbuilding)
        if cstr < minstr then
          set pmin = i
          set minstr = cstr
        endif
      endif
    endif
    set i = i + 1
  endloop
  // if pmin == -1 then
  //   call Trace("Debug: GetWeakAndNearEnemy failed!")
  //   set pmin = 0
  // endif
  set cbuilding = null
  if pmin != -1 then
    return enemy_force[pmin]
  endif
  return null
endfunction

//============================================================================
function GetNearestEnemy takes nothing returns player
local integer i = 0
local integer nearplayer = 30
local real dist = 0
local real mindistance = 1000000

loop
  exitwhen i >= c_enemy_total
  if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
    set dist = DistanceBetweenPoints_kd(home_location, GetPlayerStartLocationLoc(enemy_force[i]))
    if dist < mindistance then
      set mindistance = dist
      set nearplayer = i
    endif
  endif
  set i = i + 1
endloop
if nearplayer != 30 then
  return enemy_force[nearplayer]
endif
return null
endfunction

//============================================================================
function GetSecondNearestEnemy takes nothing returns player
  local integer i = 0
  local integer pmin = -1
  local integer spmin = -1
  local integer minstr = 10000
  local integer sminstr = 10000
  local integer cstr = 0
  local unit cbuilding = null
  loop
    exitwhen i == c_enemy_total
    if GetPlayerSlotState(enemy_force[i]) == PLAYER_SLOT_STATE_PLAYING then
      set cbuilding = GetBuilding(enemy_force[i])
      if cbuilding != null and UnitAlive(cbuilding) then
        set cstr = GetRangePenalty(cbuilding)
        if cstr < minstr then
          set spmin = pmin
          set pmin = i
          set sminstr = minstr
          set minstr = cstr
        elseif cstr < sminstr then
          set spmin = i
          set sminstr = cstr
        endif
      endif
    endif
    set i = i + 1
  endloop
  // if spmin == -1 then
  //   call Trace("Debug: GetSecondNearestEnemy failed!")
  //   set spmin = 0
  // endif
  set cbuilding = null
  if spmin != -1 then
    return enemy_force[spmin]
  endif
  return null
endfunction

function GetNearHumanPlayerEnemy takes unit u returns unit
  local group g = CreateGroup()
  if nearest_human_enemy == null or GetPlayerSlotState(nearest_human_enemy) != PLAYER_SLOT_STATE_PLAYING then
    call SetNearestEnemy()
  endif
  if nearest_human_enemy != null then
    call GroupEnumUnitsOfPlayer(g, nearest_human_enemy, null)
    set g = SelectUnittype(g, UNIT_TYPE_TOWNHALL, true)
    set g = SelectByAlive(g, true)
    set g = SelectByHidden(g, false)
    set u = FirstOfGroup(g)
  endif
  call DestroyGroup(g)
  set g = null
  return u
endfunction

//============================================================================
function GetFFAEnemy takes nothing returns player
  if GetRandomInt(1, 3) == 1 then
    return GetSecondNearestEnemy()
  else
    return GetNearestEnemy()
  endif
endfunction

//============================================================================
function GetTowerFactor takes unit target returns integer
  local integer tstrength = GetLocationTowerStrength(GetUnitX(target), GetUnitY(target), ver_tower_check_radius)
  if h_siege then
    return tstrength
  else
    return 4*tstrength
  endif
endfunction

//============================================================================
function GetRace takes player p returns integer
  return player_race[GetPlayerId(p)]
endfunction

//============================================================================
function GetRaceAggression takes unit target returns integer
  local integer i = Max((GetRace(GetOwningPlayer(target))-1) * tiernum + tier - 1,0)
  return race_aggression[i]
endfunction

//============================================================================
function GetTargetStrength takes unit target returns integer
  local integer str = GetUnexactPlayerStrength(GetOwningPlayer(target))
  if str < 100 then
    set str = Min(str + GetRangePenalty(target), 100)
  endif
  return str
endfunction

//============================================================================
function GetEnemyAllyStrength takes player tp returns integer
  local integer i = 0
  local integer ally_sum = 0
  local integer enemy_sum = 0
  local player p = null
  loop
    exitwhen i >= PLAYERAGGRESSIVE
    set p = Player(i)
    if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING and not IsPlayerObserver(p) then
      if p != ai_player and p != tp then
        if IsPlayerAlly(p, ai_player) then
          set ally_sum = ally_sum + R2I(GetPlayerStrength(p))
        elseif IsPlayerAlly(p, tp) then
          set enemy_sum = enemy_sum + GetUnexactPlayerStrength(p)
        endif
      endif
    endif
    set i = i + 1
  endloop
  set p = null
  return (enemy_sum - ally_sum)/2
endfunction

//============================================================================
function IsTargetGood takes unit target, integer attacker_bonus returns boolean
  if target != null then
    set added_target_aggression = attacker_bonus
    set added_racial_aggression = GetRaceAggression(target)
    return GetTargetStrength(target) + GetEnemyAllyStrength(GetOwningPlayer(target)) + GetTowerFactor(target) <= own_strength + attacking_aggression + added_aggression + added_racial_aggression + attacker_bonus
  else
    return false
  endif
endfunction

//============================================================================
function ChooseEnemyExpansionTarget takes unit u returns unit
  set u = GetEnemyExpansion()
  if u != null then
    if IsTargetGood(u, expansion_target_bonus) then
      call Trace("Hardcoded enemy expansion target chosen")
    else
      set u = null
    endif
  endif
  return u
endfunction

//============================================================================
function ChooseEnemyBaseTarget takes unit u returns unit
  local integer c = 0
  call StartGetEnemyBase()
  loop
    exitwhen not WaitGetEnemyBase()
    if c > 4 then
      return null
    endif
    call Sleep(1)
    set c = c + 1
  endloop
  set u = GetEnemyBase()
  if u != null and IsTargetGood(u, comp_chosen_target_bonus) then
    call Trace("Hardcoded Enemy Base Target chosen")
    return u
  endif
  return null
endfunction

//============================================================================
function ChooseAnEnemyTarget takes unit u returns unit
  local player target_enemy = null
  local player temptarget = null
  local group g = CreateGroup()
  local location enemy_base = null

  if attacking_strategy == 1 or attacking_strategy == 3 then
    set target_enemy = GetWeakestEnemy()
    //call Trace("Chooing Weakest Enemy")
  elseif attacking_strategy == 2 then
    set target_enemy = GetStrongestEnemy()
    //call Trace("Choosing Strongest Enemy")
  elseif attacking_strategy == 5 then
    set target_enemy = GetFFAEnemy()
    //call Trace("Choosing FFA Enemy")
  else
    set target_enemy = GetWeakAndNearEnemy()
    //call Trace("Choosing weakest closest Enemy")
  endif
  call GroupEnumUnitsOfPlayer(g, target_enemy, null)
  set enemy_base = GetPlayerStartLocationLoc(target_enemy)
  set g = SelectByAlive(g, true)
  set g = SelectUnittype(g, UNIT_TYPE_TOWNHALL, true)
  set g = SelectByLocation(g, enemy_base, 1000, false)
  set u = FirstOfGroup(g)
  if u == null then
    set u = GetBuilding(target_enemy)
  endif
  call DestroyGroup(g)
  set g = null
  call RemoveLocation(enemy_base)
  set enemy_base = null
  set target_enemy = null
  return u
endfunction

function ChooseAnyEnemyTarget takes unit u returns unit
  set u = ChooseAnEnemyTarget(u)
  if IsTargetGood(u,0) then
    call Trace("Enemy Advanced Target Chosen")
    set alli_target = u
    if attacking_strategy == 3 then
      set alli_target = GetBuilding(GetStrongestEnemy())
    endif
    return u
  endif
  return null
endfunction

//============================================================================
function ChooseAttackTarget takes unit u returns unit
  //call DisplayToAll("Choosing attack target")
  if GetRandomReal(0.0,1.0) > comp_chosen_target_rate then
    set u = ChooseEnemyExpansionTarget(u)
    if u == null then
      //call DisplayToAll("Attack enemy Base")
      set u = ChooseEnemyBaseTarget(u)
    endif
    set alli_target = u
  endif

  if u == null then
    set u = ChooseAnyEnemyTarget(u)
  endif
  return u
endfunction

//============================================================================
function SetChatVarsAttack takes unit u returns nothing
  local player p = GetOwningPlayer(u)
  call SetChatVar("TargetRace", race_name[player_race[GetPlayerId(p)]])
  call SetChatVar("TargetColor", ColorText(p))
  call SetChatVarR("TargetStrength", GetPlayerStrength(p))
  set p = null
endfunction

//============================================================================
// Militia Expansion melee attack
//============================================================================
function Militia_Expansion takes integer m returns nothing
  local group g = null
  local group cg = null
  local unit u = null
  local unit efoe = null
  local integer t = 0
  set efoe = GetExpFoe(efoe)
  if efoe == null or IsUnitInGroup(current_expansion,water_expansion) then  //is WaterExpansion
    set efoe = null
    return
  endif
  set g = CreateGroup()
  set break_attack = false  // to persuade attack system to hopefully not exit early and do the reforming behaviour
  set militia_check_enabled = false
  //call BuildExpa( TownCount(racial_expansion)+1, racial_expansion, farm_prio + 50 )
  call DisplayToAlliesChat(militia_expansion_chat)
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectNumberOfId(g, 100, old_id[racial_peon] )
  set g = SelectByAlive(g, true)
  set g = GetNearestSubGroupOfGroup(g, home_location, m)
  //set expansion_peon = FirstOfGroup(g)
  call AddAbilityToGroup(CopyGroup(g,cg), race_militia_ability)
  call GroupImmediateOrder(g, race_militia_unitstring)
  call RemoveInjuries()
  call FormGroupAM(4)
  loop
    exitwhen AreUnitsOfType(g, race_militia_id)
    exitwhen t > 4
    call Sleep(2)
    set t = t + 1
  endloop
  //call AddAssault(m, old_id[racial_militia])   // Lil problem with adding assaults. For some reasons
  //call AttackMoveKill(efoe)
  call GroupPointOrder(g, "attack", GetUnitX(current_expansion), GetUnitY(current_expansion))
  set town_threat_break = false
  //set captain_flee = false
  //call SetCaptainHome(ATTACK_CAPTAIN, GetUnitX(efoe), GetUnitY(efoe)) //
  //call AttackMoveKillCreep(efoe)
  set attack_running = true
  //if not retreat_controlled then
  //  call Trace("===Retreat control started===")
  //  set retreat_controlled = true
  //  call SetGroupsFlee(false)
  //  call SetTargetHeroes(false)
  //  call TQAddJob(2 * sleep_multiplier, RETREAT_CONTROL, 0)
  //endif
  call AttackMoveKill(efoe)
  call SleepUntilTargetDeadAM(efoe, true)
  call Chat(C_Done)
  call SleepInCombatAM()
  call Trace("===Attack Fully Finished===")
  call GroupPointOrder(g, "move", GetLocationX(home_location), GetLocationY(home_location))
  call GroupImmediateOrder(g, "militiaoff" )
  set attack_running = false
  //call SetCaptainHome(ATTACK_CAPTAIN, GetLocationX(home_location), GetLocationY(home_location))
  set militia_check_enabled = true
  set town_threat_break = true
  //set captain_flee = true
  //set militia = false
  set take_exp = false
  call DestroyGroup(g)
  set g = null
  set cg = null
  set efoe = null
  set u = null
endfunction

//============================================================================
// (AMAI) Defending
//============================================================================
function SleepUntilTownDefended takes integer ai_strength returns nothing
  local integer defense_length_counter = 0
  set own_strength = ai_strength
  call Trace("==Sleep Defend Town==" )
  loop
    exitwhen not town_threatened
    exitwhen player_defeated
    if town_loc[most_threatened_town] != null and LinearInterpolation(ver_low_aggression,ver_high_aggression,ver_flee_multiple1,ver_flee_multiple2,attacking_aggression)*own_strength > army_strength[town_threat_army[most_threatened_town]] then
      if town_threat[most_threatened_town] >= teleport_low_threat then
        if not teleporting then
          call AttackMoveXY(R2I(GetLocationX(town_loc[most_threatened_town])), R2I(GetLocationY(town_loc[most_threatened_town])))
        endif
      endif
      call SetCaptainHome(DEFENSE_CAPTAIN, GetLocationX(town_loc[most_threatened_town]), GetLocationY(town_loc[most_threatened_town]))
    else
      //call Trace("Town threatened - retreat" )
      //if town_threat[most_threatened_town] >= teleport_low_threat then
        if not teleporting then
          call AttackMoveXY(R2I(GetLocationX(home_location)), R2I(GetLocationY(home_location)))
        endif
        set defense_length_counter = defense_length_counter + 1
        if defense_length_counter > attack_reform_length then
          set defense_length_counter = 0
          call FormGroupAM(2)
        endif
      //endif
      call SetCaptainHome(DEFENSE_CAPTAIN, GetLocationX(home_location), GetLocationY(home_location))
      //call ClearCaptainTargets()
      //call CaptainGoHome()
    endif
    call Sleep(2*sleep_multiplier)
    set own_strength = GetOwnStrength()
  endloop
  call Trace("==exit Sleep Defend Town==")
  call SetCaptainHome(DEFENSE_CAPTAIN, GetLocationX(home_location), GetLocationY(home_location))
  endfunction

function SetLeadAlly takes nothing returns nothing
  local integer i = 0
  local boolean checkdone = false
  local player p = null
  loop
    exitwhen i >= force_number or checkdone
    set p = own_force[i]
    if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING then
      if p != ai_player then
        set leadally = false
        set checkdone = true
      elseif p == ai_player then
        set leadally = true
        set checkdone = true
      endif
    endif
    set i = i + 1
  endloop
endfunction
//============================================================================
// AMAI SingleMeleeAttack
//============================================================================
function SingleMeleeAttackAM takes boolean needs_exp, boolean has_siege, boolean br_rush, integer ai_strength returns nothing
local unit hall = null
local unit mega = null
local unit creep = null
local unit common = null
local unit humanhall = null

//call Trace("SingleMeleeAttack")

if desperation_assault and not no_attack then
  // Perpetual attack regardless of power or strength
  if c_ally_total > 0 then
    call SetLeadAlly()
    if difficulty != EASY then
      set common = GetAllianceTarget()
      if common != null then
        call Trace("===Desperation Attack Alliance Target===")
        call Chat(C_Ally)
        call FormGroupAM(3)
        call DesperationAssault()
        call AttackMoveKillAAM(common)
        call SetAllianceTarget(null)
        set common = null
        return
      endif
    endif
  endif

  set common = ChooseAnEnemyTarget(common)
  if (common != null) then
    call Trace("===Desperation Attack Random Enemy Target===")
    call SetAllianceTarget(common)
    call FormGroupAM(3)
    call DesperationAssault()
    call AttackMoveKillAAM(common)
    call SetAllianceTarget(null)
    set common = null
    return
  endif

endif

if town_threatened then
  set break_attack = false
  set isfleeing = false
  call FormGroupAM(1)
  call SleepUntilTownDefended(ai_strength)
  call SleepInCombatAM()
  return
endif

call Trace("===Single Melee Attack===" )
call Trace("AI strength: " + Int2Str(ai_strength))

set h_siege = has_siege
set own_strength = ai_strength

call set_aggression()


// Commander Control Attacks
//
if no_attack then
  call Trace("No Attack is on" )
  call Sleep(4 * sleep_multiplier)
  call ClearCaptainTargets()
  return
endif

if queue_running then

  if queue_attack_p then
    call Trace("Attacking point "+Int2Str(queue_t_x)+","+Int2Str(queue_t_y) )
    call FormGroupAM(3)
    call QueueAttackMoveXY(queue_t_x, queue_t_y)
    call Trace("Point reached or aborted" )
    return

  elseif queue_attack_u then
    if queue_t_u == null then
      call Trace("No unit targeted, queue stopped" )
      set queue_running = false
    elseif not UnitAlive(queue_t_u) then
      call Trace("Unit is dead, next command" )
      call QueueGetNextCommand()
    else
      call Trace("Attacking unit" )
      call FormGroupAM(3)
      call AttackMoveKillAAM(queue_t_u)
      call Trace("Attack complete" )
      return
    endif
  endif

endif

if attack_player then
  call Trace("Attacking player" )
  set hall = GetBuilding(Player(attack_target_p))
  if hall == null then
    call Trace("No target found" )
    set attack_player = false
    return
  endif
  call FormGroupAM(3)
  call AttackMoveKillAAM(hall)
  call Trace("Attack complete" )
  set hall = null
  return
endif

if attack_point then
  call Trace("Attacking point "+Int2Str(attack_target_x)+","+Int2Str(attack_target_y) )
  call FormGroupAM(3)
  call AttackMoveKillXYAAM(attack_target_x, attack_target_y)
  call Trace("Attack complete" )
  return
endif

if attack_unit then
  if target_unit == null then
    call Trace("No unit targeted" )
    set attack_unit = false
  elseif not UnitAlive(target_unit) then
    call Trace("Unit is dead" )
    set attack_unit = false
  else
    call Trace("Attacking unit" )
    call FormGroupAM(3)
    call AttackMoveKillAAM(target_unit)
    call Trace("Attack complete" )
    return
  endif
endif

if not creeping_only then	// Do the normal attack sequence

  // tower rush attack
  //
  if towerrush then
    call Trace("A Tower Rush Attack")
    call FormGroupAM(3)
    call AttackMoveTowerRush()
    return
  endif

  // militia expansion
  //
  if militia_expanding then
    call Trace("A Militia Expansion")
    call Militia_Expansion(6)
    set militia_expanding = false
    return
  endif

  // ancient expansion attack
  //
  if ancient_expanding then
    if ancient_exp_state == 2 or ancient_exp_state == 3 then
      call Trace("An Ancient Expansion Attack")
      //call FormGroupAM(3)
      //call AddAssault(1, old_id[racial_hall[1]])
      call SetCaptainHome(BOTH_CAPTAINS,GetUnitX(ancient_exp_unit),GetUnitY(ancient_exp_unit))
      //call AttackMoveKillXYAAM(R2I(GetUnitX(ancient_exp_unit)), R2I(GetUnitY(ancient_exp_unit)))
      return
    elseif ancient_exp_state == 4 then
      set ancient_attack_running = true
      call Trace("An Ancient Expansion - Final stage")
      call FormGroupAM(3)
      //call AddAssault(1, old_id[racial_hall[1]])
      call SetCaptainHome(BOTH_CAPTAINS,GetUnitX(ancient_exp_unit),GetUnitY(ancient_exp_unit))
      set creep = GetExpFoe(creep)
      //if DistanceBetweenUnits(ancient_exp_unit, creep) <= 500 then
      call AttackMoveKillCreep(creep)
      //else
      //call AttackMoveKillXYAAM(R2I(GetUnitX(ancient_exp_unit)), R2I(GetUnitY(ancient_exp_unit)))
      //endif
      set ancient_attack_running = false
      set creep = null
      return
    endif
  endif

  // item expansion attack
  //
  if item_expanding then
    call Trace("An Item Expansion Attack or Guard")
    set item_attack_running = true
    call FormGroupAM(3)
    if item_exp_state == 1 then
      set creep = GetExpFoe(creep)
      call AttackMoveKillCreep(creep)
      set item_attack_running = false
      set creep = null
    elseif item_exp_state > 0 then
      call AttackMoveKillXYAAM(R2I(GetLocationX(item_exp_guard_loc)),R2I(GetLocationY(item_exp_guard_loc)))  //Prevent the army from leaving before using the item , so no set item_attack_running
    endif
    return
  endif

  // ELF BR
  //
  if br_rush and rushcreep_target != null and UnitAlive(rushcreep_target) then
    call Trace("ELF BR Attack")
    call FormGroupAM(3)
    call BRRush()  //try BR
    return
  endif


  // defend expansion from other expansion
  //
  if double_expansion_target != null and IsTargetGood(double_expansion_target, 10) then
    call Trace("Double Expansion Attack")
    call SetAllianceTarget(double_expansion_target)
    call FormGroupAM(3)
    call AttackMoveKillAAM(double_expansion_target)
    if not UnitAlive(double_expansion_target) then
      set double_expansion_target = null
      call SetAllianceTarget(null)
    endif
    return
  endif

  if not (no_creep_attack or ai_no_creep) then

    // take expansions as needed
    //
    if needs_exp then
      if first_expansion_chosen and (current_expansion == null or CheckExpansionTaken(current_expansion)) then
        call ChooseExpansion()
        if current_expansion == null then
          return
        endif
      endif
      set creep = GetExpFoe(creep)
      if creep != null and UnitAlive(creep) then
        call Trace("Creep the Expansion")
        set attacking_expansion = true
        set battle_radius = creep_battle_radius
        call SetAllianceTarget(creep)
        call Chat(C_Expansion)
        call FormGroupAM(3)
        call AttackMoveKillCreep(creep)
        if creep == null then
          set take_exp = false
        endif
        call Sleep(10)
        set attacking_expansion = false
        set creep = null
        call SetAllianceTarget(null)
        return
      endif
      set creep = null
    endif
  endif

  // coordinate with allies
  //
  if c_ally_total > 0 then
    call SetLeadAlly()
    if difficulty != EASY then
      set common = GetAllianceTarget()
      if common != null then
        call Trace("Attack Alliance Target")
        call Chat(C_Ally)
        call FormGroupAM(3)
        call AttackMoveKillAAM(common)
        call Trace("Attack complete")
        call SetAllianceTarget(null)
        set common = null
        return
      endif
    endif
  endif

  if not no_player_attack then
    if firstattackhp then  // player too much or big map , first attack HumanPlayer
      set humanhall = GetNearHumanPlayerEnemy(humanhall)
      set firstattackhp = tier > 2 and (GetRandomInt(0,4) < 2)  // attack no longer working , the human player survived
      if humanhall != null then
        call Chat(C_Attack)
        call SetAllianceTarget(humanhall)
        call FormGroupAM(3)
        call AttackMoveKillAAM(humanhall)
        call SetAllianceTarget(null)
        set humanhall = null
        return
      endif
    endif

    // all-out attack if the player is weak
    //
    if difficulty != EASY then
      set mega = GetMegaTarget()
      if mega != null and UnitAlive(mega) then
        call Trace("Mega Attack Target")
        call SetAllianceTarget(mega)
        call SetChatVarsAttack(mega)
        call Chat(C_Mega)
        call Chat(C_Megatarget)
        call FormGroupAM(3)
        call AttackMoveKillAAM(mega)
        call SetAllianceTarget(null)
        set mega = null
        return
      endif
      set mega = null
    endif

    if GetHeroXP(hero_unit[1]) < GetRandomInt(50,150) or GetHeroXP(hero_unit[1]) > GetRandomInt(300,850) or GetHeroXP(hero_unit[2]) > 450 or FoodUsed() > GetRandomInt(40,60) then

      set hall = ChooseAttackTarget(hall)
      if hall != null and UnitAlive(hall) then
        call SetChatVarsAttack(hall)
        call Chat(C_Attack)
        call SetAllianceTarget(alli_target)
        //set alli_target = null
        call FormGroupAM(3)
        call AttackMoveKillAAM(hall)
        call SetAllianceTarget(null)
        set hall = null
        return
      endif
      set hall = null
    endif
  endif
endif // if not creep only

if no_creep_attack or ai_no_creep then
  call Trace("no creeping" )
  call Sleep(4 * sleep_multiplier)
  return
endif

// nothing better to do, so kill a creep camp
//
set battle_radius = creep_battle_radius
call Trace("Just gonna be creeping")
call CreepAttack(own_strength)

endfunction


//============================================================================
//  SkillArraysAM
//============================================================================
function SkillArraysAM takes nothing returns integer
  local integer level = GetHeroLevelAI()
  local integer hn = GetHeroNumber(GetHeroId())
  if level > max_hero_level then
      set max_hero_level = level
  endif
  if skillfix == true then    //Assisted Hero Learning Skills , for war3 1.31 bug
    if hero_unit[hn] == null then
      set hero_unit[hn] = GetOneOfId(hero_unit[hn], ai_player, old_id[hero[hn]])
    endif
    call SelectHeroSkill( hero_unit[hn], skills[(hn - 1) * HERO_LEVEL_NUMBER + level] )
  endif
  return skills[(hn - 1) * HERO_LEVEL_NUMBER + level]
endfunction

//============================================================================
function StoreSkills takes integer ta returns nothing
  local integer i = 1
  loop
    exitwhen i > HERO_LEVEL_NUMBER
    set skills[(ta - 1) * HERO_LEVEL_NUMBER + i] = tempskills[i]
    set i = i + 1
  endloop
endfunction

//============================================================================
function LoadSkillsExt takes integer sa returns nothing
  local integer i = 1
  loop
    exitwhen i > HERO_LEVEL_NUMBER
    set tempskills[i] = allskills[sa + i]
    set i = i + 1
  endloop
endfunction

//============================================================================
// sa = tier hero picked at, hn = hero number, ta is again tier hero picked at
function LoadSkills takes integer sa, integer hn, integer ta returns nothing
  local integer perc = GetRandomInt(0,major_hero_skill_value+minor_hero_skill_value+rare_hero_skill_value)
  local integer sk = 0	// is which of the 3 skill lines is chosen

  if perc <= rare_hero_skill_value then
    set sk = HERO_SKILL_RARE
  elseif perc <= minor_hero_skill_value+rare_hero_skill_value then
    set sk = HERO_SKILL_MINOR
  endif
  set hero_skills[sa] = sk // set global variable so we can use the fact of knowning what skill was chosen in AMAI
  call LoadSkillsExt((sa-1)*3*HERO_LEVEL_NUMBER + sk*HERO_LEVEL_NUMBER + (hn-1)*9*HERO_LEVEL_NUMBER)
  call StoreSkills(ta)
endfunction

//============================================================================
//  AwaitMeleeHeroesAM
//  Ensure we have a hero available
//============================================================================
//============================================================================
// (AMAI) HeroHealingBugFix
//  Fixes the bug where for some reason the hero dosn't get removed from the 
//  healing group. Micro usage e.g. health fountain or returning home puts 
//  the hero in the healing groups so a bug occurs in those functions.
//============================================================================
function HeroHealingBugFix takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > 3
    if HeroBugFixHealthCheck(i) then
      call Trace("HERO: Healing Bug Fix")
      call RecycleGuardPosition(hero_unit[i])
      call GroupRemoveUnit(unit_healing, hero_unit[i])
    endif
    set i = i + 1
  endloop
endfunction

// Returns a boolean if it should only attack creeps
function AwaitMeleeHeroesAM takes nothing returns boolean
  local integer i = 1
  local boolean hero_available = false

  loop
    //call HeroHealingBugFix()
    loop
      exitwhen i > 3
      if GetUnitCountDone(old_id[hero[i]]) > 0 then
        if not IsUnitInGroup(hero_unit[i], unit_healing) then
          return false
        endif
        set hero_available = true
      endif
      set i = i + 1
    endloop
    set i = 1
    exitwhen player_defeated or hero_available
    call Sleep(2 * sleep_multiplier)
    call Trace("AwaitMeleeHeroesAM: No Heroes Ready")
  endloop

  return true
endfunction

//============================================================================
// (AMAI) HealArmy
//============================================================================
function GetArmyHealthState takes nothing returns real
  local group g = CreateGroup()
  local unit u = null
  local real health_sum = 0.0
  local integer count = 0
  local real uhs = 0.0
  local integer hid = 0
  local integer hFountainID = GetHealthFountainID()
  local integer id = 0
  call GroupClear(healer_group)
  call GroupClear(urgent_healing_group)
  call GroupClear(medium_healing_group)
  call GroupClear(small_healing_group)
  set urgent_healing_count = 0
  set medium_healing_count = 0
  set small_healing_count = 0
  set ward_cast = false
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, false)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, false)
  set g = SelectByIllusion(g, false)
  set g = SelectByHidden(g, false)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set id = GetUnitTypeId(u)
    if id == 'ohwd' then
      set ward_cast = true
    endif
    if UnitAlive(u) then  //and not (IsUnitHidden(u) or IsUnitType(u, UNIT_TYPE_PEON) or IsUnitType(u, UNIT_TYPE_STRUCTURE) or IsUnitIllusion(u)) then
      if IsUnitType(u, UNIT_TYPE_MECHANICAL) or IsUnitType(u, UNIT_TYPE_SUMMONED) then
        set health_sum = health_sum + 1 // Because is not currently handled by healing and we don't want army to run away if only 1 human unit is hurt
        set uhs = 1
      else
        set uhs = GetUnitState(u, UNIT_STATE_LIFE) / GetUnitState(u, UNIT_STATE_MAX_LIFE)
        set health_sum = health_sum + uhs
      endif
      set count = count + 1
      set hid = GetHealerId(id)
      if hid != -1 and GetUnitState(u, UNIT_STATE_MANA) >= (healer_mana_cost[hid] * 2) / 3 and ((healer_upg_id[hid] == 0) or (GetUpgradeLevel(healer_upg_id[hid]) >= healer_upg_level[hid])) then
        call GroupAddUnit(healer_group, u)
      endif
      if uhs < 0.5 then
        call GroupAddUnit(urgent_healing_group, u)
        set urgent_healing_count = urgent_healing_count + 1
      elseif uhs < 0.75 then
        call GroupAddUnit(medium_healing_group, u)
        set medium_healing_count = medium_healing_count + 1
      elseif uhs < 1 then
        call GroupAddUnit(small_healing_group, u)
        set small_healing_count = small_healing_count + 1
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  if nearest_neutral[hFountainID] == null or not neutral_available[hFountainID] or not race_use_fountain then
    set fountain_available = false
  else
    set fountain_available = (neutral_night_buy[hFountainID] and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) < 6)) or not neutral_guarded[hFountainID]
  endif
  if count == 0 then
    return 1.0
  endif
  return ((health_sum / count) + (1-(urgent_healing_count + medium_healing_count) / count)) / 2
endfunction

//============================================================================
//     Orders unit to use the given mass healing item

function ApplyMassHealingItem takes unit u, item mh_i returns nothing
  local unit hu = null
  local real time = 0

  set hu = FirstOfGroup(urgent_healing_group)
  if hu == null then
    set hu = FirstOfGroup(medium_healing_group)
    if hu == null then
      set hu = FirstOfGroup(small_healing_group)
    endif
  endif

  call RemoveGuardPosition(u)
  call GroupPointOrder(urgent_healing_group, "move", GetUnitX(u), GetUnitY(u))
  call GroupPointOrder(medium_healing_group, "move", GetUnitX(u), GetUnitY(u))
  call GroupPointOrder(small_healing_group, "move", GetUnitX(u), GetUnitY(u))
  call IssuePointOrder(u, "move", GetUnitX(hu), GetUnitY(hu))
  set time = RMax((GetTimeToReachUnit(u, hu) + GetTimeToReachUnit(hu, u))/2,2)    // Average of times. Not accurate as is longer than it should be to definatly make sure units surround the hero
  call Sleep(time)
  call UnitUseItem(u, mh_i)
  call RecycleGuardPosition(u)
  set hu = null
endfunction

//============================================================================
function ApplyHealingItem takes unit u, item heal_item returns nothing
//     Orders unit to use the given healing item on a particular unit

  local unit target = null
  local group urgent = null
  local group medium = null
  set urgent = CopyGroup(urgent_healing_group,urgent)
  set medium = CopyGroup(medium_healing_group,medium)
  call RemoveGuardPosition(u)
  call GroupPointOrder(urgent_healing_group, "move", GetUnitX(u), GetUnitY(u))
  call GroupPointOrder(medium_healing_group, "move", GetUnitX(u), GetUnitY(u))
  call GroupPointOrder(small_healing_group, "move", GetUnitX(u), GetUnitY(u))
  call Sleep(5 * sleep_multiplier)
  if false then
  #INCLUDETABLE <$VER$\HealingItems.txt> #EFR #COND "%1" eq "RITUAL_DAGGER"
  elseif GetItemTypeId(heal_item) == old_id[%1] then  //prevent killing high health units
    set target = FirstOfGroup(urgent)
    if target != null then
      call UnitUseItemTarget(u, heal_item, target)
      call GroupRemoveUnit(urgent, target)
    endif
  #ENDINCLUDE
  else
    loop
      exitwhen not UnitHasItem(u, heal_item)
      set target = FirstOfGroup(urgent)
      if target != null then
        call UnitUseItemTarget(u, heal_item, target)
        call GroupRemoveUnit(urgent, target)
      else
        set target = FirstOfGroup(medium)
        if target != null then
          call UnitUseItemTarget(u, heal_item, target)
          call GroupRemoveUnit(medium, target)
        endif
      endif
      exitwhen target == null
      call Sleep(2 * sleep_multiplier)
    endloop
  endif
  call RecycleGuardPosition(u)
  call DestroyGroup(urgent)
  call DestroyGroup(medium)
  set urgent = null
  set medium = null
  set target = null
endfunction

//============================================================================
//  Orders unit to use an item that does a global healing effect
function ApplyGlobalItem takes unit u, item heal_item returns nothing
  call UnitUseItem(u, heal_item)
endfunction
//============================================================================
function HealArmy takes nothing returns nothing
  local real hs = 0.0
  local unit u = null
  local integer mh_item = 0
  local item mh_i = null
  local boolean mass_healed = false
  local boolean global_heal = false
  local integer sleepLength = 10
  local real healthTrigger = 0.75
  loop
    set hs = GetArmyHealthState()
    set mass_healed = false
    exitwhen (urgent_healing_count + medium_healing_count <= 3 and hs > healthTrigger) // and not shop_ordered	
    exitwhen player_defeated or town_threatened or ver_heroes == false
    call Trace("function HealArmy: Army is badly damaged and needs healing " + Real2Str(hs))
    set mh_item = GetMassHealingItem()
    if mh_item > 0 then
      set mass_healed = true
    endif
    if mh_item == 0 then
      set mh_item = GetMerchantMassHealingItem()
      if mh_item > 0 then
        set mass_healed = true
      endif
    endif
    if mh_item == 0 then
      set mh_item = GetGlobalHealingItem()
      if mh_item > 0 then
        set global_heal = true
      endif
    endif
    if mh_item == 0 then
      set mh_item = GetHealingItem()
    endif
    if mh_item > 0 then
      set mh_i = GetItemOfType(mh_i,mh_item)
      if mh_i != null then
        set u = GetItemHero(mh_i)
        if u != null then
          if mass_healed then
            set sleepLength = 10
            call ApplyMassHealingItem(u, mh_i)
          elseif global_heal then
            set sleepLength = 25
            call ApplyGlobalItem(u, mh_i)
          else
            set sleepLength = 10
            call ApplyHealingItem(u, mh_i)
          endif
          if hs <= healthTrigger then
            call Sleep(sleepLength * sleep_multiplier) // Wait some time for item effects to work
          endif
        endif
      else
        call StartEmergencyItem(1, mh_item)
        if hs <= healthTrigger then
          call Sleep(8*sleep_multiplier) // Wait some time for item to be bought
        endif
      endif
    endif
    call Sleep(2 * sleep_multiplier)
    exitwhen hs > healthTrigger // Still a large proportion of army is strong so exit loop
  endloop
  set mh_i = null
  set u = null
endfunction

//============================================================================
// (AMAI) Universal attack sequence
//============================================================================
function universal_attack_sequence takes nothing returns nothing
  local boolean needs_exp = false
  local boolean has_siege = false
  local boolean br_rush = false
  local integer ai_strength = 0
  //local integer ai_antiair_strength = 0
  local integer exp_strength = 0

  if hero_unit[1] == null and ver_heroes and not desperation_assault then
    call Sleep(sleep_multiplier)
    return
  endif
  call SetTargetHeroes(difficulty != EASY)
  set ai_strength = GetOwnStrength()
  //set ai_antiair_strength = air_strength
  if current_expansion != null then
    set exp_strength = GetExpansionStrength()
  endif
  if rushcreep_target != null and UnitAlive(rushcreep_target) then
    set br_rush = GetLocationCreepStrength(GetUnitX(rushcreep_target), GetUnitY(rushcreep_target), 510) <= ai_strength * 0.6
  endif
  set most_threatened_town = Max(most_threatened_town,0)
  if major_hero == null or not UnitAlive(major_hero) or not IsStandardUnit(major_hero) or (IsUnitType(major_hero, UNIT_TYPE_HERO) == false and ver_heroes) then
    set major_hero = GetMajorHero(major_hero)
  endif

  set needs_exp        = take_exp and (ai_strength > exp_strength)
  set has_siege        = ai_strength > 60
#INCLUDETABLE <$VER$\StandardUnits.txt> #EFR #COND "%4" =~ /\bsiege\b/
  set has_siege        = has_siege or TownCountDone(%1) > 0
#ENDINCLUDE

  call SingleMeleeAttackAM(needs_exp,has_siege,br_rush,ai_strength)
  set added_target_aggression = 0
  set added_racial_aggression = 0

  //call TeleportCaptain(GetLocationX(home_location), GetLocationY(home_location))

  loop
    exitwhen not teleporting
    //call Trace("UNIVERSAL ATTACK: Units are teleporting")
    call Sleep(1)
  endloop

  if town_threatened then
    set break_attack = false
    set isfleeing = false
    call FormGroupAM(1)
    call SleepUntilTownDefended(ai_strength)
    call SleepInCombatAM()
  elseif not towerrush and not ancient_expanding and not militia_expanding and not item_expanding then
    call SetCaptainHome(DEFENSE_CAPTAIN, GetLocationX(home_location), GetLocationY(home_location))
  endif

  if go_home then
    call Trace("UNIVERSAL ATTACK: Going home" )
    call ClearCaptainTargets()
    call CaptainGoHome()
  endif
  set break_attack = false
  set go_home = false
  if not town_threatened then
    call ClearCaptainTargets()   // Causes the pause in movement to allow units to catch up
                                 // disabled when town threatened as we want units to get back fast
  endif
endfunction

//============================================================================
// (AMAI) Universal peon assignment
//============================================================================
function universal_peon_assignment takes nothing returns nothing
  local integer T = TownWithMine()
  local integer g = GetGold()
  local integer w = GetWood()
  local integer pwh = 0
  local integer swh = 0
  local real gdivw = I2R(g)/I2R(Max(w,1))
  local integer i = T + 1

  if T < 0 then
    set T = 0
    set i = 1
  endif

  if g - w > 300 then
    set pwh = 2
  elseif g - w > 500 and w < 100 then
    set pwh = 5
  elseif g - w > 900 and w < 200 then
    set pwh = 8
  else
    set pwh = 2
  endif

  if w < 200 then
    set swh = 6 - pwh
  elseif gdivw < 0.5 then
    set swh = 0
  elseif gdivw < 0.8 then
    set swh = Max(1 - pwh,0)
  elseif gdivw < 1.1 then
    set swh = Max(2 - pwh,0)
  elseif gdivw < 1.4 then
    set swh = Max(3 - pwh,0)
  elseif gdivw < 1.7 then
    set swh = Max(4 - pwh,0)
  elseif gdivw < 2.0 then
    set swh = Max(5 - pwh,0)
  else
    set swh = Max(6 - pwh,0)
  endif

  set swh = Max(swh - 4 * TownCountDone(neutral_shredder),0)

  if towerrush and swh <= race_tower_peon then
    set swh = race_tower_peon + 2
  endif

  call ClearHarvestAI()

  if (desperation_assault) then
    return
  endif

  call HarvestGold(T,ver_optimal_gold - 1)
  call HarvestWood(0,1)
  call HarvestGold(T,1)
  call HarvestWood(0,pwh)
  call HarvestWood(0,swh)

  loop
    //set i = i + 1
    exitwhen i > Max(T + 3,TownCountDone(racial_expansion))
    if T != i and TownHasMine(i) and TownCountEx(racial_expansion,true,i) > 0 then
      if gdivw < 3.0 or g < 300 then
        call HarvestGold(i,ver_optimal_gold)
      else
        call HarvestGold(i,ver_optimal_gold - 2)
      endif
    endif
    set i = i + 1
  endloop

  call HarvestWood(0,20)
endfunction

//============================================================================
// (AMAI) Campaign extras
//============================================================================
function SetAIResources takes integer g, integer w returns nothing
  call SetPlayerGold(ai_player, g)
  call SetPlayerWood(ai_player, w)
endfunction

//============================================================================
function IncreaseAIResources takes integer g, integer w returns nothing
  call IncreasePlayerGold(ai_player, g)
  call IncreasePlayerWood(ai_player, w)
endfunction

//============================================================================
function AddWaveResources takes nothing returns nothing
  local integer g = 0
  local integer w = 0
  local integer i = 0
  local integer unitid = 0
  local integer desire = 0

  loop
    exitwhen i >= attack_length
    set unitid = attack_units[i]
    set desire = attack_qty[i]
    set g = g + desire * GetUnitGoldCost2(unitid)
    set w = w + desire * GetUnitWoodCost2(unitid)
    set i = i + 1
  endloop

  call IncreaseAIResources(g,w)

endfunction

//============================================================================
function BuildAndAttack takes player p, integer prio returns nothing
    local integer index = 0
    local integer unitid = 0
    local integer desire = 0
    local boolean group_ready = true

    call AddWaveResources()

    loop
      set index = 0
      set group_ready = true
      loop
        exitwhen index >= attack_length
        set unitid = attack_units[index]
        set desire = attack_qty[index] + campaign_defenders[unitid]
        if TownCountDone(unitid)<desire then
          set group_ready = false
          call BuildUnit(desire , unitid, prio)
        endif
        set index = index + 1
      endloop
      exitwhen group_ready
      call Sleep(5 * sleep_multiplier)
    endloop

    call FormGroupAM(5)
    call SuicidePlayer(p, true)
    loop
      exitwhen CaptainIsEmpty()
      call Sleep(5 * sleep_multiplier)
    endloop

endfunction

//============================================================================
function BuildDefendersAM takes integer prio returns nothing
  local integer index = 0
  local integer unitid = 0
  local integer qty = 0
  loop
    exitwhen index >= defense_length

    set unitid = defense_units[index]
    set qty = defense_qty[index]

    call BuildUnit(qty, unitid, prio)
    call ConversionsAM(qty,unitid)
    call AddDefenders(qty,old_id[unitid])
    set campaign_defenders[unitid] = qty

    set index = index + 1
  endloop
endfunction



//_________________________________________________________________________________________________________________________________________________
//_________________________________________________________________________________________________________________________________________________

//============================================================================
// Standard common.ai V1.18 by Blizzard Entertainment (Implementation by Strategy Master)
//============================================================================

//============================================================================
function InitAI takes nothing returns nothing
  set ai_player = Player(GetAiPlayer())
  set sleep_seconds = 0
  call InitAiUnits()
  call InitArrays()
  call StopGathering()
endfunction

//============================================================================
function StandardAI takes code heroes, code peons, code attacks returns nothing

    local boolean isNewbie = (MeleeDifficulty() == MELEE_NEWBIE)

    call InitAI()

    call SetMeleeAI()

    call SetDefendPlayer(true)
    call SetGroupsFlee(not isNewbie)
    call SetHeroesBuyItems(not isNewbie)
    call SetHeroesFlee(true)
    call SetHeroesTakeItems(true)
    call SetIgnoreInjured(true)
    call SetPeonsRepair(true)
    call SetSmartArtillery(not isNewbie)
    call SetTargetHeroes(not isNewbie)
    call SetUnitsFlee(not isNewbie)
    call SetWatchMegaTargets(true)

    call CreateCaptains()

    call SetHeroLevels(heroes)

    call Sleep(0.1)
    call StartThread(peons)
    call StartThread(attacks)
endfunction

//============================================================================
//  Utility Functions
//============================================================================

function SetZepNextWave takes nothing returns nothing
    set zep_next_wave = true
endfunction

function SuicideSleep takes integer seconds returns nothing
    set sleep_seconds = sleep_seconds - seconds
    loop
        exitwhen seconds <= 0
        exitwhen allow_signal_abort and CommandsWaiting() != 0

        if seconds >= 5 then
            call Sleep(5)
            set seconds = seconds - 5
        else
            call Sleep(seconds)
            set seconds = 0
        endif
    endloop
endfunction

//============================================================================
function WaitForSignal takes nothing returns integer
    local integer cmd
    local boolean display = false //xxx
    loop
        exitwhen CommandsWaiting() != 0

        //xxx
        call Trace("waiting for a signal to begin AI script...\n")
        set display = true
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        //xxx

    endloop

    //xxx
    if display then
        call Trace("signal received, beginning AI script\n")
    endif
    //xxx

    set cmd = GetLastCommand()
    call PopLastCommand()
    return cmd
endfunction

//============================================================================
function SetWoodPeons takes integer count returns nothing
    set campaign_wood_peons = count
endfunction

//============================================================================
function SetGoldPeons takes integer count returns nothing
    set campaign_gold_peons = count
endfunction

//============================================================================
function SetHarvestLumber takes boolean harvest returns nothing
    if harvest then
        set campaign_wood_peons = 3
    else
        set campaign_wood_peons = 0
    endif
endfunction

//============================================================================
function SetFormGroupTimeouts takes boolean state returns nothing
    set form_group_timeouts = state
endfunction

//============================================================================
function DoCampaignFarms takes boolean state returns nothing
    set do_campaign_farms = state
endfunction

//============================================================================
function GetMinorCreep takes nothing returns unit
    return GetCreepCamp(0,9,false)
endfunction

//============================================================================
function GetMajorCreep takes nothing returns unit
    return GetCreepCamp(10,100,allow_air_creeps)
endfunction

//============================================================================
function InitBuildArray takes nothing returns nothing
    set build_length = 0
endfunction

//============================================================================
function InitMeleeGroup takes nothing returns nothing
    call InitAssaultGroup()
    call RemoveInjuries()
    call RemoveSiege()
endfunction

//============================================================================
function PrepFullSuicide takes nothing returns nothing
    call InitAssaultGroup()
    call InitDefenseGroup()
    set campaign_gold_peons = 0
    set campaign_wood_peons = 0
endfunction

//============================================================================
function SetReplacements takes integer easy, integer med, integer hard returns nothing
    if difficulty == EASY then
        call SetReplacementCount(easy)
    elseif difficulty == NORMAL then
        call SetReplacementCount(med)
    else
        call SetReplacementCount(hard)
    endif
endfunction

//============================================================================
function StartTownBuilder takes code func returns nothing
    call StartThread(func)
endfunction

//============================================================================
function SetBuildAll takes integer t, integer qty, integer unitid, integer town returns nothing
    if qty > 0 then
        set build_qty[build_length] = qty
        set build_type[build_length] = t
        set build_item[build_length] = unitid
        set build_town[build_length] = town
        set build_length = build_length + 1
    endif
endfunction

//============================================================================
function SetBuildUnit takes integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_UNIT,qty,unitid,-1)
endfunction

//============================================================================
function SetBuildNext takes integer qty, integer unitid returns nothing
    local integer has = GetUnitCount(unitid)
    if has >= qty then
        return
    endif
    call SetBuildAll(BUILD_UNIT,GetUnitCountDone(unitid)+1,unitid,-1)
endfunction

//============================================================================
function SetBuildUnitEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call SetBuildAll(BUILD_UNIT,easy,unitid,-1)
    elseif difficulty == NORMAL then
        call SetBuildAll(BUILD_UNIT,med,unitid,-1)
    else
        call SetBuildAll(BUILD_UNIT,hard,unitid,-1)
    endif
endfunction

//============================================================================
function SecondaryTown takes integer town, integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_UNIT,qty,unitid,town)
endfunction

//============================================================================
function SecTown takes integer town, integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_UNIT,qty,unitid,town)
endfunction

//============================================================================
function SetBuildUpgr takes integer qty, integer unitid returns nothing
    if MeleeDifficulty() != MELEE_NEWBIE or qty == 1 then
        call SetBuildAll(BUILD_UPGRADE,qty,unitid,-1)
    endif
endfunction

//============================================================================
function SetBuildUpgrEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call SetBuildAll(BUILD_UPGRADE,easy,unitid,-1)
    elseif difficulty == NORMAL then
        call SetBuildAll(BUILD_UPGRADE,med,unitid,-1)
    else
        call SetBuildAll(BUILD_UPGRADE,hard,unitid,-1)
    endif
endfunction

//============================================================================
function SetBuildExpa takes integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_EXPAND,qty,unitid,-1)
endfunction

//============================================================================
function StartUpgrade takes integer level, integer upgid returns boolean
    local integer gold_cost
    local integer wood_cost

    if GetUpgradeLevel(upgid) >= level then
        return true
    endif

    set gold_cost = GetUpgradeGoldCost(upgid)
    if total_gold < gold_cost then
        return false
    endif

    set wood_cost = GetUpgradeWoodCost(upgid)
    if total_wood < wood_cost then
        return false
    endif

    return SetUpgrade(upgid)
endfunction

//============================================================================
function BuildFactory takes integer unitid returns nothing
    if GetGold() > 1000 and GetWood() > 500 then
        call SetBuildUnit( 2, unitid )
    else
        call SetBuildUnit( 1, unitid )
    endif
endfunction

//============================================================================
function GuardSecondary takes integer townid, integer qty, integer unitid returns nothing
    if TownHasHall(townid) and TownHasMine(townid) then
        call SecondaryTown( townid, qty, unitid )
    endif
endfunction

//============================================================================
function BasicExpansion takes boolean build_it, integer unitid returns nothing
    if build_it and HallsCompleted(unitid) then
        call SetBuildExpa( TownCount(unitid)+1, unitid )
    endif
endfunction

//============================================================================
function UpgradeAll takes integer baseid, integer newid returns nothing
    call SetBuildUnit( TownCountDone(baseid), newid )
endfunction

//============================================================================
//  FoodPool
//============================================================================
function FoodPool takes integer food, boolean weak, integer id1, integer use1, boolean strong, integer id2, integer use2 returns nothing
    if strong then
        call SetBuildUnit( (food - use1 * TownCount(id1)) / use2, id2 )
    elseif weak then
        call SetBuildUnit( (food - use2 * TownCount(id2)) / use1, id1 )
    endif
endfunction

//============================================================================
//  MeleeTownHall
//============================================================================
function MeleeTownHall takes integer townid, integer unitid returns nothing
    if TownHasMine(townid) and not TownHasHall(townid) then
        call SecondaryTown ( townid, 1, unitid )
    endif
endfunction

//============================================================================
function WaitForUnits takes integer unitid, integer qty returns nothing
    loop
        exitwhen TownCountDone(unitid) == qty
        call Sleep(2)
    endloop
endfunction

//============================================================================
function StartUnit takes integer ask_qty, integer unitid, integer town returns boolean
    local integer have_qty
    local integer need_qty
    local integer afford_gold
    local integer afford_wood
    local integer afford_qty
    local integer gold_cost
    local integer wood_cost

    //------------------------------------------------------------------------
    // if we have all we're asking for then make nothing
    //
    if town == -1 then
        set have_qty = TownCount(unitid)
    else
        set have_qty = TownCountTown(unitid,town)
    endif

    if have_qty >= ask_qty then
        return true
    endif
    set need_qty = ask_qty - have_qty

    //------------------------------------------------------------------------
    // limit the qty we're requesting to the amount of resources available
    //
    set gold_cost = GetUnitGoldCost(unitid)
    set wood_cost = GetUnitWoodCost(unitid)

    if gold_cost == 0 then
        set afford_gold = need_qty
    else
        set afford_gold = total_gold / gold_cost
    endif
    if afford_gold < need_qty then
        set afford_qty = afford_gold
    else
        set afford_qty = need_qty
    endif

    if wood_cost == 0 then
        set afford_wood = need_qty
    else
        set afford_wood = total_wood / wood_cost
    endif
    if afford_wood < afford_qty then
        set afford_qty = afford_wood
    endif

    // if we're waiting on gold/wood; pause build orders
    if afford_qty < 1 then
        return false
    endif

    //------------------------------------------------------------------------
    // whether we make right now what we're requesting or not, assume we will
    // and deduct the cost of the units from our fake gold total right away
    //
    set total_gold = total_gold - gold_cost * need_qty
    set total_wood = total_wood - wood_cost * need_qty

    if total_gold < 0 then
        set total_gold = 0
    endif
    if total_wood < 0 then
        set total_wood = 0
    endif

    //------------------------------------------------------------------------
    // give the AI a chance to make the units (it may not be able to right now
    // but that doesn't stop us from trying other units after this as long
    // as we have enough money to make this AND the needed, unbuilt ones)
    //
    return SetProduce(afford_qty,unitid,town)
endfunction

//============================================================================
function WaitForTown takes integer towns, integer townid returns nothing
    local integer i = 0
    loop
        call Sleep(10)
        exitwhen TownCount(townid) >= towns
        set i = i + 1
        exitwhen i == PLAYERAGGRESSIVE
    endloop
endfunction

//============================================================================
function StartExpansion takes integer qty, integer hall returns boolean
    local integer count
    local integer town
    local unit    peon = null
    local integer gold_cost
    local boolean b = true

    set count = TownCount(hall)
    if count >= qty then
        return true
    endif

    set town = GetNextExpansion()
    if town == -1 then
        return true
    endif

    set take_exp = true

    set gold_cost = GetUnitGoldCost(hall)
    if gold_cost > total_gold then
        return false
    endif
    set total_gold = total_gold - gold_cost

    if GetExpansionFoe() != null then
        return true
    endif

    set peon = GetExpansionPeon()
    if peon == null then
      set peon = GetExpansionPeon2(peon)
    endif
    if peon != null then
      set b = SetExpansion(peon,hall)
      set peon = null
      return b
    endif
    return true
endfunction

//============================================================================
function OneBuildLoop takes nothing returns nothing
    local integer index = 0
    local integer qty
    local integer id
    local integer tp

    set total_gold = GetGold() - gold_buffer
    set total_wood = GetWood()

    loop
        exitwhen index == build_length

        set qty = build_qty [index]
        set id  = build_item[index]
        set tp  = build_type[index]

        //--------------------------------------------------------------------
        if tp == BUILD_UNIT then
            if not StartUnit(qty,id,build_town[index]) then
                return
            endif

        //--------------------------------------------------------------------
        elseif tp == BUILD_UPGRADE then
            call StartUpgrade(qty,id)

        //--------------------------------------------------------------------
        else // tp == BUILD_EXPAND
            if not StartExpansion(qty,id) then
                return
            endif
        endif

        set index = index + 1
    endloop
endfunction

//============================================================================
function BuildLoop takes nothing returns nothing
    call OneBuildLoop()
    call StaggerSleep(1,2)
    loop
        call OneBuildLoop()
        call Sleep(2)
    endloop
endfunction

//============================================================================
function StartBuildLoop takes nothing returns nothing
    call StartThread(function BuildLoop)
endfunction

//============================================================================
function SetInitialWave takes integer seconds returns nothing
    set sleep_seconds = seconds
endfunction

//============================================================================
function AddSleepSeconds takes integer seconds returns nothing
    set sleep_seconds = sleep_seconds + seconds
endfunction

//============================================================================
function SleepForever takes nothing returns nothing
    call Trace("going to sleep forever\n") //xxx
    loop
        call Sleep(100)
    endloop
endfunction

//============================================================================
function PlayGame takes nothing returns nothing
    call StartBuildLoop()
    call SleepForever()
endfunction

//============================================================================
function ConvertNeeds takes integer unitid returns nothing
    if GetUnitCount(unitid) < 1 then
        call StartUnit(1,unitid,-1)
    endif
endfunction

//============================================================================
function Conversions takes integer desire, integer unitid returns nothing

  if GetUnitCount(unitid) >= desire then
    return
  endif

  #INCLUDETABLE <$VER$\UnitConversions.txt> #EFR
  if unitid == %1 then
    call ConvertNeeds(%2)
    call ConvertNeeds(%3)
    call MergeUnits(desire,%2,%3,%1)
  endif
  #ENDINCLUDE

  #INCLUDETABLE <$VER$\UnitEquivalence.txt> #EFR #COND "%2" eq "BUILT_FROM"
  if unitid == %1 then
    call ConvertNeeds(%3)
    call ConvertUnits(desire, %3)
  endif
  #ENDINCLUDE

endfunction

//============================================================================
function SetAssaultGroup takes integer qty, integer max, integer unitid returns nothing
    call Conversions(max,unitid)

    if qty <= 0 and TownCountDone(unitid) == 0 then
        return
    endif
    set harass_qty[harass_length] = qty
    set harass_max[harass_length] = max
    set harass_units[harass_length] = unitid
    set harass_length = harass_length + 1
endfunction

//============================================================================
function Interleave3 takes integer e1, integer m1, integer h1, integer u1, integer e2, integer m2, integer h2, integer u2, integer e3, integer m3, integer h3, integer u3 returns nothing
    local integer i1 = 1
    local integer i2 = 1
    local integer i3 = 1
    local integer q1
    local integer q2
    local integer q3

    if difficulty == EASY then
        set q1 = e1
        set q2 = e2
        set q3 = e3
    elseif difficulty == NORMAL then
        set q1 = m1
        set q2 = m2
        set q3 = m3
    else // difficulty == HARD
        set q1 = h1
        set q2 = h2
        set q3 = h3
    endif

    loop
        exitwhen q1<=0 and q2<=0 and q3<=0

        if q1 > 0 then
            call SetAssaultGroup(i1,i1,u1)
            set q1 = q1 - 1
            set i1 = i1 + 1
        endif

        if q2 > 0 then
            call SetAssaultGroup(i2,i2,u2)
            set q2 = q2 - 1
            set i2 = i2 + 1
        endif

        if q3 > 0 then
            call SetAssaultGroup(i3,i3,u3)
            set q3 = q3 - 1
            set i3 = i3 + 1
        endif
    endloop
endfunction

//============================================================================
function SetMeleeGroup takes integer unitid returns nothing
    if unitid == hero_id then
        call SetAssaultGroup(1,9,unitid)
    else
        call SetAssaultGroup((TownCountDone(unitid)*3)/4,20,unitid)
    endif
endfunction

//============================================================================
function CampaignDefender takes integer level, integer qty, integer unitid returns nothing
    if qty > 0 and difficulty >= level then
        set defense_qty[defense_length] = qty
        set defense_units[defense_length] = unitid
        set defense_length = defense_length + 1
        call Conversions(qty,unitid)
        call SetBuildUnit(qty,unitid)
    endif
endfunction

//============================================================================
function CampaignDefenderEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call CampaignDefender(EASY,easy,unitid)
    elseif difficulty == NORMAL then
        call CampaignDefender(NORMAL,med,unitid)
    else
        call CampaignDefender(HARD,hard,unitid)
    endif
endfunction

//============================================================================
function CampaignAttacker takes integer level, integer qty, integer unitid returns nothing
    if qty > 0 and difficulty >= level then 
        call SetAssaultGroup(qty,qty,unitid)
    endif
endfunction

//============================================================================
function CampaignAttackerEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call CampaignAttacker(EASY,easy,unitid)
    elseif difficulty == NORMAL then
        call CampaignAttacker(NORMAL,med,unitid)
    else
        call CampaignAttacker(HARD,hard,unitid)
    endif
endfunction

//============================================================================
function FormGroup takes integer seconds, boolean testReady returns nothing
    local integer index
    local integer count
    local integer unitid
    local integer desire
    local integer readyPercent

    // normally test for CaptainReadiness() of 50%
    if testReady == true then
        set readyPercent = 50
        call Trace("forming group, requiring healthy guys\n") //xxx
    else
        set readyPercent = 0
        call Trace("forming group, unit health not important\n") //xxx
    endif

    call Trace("trying to gather forces\n") //xxx

    loop
        call SuicideSleep(seconds)
        call InitAssault()

        set index = 0
        loop
            exitwhen index == harass_length

            set unitid = harass_units[index]
            set desire = harass_max[index]
            set count  = TownCountDone(unitid)

            call Conversions(desire,unitid)

            if count >= desire then
                call AddAssault(desire,unitid)
            else
                set desire = harass_qty[index]

                if count < desire then
                    call AddAssault(desire,unitid)
                else
                    call AddAssault(count,unitid)
                endif
            endif

            set index = index + 1
        endloop

        //xxx
        if form_group_timeouts and (sleep_seconds < -60) then
            call Trace("exit form group -- timeout\n")
        elseif CaptainInCombat(true) then
            call Trace("exit form group -- can't form while already in combat\n")
        elseif CaptainIsFull() and CaptainReadiness() >= readyPercent then
            call Trace("exit form group -- ready\n")
        endif
        //xxx

        // time out and send group anyway if time has already expired
        exitwhen form_group_timeouts and (sleep_seconds < -60)
        exitwhen CaptainInCombat(true)
        exitwhen CaptainIsFull() and CaptainReadiness() >= readyPercent
    endloop
endfunction

//============================================================================
function WavePrepare takes integer unitid returns integer
    return GetUnitBuildTime(unitid)
endfunction

//============================================================================
function PrepTime takes nothing returns integer
    local integer unitid
    local integer missing
    local integer prep
    local integer count
    local integer largest = 30
    local integer index = 0

    loop
        exitwhen index == harass_length

        set unitid  = harass_units[index]
        set missing = harass_qty[index] + IgnoredUnits(old_id[unitid]) - TownCount(unitid)
        set prep    = WavePrepare(unitid) * missing

        if prep > largest then
            set largest = prep
        endif

        set index = index + 1
    endloop
    call TraceI("next wave will require around %d seconds to build and gather\n",largest) //xxx

    return largest
endfunction

//============================================================================
function PrepSuicideOnPlayer takes integer seconds returns boolean
    local integer wave_prep   = PrepTime()
    local integer save_length

    set save_length = harass_length
    set harass_length = 0

    call AddSleepSeconds(seconds)
    if sleep_seconds-wave_prep > 0 then
        call TraceI("going to sleep for %d seconds before gathering next attack wave\n",sleep_seconds-wave_prep) //xxx
        call SuicideSleep(sleep_seconds-wave_prep)
    endif

    call Trace("preparing suicide attack wave\n") //xxx

    set harass_length = save_length
    if harass_length < 1 then
        call Trace("ERROR - no units specificed, exiting early\n") //xxx
        return false
    endif

    return true
endfunction

//============================================================================
function SleepUntilAtGoal takes nothing returns nothing
    loop
        exitwhen CaptainRetreating()
        exitwhen CaptainAtGoal()        // reached goal
        exitwhen CaptainIsHome()        // failed to path and returned home
        exitwhen CaptainIsEmpty()       // all units died
        call SuicideSleep(3)
    endloop
endfunction

//============================================================================
function SleepInCombat takes nothing returns nothing
    local integer count = 0
    debug call Trace("SleepInCombat\n")
    loop
        loop
            exitwhen not CaptainInCombat(true)  // goal is cleared
            exitwhen CaptainIsEmpty()           // duh
            call SuicideSleep(1)
        endloop

        set count = count + 1
        exitwhen count >= 8

        //xxx this is what it should have been; do this for next patch?
        //call SuicideSleep(1)
    endloop
    debug call Trace("exit SleepInCombat\n")
endfunction

//============================================================================
function AttackMoveXYA takes integer x, integer y returns nothing

    if zep_next_wave then
        call LoadZepWave(x,y)
        set zep_next_wave = false
    endif

    call AttackMoveXY(x,y)
    call SleepUntilAtGoal()
    call SleepInCombat()
endfunction

//============================================================================
function SuicideOnPlayerWave takes nothing returns nothing
    call Trace("waiting for attack wave to enter combat\n") //xxx
    loop
        //xxx
        if allow_signal_abort and CommandsWaiting() != 0 then
            call Trace("ABORT -- attack wave override\n")
        endif

        if CaptainInCombat(true) then
            call Trace("done - captain has entered combat\n")
        endif

        if CaptainIsEmpty() then
            call Trace("done - all units are dead\n")
        endif

        if sleep_seconds < -300 then
            call Trace("done - timeout, took too long to reach engage the enemy\n")
        endif
        //xxx

        exitwhen allow_signal_abort and CommandsWaiting() != 0

        exitwhen CaptainInCombat(true)
        exitwhen CaptainIsEmpty()
        call SuicideSleep(10)
        exitwhen sleep_seconds < -300
    endloop

    call Trace("waiting for attack wave to die\n") //xxx
    loop
        //xxx
        if allow_signal_abort and CommandsWaiting() != 0 then
            call Trace("ABORT - attack wave override\n")
        endif

        if CaptainIsEmpty() then
            call Trace("done - all units are dead\n")
        endif

        if sleep_seconds < -300 then
            call Trace("done - timeout, took too long to reach engage the enemy\n")
        endif
        //xxx

        exitwhen allow_signal_abort and CommandsWaiting() != 0

        exitwhen CaptainIsEmpty()
        call SuicideSleep(10)
        exitwhen sleep_seconds < -300
    endloop
endfunction

//--------------------------------------------------------------------------------------------------
function CommonSuicideOnPlayer takes boolean standard, boolean bldgs, integer seconds, player p, integer x, integer y returns nothing
    local integer save_peons

    if not PrepSuicideOnPlayer(seconds) then
        return
    endif

    set save_peons = campaign_wood_peons
    set campaign_wood_peons = 0

    loop
        //xxx
        if allow_signal_abort and CommandsWaiting() != 0 then
            call Trace("ABORT -- attack wave override\n")
        endif
        //xxx

        exitwhen allow_signal_abort and CommandsWaiting() != 0

        loop
            exitwhen allow_signal_abort and CommandsWaiting() != 0

            call FormGroup(5,true)
            exitwhen sleep_seconds <= 0
            call TraceI("waiting %d seconds before suicide\n",sleep_seconds) //xxx
        endloop

        if standard then
            if bldgs then
                exitwhen SuicidePlayer(p,sleep_seconds >= -60)
            else
                exitwhen SuicidePlayerUnits(p,sleep_seconds >= -60)
            endif
        else
            call AttackMoveXYA(x,y)
        endif

        call TraceI("waiting %d seconds before timeout\n",60+sleep_seconds) //xxx
        call SuicideSleep(5)
    endloop

    set campaign_wood_peons = save_peons
    set harass_length = 0

    call SuicideOnPlayerWave()
endfunction

//--------------------------------------------------------------------------------------------------
function SuicideOnPlayer takes integer seconds, player p returns nothing
    call CommonSuicideOnPlayer(true,true,seconds,p,0,0)
endfunction

//--------------------------------------------------------------------------------------------------
function SuicideOnUnits takes integer seconds, player p returns nothing
    call CommonSuicideOnPlayer(true,false,seconds,p,0,0)
endfunction

//--------------------------------------------------------------------------------------------------
function SuicideOnPoint takes integer seconds, player p, integer x, integer y returns nothing
    call CommonSuicideOnPlayer(false,false,seconds,p,x,y)
endfunction

//============================================================================
function SuicideUntilSignal takes integer seconds, player p returns nothing
    local integer save
    local integer wave_prep = PrepTime()

    loop
        call AddSleepSeconds(seconds)
        if sleep_seconds-wave_prep > 0 then
            call SuicideSleep(sleep_seconds-wave_prep)
        endif

        set save = campaign_wood_peons
        set campaign_wood_peons = 0
        loop
            loop
                call FormGroup(5, true)
                exitwhen sleep_seconds <= 0
                exitwhen CommandsWaiting() != 0
            endloop
            exitwhen SuicidePlayer(p,sleep_seconds >= -60)
            exitwhen CommandsWaiting() != 0
            call SuicideSleep(3)
        endloop
        set campaign_wood_peons = save

        loop
            exitwhen CaptainIsEmpty()
            exitwhen CommandsWaiting() != 0
            call SuicideSleep(5)
        endloop
        exitwhen CommandsWaiting() != 0
    endloop
endfunction

//--------------------------------------------------------------------------------------------------
function SuicideOnce takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call SuicideUnit(easy,unitid)
    elseif difficulty == NORMAL then
        call SuicideUnit(med,unitid)
    else
        call SuicideUnit(hard,unitid)
    endif
endfunction

//--------------------------------------------------------------------------------------------------
function SuicideUnitA takes integer unitid returns nothing
    if unitid != 0 then
        call SuicideUnit(1,unitid)
    endif
    call Sleep(0.1)
endfunction

//--------------------------------------------------------------------------------------------------
function SuicideUnitB takes integer unitid, integer playerid returns nothing
    if unitid != 0 then
        call SuicideUnitEx(1,unitid,playerid)
    endif
    call Sleep(0.1)
endfunction

//--------------------------------------------------------------------------------------------------
function SuicideUnits takes integer u1, integer u2, integer u3, integer u4, integer u5, integer u6, integer u7, integer u8, integer u9, integer uA returns nothing
    call Trace("MASS SUICIDE - this script is now technically done\n") //xxx

    call PrepFullSuicide()
    loop
        call SuicideUnitA(u1)
        call SuicideUnitA(u2)
        call SuicideUnitA(u3)
        call SuicideUnitA(u4)
        call SuicideUnitA(u5)
        call SuicideUnitA(u6)
        call SuicideUnitA(u7)
        call SuicideUnitA(u8)
        call SuicideUnitA(u9)
        call SuicideUnitA(uA)
    endloop
endfunction

//--------------------------------------------------------------------------------------------------
function SuicideUnitsEx takes integer playerid, integer u1, integer u2, integer u3, integer u4, integer u5, integer u6, integer u7, integer u8, integer u9, integer uA returns nothing
    call Trace("MASS SUICIDE - this script is now technically done\n") //xxx

    call PrepFullSuicide()
    loop
        call SuicideUnitB(u1,playerid)
        call SuicideUnitB(u2,playerid)
        call SuicideUnitB(u3,playerid)
        call SuicideUnitB(u4,playerid)
        call SuicideUnitB(u5,playerid)
        call SuicideUnitB(u6,playerid)
        call SuicideUnitB(u7,playerid)
        call SuicideUnitB(u8,playerid)
        call SuicideUnitB(u9,playerid)
        call SuicideUnitB(uA,playerid)
    endloop
endfunction

//--------------------------------------------------------------------------------------------------
function SuicideOnPlayerEx takes integer easy, integer med, integer hard, player p returns nothing
    if difficulty == EASY then
        call SuicideOnPlayer(easy,p)
    elseif difficulty == NORMAL then
        call SuicideOnPlayer(med,p)
    else
        call SuicideOnPlayer(hard,p)
    endif
endfunction

//--------------------------------------------------------------------------------------------------
function SuicideOnUnitsEx takes integer easy, integer med, integer hard, player p returns nothing
    if difficulty == EASY then
        call SuicideOnUnits(easy,p)
    elseif difficulty == NORMAL then
        call SuicideOnUnits(med,p)
    else
        call SuicideOnUnits(hard,p)
    endif
endfunction

//--------------------------------------------------------------------------------------------------
function SuicideOnPointEx takes integer easy, integer med, integer hard, player p, integer x, integer y returns nothing
    if difficulty == EASY then
        call SuicideOnPoint(easy,p,x,y)
    elseif difficulty == NORMAL then
        call SuicideOnPoint(med,p,x,y)
    else
        call SuicideOnPoint(hard,p,x,y)
    endif
endfunction

//============================================================================
function ForeverSuicideOnPlayer takes integer seconds, player p returns nothing
    local integer length = harass_length
    loop
        exitwhen allow_signal_abort and CommandsWaiting() != 0
        call SuicideOnPlayer(seconds,p)
        set harass_length = length
    endloop
endfunction

//============================================================================
function CommonSleepUntilTargetDead takes unit target, boolean reform returns nothing
    loop
        exitwhen CaptainRetreating()
        exitwhen CaptainReadinessHP() <= 40

        exitwhen not UnitAlive(target)
        exitwhen UnitInvis(target) and not IsUnitDetected(target,ai_player)

        if not TownThreatened() then
            call AttackMoveKill(target)
        endif

        call SuicideSleep(3)

        if reform and sleep_seconds < -40 then
            if CaptainInCombat(true) then
                set sleep_seconds = sleep_seconds + 5
            else
                set sleep_seconds = 0
                call FormGroup(1,false)
            endif
        endif
    endloop
endfunction

//============================================================================
function SleepUntilTargetDead takes unit target returns nothing
    call CommonSleepUntilTargetDead(target,false)
endfunction

//============================================================================
function ReformUntilTargetDead takes unit target returns nothing
    debug call Trace("ReformUntilTargetDead\n")
    call CommonSleepUntilTargetDead(target,true)
endfunction

//============================================================================
function AttackMoveKillA takes unit target returns nothing
    if target == null then
        call SuicideSleep(3)
        return
    endif

    debug call Trace("AttackMoveKillA\n")
    call AttackMoveKill(target)
    call ReformUntilTargetDead(target)
    call SleepInCombat()
endfunction

//============================================================================
function MinorCreepAttack takes nothing returns nothing
    local unit target = GetMinorCreep()
    call SetAllianceTarget(target)
    call FormGroup(3, true)
    call AttackMoveKillA(target)
    set target = null
endfunction

//============================================================================
function MajorCreepAttack takes nothing returns nothing
    local unit target = GetMajorCreep()
    call SetAllianceTarget(target)
    call FormGroup(3,true)
    call AttackMoveKillA(target)
    set target = null
endfunction

//============================================================================
function CreepAttackEx takes nothing returns nothing
    local unit target = GetCreepCamp(min_creeps,max_creeps,allow_air_creeps)
    call SetAllianceTarget(target)
    call FormGroup(3,true)
    call AttackMoveKillA(target)
    set target = null
endfunction

//============================================================================
function AnyPlayerAttack takes nothing returns nothing
  local unit hall = GetEnemyExpansion()

  if hall == null then
    call StartGetEnemyBase()
    loop
      exitwhen not WaitGetEnemyBase()
      call SuicideSleep(1)
    endloop
    set hall = GetEnemyBase()
  endif

  call SetAllianceTarget(hall)
  call FormGroup(3,true)
  call AttackMoveKillA(hall)
  set hall = null
endfunction

//============================================================================
function ExpansionAttack takes nothing returns nothing
    local unit creep = GetExpansionFoe()
    local integer x

    call FormGroup(3, true)
    if creep == null then
        set x = GetExpansionX()
        if x != -1 then
            call AttackMoveXYA(x,GetExpansionY())
        endif
    else
        call AttackMoveKillA(creep)
    endif
    set creep = null
endfunction

//============================================================================
//  AddSiege
//============================================================================
function AddSiege takes nothing returns nothing

  #INCLUDETABLE <$VER$\StandardUnits.txt> #EFR #COND "%4" =~ /\bsiege\b/
    call SetAssaultGroup( 0, 9, %1 )
  #ENDINCLUDE

endfunction

//===========================================================================
//  GetAllyCount
//============================================================================
function GetAllyCount takes player whichPlayer returns integer
    local integer    playerIndex = 0
    local integer    count = 0
    local player     indexPlayer

    loop
        set indexPlayer = Player(playerIndex)
        if whichPlayer != indexPlayer then
            if GetPlayerAlliance(whichPlayer,indexPlayer,ALLIANCE_PASSIVE) then
                if GetPlayerAlliance(indexPlayer,whichPlayer,ALLIANCE_PASSIVE) then
                    if GetPlayerStructureCount(indexPlayer,true) > 0 then
                        set count = count + 1
                    endif
                endif
            endif
        endif
        set playerIndex = playerIndex + 1
        exitwhen playerIndex == PLAYERAGGRESSIVE
    endloop
    set indexPlayer = null
    return count
endfunction

//============================================================================
//  SingleMeleeAttack
//============================================================================
function SingleMeleeAttack takes boolean needs_exp, boolean has_siege, boolean major_ok, boolean air_units returns nothing
    local boolean   can_siege
    local real      daytime 
    local unit      hall
    local unit      mega
    local unit      creep
    local unit      common
    local integer   minexp
    local boolean   allies

    call Trace("===SingleMeleeAttack===\n") //xxx

    if TownThreatened() then
        call Trace("sleep 2, town threatened\n") //xxx
        call Sleep(2)
        return
    endif

    // purchase zeppelins
    //
    if get_zeppelin and GetGold() > 300 and GetWood() > 100 then
        call Trace("purchase zep\n") //xxx
        call PurchaseZeppelin()
        set get_zeppelin = false
        set ready_for_zeppelin = false
        return
    endif
    set ready_for_zeppelin = true

    // coordinate with allies
    //
    set allies = GetAllyCount(ai_player) > 0
    if allies and MeleeDifficulty() != MELEE_NEWBIE then
        set common = GetAllianceTarget()
        if common != null then
            call Trace("join ally force\n") //xxx
            if GetMegaTarget() != null then
                call AddSiege()
            endif
            call FormGroup(3,true)
            call AttackMoveKillA(common)
            call SetAllianceTarget(null)
            set common = null
            return
        endif
    endif

    // take expansions as needed
    //
    if needs_exp then
        call Trace("needs exp\n") //xxx
        set creep = GetExpansionFoe()
        if creep != null then
            call Trace("attack exp\n") //xxx
            call SetAllianceTarget(creep)
            call FormGroup(3,true)
            call AttackMoveKillA(creep)
            call Sleep(20)
            set take_exp = false
            set creep = null
            return
        endif
    endif

    // all-out attack if the player is weak
    //
    if MeleeDifficulty() != MELEE_NEWBIE then
        set mega = GetMegaTarget()
        if mega != null then
            call Trace("MEGA TARGET!!!\n") //xxx
            call AddSiege()
            call FormGroup(3,true)
            call AttackMoveKillA(mega)
            set mega = null
            return
        endif
    endif

    // deny player an expansion
    //
    set hall = GetEnemyExpansion()
    set daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
    set can_siege = has_siege and (air_units or (daytime>=4 and daytime<=12))

    if hall!=null and (can_siege or not IsTowered(hall)) then

        call Trace("test player town attack\n") //xxx

        if MeleeDifficulty() == MELEE_NEWBIE then
            set minexp = 3
        elseif allies and MeleeDifficulty() == MELEE_NORMAL then
            set minexp = 1
        else
            set minexp = 0 // HARD, INSANE, and NORMAL with no allies
        endif

        if exp_seen >= minexp then
            call Trace("do player town attack\n") //xxx
            set exp_seen = 0
            call AddSiege()
            call SetAllianceTarget(hall)
            call FormGroup(3,true)
            call AttackMoveKillA(hall)
            set hall = null
            return
        endif
        set hall = null
        set exp_seen = exp_seen + 1
    endif

    // attack player's main base when siege is available
    //
    if can_siege then
        call Trace("attack player's town\n") //xxx
        call AddSiege()
        call AnyPlayerAttack()
        return
    endif

    // extended, more specific method of determining creep levels
    //
    if min_creeps != -1 then
        call TraceI("custom creep attack %d\n",max_creeps) //xxx
        call CreepAttackEx()
        return
    endif

    // nothing better to do, so kill a creep camp
    //
    if major_ok then
        call Trace("major creep attack\n") //xxx
        call MajorCreepAttack()
        return
    endif

    call Trace("minor creep attack\n") //xxx
    call MinorCreepAttack()
endfunction

//============================================================================
function GetZeppelin takes nothing returns nothing
    if ready_for_zeppelin then
        set get_zeppelin = true
    endif
endfunction

//============================================================================
function BuildAttackers takes nothing returns nothing
    local integer index = 0
    local integer unitid
    local integer desire
    local integer count

    loop
        exitwhen index == harass_length

        set unitid = harass_units[index]
        set desire = harass_qty[index] + IgnoredUnits(unitid)
        set count  = TownCount(unitid)

        if count != desire then
            if not StartUnit(desire,unitid,-1) then
                return
            endif
        endif

        set index = index + 1
    endloop
endfunction

//============================================================================
function BuildDefenders takes nothing returns nothing
    local integer index = 0
    local integer unitid
    local integer qty
    loop
        exitwhen index == defense_length

        set unitid = defense_units[index]
        set qty = defense_qty[index]

        call Conversions(qty,unitid)
        call AddDefenders(qty,unitid)

        set index = index + 1
    endloop
endfunction

//============================================================================
function CampaignBasicsA takes nothing returns nothing
    local integer food_each = GetFoodMade(racial_farm)
    local integer on_wood

    call ClearHarvestAI()

    if CaptainInCombat(false) then
        set on_wood = 0
    else
        set on_wood = campaign_wood_peons
    endif

    call HarvestGold(0,campaign_gold_peons)
    call HarvestWood(0,on_wood)

    if harvest_town1 then
        call HarvestGold(1,campaign_gold_peons)
        call HarvestWood(1,on_wood)
    endif

    if harvest_town2 then
        call HarvestGold(2,campaign_gold_peons)
        call HarvestWood(2,on_wood)
    endif

    if harvest_town3 then
        call HarvestGold(3,campaign_gold_peons)
        call HarvestWood(3,on_wood)
    endif

    if do_campaign_farms and FoodUsed()+food_each-1 > food_each*(TownCount(racial_farm)+1) then
        call StartUnit(TownCount(racial_farm)+1,racial_farm,-1)
    endif

    if build_campaign_attackers then
        call BuildAttackers()
    endif

    if not CaptainInCombat(false) then
        call BuildDefenders()
    endif

    call FillGuardPosts()
    call ReturnGuardPosts()
endfunction

//============================================================================
function CampaignBasics takes nothing returns nothing
    call Sleep(1)
    call CampaignBasicsA()
    call StaggerSleep(1,5)
    loop
        call CampaignBasicsA()
        call Sleep(campaign_basics_speed)
    endloop
endfunction

//============================================================================
function CampaignAI takes integer farms, code heroes returns nothing
    if GetGameDifficulty() == MAP_DIFFICULTY_EASY then
        set difficulty = EASY

        call SetTargetHeroes(false)
        call SetUnitsFlee(false)

    elseif GetGameDifficulty() == MAP_DIFFICULTY_NORMAL then
        set difficulty = NORMAL

        call SetTargetHeroes(false)
        call SetUnitsFlee(false)

    elseif GetGameDifficulty() == MAP_DIFFICULTY_HARD then
        set difficulty = HARD

        call SetPeonsRepair(true)
    else
        set difficulty = INSANE
    endif

    call InitAI()
    call InitBuildArray()
    call InitAssaultGroup()
    call CreateCaptains()

    call SetNewHeroes(false)
    if heroes != null then
        call SetHeroLevels(heroes)
    endif

    call SetHeroesFlee(false)
    call SetGroupsFlee(false)
    call SetSlowChopping(true)
    call GroupTimedLife(false)
    call SetCampaignAI()
    call Sleep(0.1)

    set racial_farm = farms
    call StartThread(function CampaignBasics)
    call StartBuildLoop()
endfunction

//============================================================================
function UnsummonAll takes nothing returns nothing
    local unit bldg
    loop
        set bldg = GetBuilding(ai_player)
        exitwhen bldg==null
        call Unsummon(bldg)
        call Sleep(2)
    endloop
endfunction

//============================================================================
//  SkillArrays
//============================================================================
function SkillArrays takes nothing returns integer
  local integer level = GetHeroLevelAI()
  if level > max_hero_level then
    set max_hero_level = level
  endif

  if skillfix == true then
    if hero_unit[1] == null then
      set hero_unit[1] = GetOneOfId(hero_unit[1], ai_player, hero_id)
    endif
    if hero_unit[2] == null then
      set hero_unit[2] = GetOneOfId(hero_unit[2], ai_player, hero_id)
    endif
    if hero_unit[3] == null then
      set hero_unit[3] = GetOneOfId(hero_unit[3], ai_player, hero_id)
    endif
    call SelectHeroSkill( hero_unit[1], skills1[level] )
    call SelectHeroSkill( hero_unit[2], skills2[level] )
    call SelectHeroSkill( hero_unit[3], skills3[level] )
    return 0
  endif

  if GetHeroId() == hero_id then
    return skills1[level]
  elseif GetHeroId() == hero_id2 then
    return skills2[level]
  else
    return skills3[level]
  endif
endfunction

//--------------------------------------------------------------------------------------------------
//  SetSkillArray
//--------------------------------------------------------------------------------------------------
function SetSkillArray takes integer index, integer id returns nothing
    local integer i = 1

    if index == 1 then
        if hero_id != id then
            return
        endif
        loop
            set skills1[i] = skill[i]
            exitwhen i == 10
            set i = i + 1
        endloop
    elseif index == 2 then
        if hero_id2 != id then
            return
        endif
        loop
            set skills2[i] = skill[i]
            exitwhen i == 10
            set i = i + 1
        endloop
    else
        if hero_id3 != id then
            return
        endif
        loop
            set skills3[i] = skill[i]
            exitwhen i == 10
            set i = i + 1
        endloop
    endif
endfunction

//============================================================================
//  AwaitMeleeHeroes
//============================================================================
function AwaitMeleeHeroes takes nothing returns nothing
    if GetUnitCountDone(hero_id2) > 0 then
        set two_heroes = true
    endif
    loop
        exitwhen GetUnitCountDone(hero_id)>0 and (take_exp or (not two_heroes or GetUnitCountDone(hero_id2)>0))
        call Sleep(1)
    endloop
endfunction

//============================================================================
//  PickMeleeHero 
//============================================================================
function PickMeleeHero takes race raceid returns integer
    local integer first
    local integer second
    local integer third
    local integer last
    local integer array heroes
    local integer i
    call GetPatchVersion()
#INCLUDETABLE <$VER$\GlobalSettings.txt> #EFR #COND '%1' eq 'ver_neutral_hero_number' 
    set %1 = %2
#ENDINCLUDE
    call InitAiUnits()  // This function makes all unit ids go back to there originals
    set i = ver_neutral_hero_number
    //------------------------------------------------------------------------
    if raceid == RACE_HUMAN then
    //------------------------------------------------------------------------

    #INCLUDETABLE <$VER$\Races.txt> #COND '%1' eq 'HUMAN'
      #INCLUDETABLE <$VER$\%1\Heroes.txt> #EFR
        set heroes[#EVAL{%row}] = %1
      #ENDINCLUDE
    #ENDINCLUDE

    //------------------------------------------------------------------------
    elseif raceid == RACE_ORC then
    //------------------------------------------------------------------------
    #INCLUDETABLE <$VER$\Races.txt> #COND '%1' eq 'ORC'
      #INCLUDETABLE <$VER$\%1\Heroes.txt> #EFR
        set heroes[#EVAL{%row}] = %1
      #ENDINCLUDE
    #ENDINCLUDE

    //------------------------------------------------------------------------
    elseif raceid == RACE_NIGHTELF then
    //------------------------------------------------------------------------
    #INCLUDETABLE <$VER$\Races.txt> #COND '%1' eq 'ELF'
      #INCLUDETABLE <$VER$\%1\Heroes.txt> #EFR
        set heroes[#EVAL{%row}] = %1
      #ENDINCLUDE
    #ENDINCLUDE

    //------------------------------------------------------------------------
    elseif raceid == RACE_UNDEAD then
    //------------------------------------------------------------------------
    #INCLUDETABLE <$VER$\Races.txt> #COND '%1' eq 'UNDEAD'
      #INCLUDETABLE <$VER$\%1\Heroes.txt> #EFR
        set heroes[#EVAL{%row}] = %1
      #ENDINCLUDE
    #ENDINCLUDE

    else
        set hero_id = 0
    endif

    //if VersionCompatible(VERSION_FROZEN_THRONE) then
        set last = race_hero_number + i
    //else
    //    set last = race_hero_number
    //endif

    set first  = GetRandomInt(i+1,last)
    set second = GetRandomInt(i+1,last-1)
    if VersionCompatible(VERSION_FROZEN_THRONE) then
      set third  = GetRandomInt(i+1,last-2)
    else
      set third = i+1
    endif
    set hero_id        = heroes[first]
    set heroes[first]  = heroes[last]
    set hero_id2       = heroes[second]
    set heroes[second] = heroes[last-1]
    set hero_id3       = heroes[third]

    return hero_id
endfunction

//function main takes nothing returns nothing

//endfunction

//library themain
//
   //! inject main
   //some function calls may go here

   // this places vjass initializations there, notice structs are first initialized then library initializers
   // are called
   //! dovjassinit
   //! endinject
//
//endlibrary