
native DebugS               takes string str                            returns nothing
native DebugFI              takes string str, integer val               returns nothing
native DebugUnitID          takes string str, integer val               returns nothing
native DisplayText          takes integer p, string str                 returns nothing
native DisplayTextI         takes integer p, string str, integer val    returns nothing
native DisplayTextII        takes integer p, string str, integer v1, integer v2 returns nothing
native DisplayTextIII       takes integer p, string str, integer v1, integer v2, integer v3 returns nothing
native DoAiScriptDebug      takes nothing                               returns boolean

native GetAiPlayer          takes nothing                               returns integer
native GetHeroId            takes nothing                               returns integer
native GetHeroLevelAI       takes nothing                               returns integer

native GetUnitCount         takes integer unitid                        returns integer
native GetPlayerUnitTypeCount takes player p, integer unitid            returns integer
native GetUnitCountDone     takes integer unitid                        returns integer
native GetTownUnitCount     takes integer id, integer tn, boolean dn    returns integer
native GetUnitGoldCost      takes integer unitid                        returns integer
native GetUnitWoodCost      takes integer unitid                        returns integer
native GetUnitBuildTime     takes integer unitid                        returns integer

native GetMinesOwned        takes nothing                               returns integer
native GetGoldOwned         takes nothing                               returns integer
native TownWithMine         takes nothing                               returns integer
native TownHasMine          takes integer townid                        returns boolean
native TownHasHall          takes integer townid                        returns boolean

native GetUpgradeLevel      takes integer id                            returns integer
native GetUpgradeGoldCost   takes integer id                            returns integer
native GetUpgradeWoodCost   takes integer id                            returns integer
native GetNextExpansion     takes nothing                               returns integer
native GetMegaTarget        takes nothing                               returns unit
native GetBuilding          takes player p                              returns unit
native GetEnemyPower        takes nothing                               returns integer
native SetAllianceTarget    takes unit id                               returns nothing
native GetAllianceTarget    takes nothing                               returns unit

native SetProduce           takes integer qty, integer id, integer town returns boolean
native Unsummon             takes unit unitid                           returns nothing
native SetExpansion         takes unit peon, integer id                 returns boolean
native SetUpgrade           takes integer id                            returns boolean
native SetHeroLevels        takes code func                             returns nothing
native SetNewHeroes         takes boolean state                         returns nothing
native PurchaseZeppelin     takes nothing                               returns nothing

native MergeUnits           takes integer qty, integer a, integer b, integer make returns boolean
native ConvertUnits         takes integer qty, integer id               returns boolean

native SetCampaignAI        takes nothing                               returns nothing
native SetMeleeAI           takes nothing                               returns nothing
native SetTargetHeroes      takes boolean state                         returns nothing
native SetPeonsRepair       takes boolean state                         returns nothing
native SetRandomPaths       takes boolean state                         returns nothing
native SetDefendPlayer      takes boolean state                         returns nothing
native SetHeroesFlee        takes boolean state                         returns nothing
native SetHeroesBuyItems    takes boolean state                         returns nothing
native SetWatchMegaTargets  takes boolean state                         returns nothing
native SetIgnoreInjured     takes boolean state                         returns nothing
native SetHeroesTakeItems   takes boolean state                         returns nothing
native SetUnitsFlee         takes boolean state                         returns nothing
native SetGroupsFlee        takes boolean state                         returns nothing
native SetSlowChopping      takes boolean state                         returns nothing
native SetCaptainChanges    takes boolean allow                         returns nothing
native SetSmartArtillery    takes boolean state                         returns nothing
native SetReplacementCount  takes integer qty                           returns nothing
native GroupTimedLife       takes boolean allow                         returns nothing
native RemoveInjuries       takes nothing                               returns nothing
native RemoveSiege          takes nothing                               returns nothing

native InitAssault          takes nothing                               returns nothing
native AddAssault           takes integer qty, integer id               returns boolean
native AddDefenders         takes integer qty, integer id               returns boolean

native GetCreepCamp         takes integer min, integer max, boolean flyers_ok returns unit

native StartGetEnemyBase    takes nothing                               returns nothing
native WaitGetEnemyBase     takes nothing                               returns boolean
native GetEnemyBase         takes nothing                               returns unit
native GetExpansionFoe      takes nothing                               returns unit
native GetEnemyExpansion    takes nothing                               returns unit
native GetExpansionX        takes nothing                               returns integer
native GetExpansionY        takes nothing                               returns integer
native SetStagePoint        takes real x, real y                        returns nothing
native AttackMoveKill       takes unit target                           returns nothing
native AttackMoveXY         takes integer x, integer y                  returns nothing
native LoadZepWave          takes integer x, integer y                  returns nothing
native SuicidePlayer        takes player id, boolean check_full         returns boolean
native SuicidePlayerUnits   takes player id, boolean check_full         returns boolean
native CaptainInCombat      takes boolean attack_captain                returns boolean
native IsTowered            takes unit target                           returns boolean

native ClearHarvestAI       takes nothing                               returns nothing
native HarvestGold          takes integer town, integer peons           returns nothing
native HarvestWood          takes integer town, integer peons           returns nothing
native GetExpansionPeon     takes nothing                               returns unit

native StopGathering        takes nothing                               returns nothing
native AddGuardPost         takes integer id, real x, real y            returns nothing
native FillGuardPosts       takes nothing                               returns nothing
native ReturnGuardPosts     takes nothing                               returns nothing
native CreateCaptains       takes nothing                               returns nothing
native SetCaptainHome       takes integer which, real x, real y         returns nothing
native ResetCaptainLocs     takes nothing                               returns nothing
native ShiftTownSpot        takes real x, real y                        returns nothing
native TeleportCaptain      takes real x, real y                        returns nothing
native ClearCaptainTargets  takes nothing                               returns nothing
native CaptainAttack        takes real x, real y                        returns nothing
native CaptainVsUnits       takes player id                             returns nothing
native CaptainVsPlayer      takes player id                             returns nothing
native CaptainGoHome        takes nothing                               returns nothing
native CaptainIsHome        takes nothing                               returns boolean
native CaptainIsFull        takes nothing                               returns boolean
native CaptainIsEmpty       takes nothing                               returns boolean
native CaptainGroupSize     takes nothing                               returns integer
native CaptainReadiness     takes nothing                               returns integer
native CaptainRetreating    takes nothing                               returns boolean
native CaptainReadinessHP   takes nothing                               returns integer
native CaptainReadinessMa   takes nothing                               returns integer
native CaptainAtGoal        takes nothing                               returns boolean
native CreepsOnMap          takes nothing                               returns boolean
native SuicideUnit          takes integer count, integer unitid         returns nothing
native SuicideUnitEx        takes integer ct, integer uid, integer pid  returns nothing
native StartThread          takes code func                             returns nothing
native Sleep                takes real seconds                          returns nothing
native UnitAlive            takes unit id                               returns boolean
native UnitInvis            takes unit id                               returns boolean
native IgnoredUnits         takes integer unitid                        returns integer
native TownThreatened       takes nothing                               returns boolean
native DisablePathing       takes nothing                               returns nothing
native SetAmphibious        takes nothing                               returns nothing

native CommandsWaiting      takes nothing                               returns integer
native GetLastCommand       takes nothing                               returns integer
native GetLastData          takes nothing                               returns integer
native PopLastCommand       takes nothing                               returns nothing
native MeleeDifficulty      takes nothing                               returns integer

globals

   //============================================================================
   // Standard Constants and Variables
   //============================================================================

    constant integer M1                 =    60
    constant integer M2                 =  2*60
    constant integer M3                 =  3*60
    constant integer M4                 =  4*60
    constant integer M5                 =  5*60
    constant integer M6                 =  6*60
    constant integer M7                 =  7*60
    constant integer M8                 =  8*60
    constant integer M9                 =  9*60
    constant integer M10                = 10*60
    constant integer M11                = 11*60
    constant integer M12                = 12*60
    constant integer M13                = 13*60
    constant integer M14                = 14*60
    constant integer M15                = 15*60

    constant integer EASY               = 1
    constant integer NORMAL             = 2
    constant integer HARD               = 3
    constant integer INSANE             = 4 // not used

    constant integer MELEE_NEWBIE       = 1
    constant integer MELEE_NORMAL       = 2
    constant integer MELEE_INSANE       = 3

    constant integer ATTACK_CAPTAIN     = 1
    constant integer DEFENSE_CAPTAIN    = 2
    constant integer BOTH_CAPTAINS      = 3

    constant integer BUILD_UNIT         = 1
    constant integer BUILD_UPGRADE      = 2
    constant integer BUILD_EXPAND       = 3

    constant integer UPKEEP_TIER1       = 50
    constant integer UPKEEP_TIER2       = 80

    //--------------------------------------------------------------------

    player  ai_player

    integer sleep_seconds
    integer total_gold              = 0
    integer total_wood              = 0
    integer gold_buffer             = 0 // usually for potion money
    integer difficulty              = NORMAL
    integer exp_seen                = 0
    integer racial_farm             = 'hhou'
    integer hero_id                 = 'Hamg'
    integer hero_id2                = 'Hmkg'
    integer hero_id3                = 'Hpal'
    integer array skill
    integer array skills1
    integer array skills2
    integer array skills3
    integer max_hero_level          = 0

    integer array harass_qty
    integer array harass_max
    integer array harass_units
    integer harass_length           = 0

    integer array defense_qty
    integer array defense_units
    integer defense_length          = 0

    integer array build_qty
    integer array build_type
    integer array build_item
    integer array build_town
    integer build_length            = 0

    integer campaign_gold_peons     = 5
    integer campaign_wood_peons     = 3
    integer campaign_basics_speed   = 5

    integer min_creeps              = -1
    integer max_creeps              = -1

    boolean harvest_town1           = true
    boolean harvest_town2           = true
    boolean harvest_town3           = true
    boolean do_campaign_farms       = true
    boolean two_heroes              = false
    boolean allow_air_creeps        = false
    boolean take_exp                = false
    boolean allow_signal_abort      = false
    boolean ready_for_zeppelin      = true
    boolean get_zeppelin            = false

    boolean build_campaign_attackers = true

    boolean do_debug_cheats         = false
    boolean trace_on                = true
    boolean zep_next_wave           = false
    boolean form_group_timeouts     = true


    // =============================================================
    // AMAI constants
    // =============================================================



    constant integer o0                 = 0

  integer ARCHMAGE = 1
  constant integer oARCHMAGE = 'Hamg'
  integer PALADIN = 2
  constant integer oPALADIN = 'Hpal'
  integer MTN_KING = 3
  constant integer oMTN_KING = 'Hmkg'
  integer BLOOD_MAGE = 4
  constant integer oBLOOD_MAGE = 'Hblm'
  integer COPTER = 5
  constant integer oCOPTER = 'hgyr'
  integer ELEMENTAL = 6
  constant integer oELEMENTAL = 'hwat'
  integer ELEMENTAL2 = 7
  constant integer oELEMENTAL2 = 'hwt2'
  integer ELEMENTAL3 = 8
  constant integer oELEMENTAL3 = 'hwt3'
  integer FOOTMAN = 9
  constant integer oFOOTMAN = 'hfoo'
  integer GRYPHON = 10
  constant integer oGRYPHON = 'hgry'
  integer KNIGHT = 11
  constant integer oKNIGHT = 'hkni'
  integer MORTAR = 12
  constant integer oMORTAR = 'hmtm'
  integer PEASANT = 13
  constant integer oPEASANT = 'hpea'
  integer PRIEST = 14
  constant integer oPRIEST = 'hmpr'
  integer RIFLEMAN = 15
  constant integer oRIFLEMAN = 'hrif'
  integer SORCERESS = 16
  constant integer oSORCERESS = 'hsor'
  integer STEAM_TANK = 17
  constant integer oSTEAM_TANK = 'hmtt'
  integer ROCKET_TANK = 18
  constant integer oROCKET_TANK = 'hrrt'
  integer MILITIA = 19
  constant integer oMILITIA = 'hmil'
  integer SPELL_BREAKER = 20
  constant integer oSPELL_BREAKER = 'hspt'
  integer HUMAN_DRAGON_HAWK = 21
  constant integer oHUMAN_DRAGON_HAWK = 'hdhw'
  integer AVIARY = 22
  constant integer oAVIARY = 'hgra'
  integer BARRACKS = 23
  constant integer oBARRACKS = 'hbar'
  integer BLACKSMITH = 24
  constant integer oBLACKSMITH = 'hbla'
  integer CANNON_TOWER = 25
  constant integer oCANNON_TOWER = 'hctw'
  integer CASTLE = 26
  constant integer oCASTLE = 'hcas'
  integer GUARD_TOWER = 27
  constant integer oGUARD_TOWER = 'hgtw'
  integer HOUSE = 28
  constant integer oHOUSE = 'hhou'
  integer HUMAN_ALTAR = 29
  constant integer oHUMAN_ALTAR = 'halt'
  integer KEEP = 30
  constant integer oKEEP = 'hkee'
  integer LUMBER_MILL = 31
  constant integer oLUMBER_MILL = 'hlum'
  integer SANCTUM = 32
  constant integer oSANCTUM = 'hars'
  integer ARCANE_SANCTUM = 33
  constant integer oARCANE_SANCTUM = 'hars'
  integer TOWN_HALL = 34
  constant integer oTOWN_HALL = 'htow'
  integer WATCH_TOWER = 35
  constant integer oWATCH_TOWER = 'hwtw'
  integer WORKSHOP = 36
  constant integer oWORKSHOP = 'harm'
  integer ARCANE_VAULT = 37
  constant integer oARCANE_VAULT = 'hvlt'
  integer ARCANE_TOWER = 38
  constant integer oARCANE_TOWER = 'hatw'
  integer UPG_MELEE = 39
  constant integer oUPG_MELEE = 'Rhme'
  integer UPG_RANGED = 40
  constant integer oUPG_RANGED = 'Rhra'
  integer UPG_ARMOR = 41
  constant integer oUPG_ARMOR = 'Rhar'
  integer UPG_MASONRY = 42
  constant integer oUPG_MASONRY = 'Rhac'
  integer UPG_SIGHT = 43
  constant integer oUPG_SIGHT = 'Rhss'
  integer UPG_DEFEND = 44
  constant integer oUPG_DEFEND = 'Rhde'
  integer UPG_BREEDING = 45
  constant integer oUPG_BREEDING = 'Rhan'
  integer UPG_PRAYING = 46
  constant integer oUPG_PRAYING = 'Rhpt'
  integer UPG_SORCERY = 47
  constant integer oUPG_SORCERY = 'Rhst'
  integer UPG_LEATHER = 48
  constant integer oUPG_LEATHER = 'Rhla'
  integer UPG_GUN_RANGE = 49
  constant integer oUPG_GUN_RANGE = 'Rhri'
  integer UPG_WOOD = 50
  constant integer oUPG_WOOD = 'Rhlh'
  integer UPG_SENTINEL = 51
  constant integer oUPG_SENTINEL = 'Rhse'
  integer UPG_BOMBS = 52
  constant integer oUPG_BOMBS = 'Rhgb'
  integer UPG_HAMMERS = 53
  constant integer oUPG_HAMMERS = 'Rhhb'
  integer UPG_CONT_MAGIC = 54
  constant integer oUPG_CONT_MAGIC = 'Rhss'
  integer UPG_FRAGS = 55
  constant integer oUPG_FRAGS = 'Rhfs'
  integer UPG_TANK = 56
  constant integer oUPG_TANK = 'Rhrt'
  integer UPG_FLAK = 57
  constant integer oUPG_FLAK = 'Rhfc'
  integer UPG_CLOUD = 58
  constant integer oUPG_CLOUD = 'Rhcd'
  integer BLADE_MASTER = 59
  constant integer oBLADE_MASTER = 'Obla'
  integer FAR_SEER = 60
  constant integer oFAR_SEER = 'Ofar'
  integer TAUREN_CHIEF = 61
  constant integer oTAUREN_CHIEF = 'Otch'
  integer SHADOW_HUNTER = 62
  constant integer oSHADOW_HUNTER = 'Oshd'
  integer CATAPULT = 63
  constant integer oCATAPULT = 'ocat'
  integer WITCH_DOCTOR = 64
  constant integer oWITCH_DOCTOR = 'odoc'
  integer GRUNT = 65
  constant integer oGRUNT = 'ogru'
  integer HEAD_HUNTER = 66
  constant integer oHEAD_HUNTER = 'ohun'
  integer BERSERKER = 67
  constant integer oBERSERKER = 'otbk'
  integer KODO_BEAST = 68
  constant integer oKODO_BEAST = 'okod'
  integer PEON = 69
  constant integer oPEON = 'opeo'
  integer RAIDER = 70
  constant integer oRAIDER = 'orai'
  integer SHAMAN = 71
  constant integer oSHAMAN = 'oshm'
  integer TAUREN = 72
  constant integer oTAUREN = 'otau'
  integer WYVERN = 73
  constant integer oWYVERN = 'owyv'
  integer BATRIDER = 74
  constant integer oBATRIDER = 'otbr'
  integer SPIRIT_WALKER = 75
  constant integer oSPIRIT_WALKER = 'ospm'
  integer SPIRIT_WALKER_M = 76
  constant integer oSPIRIT_WALKER_M = 'ospw'
  integer ORC_ALTAR = 77
  constant integer oORC_ALTAR = 'oalt'
  integer ORC_BARRACKS = 78
  constant integer oORC_BARRACKS = 'obar'
  integer BESTIARY = 79
  constant integer oBESTIARY = 'obea'
  integer FORGE = 80
  constant integer oFORGE = 'ofor'
  integer FORTRESS = 81
  constant integer oFORTRESS = 'ofrt'
  integer GREAT_HALL = 82
  constant integer oGREAT_HALL = 'ogre'
  integer LODGE = 83
  constant integer oLODGE = 'osld'
  integer STRONGHOLD = 84
  constant integer oSTRONGHOLD = 'ostr'
  integer BURROW = 85
  constant integer oBURROW = 'otrb'
  integer TOTEM = 86
  constant integer oTOTEM = 'otto'
  integer ORC_WATCH_TOWER = 87
  constant integer oORC_WATCH_TOWER = 'owtw'
  integer VOODOO_LOUNGE = 88
  constant integer oVOODOO_LOUNGE = 'ovln'
  integer UPG_ORC_WAR_DRUMS = 89
  constant integer oUPG_ORC_WAR_DRUMS = 'Rwdm'
  integer UPG_ORC_PILLAGE = 90
  constant integer oUPG_ORC_PILLAGE = 'Ropg'
  integer UPG_ORC_BERSERK = 91
  constant integer oUPG_ORC_BERSERK = 'Robs'
  integer UPG_ORC_PULVERIZE = 92
  constant integer oUPG_ORC_PULVERIZE = 'Rows'
  integer UPG_ORC_ENSNARE = 93
  constant integer oUPG_ORC_ENSNARE = 'Roen'
  integer UPG_ORC_VENOM = 94
  constant integer oUPG_ORC_VENOM = 'Rovs'
  integer UPG_ORC_REGEN = 95
  constant integer oUPG_ORC_REGEN = 'Rotr'
  integer UPG_ORC_FIRE = 96
  constant integer oUPG_ORC_FIRE = 'Rolf'
  integer UPG_ORC_BERSERKER = 97
  constant integer oUPG_ORC_BERSERKER = 'Robk'
  integer UPG_ORC_BURROWS = 98
  constant integer oUPG_ORC_BURROWS = 'Rorb'
  integer UPG_ORC_MELEE = 99
  constant integer oUPG_ORC_MELEE = 'Rome'
  integer UPG_ORC_RANGED = 100
  constant integer oUPG_ORC_RANGED = 'Rora'
  integer UPG_ORC_ARMOR = 101
  constant integer oUPG_ORC_ARMOR = 'Roar'
  integer UPG_ORC_SPIKES = 102
  constant integer oUPG_ORC_SPIKES = 'Rosp'
  integer UPG_ORC_DOCS = 103
  constant integer oUPG_ORC_DOCS = 'Rowd'
  integer UPG_ORC_SHAMAN = 104
  constant integer oUPG_ORC_SHAMAN = 'Rost'
  integer UPG_ORC_SWALKER = 105
  constant integer oUPG_ORC_SWALKER = 'Rowt'
  integer UPG_ORC_NAPTHA = 106
  constant integer oUPG_ORC_NAPTHA = 'Robf'
  integer DEATH_KNIGHT = 107
  constant integer oDEATH_KNIGHT = 'Udea'
  integer DREAD_LORD = 108
  constant integer oDREAD_LORD = 'Udre'
  integer LICH = 109
  constant integer oLICH = 'Ulic'
  integer CRYPT_LORD = 110
  constant integer oCRYPT_LORD = 'Ucrl'
  integer ABOMINATION = 111
  constant integer oABOMINATION = 'uabo'
  integer ACOLYTE = 112
  constant integer oACOLYTE = 'uaco'
  integer BANSHEE = 113
  constant integer oBANSHEE = 'uban'
  integer CRYPT_FIEND = 114
  constant integer oCRYPT_FIEND = 'ucry'
  integer BURROWED_FIEND = 115
  constant integer oBURROWED_FIEND = 'ucrm'
  integer FROST_WYRM = 116
  constant integer oFROST_WYRM = 'ufro'
  integer GARGOYLE = 117
  constant integer oGARGOYLE = 'ugar'
  integer GARGOYLE_MORPH = 118
  constant integer oGARGOYLE_MORPH = 'ugrm'
  integer GHOUL = 119
  constant integer oGHOUL = 'ugho'
  integer MEAT_WAGON = 120
  constant integer oMEAT_WAGON = 'umtw'
  integer NECRO = 121
  constant integer oNECRO = 'unec'
  integer SKEL_WARRIOR = 122
  constant integer oSKEL_WARRIOR = 'uske'
  integer SHADE = 123
  constant integer oSHADE = 'ushd'
  integer OBSIDIAN_STATUE = 124
  constant integer oOBSIDIAN_STATUE = 'uobs'
  integer BLK_SPHINX = 125
  constant integer oBLK_SPHINX = 'ubsp'
  integer UNDEAD_MINE = 126
  constant integer oUNDEAD_MINE = 'ugol'
  integer UNDEAD_ALTAR = 127
  constant integer oUNDEAD_ALTAR = 'uaod'
  integer BONEYARD = 128
  constant integer oBONEYARD = 'ubon'
  integer NECROPOLIS_1 = 129
  constant integer oNECROPOLIS_1 = 'unpl'
  integer NECROPOLIS_2 = 130
  constant integer oNECROPOLIS_2 = 'unp1'
  integer NECROPOLIS_3 = 131
  constant integer oNECROPOLIS_3 = 'unp2'
  integer SAC_PIT = 132
  constant integer oSAC_PIT = 'usap'
  integer CRYPT = 133
  constant integer oCRYPT = 'usep'
  integer SLAUGHTERHOUSE = 134
  constant integer oSLAUGHTERHOUSE = 'uslh'
  integer DAMNED_TEMPLE = 135
  constant integer oDAMNED_TEMPLE = 'utod'
  integer ZIGGURAT_1 = 136
  constant integer oZIGGURAT_1 = 'uzig'
  integer ZIGGURAT_2 = 137
  constant integer oZIGGURAT_2 = 'uzg1'
  integer ZIGGURAT_FROST = 138
  constant integer oZIGGURAT_FROST = 'uzg2'
  integer GRAVEYARD = 139
  constant integer oGRAVEYARD = 'ugrv'
  integer TOMB_OF_RELICS = 140
  constant integer oTOMB_OF_RELICS = 'utom'
  integer CARRION_BEETLE = 141
  constant integer oCARRION_BEETLE = 'ucs1'
  integer CARRION_BEETLE2 = 142
  constant integer oCARRION_BEETLE2 = 'ucs2'
  integer CARRION_BEETLE3 = 143
  constant integer oCARRION_BEETLE3 = 'ucs3'
  integer SKEL_MAGE = 144
  constant integer oSKEL_MAGE = 'uskm'
  integer UPG_CANNIBALIZE = 145
  constant integer oUPG_CANNIBALIZE = 'Ruac'
  integer UPG_GHOUL_FRENZY = 146
  constant integer oUPG_GHOUL_FRENZY = 'Rugf'
  integer UPG_FIEND_WEB = 147
  constant integer oUPG_FIEND_WEB = 'Ruwb'
  integer UPG_STONE_FORM = 148
  constant integer oUPG_STONE_FORM = 'Rusf'
  integer UPG_WYRM_BREATH = 149
  constant integer oUPG_WYRM_BREATH = 'Rufb'
  integer UPG_SKEL_LIFE = 150
  constant integer oUPG_SKEL_LIFE = 'Rusl'
  integer UPG_PLAGUE = 151
  constant integer oUPG_PLAGUE = 'Rupc'
  integer UPG_SKEL_MASTERY = 152
  constant integer oUPG_SKEL_MASTERY = 'Rusm'
  integer UPG_BLK_SPHINX = 153
  constant integer oUPG_BLK_SPHINX = 'Rusp'
  integer UPG_BURROWING = 154
  constant integer oUPG_BURROWING = 'Rubu'
  integer UPG_EXHUME = 155
  constant integer oUPG_EXHUME = 'Ruex'
  integer UPG_UNHOLY_STR = 156
  constant integer oUPG_UNHOLY_STR = 'Rume'
  integer UPG_CR_ATTACK = 157
  constant integer oUPG_CR_ATTACK = 'Rura'
  integer UPG_UNHOLY_ARMOR = 158
  constant integer oUPG_UNHOLY_ARMOR = 'Ruar'
  integer UPG_CR_ARMOR = 159
  constant integer oUPG_CR_ARMOR = 'Rucr'
  integer UPG_NECROS = 160
  constant integer oUPG_NECROS = 'Rune'
  integer UPG_BANSHEE = 161
  constant integer oUPG_BANSHEE = 'Ruba'
  integer DEMON_HUNTER = 162
  constant integer oDEMON_HUNTER = 'Edem'
  integer DEMON_HUNTER_M = 163
  constant integer oDEMON_HUNTER_M = 'Edmm'
  integer KEEPER = 164
  constant integer oKEEPER = 'Ekee'
  integer MOON_PRIESTESS = 165
  constant integer oMOON_PRIESTESS = 'Emoo'
  integer WARDEN = 166
  constant integer oWARDEN = 'Ewar'
  integer WISP = 167
  constant integer oWISP = 'ewsp'
  integer ARCHER = 168
  constant integer oARCHER = 'earc'
  integer DRUID_TALON = 169
  constant integer oDRUID_TALON = 'edot'
  integer DRUID_TALON_M = 170
  constant integer oDRUID_TALON_M = 'edtm'
  integer BALLISTA = 171
  constant integer oBALLISTA = 'ebal'
  integer DRUID_CLAW = 172
  constant integer oDRUID_CLAW = 'edoc'
  integer DRUID_CLAW_M = 173
  constant integer oDRUID_CLAW_M = 'edcm'
  integer DRYAD = 174
  constant integer oDRYAD = 'edry'
  integer HIPPO = 175
  constant integer oHIPPO = 'ehip'
  integer HIPPO_RIDER = 176
  constant integer oHIPPO_RIDER = 'ehpr'
  integer HUNTRESS = 177
  constant integer oHUNTRESS = 'esen'
  integer CHIMAERA = 178
  constant integer oCHIMAERA = 'echm'
  integer ENT = 179
  constant integer oENT = 'efon'
  integer MOUNTAIN_GIANT = 180
  constant integer oMOUNTAIN_GIANT = 'emtg'
  integer FAERIE_DRAGON = 181
  constant integer oFAERIE_DRAGON = 'efdr'
  integer ANCIENT_LORE = 182
  constant integer oANCIENT_LORE = 'eaoe'
  integer ANCIENT_WAR = 183
  constant integer oANCIENT_WAR = 'eaom'
  integer ANCIENT_WIND = 184
  constant integer oANCIENT_WIND = 'eaow'
  integer TREE_AGES = 185
  constant integer oTREE_AGES = 'etoa'
  integer TREE_ETERNITY = 186
  constant integer oTREE_ETERNITY = 'etoe'
  integer TREE_LIFE = 187
  constant integer oTREE_LIFE = 'etol'
  integer ANCIENT_PROTECT = 188
  constant integer oANCIENT_PROTECT = 'etrp'
  integer ELF_ALTAR = 189
  constant integer oELF_ALTAR = 'eate'
  integer CHIMAERA_ROOST = 190
  constant integer oCHIMAERA_ROOST = 'edos'
  integer HUNTERS_HALL = 191
  constant integer oHUNTERS_HALL = 'edob'
  integer MOON_WELL = 192
  constant integer oMOON_WELL = 'emow'
  integer ELF_MINE = 193
  constant integer oELF_MINE = 'egol'
  integer DEN_OF_WONDERS = 194
  constant integer oDEN_OF_WONDERS = 'eden'
  integer UPG_ULTRAVISION = 195
  constant integer oUPG_ULTRAVISION = 'Reuv'
  integer UPG_BLESSING = 196
  constant integer oUPG_BLESSING = 'Renb'
  integer UPG_SCOUT = 197
  constant integer oUPG_SCOUT = 'Resc'
  integer UPG_GLAIVE = 198
  constant integer oUPG_GLAIVE = 'Remg'
  integer UPG_BOWS = 199
  constant integer oUPG_BOWS = 'Reib'
  integer UPG_MARKSMAN = 200
  constant integer oUPG_MARKSMAN = 'Remk'
  integer UPG_ABOLISH = 201
  constant integer oUPG_ABOLISH = 'Resi'
  integer UPG_CHIM_ACID = 202
  constant integer oUPG_CHIM_ACID = 'Recb'
  integer UPG_HIPPO_TAME = 203
  constant integer oUPG_HIPPO_TAME = 'Reht'
  integer UPG_BOLT = 204
  constant integer oUPG_BOLT = 'Repd'
  integer UPG_MARK_CLAW = 205
  constant integer oUPG_MARK_CLAW = 'Reeb'
  integer UPG_MARK_TALON = 206
  constant integer oUPG_MARK_TALON = 'Reec'
  integer UPG_HARD_SKIN = 207
  constant integer oUPG_HARD_SKIN = 'Rehs'
  integer UPG_RESIST_SKIN = 208
  constant integer oUPG_RESIST_SKIN = 'Rers'
  integer UPG_WELL_SPRING = 209
  constant integer oUPG_WELL_SPRING = 'Rews'
  integer UPG_STR_MOON = 210
  constant integer oUPG_STR_MOON = 'Resm'
  integer UPG_STR_WILD = 211
  constant integer oUPG_STR_WILD = 'Resw'
  integer UPG_MOON_ARMOR = 212
  constant integer oUPG_MOON_ARMOR = 'Rema'
  integer UPG_HIDES = 213
  constant integer oUPG_HIDES = 'Rerh'
  integer UPG_DRUID_TALON = 214
  constant integer oUPG_DRUID_TALON = 'Redt'
  integer UPG_DRUID_CLAW = 215
  constant integer oUPG_DRUID_CLAW = 'Redc'
  integer NAGA_SORCERESS = 216
  constant integer oNAGA_SORCERESS = 'Nngs'
  integer BEAST_MASTER = 217
  constant integer oBEAST_MASTER = 'Nbst'
  integer DARK_RANGER = 218
  constant integer oDARK_RANGER = 'Nbrn'
  integer NEUTRAL_PIT_LORD = 219
  constant integer oNEUTRAL_PIT_LORD = 'Nplh'
  integer BREW_MASTER = 220
  constant integer oBREW_MASTER = 'Npbm'
  integer GOBLIN_TINKER = 221
  constant integer oGOBLIN_TINKER = 'Ntin'
  integer GOBLIN_TINKER_M = 222
  constant integer oGOBLIN_TINKER_M = 'Nrob'
  integer FIRELORD = 223
  constant integer oFIRELORD = 'Nfir'
  integer ALCHEMIST = 224
  constant integer oALCHEMIST = 'Nalc'
  integer ALCHEMIST_M1 = 225
  constant integer oALCHEMIST_M1 = 'Nalm'
  integer ALCHEMIST_M2 = 226
  constant integer oALCHEMIST_M2 = 'Nal2'
  integer ALCHEMIST_M3 = 227
  constant integer oALCHEMIST_M3 = 'Nal3'
  integer LAVASPAWN = 228
  constant integer oLAVASPAWN = 'nlv1'
  integer LAVASPAWN2 = 229
  constant integer oLAVASPAWN2 = 'nlv2'
  integer LAVASPAWN3 = 230
  constant integer oLAVASPAWN3 = 'nlv3'
  integer OGRE_MAGI = 231
  constant integer oOGRE_MAGI = 'nomg'
  integer SATYR_SHADOWDANCER = 232
  constant integer oSATYR_SHADOWDANCER = 'nsts'
  integer FURBOLG_SHAMAN = 233
  constant integer oFURBOLG_SHAMAN = 'nfrs'
  integer THUNDER_LIZARD = 234
  constant integer oTHUNDER_LIZARD = 'nthl'
  integer CENTAUR_OUTRUNNER = 235
  constant integer oCENTAUR_OUTRUNNER = 'ncen'
  integer HARPY_ROGUE = 236
  constant integer oHARPY_ROGUE = 'nhrr'
  integer RAZORMANE_MEDICINE_MAN = 237
  constant integer oRAZORMANE_MEDICINE_MAN = 'nrzm'
  integer HARPY_WINDWITCH = 238
  constant integer oHARPY_WINDWITCH = 'nhrw'
  integer FEL_BEAST = 239
  constant integer oFEL_BEAST = 'npfl'
  integer DRAENEI_DISCIPLE = 240
  constant integer oDRAENEI_DISCIPLE = 'ndrm'
  integer VOIDWALKER = 241
  constant integer oVOIDWALKER = 'nvdw'
  integer DRAENEI_DARKSLAYER = 242
  constant integer oDRAENEI_DARKSLAYER = 'ndrd'
  integer ROGUE = 243
  constant integer oROGUE = 'nrog'
  integer ASSASSIN = 244
  constant integer oASSASSIN = 'nass'
  integer KOBOLD_GEOMANCER = 245
  constant integer oKOBOLD_GEOMANCER = 'nkog'
  integer FOREST_TROLL_HIGH_PRIEST = 246
  constant integer oFOREST_TROLL_HIGH_PRIEST = 'nfsh'
  integer BURNING_ARCHER = 247
  constant integer oBURNING_ARCHER = 'nskf'
  integer WILDKIN = 248
  constant integer oWILDKIN = 'nowb'
  integer MURLOC_FLESHEATER = 249
  constant integer oMURLOC_FLESHEATER = 'nmfs'
  integer SLUDGE_FLINGER = 250
  constant integer oSLUDGE_FLINGER = 'nslf'
  integer SATYR_SOULSTEALER = 251
  constant integer oSATYR_SOULSTEALER = 'nstl'
  integer BARBED_ARACHNATHID = 252
  constant integer oBARBED_ARACHNATHID = 'nanm'
  integer BLUE_DRAGONSPAWN_MEDDLER = 253
  constant integer oBLUE_DRAGONSPAWN_MEDDLER = 'nbdm'
  integer MAGNATAUR_WARRIOR = 254
  constant integer oMAGNATAUR_WARRIOR = 'nmgw'
  integer POLAR_FURBOLG_SHAMAN = 255
  constant integer oPOLAR_FURBOLG_SHAMAN = 'nfps'
  integer GNOLL_BRUTE = 256
  constant integer oGNOLL_BRUTE = 'ngnb'
  integer GNOLL_WARDEN = 257
  constant integer oGNOLL_WARDEN = 'ngnw'
  integer MUD_GOLEM = 258
  constant integer oMUD_GOLEM = 'ngrk'
  integer FOREST_TROLL_BERSERKER = 259
  constant integer oFOREST_TROLL_BERSERKER = 'nftb'
  integer FOREST_TROLL_SHADOW_PRIEST = 260
  constant integer oFOREST_TROLL_SHADOW_PRIEST = 'nfsp'
  integer OGRE_MAULER = 261
  constant integer oOGRE_MAULER = 'nogm'
  integer GNOLL_OVERSEER = 262
  constant integer oGNOLL_OVERSEER = 'ngnv'
  integer ICE_TROLL_BERSERKER = 263
  constant integer oICE_TROLL_BERSERKER = 'nits'
  integer ICE_TROLL_TRAPPER = 264
  constant integer oICE_TROLL_TRAPPER = 'nitt'
  integer NERUBIAN_WARRIOR = 265
  constant integer oNERUBIAN_WARRIOR = 'nnwa'
  integer FROST_REVENANT = 266
  constant integer oFROST_REVENANT = 'nrvs'
  integer NERUBIAN_WEBSPINNER = 267
  constant integer oNERUBIAN_WEBSPINNER = 'nnwl'
  integer MURGUL_SNARECASTER = 268
  constant integer oMURGUL_SNARECASTER = 'nmsn'
  integer MAKRURA_SNAPPER = 269
  constant integer oMAKRURA_SNAPPER = 'nlsn'
  integer MAKRURA_DEEPSEER = 270
  constant integer oMAKRURA_DEEPSEER = 'nlds'
  integer GIANT_SEA_TURTLE = 271
  constant integer oGIANT_SEA_TURTLE = 'ntrt'
  integer KOBOLD = 272
  constant integer oKOBOLD = 'nkob'
  integer MURLOC_HUNTSMAN = 273
  constant integer oMURLOC_HUNTSMAN = 'nmrr'
  integer BLACK_DRAGON_1 = 274
  constant integer oBLACK_DRAGON_1 = 'nbdr'
  integer BLACK_DRAGON_2 = 275
  constant integer oBLACK_DRAGON_2 = 'nbdk'
  integer BLACK_DRAGON_3 = 276
  constant integer oBLACK_DRAGON_3 = 'nbwm'
  integer BLUE_DRAGON_1 = 277
  constant integer oBLUE_DRAGON_1 = 'nadw'
  integer BLUE_DRAGON_2 = 278
  constant integer oBLUE_DRAGON_2 = 'nadk'
  integer BLUE_DRAGON_3 = 279
  constant integer oBLUE_DRAGON_3 = 'nadr'
  integer BRONZE_DRAGON_1 = 280
  constant integer oBRONZE_DRAGON_1 = 'nbzw'
  integer BRONZE_DRAGON_2 = 281
  constant integer oBRONZE_DRAGON_2 = 'nbzk'
  integer BRONZE_DRAGON_3 = 282
  constant integer oBRONZE_DRAGON_3 = 'nbzd'
  integer GREEN_DRAGON_1 = 283
  constant integer oGREEN_DRAGON_1 = 'ngrw'
  integer GREEN_DRAGON_2 = 284
  constant integer oGREEN_DRAGON_2 = 'ngdk'
  integer GREEN_DRAGON_3 = 285
  constant integer oGREEN_DRAGON_3 = 'ngrd'
  integer NETHER_DRAGON_1 = 286
  constant integer oNETHER_DRAGON_1 = 'nnht'
  integer NETHER_DRAGON_2 = 287
  constant integer oNETHER_DRAGON_2 = 'nndk'
  integer NETHER_DRAGON_3 = 288
  constant integer oNETHER_DRAGON_3 = 'nndr'
  integer RED_DRAGON_1 = 289
  constant integer oRED_DRAGON_1 = 'nrdk'
  integer RED_DRAGON_2 = 290
  constant integer oRED_DRAGON_2 = 'nrdr'
  integer RED_DRAGON_3 = 291
  constant integer oRED_DRAGON_3 = 'nrwm'
  integer SHREDDER = 292
  constant integer oSHREDDER = 'ngir'
  integer SAPPER = 293
  constant integer oSAPPER = 'ngsp'
  integer ZEPPELIN = 294
  constant integer oZEPPELIN = 'nzep'
  integer GOLD_MINE = 295
  constant integer oGOLD_MINE = 'ngol'
  integer SCROLL_OF_REGENERATION = 296
  constant integer oSCROLL_OF_REGENERATION = 'sreg'
  integer MECHANICAL_CRITTER = 297
  constant integer oMECHANICAL_CRITTER = 'mcri'
  integer LESSER_CLARITY_POTION = 298
  constant integer oLESSER_CLARITY_POTION = 'plcl'
  integer HEALING_POTION = 299
  constant integer oHEALING_POTION = 'phea'
  integer MANA_POTION = 300
  constant integer oMANA_POTION = 'pman'
  integer TOWN_PORTAL = 301
  constant integer oTOWN_PORTAL = 'stwp'
  integer IVORY_TOWER = 302
  constant integer oIVORY_TOWER = 'tsct'
  integer ORB_OF_FIRE = 303
  constant integer oORB_OF_FIRE = 'ofir'
  integer STAFF_OF_SANCTUARY = 304
  constant integer oSTAFF_OF_SANCTUARY = 'ssan'
  integer HEALING_SALVE = 305
  constant integer oHEALING_SALVE = 'hslv'
  integer SCROLL_OF_SPEED = 306
  constant integer oSCROLL_OF_SPEED = 'shas'
  integer ORB_OF_LIGHTNING = 307
  constant integer oORB_OF_LIGHTNING = 'oli2'
  integer TINY_GREAT_HALL = 308
  constant integer oTINY_GREAT_HALL = 'tgrh'
  integer ROD_OF_NECROMANCY = 309
  constant integer oROD_OF_NECROMANCY = 'rnec'
  integer SACRIFICIAL_SKULL = 310
  constant integer oSACRIFICIAL_SKULL = 'skul'
  integer DUST_OF_APPEARANCE = 311
  constant integer oDUST_OF_APPEARANCE = 'dust'
  integer ORB_OF_CORRUPTION = 312
  constant integer oORB_OF_CORRUPTION = 'ocor'
  integer SCROLL_OF_HEALING = 313
  constant integer oSCROLL_OF_HEALING = 'shea'
  integer MOONSTONE = 314
  constant integer oMOONSTONE = 'moon'
  integer STAFF_OF_PRESERVATION = 315
  constant integer oSTAFF_OF_PRESERVATION = 'spre'
  integer ORB_OF_VENOM = 316
  constant integer oORB_OF_VENOM = 'oven'
  integer ANTI_MAGIC_POTION = 317
  constant integer oANTI_MAGIC_POTION = 'pams'
  integer CIRCLET_OF_NOBILITY = 318
  constant integer oCIRCLET_OF_NOBILITY = 'cnob'
  integer PERIAPT_OF_VITALITY = 319
  constant integer oPERIAPT_OF_VITALITY = 'prvt'
  integer BOOTS_OF_SPEED = 320
  constant integer oBOOTS_OF_SPEED = 'bspd'
  integer M_DUST_OF_APPEARANCE = 321
  constant integer oM_DUST_OF_APPEARANCE = 'dust'
  integer M_SCROLL_OF_HEALING = 322
  constant integer oM_SCROLL_OF_HEALING = 'shea'
  integer SCROLL_OF_PROTECTION = 323
  constant integer oSCROLL_OF_PROTECTION = 'spro'
  integer M_TOWN_PORTAL = 324
  constant integer oM_TOWN_PORTAL = 'stwp'
  integer POTION_OF_INVISIBILITY = 325
  constant integer oPOTION_OF_INVISIBILITY = 'pinv'
  integer TOME_OF_RETRAINING = 326
  constant integer oTOME_OF_RETRAINING = 'tret'
  integer STAFF_OF_TELEPORTATION = 327
  constant integer oSTAFF_OF_TELEPORTATION = 'stel'
  integer POTION_OF_LESSER_INVULNERBILITY = 328
  constant integer oPOTION_OF_LESSER_INVULNERBILITY = 'pnvl'
  integer JAINA = 329
  constant integer oJAINA = 'Hjai'
  integer MURADIN = 330
  constant integer oMURADIN = 'Hmbr'
  integer GARITHOS = 331
  constant integer oGARITHOS = 'Hlgr'
  integer KAEL = 332
  constant integer oKAEL = 'Hkal'
  integer BLOOD_PRIEST = 333
  constant integer oBLOOD_PRIEST = 'hbep'
  integer BLOOD_SORCERESS = 334
  constant integer oBLOOD_SORCERESS = 'hbes'
  integer BLOOD_PEASANT = 335
  constant integer oBLOOD_PEASANT = 'nhew'
  integer CHURCH = 336
  constant integer oCHURCH = 'htws'
  integer MAGE_TOWER = 337
  constant integer oMAGE_TOWER = 'htws'
  integer GROM = 338
  constant integer oGROM = 'Ogrh'
  integer THRALL = 339
  constant integer oTHRALL = 'Othr'
  integer GUARDIAN = 340
  constant integer oGUARDIAN = 'oang'
  integer W2_WARLOCK = 341
  constant integer oW2_WARLOCK = 'nw2w'
  integer PIG_FARM = 342
  constant integer oPIG_FARM = 'npgf'
  integer CHAOS_GRUNT = 343
  constant integer oCHAOS_GRUNT = 'nchg'
  integer CHAOS_WARLOCK = 344
  constant integer oCHAOS_WARLOCK = 'nchw'
  integer CHAOS_RAIDER = 345
  constant integer oCHAOS_RAIDER = 'nchr'
  integer CHAOS_PEON = 346
  constant integer oCHAOS_PEON = 'ncpn'
  integer CHAOS_KODO = 347
  constant integer oCHAOS_KODO = 'nckb'
  integer CHAOS_GROM = 348
  constant integer oCHAOS_GROM = 'Opgh'
  integer CHAOS_BLADEMASTER = 349
  constant integer oCHAOS_BLADEMASTER = 'Nbbc'
  integer CHAOS_BURROW = 350
  constant integer oCHAOS_BURROW = 'ocbw'
  integer MALGANIS = 351
  constant integer oMALGANIS = 'Umal'
  integer TICHONDRIUS  = 352
  constant integer oTICHONDRIUS  = 'Utic'
  integer PIT_LORD = 353
  constant integer oPIT_LORD = 'Npld'
  integer DETHEROC = 354
  constant integer oDETHEROC = 'Udth'
  integer UNDEAD_BARGE = 355
  constant integer oUNDEAD_BARGE = 'uarb'
  integer SYLVANUS = 356
  constant integer oSYLVANUS = 'Hvwd'
  integer CENARIUS = 357
  constant integer oCENARIUS = 'Ecen'
  integer ILLIDAN = 358
  constant integer oILLIDAN = 'Eevi'
  integer ILLIDAN_DEMON = 359
  constant integer oILLIDAN_DEMON = 'Eevm'
  integer MAIEV = 360
  constant integer oMAIEV = 'Ewrd'
  integer HIGH_ARCHER  = 361
  constant integer oHIGH_ARCHER  = 'nhea'
  integer HIGH_FOOTMAN = 362
  constant integer oHIGH_FOOTMAN = 'hcth'
  integer HIGH_FOOTMEN = 363
  constant integer oHIGH_FOOTMEN = 'hcth'
  integer HIGH_SWORDMAN = 364
  constant integer oHIGH_SWORDMAN = 'hhes'
  integer DRAGON_HAWK = 365
  constant integer oDRAGON_HAWK = 'nws1'
  integer CORRUPT_TREANT = 366
  constant integer oCORRUPT_TREANT = 'nenc'
  integer POISON_TREANT = 367
  constant integer oPOISON_TREANT = 'nenp'
  integer PLAGUE_TREANT = 368
  constant integer oPLAGUE_TREANT = 'nepl'
  integer SHANDRIS = 369
  constant integer oSHANDRIS = 'eshd'
  integer ELF_FARM = 370
  constant integer oELF_FARM = 'nefm'
  integer ELF_GUARD_TOWER = 371
  constant integer oELF_GUARD_TOWER = 'negt'
  integer HIGH_SKY = 372
  constant integer oHIGH_SKY = 'negm'
  integer HIGH_EARTH = 373
  constant integer oHIGH_EARTH = 'negf'
  integer HIGH_TOWER = 374
  constant integer oHIGH_TOWER = 'negt'
  integer ELF_HIGH_BARRACKS = 375
  constant integer oELF_HIGH_BARRACKS = 'nheb'
  integer CORRUPT_LIFE = 376
  constant integer oCORRUPT_LIFE = 'nctl'
  integer CORRUPT_WELL = 377
  constant integer oCORRUPT_WELL = 'ncmw'
  integer CORRUPT_PROTECTOR = 378
  constant integer oCORRUPT_PROTECTOR = 'ncap'
  integer CORRUPT_WAR = 379
  constant integer oCORRUPT_WAR = 'ncaw'
  integer NAGA_VASHJ = 380
  constant integer oNAGA_VASHJ = 'Hvsh'
  integer NAGA_DRAGON = 381
  constant integer oNAGA_DRAGON = 'nsnp'
  integer NAGA_WITCH = 382
  constant integer oNAGA_WITCH = 'nnsw'
  integer NAGA_SERPENT = 383
  constant integer oNAGA_SERPENT = 'nwgs'
  integer NAGA_HYDRA = 384
  constant integer oNAGA_HYDRA = 'nhyc'
  integer NAGA_SLAVE = 385
  constant integer oNAGA_SLAVE = 'nmpe'
  integer NAGA_SNAP_DRAGON = 386
  constant integer oNAGA_SNAP_DRAGON = 'nsnp'
  integer NAGA_COUATL = 387
  constant integer oNAGA_COUATL = 'nwgs'
  integer NAGA_SIREN = 388
  constant integer oNAGA_SIREN = 'nnsw'
  integer NAGA_MYRMIDON = 389
  constant integer oNAGA_MYRMIDON = 'nmyr'
  integer NAGA_REAVER = 390
  constant integer oNAGA_REAVER = 'nnmg'
  integer NAGA_TURTLE = 391
  constant integer oNAGA_TURTLE = 'nhyc'
  integer NAGA_ROYAL = 392
  constant integer oNAGA_ROYAL = 'nnrg'
  integer NAGA_TEMPLE = 393
  constant integer oNAGA_TEMPLE = 'nntt'
  integer NAGA_CORAL = 394
  constant integer oNAGA_CORAL = 'nnfm'
  integer NAGA_SHRINE = 395
  constant integer oNAGA_SHRINE = 'nnsa'
  integer NAGA_SPAWNING = 396
  constant integer oNAGA_SPAWNING = 'nnsg'
  integer NAGA_GUARDIAN = 397
  constant integer oNAGA_GUARDIAN = 'nntg'
  integer NAGA_ALTAR = 398
  constant integer oNAGA_ALTAR = 'nnad'
  integer UPG_NAGA_ARMOR = 399
  constant integer oUPG_NAGA_ARMOR = 'Rnam'
  integer UPG_NAGA_ATTACK = 400
  constant integer oUPG_NAGA_ATTACK = 'Rnat'
  integer UPG_NAGA_ABOLISH = 401
  constant integer oUPG_NAGA_ABOLISH = 'Rnsi'
  integer UPG_SIREN = 402
  constant integer oUPG_SIREN = 'Rnsw'
  integer UPG_NAGA_ENSNARE = 403
  constant integer oUPG_NAGA_ENSNARE = 'Rnen'
  integer UPG_ORC_CHAOS = 404
  constant integer oUPG_ORC_CHAOS = 'Roch'
  constant integer OBJECT_NUM = 404
  integer FOOTMEN = FOOTMAN
  integer oFOOTMEN = oFOOTMAN
  integer RIFLEMEN = RIFLEMAN
  integer oRIFLEMEN = oRIFLEMAN
  integer TANK = STEAM_TANK
  integer oTANK = oSTEAM_TANK
  integer GYRO = COPTER
  integer oGYRO = oCOPTER
  integer PIT_FIEND = CRYPT_FIEND
  integer oPIT_FIEND = oCRYPT_FIEND
  integer OBS_STATUE = OBSIDIAN_STATUE
  integer oOBS_STATUE = oOBSIDIAN_STATUE
  integer MOON_CHICK = MOON_PRIESTESS
  integer oMOON_CHICK = oMOON_PRIESTESS
  integer MOON_BABE = MOON_PRIESTESS
  integer oMOON_BABE = oMOON_PRIESTESS
  integer MOON_HONEY = MOON_PRIESTESS
  integer oMOON_HONEY = oMOON_PRIESTESS
  integer ORC_DRAGON = RED_DRAGON_3
  integer oORC_DRAGON = oRED_DRAGON_3
  integer ZEPPLIN = ZEPPELIN
  integer oZEPPLIN = oZEPPELIN

  constant integer AVATAR = 'AHav'
  constant integer BASH = 'AHbh'
  constant integer THUNDER_BOLT = 'AHtb'
  constant integer THUNDER_CLAP = 'AHtc'
  constant integer DEVOTION_AURA = 'AHad'
  constant integer DIVINE_SHIELD = 'AHds'
  constant integer HOLY_BOLT = 'AHhb'
  constant integer RESURRECTION = 'AHre'
  constant integer BLIZZARD = 'AHbz'
  constant integer BRILLIANCE_AURA = 'AHab'
  constant integer MASS_TELEPORT = 'AHmt'
  constant integer WATER_ELEMENTAL = 'AHwe'
  constant integer BANISH = 'AHbn'
  constant integer FLAME_STRIKE = 'AHfs'
  constant integer SUMMON_PHOENIX = 'AHpx'
  constant integer SIPHON_MANA = 'AHdr'
  constant integer CRITICAL_STRIKE = 'AOcr'
  constant integer MIRROR_IMAGE = 'AOmi'
  constant integer BLADE_STORM = 'AOww'
  constant integer WIND_WALK = 'AOwk'
  constant integer CHAIN_LIGHTNING = 'AOcl'
  constant integer EARTHQUAKE = 'AOeq'
  constant integer FAR_SIGHT = 'AOfs'
  constant integer SPIRIT_WOLF = 'AOsf'
  constant integer ENDURANCE_AURA = 'AOae'
  constant integer ENDURANE_AURA = 'AOae'
  constant integer REINCARNATION = 'AOre'
  constant integer SHOCKWAVE = 'AOsh'
  constant integer WAR_STOMP = 'AOws'
  constant integer HEALING_WAVE = 'AOhw'
  constant integer HEX = 'AOhx'
  constant integer SERPENT_WARD = 'AOsw'
  constant integer VOODOO = 'AOvd'
  constant integer SLEEP = 'AUsl'
  constant integer VAMP_AURA = 'AUav'
  constant integer CARRION_SWARM = 'AUcs'
  constant integer INFERNO = 'AUin'
  constant integer DARK_RITUAL = 'AUdr'
  constant integer DEATH_DECAY = 'AUdd'
  constant integer FROST_ARMOR = 'AUfu'
  constant integer FROST_NOVA = 'AUfn'
  constant integer ANIM_DEAD = 'AUan'
  constant integer DEATH_COIL = 'AUdc'
  constant integer DEATH_PACT = 'AUdp'
  constant integer UNHOLY_AURA = 'AUau'
  constant integer CARRION_SCARAB = 'AUcb'
  constant integer IMPALE = 'AUim'
  constant integer LOCUST_SWARM = 'AUls'
  constant integer THORNY_SHIELD = 'AUts'
  constant integer FORCE_NATURE = 'AEfn'
  constant integer ENT_ROOTS = 'AEer'
  constant integer THORNS_AURA = 'AEah'
  constant integer TRANQUILITY = 'AEtq'
  constant integer EVASION = 'AEev'
  constant integer IMMOLATION = 'AEim'
  constant integer MANA_BURN = 'AEmb'
  constant integer METAMORPHOSIS = 'AEme'
  constant integer SEARING_ARROWS = 'AHfa'
  constant integer SCOUT = 'AEst'
  constant integer STARFALL = 'AEsf'
  constant integer TRUESHOT = 'AEar'
  constant integer BLINK = 'AEbl'
  constant integer FAN_KNIVES = 'AEfk'
  constant integer SHADOW_TOUCH = 'AEsh'
  constant integer VENGEANCE = 'AEsv'
  constant integer BLACKARROW = 'ANba'
  constant integer CHARM = 'ANch'
  constant integer DRAIN = 'ANdr'
  constant integer SILENCE = 'ANsi'
  constant integer FORKLIGHTNING = 'ANfl'
  constant integer FROSTARROWS = 'ANfa'
  constant integer TORNADO = 'ANto'
  constant integer MANASHIELD = 'ANms'
  constant integer BOF = 'ANbf'
  constant integer BRAWLER = 'ANdb'
  constant integer HAZE = 'ANdh'
  constant integer SEF = 'ANef'
  constant integer DOOM = 'ANdo'
  constant integer HOWL = 'ANht'
  constant integer CLEAVING = 'ANca'
  constant integer RAINOFFIRE = 'ANrf'
  constant integer STAMPEDE = 'ANst'
  constant integer BEAR = 'ANsg'
  constant integer QUILBEAST = 'ANsq'
  constant integer HAWK = 'ANsw'
  constant integer POCKETFACTORY = 'ANsy'
  constant integer ROBOGOBLIN = 'ANrg'
  constant integer UPGRADE = 'ANeg'
  constant integer ROCKETS = 'ANcs'
  constant integer INCINERATE = 'ANia'
  constant integer SOUL_BURN = 'ANso'
  constant integer SUMMON_LAVASPAWN = 'ANlm'
  constant integer VOLCANO = 'ANvc'
  constant integer HEALING_SPRAY = 'ANhs'
  constant integer ACID_BOMB = 'ANab'
  constant integer CHEMICAL_RAGE = 'ANcr'
  constant integer TRANSMUTE = 'ANtm'


    constant integer BUILD_ITEM         = 4
    
    constant integer BLOC_STD = 1
    constant integer BLOC_FRONT = 2
    constant integer BLOC_MINE = 3

    constant integer NOT_ENOUGH_RES = 1
    constant integer CANNOT_BUILD = 2
    constant integer BUILT_ALL = 3
    constant integer BUILT_SOME = 4

    constant integer SR_RANDOM = 0
    constant integer SR_ELF = 1
    constant integer SR_HUMAN = 2
    constant integer SR_ORC = 3
    constant integer SR_UNDEAD = 4

    constant integer R_RANDOM = 0
    constant integer R_ELF = 1
    constant integer R_HUMAN = 2
    constant integer R_ORC = 3
    constant integer R_UNDEAD = 4
    constant integer R_NEUTRAL = 5
    constant integer RACE_NUMBER = 4

    constant integer HERO_LEVEL_NUMBER = 10


    constant integer RESET_HEALTH = 0
    constant integer ZEPPELIN_MOVE = 1
    constant integer TELEPORT = 2
    constant integer TOWN_TRACK = 3
    constant integer CHAT_VARS = 4
    constant integer REVEAL_ENEMY = 5
    constant integer TIMED_CHAT = 6
    constant integer CLEANUP_BLOCKS = 7
    constant integer NEUTRAL_GUARDED = 8
    constant integer RESET_WINDWALKER = 9
    constant integer SELL_ZIGGURATS = 10
    constant integer EXCHANGE = 11
    constant integer ZEPPELIN_FOLLOW = 12
    constant integer RESET_GUARD_POSITION = 13
    constant integer BUY_ITEM = 14
    constant integer HEALTH_FOUNTAIN = 15
    constant integer MANA_FOUNTAIN = 16
    constant integer NEUTRAL_ENEMY_CHECK = 17
    constant integer MOON_WELL_CONTROL = 18
    constant integer SEND_HOME = 19
    constant integer BUY_NEUTRAL = 20
    constant integer BUY_NEUTRAL_HERO = 21
    constant integer UPDATE_STRENGTH = 22
    constant integer DETECT_DEFEAT = 23
    constant integer DETECT_DOUBLE_EXP = 24
    constant integer WISP_CHECK = 25
    constant integer MICRO_UNITS = 26
    constant integer MILITIA_CHECK = 27
    constant integer TOWER_RUSH = 28
    constant integer FOCUSFIRE_CONTROL = 29
    constant integer FAST_BUILD = 30
    constant integer MILITIA_EXPAND = 31
    constant integer HARASS = 32
    constant integer MICRO_HERO = 33
    constant integer RETREAT_CONTROL = 34
    constant integer ARMY_TRACK = 35
    constant integer RALLY_POINT = 36
    constant integer ANCIENT_EXPANSION = 37
    constant integer REPAIR_CONTROL = 38
    constant integer TOWER_RUSH_CHECK = 39
    constant integer ANCIENT_EXPANSION_CHECK = 40
    
    constant integer STRATEGY_TYPE_MELEE = 0
    constant integer STRATEGY_TYPE_RANGED = 1
    constant integer STRATEGY_TYPE_AIR = 2
    constant integer STRATEGY_TYPE_CASTER = 3
    
    constant integer NEUTRAL_TAVERN = 0
    constant integer NEUTRAL_OBSERVATORY = 1
    constant integer NEUTRAL_MERC_CAMP = 2
    constant integer NEUTRAL_DRAGON_ROOST = 3
    constant integer NEUTRAL_HEALING_FOUNTAIN = 4
    constant integer NEUTRAL_MERCHANT = 5
    constant integer NEUTRAL_MANA_FOUNTAIN = 6
    constant integer NEUTRAL_SHIPYARD = 7
    constant integer NEUTRAL_MARKETPLACE = 8
    
    constant integer UPKEEP_UNDECIDED = 0
    constant integer UPKEEP_NOT_ALLOWED = 1
    constant integer UPKEEP_ALLOWED = 2

    constant integer UPKEEP_LOW = 0
    constant integer UPKEEP_HIGH = 1
    constant integer UPKEEP_NUM = 2
    
    constant integer HEALER_TYPE_NO_TARGET = 0
    constant integer HEALER_TYPE_SUDDEN = 1
    constant integer HEALER_TYPE_CONTINUOUS = 2
    constant integer HEALER_TYPE_WARD = 3
    constant integer HEALER_TYPE_HERO = 4

    constant integer UPGRADED = 9999
    
    constant integer BT_UNIT = 0
    constant integer BT_BUILDING = 1
    constant integer BT_HERO = 2
    constant integer BT_UPGRADE = 3
    constant integer BT_ML_UPGRADE = 4
    constant integer BT_RACIAL_ITEM = 5
    constant integer BT_NEUTRAL_HERO = 6
    constant integer BT_MERC = 7
    constant integer BT_GOBLIN_MERC = 8
    constant integer BT_DRAGON = 9
    constant integer BT_MERCHANT_ITEM = 10
    
    constant integer COMPARE_TRUE = 0
    constant integer COMPARE_EQ = 1
    constant integer COMPARE_UNEQ = 2
    constant integer COMPARE_GREATER = 3
    constant integer COMPARE_GREATER_EQ = 4
    constant integer COMPARE_LESS = 5
    constant integer COMPARE_LESS_EQ = 6
	
	constant integer HEALINGITEM_MASS = 0
	constant integer HEALINGITEM_SINGLE = 1
	constant integer MERCHANTITEM_MASS = 2	
	constant integer GLOBALHEALING = 3
	constant integer HEALINGITEM_HERO = 4
	constant integer MANAITEM_HERO = 5
	constant integer ITEMTYPE_SUDDEN = 0
	constant integer ITEMTYPE_CONTINUOUS = 1
	
	constant integer HERO_SKILL_MAJOR = 0
	constant integer HERO_SKILL_MINOR = 1
	constant integer HERO_SKILL_RARE = 2

    real sleep_multiplier = 1  // increases performance by checking stuff not so often
    integer slm_start = 4  // how many computer players is needed tor the sleep multiplier to start increasing
    integer slm_end = 10 // how many computer players is needed tor the sleep multiplier to stop increasing
    real slm_start_mult = 1 // how much is the sleep multiplied when its below the slm_start codition
    real slm_end_mult = 2  // how much is the sleep multiplied when its above the slm_end codition
    real hero_radius = 200  // scanning this small area around hero to detect if the hero gets surrounded by enemy or is in danger of becoming that so it should move
    boolean use_linear_upkeep_saving = false  // should the computers save the upkeep threshold gold over the time above or save it all at once when it get's to the upkeep border?
    integer repair_threshold = 6  // computers only repair buildings if they have more than this many workers
    integer repair_threshold_threatened = 8 // computers only repair buildings when the town is under attack if they got more than this many workers
    real max_follow_dist = 1000  // Max Distance behind the army a zeppelin follows
    integer neutral_hero_time = 25  // when is neutral heroes available in seconds /5
    real buy_timeout_large = 120  // time in seconds the hero goes to a shop before it gives up if it haven't reached it
    real buy_timeout_small = 15  // time in seconds a hero tries to buy items at shop before giving up      
    real buy_distance = 350  // how close to a shop does a unit have to be for buying?
    integer build_array_reset_time = 100  // every this * 5 seconds, the build array is reset    
    integer rp_strat_normal = 250  // normalizing strategy priorities added from strengths with this value
    integer strategy_tier_bonus = 35  // the priority bonus added to a strategy if the computer is in the same tier as specified for the strategy
    integer attacking_strategy = 4       // strategy when attacking enemy players
    real focus_fire_limit = 35	// if a enemy heros hp fall below the computers combined strength of ranged attackers in a battle * this, they will focus fire on the hero
    real focus_fire_ranged_dist = 600 // Distance from ranged units enemy units can be targeted with focus fire
    real focus_fire_melee_dist = 50 // Distance from melee units enemy units can be targeted with focus fire
    real flee_health_percentage = 0.25  // Units flee from battle if the health goes below his % value(0.25 = 25%)
    real flee_minimum_health = 100  // Units flee from battle if the health goes below this    
    real statue_distance = 300  // how near the units a statue used by undead should be in the fights
    real teleport_radius = 800  // units will stay within this radius from a hero that is using town portal  
    integer gold_exchange_level = 650  // computers give extra gold above this value to other computers on the same team in need of gold
    integer wood_exchange_level = 350  // computers give extra lumber above this value to other computers on the same team in need of lumber
    integer max_towns = 5  // how many towns is a computer allowed to have?   
    boolean add_tag = true // Add the [AMAI] tag in front of name
    boolean add_skill = false // Add the current skill after the name    
    integer fav_hero_add = 20  // priority added to heroes to be picked if they are favorites of the used profile       
    integer max_harass_groups = 10  // how many different harass groups you can use    
    integer attacking_aggression = -12  // the base agression value for all computers, higher value and they will play more agressive. Recomended -5 to 5   
    real expansion_radius = 650  // the radius araound a mine computers check for creeps before expanding there
    real harass_radius_attack_ranged = 800  // how far away from ranged enemy units harassing units attack a inferior enemy unit
    real harass_radius_attack_melee = 400  // how far away from melee enemy units harassing units attack a inferior enemy unit
    real harass_radius_flee_ranged = 1200  // how far away from ranged enemy units harassing units turn and flee
    real harass_radius_flee_melee = 800  // how far away from melee enemy units harassing units turn and flee  
    boolean chatting	= true  // set to false to turn off computer taunts and chatting (Can still talk in observer mode)
    real full_threat_distance = 600  // a enemy army within this distance is counted as a full threat
    real no_threat_distance = 3000  // a enemy army outside this distance is counted as no threat
    real distance_threat_exponent = 0.8  // how fast the threat increases as the enemy army gets from the no_threat_distance to the full_threat_distance
    real distance_threat_mult = 540  // how much the threat vlaue goes up on a town when a enemy army aproaches, higher value means higher threat to town
    real atl_time_start = 300  // accepted threat level increase starts at this time
    real atl_time_end = 900    // and ends at that time
    real atl_time_start_val = 10  // it starts with this value
    real atl_time_end_val = 20  // and ends with that value
    real atl_enemy_start = 1 // accepted threat level multiplier increases at that enemy number
    real atl_enemy_end = 4   // until that enemy number
    real atl_enemy_start_mult = 1  // the multiplier starts for accepted threat level starts with this
    real atl_enemy_end_mult = 1.5    // and ends with this    
    real teleport_low_threat = 40  // Army uses TP to get home and defend if a threat is greater than this
    real teleport_high_threat = 80  // Army uses TP to get home and defend if a threat is greater than this
    real teleport_low_threat_distance = 6000  // Army won't use TP home if they are closer to base than this and a low threat level appears
    real teleport_high_threat_distance = 3000  // Army won't use TP home if they are closer to base than this and a high threat level appears
    real teleport_army_min_strength = 20  // how big the army need to be for use of TP to threatened town
    real teleport_min_threat = 70  // minimum threat level TP use is allowed on  
    integer shredder_peon_count = 6  // how many peons does a goblin shredder replace in lumber harvesting
    integer minimum_peon_wood = 2000 // computers don't build any workers for lumber harvesting if they have more lumber than this
    integer maximum_peon_wood = 200  // computers build all needed workers for lumber harvesting if they have lumber lower than this  
                 

   boolean ver_neutral_heroes_available = true  // does the version have neutral heroes ?
   integer ver_neutral_hero_number = 6  // how many neutral heroes ?
   boolean ver_only_heroes_buy = false  // can only heroes buy stuff ?
   integer ver_food_limit = 100  // what is the food limit ?
   integer ver_strat_change_enemy_strength_min = 25  // don't allow strategy change unless the maximum strength of all enemy players in the game is above this.
   integer ver_hero_base_value = 4  // what is the base strength of a hero (the level number is added to get the actual strength) ?
   integer ver_hero_ultimate_level = 6  // at what level do the heroes get their ultimates ?
   integer ver_hero_ultimate_value = 4  // how much extra strength does the ultimate give to the hero ?
   real ver_creeps_attack_buildings_dist = 1000  // how far away do creeps attack buildings ?
   boolean ver_mercs_night_buy = false // can mercs be bought at night without waking up creeps ?
   real ver_tower_check_radius = 2000  // check for towers in this radius around a target
   real ver_harass_tower_check_radius = 1400  // check for towers in this radius during harassing
   integer ver_optimal_gold = 5  // The optimal number of peons that should be harvesting gold
   real ver_flee_multiple1 = 1  // Multiplier to players strength at lowest aggression to measure if amai is allowed to flee
   real ver_flee_multiple2 = 2  // Multiplier to players strength at highest aggression to measure if amai allowed to flee
   real ver_flee_multiple3 = 3  // Multipler to players strength at highest aggression to measure if amai will flee
   real ver_low_aggression = -15  // Aggression below this uses the lowest strength flee multiplier
   real ver_high_aggression = 45  // Agression above this uses the highest strength flee multiplier

   

   
    integer hero1_revive_prio = 200  // priority for reviving hero1
    integer hero2_revive_prio = 120  // priority for reviving hero2
    integer hero3_revive_prio = 80  // priority for reviving hero1
    integer prio_n_inc = 2  // priority increase for building needed buildings
    integer prio_t_inc = 1  // priority increase in time
    integer prio_q_inc = 2  // priority increase in quantity
    integer farm_food2 = 1 // builds another farm at the same time when this near food used to food produced
    integer farm_prio = 400 // priority for farm building
    integer peon_prio = 280 // priority for peon building
	integer ghoul_prio = 250  // priority for ghoul building
    integer expa_prio = 200 // priority for expansion building
    integer expa_emergency_prio = 300  // priority for rebuilding an expansion
    integer expa_rebuild_prio = 200 // priority for rebuilding an expansion
    integer peon_1_mine_number = 15 // maximum number of peons to build when 1 mine is owned (redundent if race uses ghouls)
    integer peon_2_mines_number = 20 // maximum number of peons to build when 2 mines are owned (redundent if race uses ghouls)
    integer peon_mines_number = 24  // maximum number of peons to build when more mines are owned (redundent if race uses ghouls)
    integer min_peon_number_single_mine = 6 // minimum number of peons when 1 mine is owned
    integer min_peon_number_multi_mine = 11 // minimum number of peons when more than 1 mine is owned
    integer strat_food_persistence = 2  // * current food use added to priority for current strategy (prevents computers from changing styrategy when having large army)
    integer relevant_strat_change_number = 3   // number of strategies with highest RPs that can be chosen when changing strategy
    integer kb_add1 = 8  // priority added to all strategies having a building the computer already got as a key building
    integer kb_add2 = 9  // priority added to all strategies having a building the computer already started to build as key building
    integer kb_add3 = 7  // priority added to all strategies having both building the computer already got as key buildings
    integer kb_add4 = 10 // value for 2 of a key buildings
    integer ku_add1 = 4  // priority added to all strategies having a upgrade the computer already got as key upgrade in first level
    integer ku_add2 = 7  // priority added to all strategies having a upgrade the computer already got as key upgrade in second level
    integer ku_add3 = 8  // priority added to all strategies having a upgrade the computer already got as key upgrade in third level
    integer fav_unit_add = 20  // priority added to strategies havign the current profiles favorite unit as key units.
    integer debug_strategy = -1  // this race is locked to this strategy number for testing.(-1 is unlocked) 
    boolean race_use_fountain = true  // does the race use healing fountains ?
    boolean race_manual_loading = true  // does the race need manual loading of wisps in goldmines ?
    integer race_manual_loading_wisp = 0 //
    integer race_manual_loading_mine = 0 //
    boolean race_towerrush_available = false  // does the race have a towerrush ?
    integer race_towerrush_requirement = 0  // what is the building required to build towers ?
    integer race_tower_id = 0  // what is the id of the races towers?
    integer race_tower_upgrade = 0  //what is the id of the tower upgrade ?
    integer race_towerrush_probability = 33 // how high (in percent) is the probability of doing a tower rush?
	integer race_towerrush_hero_rush_level = 2   // the bonus strength value hero must have to be able to do the tower rush
    boolean race_militia_expansion_available = false  // does the race have a militia expansion ?
    integer race_hero_number = 4  // how many racial heroes ?
    integer race_simple_melee = 0  // a basic melee unit, only necessary when basic_melee is used
    integer race_advanced_melee = 0  // an advanced melee unit to replace the basic one, only necessary when basic_melee is used
    boolean race_has_ghouls = false  // has the race a ghoul-like wood harvester/fighter unit ?
    boolean race_ghouls_attack = true  // do those ghouls go with the army on attacks ?
	integer race_min_ghouls = 2  // smallest number of ghouls to build at all times
	integer race_max_ghouls = 5  // maximum number of ghouls to build in low lumber situations
    boolean race_has_power_build = false  // can multiple racial workers work on the same building ?
    boolean race_no_wood_harvest = false  // has the race no wood harvesters ?
    boolean race_ignore_injured = false  // should the race leave injured units at home ?
    boolean race_uses_mine_expansion = false  // does the race expand with a mine building like undead ?
    boolean race_uses_shredder = true  // does the race use the goblin shredder ?
    boolean race_militia_available = false  // does the race have militia ?
    real race_militia_max_distance = 1000  // how far away from the town hall are the militia allowed ?
    integer race_militia_id = 'hmil'  // what is the militia unit type id?
    integer race_militia_ability = 'Amil'  // what is the militia ability id ?
    integer race_militia_hall_ability = 'Amic'  // what is the militia ability of the hall ?
    string race_militia_unitstring = "militia"  // what is the unitstring/name of the militia ?
    string race_militiaworker_unitstring = "peasant"  // what is the string of the unit that can be turned to militia ?
    boolean race_ancient_expansion_available = false  // can the race expand with an uprooted building that also helps fighting the creeps ?
    integer race_ancient_expansion_probability = 33  // how high (in percent) is the probability of doing an ancient expansion when possible ?
    integer race_ancient_expansion_strength = 15  // up to how much expansion strength is an ancient expansion allowed ?
    integer race_ancient_expansion_help_id = 'earc'  // the unit id of the unit that should help in ancient expansion
	integer race_ancient_expansion_hero_rush_level = 2  // the bonus strength value hero must have to be able to do the ancient expansion
    boolean race_sell_ziggurats = false  // does the race sell ziggurats that are at no more needed expansions ?
    real race_ziggurat_keep_distance = 1500  // keep ziggurat if this near another building except a ziggurat is
    boolean race_build_farms_front = false  // should the race build farms towards the front (as soon as the front is computed) ?
    integer race_farms_front_limit = 4  // limit the number of farms at the front to this number
    integer race_farms_at_mine = 0  // the first that many farms will be built at the mine
    real race_max_expa_mine_distance = 850  // the maximum distance between the mine and the expansion building
    integer min_peon_number_double_mine = 11  // minimum number of peons when 2 mines are owned
    boolean race_has_moonwells = false  // Racial farms have healing properties
	


    boolean destroy_buildings_on_defeat = true  // Should the buildings of the AI be destroyed on defeat or given to neutral player ?
    integer attack_reform_length = 20  // reform the attack group (getting new units) every that time on an attack (in seconds / 2)
    real front_base_distance = 1100  // the distance of the front locations from the start location
    boolean ver_heroes = true  // Does this version have heroes?
    boolean fixedcomputername = false  // Enable to force computers to have there fixed name instead of a profile name
    integer green_creep_camp_strength_bonus = 0  // Bonus strength added to minor creep camps
    integer orange_creep_camp_strength_bonus = 5  // Bonus strength added to mediocre creep camps
    integer red_creep_camp_strength_bonus = 10  // Bonus strength added to major creep camps
	boolean disable_surrender = false  // Set to true to stop amai from giving up early when it detects its going to lose
	real strategy_change_threshold = 1.2  // New strategy priority must be larger than this (default 1.20) multiple to the current strategy prority
    boolean debugging = false  // Can turn on for debugging mode to display debug type messages
    integer major_hero_skill_value = 60  // Priority to choose the first line of hero skills
    integer minor_hero_skill_value = 30  // Priority to choose the second line of hero skills
    integer rare_hero_skill_value = 10  // Priority to choose the third line of hero skills

	boolean IsAMAI = false
    boolean leadally = false
	
	boolean campaign_ai = false

    string language = "English"
    
    string ai_id = ""
    
    string message_add = ""
    
    real command_wait = 3
    
    real time_of_day = 0
    
    boolean water_map = false
    
    string array digit_map
    
    integer array player_race
    integer array player_race_pref
    string array race_name
    
    boolean game_is_ffa = false
    boolean game_is_1on1 = false


    integer total_food              = 0
    integer wood_buffer             = 0
    real    gold_income             = 0
    integer income_per_mine         = 3000
    real    gold_unit_percentage    = 0.9


    integer racial_peon	= 0
    integer array racial_hall
	integer array racial_goldmine
	integer minearray = 0
	integer array racial_zigg
	integer ziggarray = 0
    integer racial_expansion	= 0
    integer racial_altar	= 0
    integer racial_shop = 0
    integer racial_militia = 0
    integer racial_militiahero = 0
    integer racial_ghoul = 0
	integer racial_lumber = 0
    integer neutral_shredder = 0
    integer neutral_zeppelin = 0
    integer tp_item = 0
    integer tiernum = 3

    integer array hero
	integer array hero_skills // The skill line chosen for the hero, major, minor or rare
    integer array skills
    integer array tempskills
    integer array allskills
    integer first_choosable_hero = 0
    boolean array hero_built
    integer array hero_revive_prio
    unit array hero_unit
    integer array all_heroes
	integer array all_heroes_copy
    integer array hero_rp
    integer hero_number = 0
    integer chosen = 0
    
    real array action_points
    integer action_numbers = 0
    
    real enemy_density = 0
    location enemy_density_loc = null
    real ally_density = 0
    location ally_density_loc = null
    
    real nearest_enemy_range = 10000000
    player nearest_enemy = null
    
    integer array upkeep_allowed
    integer array last_upkeep_allowed
    integer array upkeep_border
    integer array upkeep_resistance
    integer array upkeep_save_time
    integer array upkeep_time
    integer array upkeep_mines_needed

    integer array attack_qty
    integer array attack_max
    integer array attack_units
    integer attack_length           = 0

	//==============================================================
    // (AMAI)  Build Variables
    //==============================================================
    integer array build_prio
    integer array build_loc

    integer array t_build_qty
    integer array t_build_type
    integer array t_build_item
    integer array t_build_town
    integer array t_build_prio
    integer array t_build_loc
    integer t_build_length            = 0

    integer array bl_req_qty
    integer array bl_req_type
    integer array bl_allow_qty
    integer array bl_allow_type
    integer array bl_expire_time
    boolean array bl_only_done
    integer bl_length = 0
    integer blocked_gold = 0
    integer blocked_wood = 0
	integer blocked_food = 0
    
    integer array rbl_req_gold
    integer array rbl_req_wood
	integer array rbl_req_food   // Food required before building unit
    integer array rbl_allow_qty
    integer array rbl_allow_type
    integer array rbl_expire_time
    integer rbl_length = 0

    boolean build_lock = true

	//==============================================================
    // (AMAI)  Standard Unit Variables
    //==============================================================
    integer array old_id
    integer array needed1  // needed building and factory if unit
    integer array needed2  // needed building 2
    integer array needed3  // needed for upgrade level 3
    integer array build_free // free buildings
    integer array gold_sum
    integer array build_time_sum
    integer array build_num
    real array income_percentage
    integer array prio_sum
    integer array tc_add1  // building that has to be added for TownCount
    integer array tc_add2  // building that has to be added for TownCount
    integer array available_time
    integer array regenerate_time
    integer array attacking_max_num
    integer array upgrade_time
    integer array gold_price
    integer array wood_price
	integer array hero_rush_bonus
    integer array buy_type
    
    integer array building
    integer building_length = 0

    integer array campaign_defenders
    
    integer array creep_strength
    integer creep_strength_length = 0

    unit follow_zeppelin = null
    boolean zeppelin_following = false

    boolean array neutral_available
    unit array nearest_neutral
    group array neutral_guards
    boolean array neutral_guarded
    integer array neutral_enemy
    boolean array neutral_ordered
    unit array neutral_sent
    boolean array neutral_night_buy
    integer array neutral_id
    real array buy_time_large
    real array buy_time_small
    integer array neutral_wanted
    boolean no_sleep = false
    integer array dragons
    integer array merc_unit
    integer merc_number = 0
	integer dragon_number = 0
    integer merc_healer = 0
    integer merc_caster = 0
    integer merc_melee = 0
    integer merc_range = 0
    integer merc_stopper = 0
    integer merc_rush = 0

    integer minimum_attack_strength = 11

    integer max_farms = 0

    integer exp_time_count = 0
    integer exp_first_time = 30
    integer exp_second_time = 180
    real expansion_taken_radius = 1000  // the radius around a mine where enemy or allied buildings are considered as possessing that mine (it is considered taken then)

    integer creep_camp_radius = 550
    integer camp_scan_depth = 3
    integer camp_last_checked = 40

    integer air_strength = 0
    integer array p_str_cache
    integer array p_str_cache_timeout
    integer p_str_cache_valid_time = 2

    boolean ai_no_creep = false
    boolean town_threat_break = true
    //boolean captain_flee = true

    integer strategy = 0
    integer chosen_strategy = 0
    integer last_strategy = 100
    string array strategy_name
    string array strategy_default_name
    string array strategy_default_report
    integer array key_building1
    integer array key_building2
    integer array key_upgrade1
    integer array key_upgrade2
    integer array key_unit
    integer array rp_strat
    integer array rp_strat_sort
    boolean array beginning_strat
    integer array strat_minimum_time
    integer rp_strat_length	= 0
    integer rp_strat_sort_length = 0
    integer small_map_tier1_bonus = 20
    real k_add_start_mult = 3
    real k_add_end_mult = 1
    real k_add_start_time = 120
    real k_add_end_time = 1200
    boolean array strategy_type_used
    integer array strategy_type
    integer strategy_type_used_penalty = 30
    integer array strategy_tier
    integer array strategy_first_exp_time
    integer array strategy_second_exp_time
    integer array strategy_first_hero
    integer array strategy_first_hero_bonus
    integer array strategy_second_hero
    integer array strategy_second_hero_bonus
	integer array strategy_third_hero
	integer array strategy_third_hero_bonus
    integer array strategy_race_aggression

    boolean attacking_expansion = false
	boolean recalculate_heros = false // Tavern heros cannot be trained so get a normal hero
	
    integer tier = 0
    integer own_strength	= 0
    integer uncertainty	= 10
    integer tower_factor	= 10
    integer array race_aggression
    integer array b_race_aggression
    integer added_aggression = 0  // aggression added when upkeep becomes higher
    boolean h_siege	= false
    unit alli_target = null
    integer expansion_target_bonus = 7
    integer comp_chosen_target_bonus = 5
    real comp_chosen_target_rate = 0.5

    boolean balancing	= false
    
    group healer_group = CreateGroup()
    boolean ward_cast = false
    
    group urgent_healing_group = CreateGroup()
    group medium_healing_group = CreateGroup()
    group small_healing_group = CreateGroup()
    integer urgent_healing_count = 0
    integer medium_healing_count = 0
    integer small_healing_count = 0
    boolean fountain_available = false
    
    unit item_unit = null
    
    integer array healer_id
    integer array healer_spell
    integer array healer_type
    integer array healer_mana_cost
    integer array healer_upg_id
    integer array healer_upg_level
    integer healer_length = 0

    integer array c_enemy  // number of enemy players of certain races or random
    integer c_enemy_total	= 0
    integer array c_ally   // number of allied players of certain races
    integer c_ally_total	= 0
    integer c_ai_total = 0
    boolean enemy_revealed	= false
    integer strat_prev		= 0 // strategy chosen by the ai before this one
    integer hero_prev		= 0 // hero chosen by the ai before this one
    integer picked_hero		= 0
    boolean first_ai		= true
    integer next_ai		= 0
    boolean no_ai_ally	= false
    boolean no_ally_ctrl 	= true

    boolean player_defeated	= false

    real enemy_air		= 0
	real ally_air		= 0
    real enemy_casters		= 0
	real ally_casters		= 0
    real enemy_towers		= 0
	real ally_towers		= 0
    real enemy_piercing		= 0
	real ally_piercing		= 0
    real enemy_normal		= 0
	real ally_normal		= 0
    real enemy_siege		= 0
	real ally_siege		= 0
    real enemy_magic		= 0
	real ally_magic		= 0
    real enemy_unarmored		= 0
	real ally_unarmored		= 0
    real enemy_lightarmor		= 0
	real ally_lightarmor		= 0
    real enemy_mediumarmor		= 0
	real ally_mediumarmor		= 0
    real enemy_heavyarmor		= 0
	real ally_heavyarmor		= 0
    
    unit build_zeppelin = null

    boolean array town_built
    location array own_town_loc
    real array own_town_dist
    unit array own_town_mine

    integer attacking_ghouls          = 0
	integer harvesting_ghouls		= 0

    integer ai_time = 0

    integer tq_length = 0
    real array tq_time
    integer array tq_jid
    integer array tq_par
    unit array tq_unit_par
    group array tq_group_par
    boolean tq_lock = true
    timer tq_timer = CreateTimer()

    boolean attack_running = false
    boolean no_attack_allowed = false

    integer order_cancel = 851976
    integer order_attack = 851983

    sound chatSound = CreateSound( "Sound\\Interface\\InGameChatWhat1.wav", false, false, false, 10, 10, "" )
    sound importantSound = CreateSound( "Sound\\Interface\\CreepAggroWhat1.wav", false, false, false, 10, 10, "" )

    boolean array chat_target_obs
    boolean array chat_target_ally
    boolean array chat_target_enemy
    boolean array chat_important
    string array chat_list
    string array chat_list_race
    integer array chat_list_eq
    integer chat_list_length = 0
    string chat_race = ""
    integer chat_eq = 0
    constant integer C_STRATEGY = 0
    
    string array chat_AGG
    integer chat_AGG_length = 0
    constant integer C_AGG = 1
    string array chat_Ally
    integer chat_Ally_length = 0
    constant integer C_Ally = 2
    string array chat_Attack
    integer chat_Attack_length = 0
    constant integer C_Attack = 3
    string array chat_Creep
    integer chat_Creep_length = 0
    constant integer C_Creep = 4
    string array chat_Done
    integer chat_Done_length = 0
    constant integer C_Done = 5
    string array chat_EGG
    integer chat_EGG_length = 0
    constant integer C_EGG = 6
    string array chat_Expansion
    integer chat_Expansion_length = 0
    constant integer C_Expansion = 7
    string array chat_Goldproblem
    integer chat_Goldproblem_length = 0
    constant integer C_Goldproblem = 8
    string array chat_Greet
    integer chat_Greet_length = 0
    constant integer C_Greet = 9
    string array chat_Mega
    integer chat_Mega_length = 0
    constant integer C_Mega = 10
    string array chat_Megatarget
    integer chat_Megatarget_length = 0
    constant integer C_Megatarget = 11
    string array chat_Taunt
    integer chat_Taunt_length = 0
    constant integer C_Taunt = 12
    string array chat_Thanks
    integer chat_Thanks_length = 0
    constant integer C_Thanks = 13

    string chat_no_unit_selected    = ""
    string chat_confirm_attack_unit = ""
    string chat_towerrush = ""
    string chat_no_orc = ""
    string militia_expansion_chat = ""
    
    gamecache translation_map = InitGameCache("AMAI_TM.w3v")
    string array translation
    integer translation_length = 0
    
    gamecache additional_info = InitGameCache("AMAI_AI.w3v") // Used for harrass data
    gamecache com = InitGameCache("AMAI_Com.w3v")
	gamecache settings = InitGameCache("AMAI_Set.w3v")
    
    string array char_table
    string array chat_vars
    integer chat_vars_length = 1
    gamecache chat_vars_map = InitGameCache("AMAI_CVM.w3v")


    integer area_uncertainty		= 10
    integer force_number	= 0
    player array own_force
    integer gold_problem_level = 0
    unit double_expansion_target = null
    unit nearby_enemy_building = null

    unit major_hero = null
    real battle_radius = 1500
    real normal_battle_radius = 1500  // units within that radius are considered belonging to the current battle
    real creep_battle_radius = 750  // same as with normal_battle_radius, but for battles against creeps
    boolean retreat_controlled = false
    location home_location = null
    real enemy_strength_sum = 0
    real ally_strength_sum = 0
	boolean isfleeing = false
	integer added_target_aggression = 0  // The current bonus aggression added to current attack specified in the profiles
	integer added_racial_aggression = 0  // The current bonus added to current attack based on which race amai is attacking
	
    location enemy_loc = Location(0,0)
    location last_enemy_loc = Location(0,0)
    location ally_loc = Location(0,0)
    location last_ally_loc = Location(0,0)	
    unit shop_sent = null
    boolean shop_ordered = false
    real shop_buy_time_small = -1
    real shop_buy_time_large = -1
    integer shop_wanted = 0
    unit shop_unit = null
    real shop_distance_limit = 100000
    real raceshop_distance_limit = 100000
    real merchant_distance_limit = 5000
	boolean retreat_home = false
	boolean ismoving = false
	real buyX
	real buyY
	
	group going_home_group = CreateGroup()
	group buying_group = CreateGroup()
	
    constant integer ACTION_DO_NOTHING = 0
    constant integer ACTION_GO_HOME = 1
    constant integer ACTION_FOUNTAIN = 2
    constant integer ACTION_TP = 3
    constant integer ACTION_ZEPPELIN_HOME = 4
    constant integer ACTION_ZEPPELIN_FOUNTAIN = 5
    constant integer ACTION_HEALER = 6
    constant integer ACTION_MANA_FOUNTAIN = 7
	constant integer ACTION_MOONWELLS = 8
    
    location array hero_loc
    location array hero_dir
    real array hero_hp
    real array hero_hp_loss
    real array hero_enemy_density
    location array hero_enemy_loc
    real array hero_ally_density
    location array hero_ally_loc
    

    group unit_healing = CreateGroup()
    group unit_rescueing = CreateGroup()
    group unit_harassing = CreateGroup()
    group unit_zepplin_move = CreateGroup()
	group unit_buying_item = CreateGroup()
	group unit_buying_merc = CreateGroup()
	group unit_buying_tavern = CreateGroup()

    constant integer ZTARGET_HOME = 0
    constant integer ZTARGET_FOUNTAIN = 1
	constant integer ZTARGET_MOONWELLS = 2
	boolean zepdropping = false	// Currently ordering unit to exit zepplin
    boolean teleporting = false
    constant integer HARASS_TARGET_PEONS = 0
    constant integer HARASS_TARGET_EXPANSION = 1
    constant integer HARASS_TARGET_LOCATION = 2
    constant integer HARASS_TARGET_MAIN_HALL = 3
    

    integer array harass_time
    integer array harass_size
    integer distraction_group = 0
    integer array army_owner
    location array army_loc
    location array army_dir
    location array army_future
    real array army_strength
    group array army_group
    integer array army_count
    integer army_num = 0
    real army_radius = 1200
    real army_future_mult = 3
    group in_army_group = CreateGroup()
    integer main_army = -1
      
    boolean town_threatened = false
    integer array town_owner
    location array town_loc
    real array town_value
    real array town_threat
    group array town_group
    integer array town_count
    integer array town_threat_army
    boolean array town_can_tp
    integer most_threatened_town = -1
    integer most_threatened_enemy_town = -1
    integer town_num = 0
    real town_radius = 2500
    group in_town_group = CreateGroup()
    boolean militia_allowed = false
    boolean militia_check_enabled = true
    unit militia_hall = null
    boolean use_militia_only_on_bigger_threats = false

    boolean towerrush = false
    unit array builder
    location tower_target_loc = null
    real first_tower_point_x = 0
    real first_tower_point_y = 0
    real enemy_point_x = 0
    real enemy_point_y = 0
    integer towers_built = 0
    player rushedplayer = null
	location toweringplayerloc = null
    integer ancient_exp_state = 0
	integer ancient_exp_count = 0
    location ancient_exp_loc = null
    unit ancient_exp_wisp = null
    unit ancient_exp_unit = null
    group ancient_exp_group = CreateGroup()
	boolean ancient_attack_running = false

   boolean ancient_expanding = false
   integer OrderIdCancel = 851976
	group windwalk_group = CreateGroup()
    group focus_fire_group = CreateGroup()
	group micro_ranged_group = CreateGroup()
	group micro_enemymelee_group = CreateGroup()
    location last_major_hero_loc = Location(0,0)
	location enemy_melee_loc = Location(0,0)
	unit focus_fire_unit = null
	unit nearest_moon_well = null

    boolean town_hall_built = false
    real last_expansion_x = 0
    real last_expansion_y = 0
    real next_expansion_x = 0
    real next_expansion_y = 0
    boolean expansion_changed = false
	

boolean militia_expanding = false
boolean militia = true
integer militia_time_count = 0
integer militia_time_out = 100  // value * 3 seconds
integer militia_state = 0
unit militia_builder = null
unit militia_fastb1 = null
unit militia_fastb2 = null
unit militia_fastb3 = null
unit militia_expansion = null
location militia_loc = null



	boolean creeping_only = false

    boolean break_attack 	= false
    boolean go_home		= false
    boolean attack_player	= false
    boolean attack_point	= false
    boolean attack_unit		= false
    boolean no_attack		= false
    boolean no_creep_attack	= false
    boolean no_player_attack	= false
    boolean strat_change_allowed = true
    integer attack_target_p	= 0
    integer attack_target_x	= 0
    integer attack_target_y	= 0
    integer bn_airair = 0
    integer bn_airground = 0
    integer bn_groundair = 0
    integer bn_groundground = 0
    integer bn_farm = 0
    integer bn_guard = 0
    unit 	target_unit = null
    integer array target_queue_x
    integer array target_queue_y
    unit    array target_queue_u
    integer queue_length	= 0
    integer queue_pointer	= 0
    boolean queue_running	= false
    boolean queue_attack_p	= false
    boolean queue_attack_u	= false
    integer queue_t_x		= 0
    integer queue_t_y		= 0
    unit	queue_t_u = null


    integer profile_length      = 0
    integer profile            = 0
    integer debug_profile = -1

    string ai_name = "Computer"
    integer own_race = 0
	real taunt_rate = 1.00 // how man % of the time computers taunt, set by profiles. Recommended values 0.50 to 1.50
    integer taunt_start_time = 60  // the time for the computers to start taunting (in seconds * 5)
    integer farm_food = 8 // build farm when this near food used to food produced
    integer strat_persistence = 1000  // extra priority to the current strategy to make computer not change strategy too fast  

	// Profile settings
    string array profilename
    integer array fav_hero
    integer array fav_unit
    integer array p_race  // Desired race for the profile to be picked (default random)
    integer array p_aggression  // aggression modify to total attacking_aggression. reccomended -10 to 10
    integer array p_uncertainty  // adds or subtracts this value to the enemies strength every so often. reccomended 5 to 15
    integer array p_minimum_attack_strength  // How much strength required before amai can start attacking. reccomended 3 to 6
    integer array p_farm_food  // How much food to have left before building a new farm
    integer array p_exp_first_time  // Make amai build expansion earlier or later by this number of seconds. reccomended -10 to 10
    integer array p_exp_second_time
    integer array p_strat_persistence  // How persistance amai is to keep its current strategy. reccomended 1.05 to 2.00
    integer array p_expansion_target_bonus  // aggression bonus for expansion targets
    integer array p_comp_chosen_target_bonus  // aggression bonus for targets chosen by the hard coded AI
    integer array p_surrender  // How likly amai will give up, 0 being never give up and 4 being give up really easily
    real array p_gold_unit_percentage  // The higher this is the more unit production buildings are constructed. reccomended 0.9 to 1
    real array p_taunt_rate // Will display a taunt every 5th second for this percent of the time. Reccomended 1 to 2
    real array p_comp_chosen_target_rate  // how often the computer considers an attack target chosen by the hard coded AI


    real path_top = GetCameraBoundMaxY()+GetCameraMargin(CAMERA_MARGIN_TOP)
    real path_bottom = GetCameraBoundMinY()-GetCameraMargin(CAMERA_MARGIN_BOTTOM)
    real path_left = GetCameraBoundMinX()-GetCameraMargin(CAMERA_MARGIN_LEFT)
    real path_right = GetCameraBoundMaxX()+GetCameraMargin(CAMERA_MARGIN_RIGHT)
    //rect playable_rect = Rect(path_left, path_bottom, path_right, path_top)

    unit array expansion_list
	location array expansion_ancient
    real array expansion_dist
	group array expansion_creeps
    integer expansion_list_length = 0
    
    unit array water_expansion_list
    integer water_expansion_list_length = 0
    
    unit expansion_peon = null
    location exp_loc_cache = Location(0,0)
    integer exp_loc_cache_timeout = 0
    
    integer exp_number = 0
    integer array exp_rp
    unit array exp_unit
    real array exp_dist
	location array exp_ancient
	group array exp_creeps
	
    group current_expansion_creeps = CreateGroup()
    unit current_expansion = null
    boolean first_expansion_chosen = false
    unit not_taken_expansion = null
    
    integer confirm_count = 0
    integer array ai_force
    integer ai_force_length = 0
    boolean pathing_receive_finished = false

    integer home_field = 0
    
    location mine_loc = null
    location array front_loc   // the locations along the frontier of the main base (on the way to the enemies and a certain distance from the base)
    integer front_loc_num = 0  // the number of front locations
    boolean front_locs_computed = false  // are the front points computed ?

    integer udg_unique_counter = 0
    gamecache udg_debug_cache = null
    string udg_current_category = null
    timer udg_debug_timer = CreateTimer()
	boolean job_debug = false	// Job system reports will be displayed (used for finding thread crashes)

		integer array dyanti_air
		integer totalanti_air = 0
		integer array dychance_air
		integer totalchance_air = 0
		integer array dyanti_casters
		integer totalanti_casters = 0
		integer array dychance_casters
		integer totalchance_casters = 0
		integer array dyanti_towers
		integer totalanti_towers = 0
		integer array dychance_towers
		integer totalchance_towers = 0
		integer array dyanti_piercing
		integer totalanti_piercing = 0
		integer array dychance_piercing
		integer totalchance_piercing = 0
		integer array dyanti_normal
		integer totalanti_normal = 0
		integer array dychance_normal
		integer totalchance_normal = 0
		integer array dyanti_siege
		integer totalanti_siege = 0
		integer array dychance_siege
		integer totalchance_siege = 0
		integer array dyanti_magic
		integer totalanti_magic = 0
		integer array dychance_magic
		integer totalchance_magic = 0
		integer array dyanti_unarmored
		integer totalanti_unarmored = 0
		integer array dychance_unarmored
		integer totalchance_unarmored = 0
		integer array dyanti_lightarmor
		integer totalanti_lightarmor = 0
		integer array dychance_lightarmor
		integer totalchance_lightarmor = 0
		integer array dyanti_mediumarmor
		integer totalanti_mediumarmor = 0
		integer array dychance_mediumarmor
		integer totalchance_mediumarmor = 0
		integer array dyanti_heavyarmor
		integer totalanti_heavyarmor = 0
		integer array dychance_heavyarmor
		integer totalchance_heavyarmor = 0
	
endglobals


  // Global Utility Functions ( A collection of functions used for debugging and
  // language utilities. Also contains the algorithm functions e.g. hashmaps etc)

function H2I takes handle h returns integer
  return h
  return 0
endfunction

 
 
 

 

function String2Int takes string s returns integer
  return s
  return 0
endfunction

function DoNothing takes nothing returns nothing
endfunction

function InitAMAIGameCache takes nothing returns nothing
	call FlushGameCache(InitGameCache("AMAI_TM.w3v"))
	call FlushGameCache(InitGameCache("AMAI_AI.w3v"))
	call FlushGameCache(InitGameCache("AMAI_Com.w3v"))
	call FlushGameCache(InitGameCache("AMAI_Set.w3v"))
	call FlushGameCache(InitGameCache("AMAI_CVM.w3v"))
    set translation_map = InitGameCache("AMAI_TM.w3v")
    set additional_info = InitGameCache("AMAI_AI.w3v")
    set com = InitGameCache("AMAI_Com.w3v")
	set settings = InitGameCache("AMAI_Set.w3v")
    set chat_vars_map = InitGameCache("AMAI_CVM.w3v")
endfunction
	
function c2s takes playercolor c returns string
if c == PLAYER_COLOR_RED then
    return "|c00ff0000"+ai_name+"|r: "
elseif c == PLAYER_COLOR_BLUE then
    return "|c000000ff"+ai_name+"|r: "
elseif c == PLAYER_COLOR_CYAN then
    return "|c0000ffff"+ai_name+"|r: "
elseif c == PLAYER_COLOR_PURPLE then
    return "|c00660099"+ai_name+"|r: "
elseif c == PLAYER_COLOR_YELLOW then
    return "|c00ffff00"+ai_name+"|r: "
elseif c == PLAYER_COLOR_ORANGE then
    return "|c00ff9933"+ai_name+"|r: "
elseif c == PLAYER_COLOR_GREEN then
    return "|c0000ff00"+ai_name+"|r: "
elseif c == PLAYER_COLOR_PINK then
    return "|c00dd00ff"+ai_name+"|r: "
elseif c == PLAYER_COLOR_LIGHT_GRAY then
    return "|c00dddddd"+ai_name+"|r: "
elseif c == PLAYER_COLOR_LIGHT_BLUE then
    return "|c0033ccff"+ai_name+"|r: "
elseif c == PLAYER_COLOR_AQUA then
    return "|c007fffd4"+ai_name+"|r: "
else //Brown
    return "|c00660000"+ai_name+"|r: "
endif
endfunction

function AMAIPercentToInt takes real percentage, integer max returns integer
    local integer result = R2I(percentage * I2R(max) * 0.01)

    if (result < 0) then
        set result = 0
    elseif (result > max) then
        set result = max
    endif

    return result
endfunction

function AMAIPercentTo255 takes real percentage returns integer
    return AMAIPercentToInt(percentage, 255)
endfunction

function CreateDebugTag takes string s, real fontsize, unit u, real lifespan, real fadespan returns nothing
	local texttag tt = null
    local playercolor c = GetPlayerColor(ai_player)	

	if debugging then
	set tt = CreateTextTag()
	call SetTextTagText(tt, s, ( fontsize * 0.023 / 10))  // *0.023/10 creates the correct font size from given real
    call SetTextTagPosUnit(tt, u, 0)	
	if c == PLAYER_COLOR_RED then
		call SetTextTagColor(tt, AMAIPercentTo255(100), AMAIPercentTo255(0), AMAIPercentTo255(0), AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_BLUE then
		call SetTextTagColor(tt, AMAIPercentTo255(0), AMAIPercentTo255(0), AMAIPercentTo255(100), AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_CYAN then
		call SetTextTagColor(tt, AMAIPercentTo255(0), AMAIPercentTo255(100), AMAIPercentTo255(100), AMAIPercentTo255(100-0))
	elseif c == PLAYER_COLOR_PURPLE then
		call SetTextTagColor(tt, AMAIPercentTo255(40), AMAIPercentTo255(0), AMAIPercentTo255(60), AMAIPercentTo255(100-0))	
	elseif c == PLAYER_COLOR_YELLOW then
		call SetTextTagColor(tt, AMAIPercentTo255(100), AMAIPercentTo255(100), AMAIPercentTo255(0), AMAIPercentTo255(100-0))	
	elseif c == PLAYER_COLOR_ORANGE then
		call SetTextTagColor(tt, AMAIPercentTo255(100), AMAIPercentTo255(60), AMAIPercentTo255(20), AMAIPercentTo255(100-0))	
	elseif c == PLAYER_COLOR_GREEN then
		call SetTextTagColor(tt, AMAIPercentTo255(0), AMAIPercentTo255(100), AMAIPercentTo255(0), AMAIPercentTo255(100-0))	
	elseif c == PLAYER_COLOR_PINK then
		call SetTextTagColor(tt, AMAIPercentTo255(87), AMAIPercentTo255(0), AMAIPercentTo255(100), AMAIPercentTo255(100-0))	
	elseif c == PLAYER_COLOR_LIGHT_GRAY then
		call SetTextTagColor(tt, AMAIPercentTo255(87), AMAIPercentTo255(87), AMAIPercentTo255(87), AMAIPercentTo255(100-0))	
	elseif c == PLAYER_COLOR_LIGHT_BLUE then
		call SetTextTagColor(tt, AMAIPercentTo255(20), AMAIPercentTo255(80), AMAIPercentTo255(100), AMAIPercentTo255(100-0))	
	elseif c == PLAYER_COLOR_AQUA then
		call SetTextTagColor(tt, AMAIPercentTo255(50), AMAIPercentTo255(100), AMAIPercentTo255(83), AMAIPercentTo255(100-0))	
	else //Brown
		call SetTextTagColor(tt, AMAIPercentTo255(40), AMAIPercentTo255(0), AMAIPercentTo255(0), AMAIPercentTo255(100-0))	
	endif
    call SetTextTagPermanent(tt, false)
	call SetTextTagLifespan(tt, lifespan)
    call SetTextTagFadepoint(tt, fadespan)
	endif
endfunction

function ColorText takes player CPlayer returns string
  //Required Variables
  local playercolor PColor = GetPlayerColor(CPlayer)  //Gets the Player's color
    
  //Finds the Nicer Text Version of the Player's Color
  if (PColor == PLAYER_COLOR_RED) then
    return "Red"
  elseif (PColor == PLAYER_COLOR_BLUE) then
    return "Blue"
  elseif (PColor == PLAYER_COLOR_CYAN) then
    return "Cyan"
  elseif (PColor == PLAYER_COLOR_PURPLE) then
    return "Purple"
  elseif (PColor == PLAYER_COLOR_YELLOW) then
    return "Yellow"
  elseif (PColor == PLAYER_COLOR_ORANGE) then
    return "Orange"
  elseif (PColor == PLAYER_COLOR_GREEN) then
    return "Green"
  elseif (PColor == PLAYER_COLOR_PINK) then
    return "Pink"
  elseif (PColor == PLAYER_COLOR_LIGHT_GRAY) then
    return "Light Gray"
  elseif (PColor == PLAYER_COLOR_LIGHT_BLUE) then
    return "Light Blue"
  elseif (PColor == PLAYER_COLOR_AQUA) then
    return "Aqua"
  elseif (PColor == PLAYER_COLOR_BROWN) then
    return "Brown"
  endif
  
  //Returns text version
  return ""
endfunction

function InitDigits takes nothing returns nothing
  set digit_map[0] = "0"
  set digit_map[1] = "1"
  set digit_map[2] = "2"
  set digit_map[3] = "3"
  set digit_map[4] = "4"
  set digit_map[5] = "5"
  set digit_map[6] = "6"
  set digit_map[7] = "7"
  set digit_map[8] = "8"
  set digit_map[9] = "9"
endfunction

function Int2Str takes integer ic returns string
    local string s = ""
    local integer i = ic
    local integer ialt = 0
    local boolean neg = false

    if i == 0 then
      return "0"
    endif
    if i < 0 then
      set neg = true
      set i = -i
    endif
    loop
      exitwhen i == 0
      set ialt = i
      set i = i / 10
      set s = digit_map[ ialt - 10*i ] + s
    endloop
    if neg then
      return "-"+s
    endif
    return s
endfunction

function B2S takes boolean b returns string
  if b then
    return "true"
  else
    return "false"
  endif
endfunction

function DebugSequenceStart takes string name returns nothing
  call FlushGameCache(InitGameCache("Debug.w3v"))
  set udg_debug_cache = InitGameCache("Debug.w3v")
  set udg_current_category = Int2Str(GetRandomInt(1, 100000000))
  call TimerStart(udg_debug_timer, 1000000, false, null)
  call StoreString(udg_debug_cache, udg_current_category, "Debug0", "SequenceStart "+name)
  set udg_unique_counter = 1
endfunction

function DebugSequenceEnd takes nothing returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), "SequenceEnd")
  call SaveGameCache(udg_debug_cache)
endfunction

function DumpString takes string label, string s returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), s)
  set udg_unique_counter = udg_unique_counter + 2
endfunction

function DumpInteger takes string label, integer i returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), Int2Str(i))
  set udg_unique_counter = udg_unique_counter + 2
endfunction

function DumpReal takes string label, real r returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), Int2Str(R2I(r * 1000)))
  set udg_unique_counter = udg_unique_counter + 2
endfunction

function DumpBoolean takes string label, boolean b returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), B2S(b))
  set udg_unique_counter = udg_unique_counter + 2
endfunction

function DumpHandle takes string label, handle h returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), Int2Str(H2I(h)))
  set udg_unique_counter = udg_unique_counter + 2
endfunction

function EndDump takes string label returns nothing
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter), "EndDump "+label)
  call StoreString(udg_debug_cache, udg_current_category, "Debug"+Int2Str(udg_unique_counter+1), Int2Str(R2I(TimerGetElapsed(udg_debug_timer)*1000)))
  set udg_unique_counter = udg_unique_counter + 2
endfunction

function DumpMessage takes string label, string s returns nothing
  call DumpString("Message", s)
  call EndDump(label)
endfunction

function AddTrans takes string lang, string key, string value returns nothing
  set translation[translation_length] = value
  call StoreInteger(translation_map, lang, key, translation_length)
  set translation_length = translation_length + 1
endfunction

function ApplyTrans takes string s returns string
  if HaveStoredInteger(translation_map, language, s) then
    return translation[GetStoredInteger(translation_map, language, s)]
  else
    return s
  endif
endfunction

function InitTrans takes nothing returns nothing
  local string lang = ""
  set lang = "English"
  call AddTrans(lang, "HUMAN", "human")
  call AddTrans(lang, "ORC", "orc")
  call AddTrans(lang, "ELF", "elf")
  call AddTrans(lang, "UNDEAD", "undead")
  call AddTrans(lang, "Red", "red")
  call AddTrans(lang, "Blue", "blue")
  call AddTrans(lang, "Cyan", "cyan")
  call AddTrans(lang, "Purple", "purple")
  call AddTrans(lang, "Yellow", "yellow")
  call AddTrans(lang, "Orange", "orange")
  call AddTrans(lang, "Green", "green")
  call AddTrans(lang, "Pink", "pink")
  call AddTrans(lang, "Light Gray", "light gray")
  call AddTrans(lang, "Light Blue", "light blue")
  call AddTrans(lang, "Aqua", "aqua")
  call AddTrans(lang, "Brown", "brown")
  call AddTrans(lang, "HUMAN:S", "humans")
  call AddTrans(lang, "ORC:S", "orcs")
  call AddTrans(lang, "ELF:S", "elves")
  call AddTrans(lang, "UNDEAD:S", "undead")
  call AddTrans(lang, "Red:S", "reds")
  call AddTrans(lang, "Blue:S", "blues")
  call AddTrans(lang, "Purple:S", "purples")
  call AddTrans(lang, "Yellow:S", "yellows")
  call AddTrans(lang, "Orange:S", "oranges")
  call AddTrans(lang, "Green:S", "greenies")
  call AddTrans(lang, "Pink:S", "pinkos")
  call AddTrans(lang, "Light Gray:S", "Light Grays")
  call AddTrans(lang, "Light Blue:S", "Light Blues")
  call AddTrans(lang, "Aqua:S", "Aquas")
  call AddTrans(lang, "Brown:S", "Brownies")
  set lang = "Deutsch"
  call AddTrans(lang, "ORC", "Ork")
  call AddTrans(lang, "ORC:S", "Orks")
  call AddTrans(lang, "ORC:Armee", "der orkischen Horde")
  call AddTrans(lang, "HUMAN", "Mensch")
  call AddTrans(lang, "HUMAN:S", "Menschen")
  call AddTrans(lang, "HUMAN:Armee", "der menschlichen Legion")
  call AddTrans(lang, "ELF", "Elf")
  call AddTrans(lang, "ELF:S", "Elfen")
  call AddTrans(lang, "ELF:Armee", "der Gesandten des Cenarius")
  call AddTrans(lang, "UNDEAD", "Untoter")
  call AddTrans(lang, "UNDEAD:S", "Untote")
  call AddTrans(lang, "UNDEAD:Armee", "der Armee der Finsternis")
  set lang = "Swedish"
  call AddTrans(lang, "HUMAN", "human")
  call AddTrans(lang, "HUMAN:EN", "humanen")
  call AddTrans(lang, "ORC", "orc")
  call AddTrans(lang, "ORC:EN", "orcen")
  call AddTrans(lang, "ELF", "night elf")
  call AddTrans(lang, "ELF:EN", "night elfen")
  call AddTrans(lang, "UNDEAD", "undead")
  call AddTrans(lang, "UNDEAD:EN", "undeaden")
  call AddTrans(lang, "Red", "rd")
  call AddTrans(lang, "Red:A", "rda")
  call AddTrans(lang, "Blue", "bl")
  call AddTrans(lang, "Blue:A", "bla")
  call AddTrans(lang, "Cyan", "ljusbl")
  call AddTrans(lang, "Cyan:A", "ljusbla")
  call AddTrans(lang, "Purple", "lila")
  call AddTrans(lang, "Purple:A", "lila")
  call AddTrans(lang, "Yellow", "gula")
  call AddTrans(lang, "Yellow:A", "gula")
  call AddTrans(lang, "Orange", "brandgula")
  call AddTrans(lang, "Orange:A", "brandgula")
  call AddTrans(lang, "Green", "grn")
  call AddTrans(lang, "Green:A", "grna")
  call AddTrans(lang, "Pink", "rosa")
  call AddTrans(lang, "Pink:A", "rosa")
  call AddTrans(lang, "Light Gray", "ljusgr")
  call AddTrans(lang, "Light Gray:A", "ljusgra")
  call AddTrans(lang, "Light Blue", "ljusbl")
  call AddTrans(lang, "Light Blue:A", "ljusbla")
  call AddTrans(lang, "Aqua", "vattenfrgad")
  call AddTrans(lang, "Aqua:A", "vattenfrgade")
  call AddTrans(lang, "Brown", "brun")
  call AddTrans(lang, "Brown:A", "bruna")
  set lang = "French"
  set lang = "Spanish"
  call AddTrans(lang, "ORC", "Orco")
  call AddTrans(lang, "ORC:s", "Orcos")
  call AddTrans(lang, "ORC:UBER", "Los brutales y fuertes orcos")
  call AddTrans(lang, "HUMAN", "Humano")
  call AddTrans(lang, "HUMAN:s", "Humanos")
  call AddTrans(lang, "HUMAN:UBER", "La alianza de humanos, elfos y enanos")
  call AddTrans(lang, "UNDEAD", "Muerto viviente")
  call AddTrans(lang, "UNDEAD:s", "Muertos vivientes")
  call AddTrans(lang, "UNDEAD:UBER", "Los invencibles muertos vivientes")
  call AddTrans(lang, "NIGHTELF", "Elfo nocturno")
  call AddTrans(lang, "NIGHTELF:s", "Elfos nocturnos")
  call AddTrans(lang, "NIGHTELF:UBER", "Los inmortales elfos nocturnos")
  call AddTrans(lang, "small", "pequeo")
  call AddTrans(lang, "medium", "mediano")
  call AddTrans(lang, "large", "grande")
  call AddTrans(lang, "small:s", "pequeos")
  call AddTrans(lang, "medium:s", "medianos")
  call AddTrans(lang, "large:s", "grandes")
  call AddTrans(lang, "Red", "rojo")
  call AddTrans(lang, "Red:s", "rojos")
  call AddTrans(lang, "Blue", "azl")
  call AddTrans(lang, "Blue:s", "azules")
  call AddTrans(lang, "Teal", "verde agua")
  call AddTrans(lang, "Teal:s", "verde agua")
  call AddTrans(lang, "Purple", "prpura")
  call AddTrans(lang, "Purple:s", "prpuras")
  call AddTrans(lang, "Yellow", "amarillo")
  call AddTrans(lang, "Yellow:s", "amarillos")
  call AddTrans(lang, "Orange", "naranja")
  call AddTrans(lang, "Orange:s", "naranjas")
  call AddTrans(lang, "Green", "verde")
  call AddTrans(lang, "Green:s", "verdes")
  call AddTrans(lang, "Pink", "rosa")
  call AddTrans(lang, "Pink:s", "rosados")
  call AddTrans(lang, "Light Gray", "gris")
  call AddTrans(lang, "Light Gray:s", "grises")
  call AddTrans(lang, "Light Blue", "Azl claro")
  call AddTrans(lang, "Light Blue:s", "Azl claro")
  call AddTrans(lang, "Aqua", "Verde oscuro")
  call AddTrans(lang, "Aqua:s", "Verde oscuro")
  call AddTrans(lang, "Brown", "Caf")
  call AddTrans(lang, "Brown:s", "Cafs")
  set lang = "Romanian"
  set lang = "Russian"
  call AddTrans(lang, "HUMAN", "")
  call AddTrans(lang, "HUMAN:S", "")
  call AddTrans(lang, "HUMAN:OFF", "")
  call AddTrans(lang, "HUMAN:AYA", "")
  call AddTrans(lang, "ORC", "")
  call AddTrans(lang, "ORC:S", "")
  call AddTrans(lang, "ORC:OFF", "")
  call AddTrans(lang, "ORC:AYA", "")
  call AddTrans(lang, "UNDEAD", "")
  call AddTrans(lang, "UNDEAD:S", "")
  call AddTrans(lang, "UNDEAD:OFF", "")
  call AddTrans(lang, "UNDEAD:AYA", "")
  call AddTrans(lang, "ELF", "")
  call AddTrans(lang, "ELF:I", " ")
  call AddTrans(lang, "ELF:S", "")
  call AddTrans(lang, "ELF:OFF", "")
  call AddTrans(lang, "ELF:AYA", "")
  call AddTrans(lang, "Red", "")
  call AddTrans(lang, "Red:A", "")
  call AddTrans(lang, "Red:E", "")
  call AddTrans(lang, "Red:X", "")
  call AddTrans(lang, "Blue", "")
  call AddTrans(lang, "Blue:A", "")
  call AddTrans(lang, "Blue:E", "")
  call AddTrans(lang, "Blue:X", "")
  call AddTrans(lang, "Cyan", "-")
  call AddTrans(lang, "Cyan:A", "-")
  call AddTrans(lang, "Cyan:E", "-")
  call AddTrans(lang, "Cyan:X", "-")
  call AddTrans(lang, "Purple", "")
  call AddTrans(lang, "Purple:A", "")
  call AddTrans(lang, "Purple:E", "")
  call AddTrans(lang, "Purple:X", "")
  call AddTrans(lang, "Yellow", "")
  call AddTrans(lang, "Yellow:A", "")
  call AddTrans(lang, "Yellow:E", "")
  call AddTrans(lang, "Yellow:X", "")
  call AddTrans(lang, "Orange", "")
  call AddTrans(lang, "Orange:A", "")
  call AddTrans(lang, "Orange:E", "")
  call AddTrans(lang, "Orange:X", "")
  call AddTrans(lang, "Green", "")
  call AddTrans(lang, "Green:A", "")
  call AddTrans(lang, "Green:E", "")
  call AddTrans(lang, "Green:X", "")
  call AddTrans(lang, "Pink", "")
  call AddTrans(lang, "Pink:A", "")
  call AddTrans(lang, "Pink:E", "")
  call AddTrans(lang, "Pink:X", "")
  call AddTrans(lang, "Light Gray", "")
  call AddTrans(lang, "Light Gray:A", "")
  call AddTrans(lang, "Light Gray:E", "")
  call AddTrans(lang, "Light Gray:X", "")
  call AddTrans(lang, "Light Blue", "-")
  call AddTrans(lang, "Light Blue:A", "-")
  call AddTrans(lang, "Light Blue:E", "-")
  call AddTrans(lang, "Light Blue:X", "-")
  call AddTrans(lang, "Aqua", "-")
  call AddTrans(lang, "Aqua:A", "-")
  call AddTrans(lang, "Aqua:E", "-")
  call AddTrans(lang, "Aqua:X", "-")
  call AddTrans(lang, "Brown", "")
  call AddTrans(lang, "Brown:A", "")
  call AddTrans(lang, "Brown:E", "")
  call AddTrans(lang, "Brown:X", "")
  set lang = "Portuguese"
  call AddTrans(lang, "HUMAN", "human")
  call AddTrans(lang, "ORC", "orc")
  call AddTrans(lang, "ELF", "elf")
  call AddTrans(lang, "UNDEAD", "undead")
  call AddTrans(lang, "Red", "vermelho")
  call AddTrans(lang, "Blue", "azul")
  call AddTrans(lang, "Cyan", "magenta")
  call AddTrans(lang, "Purple", "roxo")
  call AddTrans(lang, "Yellow", "amarelo")
  call AddTrans(lang, "Orange", "laranja")
  call AddTrans(lang, "Green", "verde")
  call AddTrans(lang, "Pink", "rosa")
  call AddTrans(lang, "Light Gray", "cinza claro")
  call AddTrans(lang, "Light Blue", "azul claro")
  call AddTrans(lang, "Aqua", "aqua")
  call AddTrans(lang, "Brown", "marrons")
  call AddTrans(lang, "HUMAN:S", "humanos")
  call AddTrans(lang, "ORC:S", "orcs")
  call AddTrans(lang, "ELF:S", "elfos")
  call AddTrans(lang, "UNDEAD:S", "undead")
  call AddTrans(lang, "Red:S", "vermelhos")
  call AddTrans(lang, "Blue:S", "azuis")
  call AddTrans(lang, "Purple:S", "roxos")
  call AddTrans(lang, "Yellow:S", "amarelos")
  call AddTrans(lang, "Orange:S", "laranjas")
  call AddTrans(lang, "Green:S", "verdes")
  call AddTrans(lang, "Pink:S", "rosas")
  call AddTrans(lang, "Light Gray:S", "cinzas claro")
  call AddTrans(lang, "Light Blue:S", "azuis claro")
  call AddTrans(lang, "Aqua:S", "Aquas")
  call AddTrans(lang, "Brown:S", "marrons")
  set lang = "Norwegian"
  set lang = "Chinese"
endfunction


function DisplayToAll takes string s returns nothing
    local integer i = 0
    loop
        call DisplayTimedTextToPlayer(Player(i),0,0,15,message_add+s)
        set i = i + 1
        exitwhen i == 12
    endloop
    call StartSound(chatSound)
endfunction

function DisplayToAllImportant takes string s returns nothing
    local integer i = 0
    loop
        call DisplayTimedTextToPlayer(Player(i),0,0,15,message_add+s)
        set i = i + 1
        exitwhen i == 12
    endloop
    call StartSound(importantSound)
endfunction

function DisplayToAllies takes string s returns nothing
  if IsPlayerAlly(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(chatSound)
  endif
endfunction

function DisplayToAlliesImportant takes string s returns nothing
  if IsPlayerAlly(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(importantSound)
  endif
endfunction

function DisplayToEnemy takes string s returns nothing
  if IsPlayerEnemy(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(chatSound)
  endif
endfunction

function DisplayToEnemyImportant takes string s returns nothing
  if IsPlayerEnemy(ai_player,GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(importantSound)
  endif
endfunction

function DisplayToObservers takes string s returns nothing
  if IsPlayerObserver(GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(chatSound)
  endif
endfunction

function DisplayToObserversImportant takes string s returns nothing
  if IsPlayerObserver(GetLocalPlayer()) then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    call StartSound(importantSound)
  endif
endfunction


	

function Trace takes string s returns nothing
    local integer i = 0
	if debugging and Player(GetAiPlayer()) == Player(2) then
		loop
			call DisplayTimedTextToPlayer(Player(i),0,0,15,message_add+s)
			set i = i + 1
			exitwhen i == 12
		endloop
		call StartSound(chatSound)
	endif	
	// Blizzard ai part
    if trace_on then
        call DisplayText(GetAiPlayer(),s)
    endif
endfunction

function TraceI takes string s, integer val returns nothing	
    if trace_on then
        call DisplayTextI(GetAiPlayer(),s,val)
    endif
endfunction

function TraceII takes string message, integer v1, integer v2 returns nothing
    if trace_on then
        call DisplayTextII(GetAiPlayer(),message,v1,v2)
    endif
endfunction

function TraceIII takes string message, integer v1, integer v2, integer v3 returns nothing
    if trace_on then
        call DisplayTextIII(GetAiPlayer(),message,v1,v2,v3)
    endif
endfunction

function DisplayToAllJobDebug takes string s returns nothing
  local integer i = 0
  if job_debug and ai_player == Player(2) then
    loop
        call DisplayTimedTextToPlayer(Player(i),0,0,15,message_add+s)
        set i = i + 1
        exitwhen i == 12
    endloop
    call StartSound(chatSound)
  endif
endfunction

function DisplayToAlliesChat takes string s returns nothing
  if chatting then
    if IsPlayerAlly(ai_player,GetLocalPlayer()) then
      call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
      call StartSound(chatSound)
    endif
  endif
endfunction

function DisplayToEnemyChat takes string s returns nothing
  if chatting then
    if IsPlayerEnemy(ai_player,GetLocalPlayer()) then
      call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
      call StartSound(chatSound)
    endif
  endif
endfunction

function DisplayToAlliesDebug takes string s returns nothing
  if debugging then
    if IsPlayerAlly(ai_player,GetLocalPlayer()) then
      call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
      call StartSound(chatSound)
    endif
  endif
endfunction

function DisplayToPlayer takes string s, player p, boolean important returns nothing
  if p == GetLocalPlayer() then
    call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,15,message_add+s)
    if important then
      call StartSound(importantSound)
    else
      call StartSound(chatSound)
    endif
  endif
endfunction

function PlayerEx takes integer slot returns player
    return Player(slot-1)
endfunction

function Abs takes integer a returns integer
  if a >= 0 then
    return a
  else
    return -a
  endif
endfunction

function RAbs takes real a returns real
  if a >= 0 then
    return a
  else
    return -a
  endif
endfunction

function Min takes integer A, integer B returns integer
    if A < B then
        return A
    else
        return B
    endif
endfunction

function RMin takes real A, real B returns real
    if A < B then
        return A
    else
        return B
    endif
endfunction

function Max takes integer A, integer B returns integer
    if A > B then
        return A
    else
        return B
    endif
endfunction

function RMax takes real A, real B returns real
    if A > B then
        return A
    else
        return B
    endif
endfunction

function GetRandomDiff takes integer maxdiff returns integer
  if GetRandomInt(0,1) == 1 then
    return GetRandomInt(0,maxdiff)
  else
    return -GetRandomInt(0,maxdiff)
  endif
endfunction

function LinearInterpolation takes real x1, real x2, real y1, real y2, real p returns real
  if p <= x1 then
    return y1
  elseif p >= x2 then
    return y2
  else
    return y1 + ((p - x1)/(x2 - x1)) * (y2 - y1)
  endif
endfunction

function GetUnitGoldCost2 takes integer id returns integer
  if needed3[id] == UPGRADED then
    return GetUnitGoldCost(old_id[id]) - GetUnitGoldCost(old_id[needed1[id]])
  else
    return GetUnitGoldCost(old_id[id])
  endif
endfunction

function GetUnitWoodCost2 takes integer id returns integer
  if needed3[id] == UPGRADED then
    return GetUnitWoodCost(old_id[id]) - GetUnitWoodCost(old_id[needed1[id]])
  else
    return GetUnitWoodCost(old_id[id])
  endif
endfunction

function GetExpansionPeon2 takes nothing returns unit
	local group g = CreateGroup()
	local unit u = null
	
	call GroupEnumUnitsOfPlayer(g, ai_player, null)	
	loop
		set u = FirstOfGroup(g)
		exitwhen u == null
		if GetUnitTypeId(u) == old_id[racial_peon] and GetUnitCurrentOrder(u) != OrderId("repair") and GetUnitCurrentOrder(u) != OrderId("build") then
			return u
		endif
		call GroupRemoveUnit(g, u)
	endloop
	return null
endfunction

function LookupCT takes string s returns string
  local integer i = String2Int(s)
  return char_table[i - (i/JASS_MAX_ARRAY_SIZE)*JASS_MAX_ARRAY_SIZE]
endfunction

function AddToCT takes string s returns nothing
  local integer i = String2Int(SubString(s, 0, 1))
  set char_table[i - (i/JASS_MAX_ARRAY_SIZE)*JASS_MAX_ARRAY_SIZE] = s
endfunction

function GetChar takes string s, integer num returns string
  return LookupCT(SubString(s, num, num + 1))
endfunction

function InitCT takes nothing returns nothing
  set chat_vars[0] = ""
  call AddToCT(" ")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT(" ")
  call AddToCT("!")
  call AddToCT("$")
  call AddToCT("%")
  call AddToCT("&")
  call AddToCT("'")
  call AddToCT("(")
  call AddToCT(")")
  call AddToCT("*")
  call AddToCT("+")
  call AddToCT(",")
  call AddToCT("-")
  call AddToCT(".")
  call AddToCT("/")
  call AddToCT("0")
  call AddToCT("1")
  call AddToCT("2")
  call AddToCT("3")
  call AddToCT("4")
  call AddToCT("5")
  call AddToCT("6")
  call AddToCT("7")
  call AddToCT("8")
  call AddToCT("9")
  call AddToCT(":")
  call AddToCT(";")
  call AddToCT("<")
  call AddToCT("=")
  call AddToCT(">")
  call AddToCT("?")
  call AddToCT("@")
  call AddToCT("A")
  call AddToCT("B")
  call AddToCT("C")
  call AddToCT("D")
  call AddToCT("E")
  call AddToCT("F")
  call AddToCT("G")
  call AddToCT("H")
  call AddToCT("I")
  call AddToCT("J")
  call AddToCT("K")
  call AddToCT("L")
  call AddToCT("M")
  call AddToCT("N")
  call AddToCT("O")
  call AddToCT("P")
  call AddToCT("Q")
  call AddToCT("R")
  call AddToCT("S")
  call AddToCT("T")
  call AddToCT("U")
  call AddToCT("V")
  call AddToCT("W")
  call AddToCT("X")
  call AddToCT("Y")
  call AddToCT("Z")
  call AddToCT("[")
  call AddToCT("]")
  call AddToCT("^")
  call AddToCT("_")
  call AddToCT("`")
  call AddToCT("a")
  call AddToCT("b")
  call AddToCT("c")
  call AddToCT("d")
  call AddToCT("e")
  call AddToCT("f")
  call AddToCT("g")
  call AddToCT("h")
  call AddToCT("i")
  call AddToCT("j")
  call AddToCT("k")
  call AddToCT("l")
  call AddToCT("m")
  call AddToCT("n")
  call AddToCT("o")
  call AddToCT("p")
  call AddToCT("q")
  call AddToCT("r")
  call AddToCT("s")
  call AddToCT("t")
  call AddToCT("u")
  call AddToCT("v")
  call AddToCT("w")
  call AddToCT("x")
  call AddToCT("y")
  call AddToCT("z")
  call AddToCT("{")
  call AddToCT("|")
  call AddToCT("}")
  call AddToCT("~")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("")
  call AddToCT("#")
  call AddToCT("\"") 
  call AddToCT("\\")
endfunction

function SetChatVar takes string key, string value returns nothing
  local integer i = GetStoredInteger(chat_vars_map, ai_id, key)
  if i == 0 then
    set i = chat_vars_length
    set chat_vars_length = chat_vars_length + 1
    call StoreInteger(chat_vars_map, ai_id, key, i)
  endif
  set chat_vars[i] = value
endfunction

function GetChatVar takes string key returns string
  return chat_vars[GetStoredInteger(chat_vars_map, ai_id, key)]
endfunction

function SetChatVarB takes string key, boolean value returns nothing
  call StoreBoolean(chat_vars_map, ai_id, key, value)
endfunction

function GetChatVarB takes string key returns boolean
  return GetStoredBoolean(chat_vars_map, ai_id, key)
endfunction

function SetChatVarR takes string key, real value returns nothing
  call StoreReal(chat_vars_map, ai_id, key, value)
endfunction

function GetChatVarR takes string key returns real
  return GetStoredReal(chat_vars_map, ai_id, key)
endfunction

function ApplyChatVars takes string s_in returns string
  local string s = ""
  local integer i = 0
  local integer l = StringLength(s_in)
  local boolean is_cv = false
  local boolean is_wf = false
  local boolean is_cond = false
  local string key = ""
  local string wf = ""
  local string c = ""
  loop
    exitwhen i >= l
    set c = GetChar(s_in, i)
    if c == "}" then
      set is_cond = false
    elseif is_cond then
    elseif c == "{" then
      set is_cond = true
    elseif c == "[" then
      set is_cv = true
      set key = ""
      set wf = ""
    elseif c == "]" then
      set is_cv = false
      set is_wf = false
      set s = s + ApplyTrans(GetChatVar(key)+wf)
    elseif is_cv then
      if c == ":" then
        set is_cv = false
        set is_wf = true
        set wf = ":"
      else
        set key = key + c
      endif
    elseif is_wf then
      set wf = wf + c
    else
      set s = s + c
    endif
    set i = i + 1
  endloop
  return s
endfunction

function CompareReal takes real x, real y, integer compare returns boolean
  if compare == COMPARE_GREATER then
    return x > y
  elseif compare == COMPARE_GREATER_EQ then
    return x >= y
  elseif compare == COMPARE_LESS then
    return x < y
  else
    return x <= y
  endif
endfunction

function CheckChatCondition takes string s returns boolean
  local integer i = 1
  local boolean is_compare = false
  local integer compare = 0
  local string key = ""
  local string value = ""
  local string c = ""
  local boolean part_cond = true
  local boolean not_cond = false
  set chat_eq = COMPARE_TRUE
  set c = GetChar(s, 0)
  if c != "{" then
    return true
  endif
  loop
    set c = GetChar(s, i)
    if c == "}" then
      if is_compare then
        if key == "PlayerRace" then
          set chat_race = value
          set chat_eq = compare
          return true
        elseif compare == COMPARE_EQ then
          return GetChatVar(key) == value
        elseif compare == COMPARE_UNEQ then
          return GetChatVar(key) != value
        else
          return CompareReal(GetChatVarR(key), S2R(value), compare)
        endif
      else
        return not_cond != GetChatVarB(key)
      endif
    elseif c == "," then
      if is_compare then
        if key == "PlayerRace" then
          set chat_race = value
          set chat_eq = compare
        elseif compare == COMPARE_EQ then
          set part_cond = GetChatVar(key) == value
        elseif compare == COMPARE_UNEQ then
          set part_cond = GetChatVar(key) != value
        else
          set part_cond = CompareReal(GetChatVarR(key), S2R(value), compare)
        endif
      else
        set part_cond = not_cond != GetChatVarB(key)
      endif
      if not part_cond then
        return false
      endif
      set is_compare = false
      set not_cond = false
      set key = ""
      set value = ""
      set compare = 0
    elseif c == "=" then
      if is_compare then
        if compare == COMPARE_GREATER then
          set compare = COMPARE_GREATER_EQ
        elseif compare == COMPARE_LESS then
          set compare = COMPARE_LESS_EQ
        endif
      else
        set is_compare = true
        if not_cond then
          set compare = COMPARE_UNEQ
        else
          set compare = COMPARE_EQ
        endif
      endif
    elseif c == "<" then
      set is_compare = true
      set compare = COMPARE_LESS
    elseif c == ">" then
      set is_compare = true
      set compare = COMPARE_GREATER
    elseif c == "!" then
      set not_cond = true
    elseif is_compare then
      set value = value + c
    else
      set key = key + c
    endif
    set i = i + 1
  endloop
  return false
endfunction

function ApplyChatConditions takes nothing returns nothing
  local integer i = 0
  local integer free = 0
  loop
    exitwhen i >= chat_list_length
    call SetChatVarR("Random",GetRandomReal(0,100))
    if CheckChatCondition(chat_list[i]) then
      set chat_list[free] = chat_list[i]
      set chat_list_race[free] = chat_race
      set chat_list_eq[free] = chat_eq
      set free = free + 1
    endif
    set i = i + 1
  endloop
  set chat_list_length = free
endfunction

   // Global Functions that are used in both AMAI and standard ai

function GetAMAIId takes integer id returns integer   
   local integer i = 0
	loop
		exitwhen i > OBJECT_NUM
		if old_id[i] == id then
		    call Trace("Returned AMAI id - " + Int2Str(i) + ":" + UnitId2String(old_id[i]) + " for " + UnitId2String(id))
			return i
		endif
		set i = i + 1
	endloop
    call Trace("Couldn't get AMAI id - " + UnitId2String(id))
	return 0
endfunction

function GetGold takes nothing returns integer
    return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_GOLD)
endfunction

function GetWood takes nothing returns integer
    return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_LUMBER)
endfunction

function InitDefenseGroup takes nothing returns nothing
    set defense_length = 0
endfunction

function InitAssaultGroup takes nothing returns nothing
	if IsAMAI then
		set attack_length = 0
	else
		set harass_length = 0
	endif
endfunction

function GetUnitCountEx takes integer unitid, boolean only_done, integer townid returns integer

    if unitid == 0 then // can happen but lets speed up calculation a little instead of running the functions
	   return 0
	endif
	
	if IsAMAI then
	    if townid == -1 then
	        if only_done then
	            return GetUnitCountDone(old_id[unitid])
	        else
	            return GetUnitCount(old_id[unitid])
	        endif
	    else
	        return GetTownUnitCount(old_id[unitid],townid,only_done)
	    endif
	else
	    if townid == -1 then
	        if only_done then
	            return GetUnitCountDone(unitid)
	        else
	            return GetUnitCount(unitid)
	        endif
	    else
	        return GetTownUnitCount(unitid,townid,only_done)
	    endif
	endif
endfunction

function TownCountEx takes integer unitid, boolean only_done, integer townid returns integer
  local integer have_qty = 0
  local integer newid = 0
  
  if IsAMAI then
	set have_qty = GetUnitCountEx(unitid,only_done,townid) + GetUnitCountEx(tc_add1[unitid],false,townid) + GetUnitCountEx(tc_add2[unitid],false,townid)
  else
	//set newid = GetAMAIId(unitid)
	//set have_qty = GetUnitCountEx(unitid,only_done,townid) + GetUnitCountEx(tc_add1[newid],false,townid) + GetUnitCountEx(tc_add2[newid],false,townid)
    set have_qty = GetUnitCountEx(unitid,only_done,townid)
    if unitid == PEASANT then
		set have_qty = have_qty + GetUnitCountEx(MILITIA,false,townid) + GetUnitCountEx(0, false,townid)
	endif
    if unitid == MILITIA then
		set have_qty = have_qty + GetUnitCountEx(PEASANT,false,townid) + GetUnitCountEx(0, false,townid)
	endif
    if unitid == KEEP then
		set have_qty = have_qty + GetUnitCountEx(CASTLE,false,townid) + GetUnitCountEx(0, false,townid)
	endif
    if unitid == TOWN_HALL then
		set have_qty = have_qty + GetUnitCountEx(KEEP,false,townid) + GetUnitCountEx(CASTLE, false,townid)
	endif
    if unitid == WATCH_TOWER then
		set have_qty = have_qty + GetUnitCountEx(GUARD_TOWER,false,townid) + GetUnitCountEx(CANNON_TOWER, false,townid)
	endif
    if unitid == HEAD_HUNTER then
		set have_qty = have_qty + GetUnitCountEx(BERSERKER,false,townid) + GetUnitCountEx(0, false,townid)
	endif
    if unitid == SPIRIT_WALKER then
		set have_qty = have_qty + GetUnitCountEx(SPIRIT_WALKER_M,false,townid) + GetUnitCountEx(0, false,townid)
	endif
    if unitid == SPIRIT_WALKER_M then
		set have_qty = have_qty + GetUnitCountEx(0,false,townid) + GetUnitCountEx(SPIRIT_WALKER, false,townid)
	endif
    if unitid == GREAT_HALL then
		set have_qty = have_qty + GetUnitCountEx(STRONGHOLD,false,townid) + GetUnitCountEx(FORTRESS, false,townid)
	endif
    if unitid == STRONGHOLD then
		set have_qty = have_qty + GetUnitCountEx(FORTRESS,false,townid) + GetUnitCountEx(0, false,townid)
	endif
    if unitid == GARGOYLE then
		set have_qty = have_qty + GetUnitCountEx(0,false,townid) + GetUnitCountEx(GARGOYLE_MORPH, false,townid)
	endif
    if unitid == GARGOYLE_MORPH then
		set have_qty = have_qty + GetUnitCountEx(0,false,townid) + GetUnitCountEx(GARGOYLE, false,townid)
	endif
    if unitid == NECROPOLIS_1 then
		set have_qty = have_qty + GetUnitCountEx(NECROPOLIS_2,false,townid) + GetUnitCountEx(NECROPOLIS_3, false,townid)
	endif
    if unitid == NECROPOLIS_2 then
		set have_qty = have_qty + GetUnitCountEx(NECROPOLIS_3,false,townid) + GetUnitCountEx(0, false,townid)
	endif
    if unitid == ZIGGURAT_1 then
		set have_qty = have_qty + GetUnitCountEx(ZIGGURAT_2,false,townid) + GetUnitCountEx(ZIGGURAT_FROST, false,townid)
	endif
    if unitid == DRUID_TALON then
		set have_qty = have_qty + GetUnitCountEx(0,false,townid) + GetUnitCountEx(DRUID_TALON_M, false,townid)
	endif
    if unitid == DRUID_TALON_M then
		set have_qty = have_qty + GetUnitCountEx(0,false,townid) + GetUnitCountEx(DRUID_TALON, false,townid)
	endif
    if unitid == DRUID_CLAW then
		set have_qty = have_qty + GetUnitCountEx(0,false,townid) + GetUnitCountEx(DRUID_CLAW_M, false,townid)
	endif
    if unitid == DRUID_CLAW_M then
		set have_qty = have_qty + GetUnitCountEx(0,false,townid) + GetUnitCountEx(DRUID_CLAW, false,townid)
	endif
    if unitid == TREE_AGES then
		set have_qty = have_qty + GetUnitCountEx(TREE_ETERNITY,false,townid) + GetUnitCountEx(0, false,townid)
	endif
    if unitid == TREE_LIFE then
		set have_qty = have_qty + GetUnitCountEx(TREE_AGES,false,townid) + GetUnitCountEx(TREE_ETERNITY, false,townid)
	endif
    if unitid == ILLIDAN_DEMON then
		set have_qty = have_qty + GetUnitCountEx(ILLIDAN,false,townid) + GetUnitCountEx(0, false,townid)
	endif
  endif
  
  if unitid == WATCH_TOWER then
	set have_qty = have_qty + GetUnitCountEx(ARCANE_TOWER, false, townid)
  endif
  return have_qty  
  
endfunction

function TownCountDone takes integer base returns integer
    return TownCountEx(base,true,-1)
endfunction

function TownCount takes integer base returns integer
    return TownCountEx(base,false,-1)
endfunction

function TownCountTown takes integer base, integer townid returns integer
    return TownCountEx(base,false,townid)
endfunction

function HallsCompleted takes integer unitid returns boolean
  if IsAMAI then
    return GetUnitCount(old_id[unitid]) == GetUnitCountDone(old_id[unitid]) 
  else
	return GetUnitCount(unitid) == GetUnitCountDone(unitid)
  endif
endfunction

function StaggerSleep takes real base, real spread returns nothing
    call Sleep(base + spread * I2R(GetAiPlayer()) / I2R(GetPlayers()))
endfunction

function FoodUsed takes nothing returns integer
    return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_FOOD_USED)
endfunction

function FoodCap takes nothing returns integer
    return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_FOOD_CAP)
endfunction

function FoodSpace takes nothing returns integer
    return FoodCap() - FoodUsed()
endfunction

function FoodAvail takes integer base returns integer
    return GetFoodMade(racial_farm) * TownCount(racial_farm) + GetFoodMade(base) * TownCount(base)
endfunction



function InitMapSizeVars takes nothing returns nothing
  local real x = path_right - path_left
  local real y = path_top - path_bottom
  local real a = (x/1000)*(y/1000)
  call SetChatVarR("MapSizeX", x)
  call SetChatVarR("MapSizeY", y)
  if a < 120 then
    call SetChatVar("MapSize", "tiny")
  elseif a < 240 then
    call SetChatVar("MapSize", "small")
  elseif a < 380 then
    call SetChatVar("MapSize", "medium")
  elseif a < 540 then
    call SetChatVar("MapSize", "large")
  else
    call SetChatVar("MapSize", "huge")
  endif
endfunction

function InitDifficultyVars takes nothing returns nothing
  if difficulty == HARD then
    call SetChatVar("Difficulty", "Insane")
  elseif difficulty == NORMAL then
    call SetChatVar("Difficulty", "Normal")
  else
    call SetChatVar("Difficulty", "Easy")
  endif
  call SetChatVarR("Handicap", GetPlayerHandicap(ai_player))
endfunction

function InitChatVars takes nothing returns nothing
  call SetChatVar("Race", race_name[own_race])
  call SetChatVar("Color", ColorText(ai_player))
  call SetChatVarR("PlayerNum", c_ally_total + c_enemy_total + 1)
  call SetChatVar("PlayerNum", Int2Str(c_ally_total + c_enemy_total + 1))
  call SetChatVarB("1vs1", game_is_1on1)
  call SetChatVarB("FFA", game_is_ffa)
  call SetChatVarB("RaceChoiceRandom", player_race_pref[GetAiPlayer()] == R_RANDOM)
  call SetChatVar("MaxPlayerNum", Int2Str(GetPlayers()))
  call SetChatVarR("MaxPlayerNum", GetPlayers())
  call InitMapSizeVars()
  call InitDifficultyVars()
endfunction

function SetChatVarsPlayer takes player p returns nothing
  call SetChatVar("PlayerRace", race_name[player_race[GetPlayerId(p)]])
  call SetChatVar("PlayerColor", ColorText(p))
endfunction


function GetSumLoc takes location l1, location l2 returns location
  return Location(GetLocationX(l1) + GetLocationX(l2), GetLocationY(l1) + GetLocationY(l2))
endfunction
function GetSumLoc_dd takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) + GetLocationX(l2)
  local real locY = GetLocationY(l1) + GetLocationY(l2)  
	call RemoveLocation(l1)
    call RemoveLocation(l2)
  return Location(locX, locY)
endfunction
function GetSumLoc_kd takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) + GetLocationX(l2)
  local real locY = GetLocationY(l1) + GetLocationY(l2)  
    call RemoveLocation(l2)
  return Location(locX, locY)
endfunction
function GetSumLoc_dk takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) + GetLocationX(l2)
  local real locY = GetLocationY(l1) + GetLocationY(l2)  
    call RemoveLocation(l1)
  return Location(locX, locY)
endfunction

function GetSubtractionLoc takes location l1, location l2 returns location
  return Location(GetLocationX(l1) - GetLocationX(l2), GetLocationY(l1) - GetLocationY(l2))
endfunction

function GetSubtractionLoc_dd takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) - GetLocationX(l2)
  local real locY = GetLocationY(l1) - GetLocationY(l2)  
	call RemoveLocation(l1)
    call RemoveLocation(l2)
  return Location(locX, locY)
endfunction
function GetSubtractionLoc_kd takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) - GetLocationX(l2)
  local real locY = GetLocationY(l1) - GetLocationY(l2)  
    call RemoveLocation(l2)
  return Location(locX, locY)
endfunction
function GetSubtractionLoc_dk takes location l1, location l2 returns location
  local real locX = GetLocationX(l1) - GetLocationX(l2)
  local real locY = GetLocationY(l1) - GetLocationY(l2)  
	call RemoveLocation(l1)
  return Location(locX, locY)
endfunction

function GetMultipleLoc takes location l, real m returns location
  return Location(GetLocationX(l) * m, GetLocationY(l) * m)
endfunction

function GetMultipleLoc_d takes location l, real m returns location
  local real locX = GetLocationX(l) * m 
  local real locY = GetLocationY(l) * m  
  call RemoveLocation(l)
  return Location(locX, locY)
endfunction

function GetDivisionLoc takes location l, real d returns location
  return Location(GetLocationX(l) / d, GetLocationY(l) / d)
endfunction

function GetDivisionLoc_d takes location l, real d returns location
  local real locX = GetLocationX(l) / d 
  local real locY = GetLocationY(l) / d  
  call RemoveLocation(l)
  return Location(locX, locY)
endfunction

function GetLengthOfLoc takes location l returns real
  local real x = GetLocationX(l)
  local real y = GetLocationY(l)
  return SquareRoot(x * x + y * y)
endfunction

function GetLengthOfLoc_d takes location l returns real
  local real x = GetLocationX(l)
  local real y = GetLocationY(l)
  call RemoveLocation(l)
  return SquareRoot(x * x + y * y)
endfunction

function GetNormalisedLoc takes location l returns location
  return GetDivisionLoc(l, RMax(GetLengthOfLoc(l),1.00))
endfunction

function GetNormalisedLoc_d takes location l returns location
  return GetDivisionLoc_d(l, RMax(GetLengthOfLoc(l),1.00))
endfunction

function GetProjectedLoc takes location l, location v, real r returns location
  local location loc = GetNormalisedLoc(v)
  local location loc2 = GetMultipleLoc_d(loc, r)
  local location returnloc = GetSumLoc_kd(l, loc2)
  set loc = null
  set loc2 = null
  return returnloc
endfunction

function l_smult_kk takes location l1, location l2 returns real
  return GetLocationX(l1) * GetLocationX(l2) + GetLocationY(l1) * GetLocationY(l2)
endfunction

function GetAngleBetweenLocs takes location l1, location l2 returns real
  return Acos(l_smult_kk(l1, l2) / (GetLengthOfLoc(l1) * GetLengthOfLoc(l2)))
endfunction

function set_profiles takes nothing returns nothing

    set profilename[0] = "Hunter"
    set p_race[0] = R_RANDOM
    set p_aggression[0] = -10
    set p_uncertainty[0] = 10
    set p_minimum_attack_strength[0] = 4
    set p_farm_food[0] = 6
    set p_exp_first_time[0] = -5
    set p_exp_second_time[0] = 10
    set p_strat_persistence[0] = 1000
    set p_gold_unit_percentage[0] = 0.9
    set p_taunt_rate[0] = 1
    set p_expansion_target_bonus[0] = 7
    set p_comp_chosen_target_bonus[0] = 5
    set p_comp_chosen_target_rate[0] = 0.5
    set p_surrender[0] = 3

    set fav_hero[0] = MOON_CHICK
    set fav_hero[1] = ARCHMAGE
    set fav_hero[2] = FAR_SEER
    set fav_hero[3] = DEATH_KNIGHT
    set fav_hero[4] = 0

    set fav_unit[0] = HUNTRESS
    set fav_unit[1] = GRYPHON
    set fav_unit[2] = GRUNT
    set fav_unit[3] = GHOUL

    set profilename[1] = "Crazy_Rusher"
    set p_race[1] = R_RANDOM
    set p_aggression[1] = 5
    set p_uncertainty[1] = 5
    set p_minimum_attack_strength[1] = 2
    set p_farm_food[1] = 5
    set p_exp_first_time[1] = 4
    set p_exp_second_time[1] = -8
    set p_strat_persistence[1] = 780
    set p_gold_unit_percentage[1] = 1
    set p_taunt_rate[1] = 1
    set p_expansion_target_bonus[1] = 8
    set p_comp_chosen_target_bonus[1] = 4
    set p_comp_chosen_target_rate[1] = 0.4
    set p_surrender[1] = 1

    set fav_hero[5] = WARDEN
    set fav_hero[6] = ARCHMAGE
    set fav_hero[7] = FAR_SEER
    set fav_hero[8] = DEATH_KNIGHT
    set fav_hero[9] = 0

    set fav_unit[4] = ARCHER
    set fav_unit[5] = KNIGHT
    set fav_unit[6] = GRUNT
    set fav_unit[7] = GHOUL

    set profilename[2] = "Crusher"
    set p_race[2] = R_RANDOM
    set p_aggression[2] = -6
    set p_uncertainty[2] = 7
    set p_minimum_attack_strength[2] = 4
    set p_farm_food[2] = 7
    set p_exp_first_time[2] = 7
    set p_exp_second_time[2] = 12
    set p_strat_persistence[2] = 850
    set p_gold_unit_percentage[2] = 0.9
    set p_taunt_rate[2] = 1
    set p_expansion_target_bonus[2] = 12
    set p_comp_chosen_target_bonus[2] = 6
    set p_comp_chosen_target_rate[2] = 0.6
    set p_surrender[2] = 2

    set fav_hero[10] = DEMON_HUNTER
    set fav_hero[11] = MTN_KING
    set fav_hero[12] = BLADE_MASTER
    set fav_hero[13] = DEATH_KNIGHT
    set fav_hero[14] = 0

    set fav_unit[8] = HUNTRESS
    set fav_unit[9] = KNIGHT
    set fav_unit[10] = WYVERN
    set fav_unit[11] = GHOUL

    set profilename[3] = "Zmasher"
    set p_race[3] = R_RANDOM
    set p_aggression[3] = -8
    set p_uncertainty[3] = 8
    set p_minimum_attack_strength[3] = 4
    set p_farm_food[3] = 6
    set p_exp_first_time[3] = 7
    set p_exp_second_time[3] = 12
    set p_strat_persistence[3] = 900
    set p_gold_unit_percentage[3] = 0.9
    set p_taunt_rate[3] = 1
    set p_expansion_target_bonus[3] = 5
    set p_comp_chosen_target_bonus[3] = 4
    set p_comp_chosen_target_rate[3] = 0.4
    set p_surrender[3] = 2

    set fav_hero[15] = MOON_CHICK
    set fav_hero[16] = ARCHMAGE
    set fav_hero[17] = FAR_SEER
    set fav_hero[18] = LICH
    set fav_hero[19] = 0

    set fav_unit[12] = HUNTRESS
    set fav_unit[13] = GRYPHON
    set fav_unit[14] = GRUNT
    set fav_unit[15] = CRYPT_FIEND

    set profilename[4] = "Aggressario"
    set p_race[4] = R_RANDOM
    set p_aggression[4] = -2
    set p_uncertainty[4] = 6
    set p_minimum_attack_strength[4] = 3
    set p_farm_food[4] = 7
    set p_exp_first_time[4] = -8
    set p_exp_second_time[4] = 15
    set p_strat_persistence[4] = 800
    set p_gold_unit_percentage[4] = 1
    set p_taunt_rate[4] = 1
    set p_expansion_target_bonus[4] = 12
    set p_comp_chosen_target_bonus[4] = 7
    set p_comp_chosen_target_rate[4] = 0.3
    set p_surrender[4] = 1

    set fav_hero[20] = KEEPER
    set fav_hero[21] = ARCHMAGE
    set fav_hero[22] = BLADE_MASTER
    set fav_hero[23] = DEATH_KNIGHT
    set fav_hero[24] = 0

    set fav_unit[16] = HUNTRESS
    set fav_unit[17] = RIFLEMAN
    set fav_unit[18] = GRUNT
    set fav_unit[19] = GHOUL

    set profilename[5] = "chick3n"
    set p_race[5] = R_RANDOM
    set p_aggression[5] = -15
    set p_uncertainty[5] = 4
    set p_minimum_attack_strength[5] = 6
    set p_farm_food[5] = 8
    set p_exp_first_time[5] = 6
    set p_exp_second_time[5] = 16
    set p_strat_persistence[5] = 1000
    set p_gold_unit_percentage[5] = 0.9
    set p_taunt_rate[5] = 1
    set p_expansion_target_bonus[5] = 3
    set p_comp_chosen_target_bonus[5] = 3
    set p_comp_chosen_target_rate[5] = 0.8
    set p_surrender[5] = 4

    set fav_hero[25] = WARDEN
    set fav_hero[26] = MTN_KING
    set fav_hero[27] = BLADE_MASTER
    set fav_hero[28] = DEATH_KNIGHT
    set fav_hero[29] = 0

    set fav_unit[20] = ARCHER
    set fav_unit[21] = MORTAR
    set fav_unit[22] = GRUNT
    set fav_unit[23] = GHOUL

    set profilename[6] = "CPU"
    set p_race[6] = R_RANDOM
    set p_aggression[6] = -9
    set p_uncertainty[6] = 5
    set p_minimum_attack_strength[6] = 4
    set p_farm_food[6] = 7
    set p_exp_first_time[6] = 6
    set p_exp_second_time[6] = 18
    set p_strat_persistence[6] = 900
    set p_gold_unit_percentage[6] = 0.9
    set p_taunt_rate[6] = 1
    set p_expansion_target_bonus[6] = 8
    set p_comp_chosen_target_bonus[6] = 6
    set p_comp_chosen_target_rate[6] = 0.5
    set p_surrender[6] = 0

    set fav_hero[30] = DEMON_HUNTER
    set fav_hero[31] = ARCHMAGE
    set fav_hero[32] = FAR_SEER
    set fav_hero[33] = DEATH_KNIGHT
    set fav_hero[34] = 0

    set fav_unit[24] = HUNTRESS
    set fav_unit[25] = KNIGHT
    set fav_unit[26] = GRUNT
    set fav_unit[27] = GHOUL

    set profilename[7] = "ErRoR"
    set p_race[7] = R_RANDOM
    set p_aggression[7] = -10
    set p_uncertainty[7] = 7
    set p_minimum_attack_strength[7] = 5
    set p_farm_food[7] = 6
    set p_exp_first_time[7] = 8
    set p_exp_second_time[7] = 13
    set p_strat_persistence[7] = 800
    set p_gold_unit_percentage[7] = 0.9
    set p_taunt_rate[7] = 1
    set p_expansion_target_bonus[7] = 7
    set p_comp_chosen_target_bonus[7] = 7
    set p_comp_chosen_target_rate[7] = 0.6
    set p_surrender[7] = 3

    set fav_hero[35] = MOON_CHICK
    set fav_hero[36] = ARCHMAGE
    set fav_hero[37] = FAR_SEER
    set fav_hero[38] = DEATH_KNIGHT
    set fav_hero[39] = 0

    set fav_unit[28] = HUNTRESS
    set fav_unit[29] = GRYPHON
    set fav_unit[30] = CATAPULT
    set fav_unit[31] = CRYPT_FIEND

    set profilename[8] = "RomuLus"
    set p_race[8] = R_RANDOM
    set p_aggression[8] = -11
    set p_uncertainty[8] = 4
    set p_minimum_attack_strength[8] = 4
    set p_farm_food[8] = 5
    set p_exp_first_time[8] = 9
    set p_exp_second_time[8] = 12
    set p_strat_persistence[8] = 1100
    set p_gold_unit_percentage[8] = 1
    set p_taunt_rate[8] = 1
    set p_expansion_target_bonus[8] = 7
    set p_comp_chosen_target_bonus[8] = 3
    set p_comp_chosen_target_rate[8] = 0.5
    set p_surrender[8] = 2

    set fav_hero[40] = KEEPER
    set fav_hero[41] = MTN_KING
    set fav_hero[42] = FAR_SEER
    set fav_hero[43] = LICH
    set fav_hero[44] = 0

    set fav_unit[32] = HUNTRESS
    set fav_unit[33] = KNIGHT
    set fav_unit[34] = WYVERN
    set fav_unit[35] = NECRO

    set profilename[9] = "ReMus"
    set p_race[9] = R_RANDOM
    set p_aggression[9] = -11
    set p_uncertainty[9] = 5
    set p_minimum_attack_strength[9] = 5
    set p_farm_food[9] = 5
    set p_exp_first_time[9] = 7
    set p_exp_second_time[9] = 14
    set p_strat_persistence[9] = 1050
    set p_gold_unit_percentage[9] = 1
    set p_taunt_rate[9] = 1
    set p_expansion_target_bonus[9] = 8
    set p_comp_chosen_target_bonus[9] = 4
    set p_comp_chosen_target_rate[9] = 0.5
    set p_surrender[9] = 2

    set fav_hero[45] = WARDEN
    set fav_hero[46] = ARCHMAGE
    set fav_hero[47] = FAR_SEER
    set fav_hero[48] = DEATH_KNIGHT
    set fav_hero[49] = 0

    set fav_unit[36] = DRYAD
    set fav_unit[37] = RIFLEMAN
    set fav_unit[38] = TAUREN
    set fav_unit[39] = CRYPT_FIEND

    set profilename[10] = "Xerox"
    set p_race[10] = R_RANDOM
    set p_aggression[10] = -7
    set p_uncertainty[10] = 9
    set p_minimum_attack_strength[10] = 3
    set p_farm_food[10] = 8
    set p_exp_first_time[10] = 9
    set p_exp_second_time[10] = 12
    set p_strat_persistence[10] = 700
    set p_gold_unit_percentage[10] = 0.95
    set p_taunt_rate[10] = 1
    set p_expansion_target_bonus[10] = 12
    set p_comp_chosen_target_bonus[10] = 5
    set p_comp_chosen_target_rate[10] = 0.6
    set p_surrender[10] = 2

    set fav_hero[50] = DEMON_HUNTER
    set fav_hero[51] = ARCHMAGE
    set fav_hero[52] = BLADE_MASTER
    set fav_hero[53] = DEATH_KNIGHT
    set fav_hero[54] = 0

    set fav_unit[40] = HUNTRESS
    set fav_unit[41] = KNIGHT
    set fav_unit[42] = GRUNT
    set fav_unit[43] = CRYPT_FIEND

    set profilename[11] = "Xenon"
    set p_race[11] = R_RANDOM
    set p_aggression[11] = -7
    set p_uncertainty[11] = 8
    set p_minimum_attack_strength[11] = 4
    set p_farm_food[11] = 6
    set p_exp_first_time[11] = -9
    set p_exp_second_time[11] = 12
    set p_strat_persistence[11] = 800
    set p_gold_unit_percentage[11] = 0.9
    set p_taunt_rate[11] = 1
    set p_expansion_target_bonus[11] = 11
    set p_comp_chosen_target_bonus[11] = 6
    set p_comp_chosen_target_rate[11] = 0.4
    set p_surrender[11] = 2

    set fav_hero[55] = KEEPER
    set fav_hero[56] = ARCHMAGE
    set fav_hero[57] = BLADE_MASTER
    set fav_hero[58] = DEATH_KNIGHT
    set fav_hero[59] = 0

    set fav_unit[44] = ARCHER
    set fav_unit[45] = GRYPHON
    set fav_unit[46] = GRUNT
    set fav_unit[47] = GHOUL

    set profilename[12] = "Zitrax"
    set p_race[12] = R_RANDOM
    set p_aggression[12] = -9
    set p_uncertainty[12] = 11
    set p_minimum_attack_strength[12] = 4
    set p_farm_food[12] = 6
    set p_exp_first_time[12] = 8
    set p_exp_second_time[12] = 17
    set p_strat_persistence[12] = 700
    set p_gold_unit_percentage[12] = 1
    set p_taunt_rate[12] = 1
    set p_expansion_target_bonus[12] = 5
    set p_comp_chosen_target_bonus[12] = 8
    set p_comp_chosen_target_rate[12] = 0.6
    set p_surrender[12] = 3

    set fav_hero[60] = MOON_CHICK
    set fav_hero[61] = ARCHMAGE
    set fav_hero[62] = FAR_SEER
    set fav_hero[63] = DEATH_KNIGHT
    set fav_hero[64] = 0

    set fav_unit[48] = HUNTRESS
    set fav_unit[49] = RIFLEMAN
    set fav_unit[50] = HEAD_HUNTER
    set fav_unit[51] = GHOUL

    set profilename[13] = "Menace"
    set p_race[13] = R_RANDOM
    set p_aggression[13] = -11
    set p_uncertainty[13] = 12
    set p_minimum_attack_strength[13] = 3
    set p_farm_food[13] = 7
    set p_exp_first_time[13] = 7
    set p_exp_second_time[13] = 17
    set p_strat_persistence[13] = 700
    set p_gold_unit_percentage[13] = 0.85
    set p_taunt_rate[13] = 1
    set p_expansion_target_bonus[13] = 6
    set p_comp_chosen_target_bonus[13] = 6
    set p_comp_chosen_target_rate[13] = 0.7
    set p_surrender[13] = 1

    set fav_hero[65] = KEEPER
    set fav_hero[66] = ARCHMAGE
    set fav_hero[67] = BLADE_MASTER
    set fav_hero[68] = DEATH_KNIGHT
    set fav_hero[69] = 0

    set fav_unit[52] = HUNTRESS
    set fav_unit[53] = MORTAR
    set fav_unit[54] = GRUNT
    set fav_unit[55] = FROST_WYRM

    set profilename[14] = "Razkal"
    set p_race[14] = R_RANDOM
    set p_aggression[14] = -8
    set p_uncertainty[14] = 8
    set p_minimum_attack_strength[14] = 5
    set p_farm_food[14] = 5
    set p_exp_first_time[14] = 6
    set p_exp_second_time[14] = 12
    set p_strat_persistence[14] = 800
    set p_gold_unit_percentage[14] = 1
    set p_taunt_rate[14] = 1
    set p_expansion_target_bonus[14] = 7
    set p_comp_chosen_target_bonus[14] = 7
    set p_comp_chosen_target_rate[14] = 0.6
    set p_surrender[14] = 4

    set fav_hero[70] = WARDEN
    set fav_hero[71] = MTN_KING
    set fav_hero[72] = FAR_SEER
    set fav_hero[73] = DEATH_KNIGHT
    set fav_hero[74] = 0

    set fav_unit[56] = DRYAD
    set fav_unit[57] = KNIGHT
    set fav_unit[58] = WYVERN
    set fav_unit[59] = NECRO

    set profilename[15] = "Terra"
    set p_race[15] = R_RANDOM
    set p_aggression[15] = -9
    set p_uncertainty[15] = 7
    set p_minimum_attack_strength[15] = 4
    set p_farm_food[15] = 7
    set p_exp_first_time[15] = 8
    set p_exp_second_time[15] = 14
    set p_strat_persistence[15] = 900
    set p_gold_unit_percentage[15] = 1.05
    set p_taunt_rate[15] = 1
    set p_expansion_target_bonus[15] = 5
    set p_comp_chosen_target_bonus[15] = 8
    set p_comp_chosen_target_rate[15] = 0.5
    set p_surrender[15] = 2

    set fav_hero[75] = DEMON_HUNTER
    set fav_hero[76] = ARCHMAGE
    set fav_hero[77] = FAR_SEER
    set fav_hero[78] = LICH
    set fav_hero[79] = 0

    set fav_unit[60] = HUNTRESS
    set fav_unit[61] = GRYPHON
    set fav_unit[62] = CATAPULT
    set fav_unit[63] = CRYPT_FIEND

    set profilename[16] = "Utopio"
    set p_race[16] = R_RANDOM
    set p_aggression[16] = -8
    set p_uncertainty[16] = 9
    set p_minimum_attack_strength[16] = 5
    set p_farm_food[16] = 6
    set p_exp_first_time[16] = -8
    set p_exp_second_time[16] = 15
    set p_strat_persistence[16] = 850
    set p_gold_unit_percentage[16] = 0.85
    set p_taunt_rate[16] = 1
    set p_expansion_target_bonus[16] = 8
    set p_comp_chosen_target_bonus[16] = 5
    set p_comp_chosen_target_rate[16] = 0.4
    set p_surrender[16] = 3

    set fav_hero[80] = KEEPER
    set fav_hero[81] = ARCHMAGE
    set fav_hero[82] = FAR_SEER
    set fav_hero[83] = DEATH_KNIGHT
    set fav_hero[84] = 0

    set fav_unit[64] = DRUID_CLAW
    set fav_unit[65] = RIFLEMAN
    set fav_unit[66] = WYVERN
    set fav_unit[67] = GHOUL

    set profilename[17] = "Q"
    set p_race[17] = R_RANDOM
    set p_aggression[17] = -11
    set p_uncertainty[17] = 8
    set p_minimum_attack_strength[17] = 4
    set p_farm_food[17] = 5
    set p_exp_first_time[17] = 7
    set p_exp_second_time[17] = 16
    set p_strat_persistence[17] = 950
    set p_gold_unit_percentage[17] = 0.9
    set p_taunt_rate[17] = 1
    set p_expansion_target_bonus[17] = 9
    set p_comp_chosen_target_bonus[17] = 6
    set p_comp_chosen_target_rate[17] = 0.5
    set p_surrender[17] = 1

    set fav_hero[85] = MOON_CHICK
    set fav_hero[86] = MTN_KING
    set fav_hero[87] = FAR_SEER
    set fav_hero[88] = DEATH_KNIGHT
    set fav_hero[89] = 0

    set fav_unit[68] = HUNTRESS
    set fav_unit[69] = KNIGHT
    set fav_unit[70] = HEAD_HUNTER
    set fav_unit[71] = CRYPT_FIEND

    set profilename[18] = "MaTrIx"
    set p_race[18] = R_RANDOM
    set p_aggression[18] = -10
    set p_uncertainty[18] = 5
    set p_minimum_attack_strength[18] = 5
    set p_farm_food[18] = 8
    set p_exp_first_time[18] = 9
    set p_exp_second_time[18] = 14
    set p_strat_persistence[18] = 970
    set p_gold_unit_percentage[18] = 1
    set p_taunt_rate[18] = 1
    set p_expansion_target_bonus[18] = 5
    set p_comp_chosen_target_bonus[18] = 8
    set p_comp_chosen_target_rate[18] = 0.6
    set p_surrender[18] = 2

    set fav_hero[90] = DEMON_HUNTER
    set fav_hero[91] = MTN_KING
    set fav_hero[92] = BLADE_MASTER
    set fav_hero[93] = DEATH_KNIGHT
    set fav_hero[94] = 0

    set fav_unit[72] = CHIMAERA
    set fav_unit[73] = KNIGHT
    set fav_unit[74] = GRUNT
    set fav_unit[75] = GHOUL

    set profilename[19] = "BORG"
    set p_race[19] = R_RANDOM
    set p_aggression[19] = -12
    set p_uncertainty[19] = 6
    set p_minimum_attack_strength[19] = 4
    set p_farm_food[19] = 6
    set p_exp_first_time[19] = -7
    set p_exp_second_time[19] = 13
    set p_strat_persistence[19] = 780
    set p_gold_unit_percentage[19] = 0.95
    set p_taunt_rate[19] = 1
    set p_expansion_target_bonus[19] = 10
    set p_comp_chosen_target_bonus[19] = 7
    set p_comp_chosen_target_rate[19] = 0.6
    set p_surrender[19] = 1

    set fav_hero[95] = DEMON_HUNTER
    set fav_hero[96] = ARCHMAGE
    set fav_hero[97] = BLADE_MASTER
    set fav_hero[98] = DEATH_KNIGHT
    set fav_hero[99] = 0

    set fav_unit[76] = DRYAD
    set fav_unit[77] = KNIGHT
    set fav_unit[78] = GRUNT
    set fav_unit[79] = GHOUL

    set profilename[20] = "Cybernetic"
    set p_race[20] = R_RANDOM
    set p_aggression[20] = -7
    set p_uncertainty[20] = 5
    set p_minimum_attack_strength[20] = 4
    set p_farm_food[20] = 7
    set p_exp_first_time[20] = 6
    set p_exp_second_time[20] = 15
    set p_strat_persistence[20] = 960
    set p_gold_unit_percentage[20] = 0.9
    set p_taunt_rate[20] = 1
    set p_expansion_target_bonus[20] = 13
    set p_comp_chosen_target_bonus[20] = 5
    set p_comp_chosen_target_rate[20] = 0.5
    set p_surrender[20] = 3

    set fav_hero[100] = WARDEN
    set fav_hero[101] = ARCHMAGE
    set fav_hero[102] = FAR_SEER
    set fav_hero[103] = DEATH_KNIGHT
    set fav_hero[104] = 0

    set fav_unit[80] = DRUID_TALON
    set fav_unit[81] = GRYPHON
    set fav_unit[82] = TAUREN
    set fav_unit[83] = NECRO

    set profilename[21] = "CyberPro"
    set p_race[21] = R_RANDOM
    set p_aggression[21] = -6
    set p_uncertainty[21] = 6
    set p_minimum_attack_strength[21] = 4
    set p_farm_food[21] = 8
    set p_exp_first_time[21] = 6
    set p_exp_second_time[21] = 14
    set p_strat_persistence[21] = 800
    set p_gold_unit_percentage[21] = 1
    set p_taunt_rate[21] = 1
    set p_expansion_target_bonus[21] = 11
    set p_comp_chosen_target_bonus[21] = 3
    set p_comp_chosen_target_rate[21] = 0.5
    set p_surrender[21] = 2

    set fav_hero[105] = KEEPER
    set fav_hero[106] = ARCHMAGE
    set fav_hero[107] = BLADE_MASTER
    set fav_hero[108] = LICH
    set fav_hero[109] = 0

    set fav_unit[84] = ARCHER
    set fav_unit[85] = RIFLEMAN
    set fav_unit[86] = WYVERN
    set fav_unit[87] = CRYPT_FIEND

    set profilename[22] = "Cyrrix"
    set p_race[22] = R_RANDOM
    set p_aggression[22] = -7
    set p_uncertainty[22] = 5
    set p_minimum_attack_strength[22] = 5
    set p_farm_food[22] = 6
    set p_exp_first_time[22] = -7
    set p_exp_second_time[22] = 13
    set p_strat_persistence[22] = 900
    set p_gold_unit_percentage[22] = 0.8
    set p_taunt_rate[22] = 1
    set p_expansion_target_bonus[22] = 10
    set p_comp_chosen_target_bonus[22] = 4
    set p_comp_chosen_target_rate[22] = 0.4
    set p_surrender[22] = 2

    set fav_hero[110] = DEMON_HUNTER
    set fav_hero[111] = ARCHMAGE
    set fav_hero[112] = FAR_SEER
    set fav_hero[113] = DEATH_KNIGHT
    set fav_hero[114] = 0

    set fav_unit[88] = DRYAD
    set fav_unit[89] = KNIGHT
    set fav_unit[90] = HEAD_HUNTER
    set fav_unit[91] = FROST_WYRM

    set profilename[23] = "ArraXy"
    set p_race[23] = R_RANDOM
    set p_aggression[23] = -10
    set p_uncertainty[23] = 9
    set p_minimum_attack_strength[23] = 4
    set p_farm_food[23] = 8
    set p_exp_first_time[23] = 8
    set p_exp_second_time[23] = 16
    set p_strat_persistence[23] = 700
    set p_gold_unit_percentage[23] = 0.9
    set p_taunt_rate[23] = 1
    set p_expansion_target_bonus[23] = 8
    set p_comp_chosen_target_bonus[23] = 6
    set p_comp_chosen_target_rate[23] = 0.5
    set p_surrender[23] = 2

    set fav_hero[115] = MOON_CHICK
    set fav_hero[116] = ARCHMAGE
    set fav_hero[117] = FAR_SEER
    set fav_hero[118] = DEATH_KNIGHT
    set fav_hero[119] = 0

    set fav_unit[92] = HUNTRESS
    set fav_unit[93] = MORTAR
    set fav_unit[94] = CATAPULT
    set fav_unit[95] = NECRO

    set profilename[24] = "Trollus"
    set p_race[24] = R_RANDOM
    set p_aggression[24] = -8
    set p_uncertainty[24] = 8
    set p_minimum_attack_strength[24] = 4
    set p_farm_food[24] = 6
    set p_exp_first_time[24] = 7
    set p_exp_second_time[24] = 13
    set p_strat_persistence[24] = 870
    set p_gold_unit_percentage[24] = 1
    set p_taunt_rate[24] = 1
    set p_expansion_target_bonus[24] = 9
    set p_comp_chosen_target_bonus[24] = 7
    set p_comp_chosen_target_rate[24] = 0.4
    set p_surrender[24] = 2

    set fav_hero[120] = WARDEN
    set fav_hero[121] = ARCHMAGE
    set fav_hero[122] = FAR_SEER
    set fav_hero[123] = LICH
    set fav_hero[124] = 0

    set fav_unit[96] = CHIMAERA
    set fav_unit[97] = RIFLEMAN
    set fav_unit[98] = GRUNT
    set fav_unit[99] = GHOUL

    set profilename[25] = "Aaargh"
    set p_race[25] = R_RANDOM
    set p_aggression[25] = -9
    set p_uncertainty[25] = 9
    set p_minimum_attack_strength[25] = 4
    set p_farm_food[25] = 7
    set p_exp_first_time[25] = -7
    set p_exp_second_time[25] = 18
    set p_strat_persistence[25] = 790
    set p_gold_unit_percentage[25] = 1.1
    set p_taunt_rate[25] = 1
    set p_expansion_target_bonus[25] = 7
    set p_comp_chosen_target_bonus[25] = 5
    set p_comp_chosen_target_rate[25] = 0.4
    set p_surrender[25] = 1

    set fav_hero[125] = DEMON_HUNTER
    set fav_hero[126] = MTN_KING
    set fav_hero[127] = BLADE_MASTER
    set fav_hero[128] = LICH
    set fav_hero[129] = 0

    set fav_unit[100] = ARCHER
    set fav_unit[101] = GRYPHON
    set fav_unit[102] = HEAD_HUNTER
    set fav_unit[103] = GHOUL

    set profile_length = 25

endfunction

function IsProfileUsed takes integer profile returns boolean
  return GetStoredBoolean(com, "ProfileUsed", Int2Str(profile))
endfunction

function SetProfileUsed takes integer profile returns nothing
  call StoreBoolean(com, "ProfileUsed", Int2Str(profile), true)
endfunction

function InitProfile takes nothing returns nothing

  call set_profiles()
  
  if debug_profile != -1 then
    set profile = debug_profile
  else
    loop
      set profile = GetRandomInt(0, profile_length)
      exitwhen (p_race[profile] == R_RANDOM or p_race[profile] == own_race) and not IsProfileUsed(profile)
    endloop
  endif

  call SetProfileUsed(profile)

  if not fixedcomputername then
  	set ai_name = profilename[profile]
  elseif add_tag then
	set ai_name = "AMAI"
  else
	set ai_name = "Computer"
  endif

  call SetChatVar("Name", ai_name)

  if add_tag == true and not fixedcomputername then
     set ai_name = "[AMAI]"+ai_name
  endif

  if add_skill == true then
     if MeleeDifficulty() == EASY then
        set ai_name = ai_name+" (Easy)"
     elseif MeleeDifficulty() == HARD then
        set ai_name = ai_name+" (Insane)"
     else
        set ai_name = ai_name+" (Normal)"
     endif
  endif

  call SetPlayerName(ai_player, ai_name)
  set message_add = c2s(GetPlayerColor(ai_player))
  
  set attacking_aggression = attacking_aggression + p_aggression[profile]
  set uncertainty = p_uncertainty[profile]
  set area_uncertainty = uncertainty / 2
  set minimum_attack_strength = p_minimum_attack_strength[profile]
  set farm_food = p_farm_food[profile]
  set exp_first_time = p_exp_first_time[profile]
  set exp_second_time = p_exp_second_time[profile]
  set strat_persistence = p_strat_persistence[profile]
  set gold_unit_percentage = p_gold_unit_percentage[profile]
  set taunt_rate = p_taunt_rate[profile]
  set expansion_target_bonus = p_expansion_target_bonus[profile]
  set comp_chosen_target_bonus = p_comp_chosen_target_bonus[profile]
  set comp_chosen_target_rate = p_comp_chosen_target_rate[profile]

endfunction

function AddFavoriteUnitRP takes nothing returns nothing
  local integer i = 0
  local string team = "Team" + Int2Str(GetPlayerTeam(ai_player)) + "StratUsed"
  if debug_strategy != -1 then
    set rp_strat[debug_strategy] = 100000000
  endif
  loop
    exitwhen i >= rp_strat_length
    if key_unit[i] == fav_unit[profile*RACE_NUMBER+own_race-1] then
      set rp_strat[i] = rp_strat[i] + fav_unit_add
    endif
    set i = i + 1
  endloop
  if ai_time < 10 then
    set i = 0
    loop
      exitwhen i >= 4
      set strategy_type_used[i] = GetStoredBoolean(com, team, Int2Str(i))
      set i = i + 1
    endloop
    set i = 0
    loop
      exitwhen i >= rp_strat_length
      if strategy_type_used[strategy_type[i]] then
        set rp_strat[i] = rp_strat[i] - strategy_type_used_penalty
      endif
      set i = i + 1
    endloop
  endif
endfunction

function AddFavoriteHeroRP takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= hero_number
    if all_heroes[i] == fav_hero[profile*(RACE_NUMBER+1)+own_race-1] or all_heroes[i] == fav_hero[profile*(RACE_NUMBER+1)+R_NEUTRAL-1] then
      set hero_rp[i] = hero_rp[i] + fav_hero_add
    endif
    set i = i + 1
  endloop
endfunction

function InitAiUnits takes nothing returns nothing
	if IsAMAI then
	else
	// Set the unit ids to that of the original ai for compatability with non AMAI scripts

		set ARCHMAGE = oARCHMAGE	
		set PALADIN = oPALADIN	
		set MTN_KING = oMTN_KING	
		set BLOOD_MAGE = oBLOOD_MAGE	
		set COPTER = oCOPTER	
		set ELEMENTAL = oELEMENTAL	
		set ELEMENTAL2 = oELEMENTAL2	
		set ELEMENTAL3 = oELEMENTAL3	
		set FOOTMAN = oFOOTMAN	
		set GRYPHON = oGRYPHON	
		set KNIGHT = oKNIGHT	
		set MORTAR = oMORTAR	
		set PEASANT = oPEASANT	
		set PRIEST = oPRIEST	
		set RIFLEMAN = oRIFLEMAN	
		set SORCERESS = oSORCERESS	
		set STEAM_TANK = oSTEAM_TANK	
		set ROCKET_TANK = oROCKET_TANK	
		set MILITIA = oMILITIA	
		set SPELL_BREAKER = oSPELL_BREAKER	
		set HUMAN_DRAGON_HAWK = oHUMAN_DRAGON_HAWK	
		set AVIARY = oAVIARY	
		set BARRACKS = oBARRACKS	
		set BLACKSMITH = oBLACKSMITH	
		set CANNON_TOWER = oCANNON_TOWER	
		set CASTLE = oCASTLE	
		set GUARD_TOWER = oGUARD_TOWER	
		set HOUSE = oHOUSE	
		set HUMAN_ALTAR = oHUMAN_ALTAR	
		set KEEP = oKEEP	
		set LUMBER_MILL = oLUMBER_MILL	
		set SANCTUM = oSANCTUM	
		set ARCANE_SANCTUM = oARCANE_SANCTUM	
		set TOWN_HALL = oTOWN_HALL	
		set WATCH_TOWER = oWATCH_TOWER	
		set WORKSHOP = oWORKSHOP	
		set ARCANE_VAULT = oARCANE_VAULT	
		set ARCANE_TOWER = oARCANE_TOWER	
		set UPG_MELEE = oUPG_MELEE	
		set UPG_RANGED = oUPG_RANGED	
		set UPG_ARMOR = oUPG_ARMOR	
		set UPG_MASONRY = oUPG_MASONRY	
		set UPG_SIGHT = oUPG_SIGHT	
		set UPG_DEFEND = oUPG_DEFEND	
		set UPG_BREEDING = oUPG_BREEDING	
		set UPG_PRAYING = oUPG_PRAYING	
		set UPG_SORCERY = oUPG_SORCERY	
		set UPG_LEATHER = oUPG_LEATHER	
		set UPG_GUN_RANGE = oUPG_GUN_RANGE	
		set UPG_WOOD = oUPG_WOOD	
		set UPG_SENTINEL = oUPG_SENTINEL	
		set UPG_BOMBS = oUPG_BOMBS	
		set UPG_HAMMERS = oUPG_HAMMERS	
		set UPG_CONT_MAGIC = oUPG_CONT_MAGIC	
		set UPG_FRAGS = oUPG_FRAGS	
		set UPG_TANK = oUPG_TANK	
		set UPG_FLAK = oUPG_FLAK	
		set UPG_CLOUD = oUPG_CLOUD	
		set BLADE_MASTER = oBLADE_MASTER	
		set FAR_SEER = oFAR_SEER	
		set TAUREN_CHIEF = oTAUREN_CHIEF	
		set SHADOW_HUNTER = oSHADOW_HUNTER	
		set CATAPULT = oCATAPULT	
		set WITCH_DOCTOR = oWITCH_DOCTOR	
		set GRUNT = oGRUNT	
		set HEAD_HUNTER = oHEAD_HUNTER	
		set BERSERKER = oBERSERKER	
		set KODO_BEAST = oKODO_BEAST	
		set PEON = oPEON	
		set RAIDER = oRAIDER	
		set SHAMAN = oSHAMAN	
		set TAUREN = oTAUREN	
		set WYVERN = oWYVERN	
		set BATRIDER = oBATRIDER	
		set SPIRIT_WALKER = oSPIRIT_WALKER	
		set SPIRIT_WALKER_M = oSPIRIT_WALKER_M	
		set ORC_ALTAR = oORC_ALTAR	
		set ORC_BARRACKS = oORC_BARRACKS	
		set BESTIARY = oBESTIARY	
		set FORGE = oFORGE	
		set FORTRESS = oFORTRESS	
		set GREAT_HALL = oGREAT_HALL	
		set LODGE = oLODGE	
		set STRONGHOLD = oSTRONGHOLD	
		set BURROW = oBURROW	
		set TOTEM = oTOTEM	
		set ORC_WATCH_TOWER = oORC_WATCH_TOWER	
		set VOODOO_LOUNGE = oVOODOO_LOUNGE	
		set UPG_ORC_WAR_DRUMS = oUPG_ORC_WAR_DRUMS	
		set UPG_ORC_PILLAGE = oUPG_ORC_PILLAGE	
		set UPG_ORC_BERSERK = oUPG_ORC_BERSERK	
		set UPG_ORC_PULVERIZE = oUPG_ORC_PULVERIZE	
		set UPG_ORC_ENSNARE = oUPG_ORC_ENSNARE	
		set UPG_ORC_VENOM = oUPG_ORC_VENOM	
		set UPG_ORC_REGEN = oUPG_ORC_REGEN	
		set UPG_ORC_FIRE = oUPG_ORC_FIRE	
		set UPG_ORC_BERSERKER = oUPG_ORC_BERSERKER	
		set UPG_ORC_BURROWS = oUPG_ORC_BURROWS	
		set UPG_ORC_MELEE = oUPG_ORC_MELEE	
		set UPG_ORC_RANGED = oUPG_ORC_RANGED	
		set UPG_ORC_ARMOR = oUPG_ORC_ARMOR	
		set UPG_ORC_SPIKES = oUPG_ORC_SPIKES	
		set UPG_ORC_DOCS = oUPG_ORC_DOCS	
		set UPG_ORC_SHAMAN = oUPG_ORC_SHAMAN	
		set UPG_ORC_SWALKER = oUPG_ORC_SWALKER	
		set UPG_ORC_NAPTHA = oUPG_ORC_NAPTHA	
		set DEATH_KNIGHT = oDEATH_KNIGHT	
		set DREAD_LORD = oDREAD_LORD	
		set LICH = oLICH	
		set CRYPT_LORD = oCRYPT_LORD	
		set ABOMINATION = oABOMINATION	
		set ACOLYTE = oACOLYTE	
		set BANSHEE = oBANSHEE	
		set CRYPT_FIEND = oCRYPT_FIEND	
		set BURROWED_FIEND = oBURROWED_FIEND	
		set FROST_WYRM = oFROST_WYRM	
		set GARGOYLE = oGARGOYLE	
		set GARGOYLE_MORPH = oGARGOYLE_MORPH	
		set GHOUL = oGHOUL	
		set MEAT_WAGON = oMEAT_WAGON	
		set NECRO = oNECRO	
		set SKEL_WARRIOR = oSKEL_WARRIOR	
		set SHADE = oSHADE	
		set OBSIDIAN_STATUE = oOBSIDIAN_STATUE	
		set BLK_SPHINX = oBLK_SPHINX	
		set UNDEAD_MINE = oUNDEAD_MINE	
		set UNDEAD_ALTAR = oUNDEAD_ALTAR	
		set BONEYARD = oBONEYARD	
		set NECROPOLIS_1 = oNECROPOLIS_1	
		set NECROPOLIS_2 = oNECROPOLIS_2	
		set NECROPOLIS_3 = oNECROPOLIS_3	
		set SAC_PIT = oSAC_PIT	
		set CRYPT = oCRYPT	
		set SLAUGHTERHOUSE = oSLAUGHTERHOUSE	
		set DAMNED_TEMPLE = oDAMNED_TEMPLE	
		set ZIGGURAT_1 = oZIGGURAT_1	
		set ZIGGURAT_2 = oZIGGURAT_2	
		set ZIGGURAT_FROST = oZIGGURAT_FROST	
		set GRAVEYARD = oGRAVEYARD	
		set TOMB_OF_RELICS = oTOMB_OF_RELICS	
		set CARRION_BEETLE = oCARRION_BEETLE	
		set CARRION_BEETLE2 = oCARRION_BEETLE2	
		set CARRION_BEETLE3 = oCARRION_BEETLE3	
		set SKEL_MAGE = oSKEL_MAGE	
		set UPG_CANNIBALIZE = oUPG_CANNIBALIZE	
		set UPG_GHOUL_FRENZY = oUPG_GHOUL_FRENZY	
		set UPG_FIEND_WEB = oUPG_FIEND_WEB	
		set UPG_STONE_FORM = oUPG_STONE_FORM	
		set UPG_WYRM_BREATH = oUPG_WYRM_BREATH	
		set UPG_SKEL_LIFE = oUPG_SKEL_LIFE	
		set UPG_PLAGUE = oUPG_PLAGUE	
		set UPG_SKEL_MASTERY = oUPG_SKEL_MASTERY	
		set UPG_BLK_SPHINX = oUPG_BLK_SPHINX	
		set UPG_BURROWING = oUPG_BURROWING	
		set UPG_EXHUME = oUPG_EXHUME	
		set UPG_UNHOLY_STR = oUPG_UNHOLY_STR	
		set UPG_CR_ATTACK = oUPG_CR_ATTACK	
		set UPG_UNHOLY_ARMOR = oUPG_UNHOLY_ARMOR	
		set UPG_CR_ARMOR = oUPG_CR_ARMOR	
		set UPG_NECROS = oUPG_NECROS	
		set UPG_BANSHEE = oUPG_BANSHEE	
		set DEMON_HUNTER = oDEMON_HUNTER	
		set DEMON_HUNTER_M = oDEMON_HUNTER_M	
		set KEEPER = oKEEPER	
		set MOON_PRIESTESS = oMOON_PRIESTESS	
		set WARDEN = oWARDEN	
		set WISP = oWISP	
		set ARCHER = oARCHER	
		set DRUID_TALON = oDRUID_TALON	
		set DRUID_TALON_M = oDRUID_TALON_M	
		set BALLISTA = oBALLISTA	
		set DRUID_CLAW = oDRUID_CLAW	
		set DRUID_CLAW_M = oDRUID_CLAW_M	
		set DRYAD = oDRYAD	
		set HIPPO = oHIPPO	
		set HIPPO_RIDER = oHIPPO_RIDER	
		set HUNTRESS = oHUNTRESS	
		set CHIMAERA = oCHIMAERA	
		set ENT = oENT	
		set MOUNTAIN_GIANT = oMOUNTAIN_GIANT	
		set FAERIE_DRAGON = oFAERIE_DRAGON	
		set ANCIENT_LORE = oANCIENT_LORE	
		set ANCIENT_WAR = oANCIENT_WAR	
		set ANCIENT_WIND = oANCIENT_WIND	
		set TREE_AGES = oTREE_AGES	
		set TREE_ETERNITY = oTREE_ETERNITY	
		set TREE_LIFE = oTREE_LIFE	
		set ANCIENT_PROTECT = oANCIENT_PROTECT	
		set ELF_ALTAR = oELF_ALTAR	
		set CHIMAERA_ROOST = oCHIMAERA_ROOST	
		set HUNTERS_HALL = oHUNTERS_HALL	
		set MOON_WELL = oMOON_WELL	
		set ELF_MINE = oELF_MINE	
		set DEN_OF_WONDERS = oDEN_OF_WONDERS	
		set UPG_ULTRAVISION = oUPG_ULTRAVISION	
		set UPG_BLESSING = oUPG_BLESSING	
		set UPG_SCOUT = oUPG_SCOUT	
		set UPG_GLAIVE = oUPG_GLAIVE	
		set UPG_BOWS = oUPG_BOWS	
		set UPG_MARKSMAN = oUPG_MARKSMAN	
		set UPG_ABOLISH = oUPG_ABOLISH	
		set UPG_CHIM_ACID = oUPG_CHIM_ACID	
		set UPG_HIPPO_TAME = oUPG_HIPPO_TAME	
		set UPG_BOLT = oUPG_BOLT	
		set UPG_MARK_CLAW = oUPG_MARK_CLAW	
		set UPG_MARK_TALON = oUPG_MARK_TALON	
		set UPG_HARD_SKIN = oUPG_HARD_SKIN	
		set UPG_RESIST_SKIN = oUPG_RESIST_SKIN	
		set UPG_WELL_SPRING = oUPG_WELL_SPRING	
		set UPG_STR_MOON = oUPG_STR_MOON	
		set UPG_STR_WILD = oUPG_STR_WILD	
		set UPG_MOON_ARMOR = oUPG_MOON_ARMOR	
		set UPG_HIDES = oUPG_HIDES	
		set UPG_DRUID_TALON = oUPG_DRUID_TALON	
		set UPG_DRUID_CLAW = oUPG_DRUID_CLAW	
		set NAGA_SORCERESS = oNAGA_SORCERESS	
		set BEAST_MASTER = oBEAST_MASTER	
		set DARK_RANGER = oDARK_RANGER	
		set NEUTRAL_PIT_LORD = oNEUTRAL_PIT_LORD	
		set BREW_MASTER = oBREW_MASTER	
		set GOBLIN_TINKER = oGOBLIN_TINKER	
		set GOBLIN_TINKER_M = oGOBLIN_TINKER_M	
		set FIRELORD = oFIRELORD	
		set ALCHEMIST = oALCHEMIST	
		set ALCHEMIST_M1 = oALCHEMIST_M1	
		set ALCHEMIST_M2 = oALCHEMIST_M2	
		set ALCHEMIST_M3 = oALCHEMIST_M3	
		set LAVASPAWN = oLAVASPAWN	
		set LAVASPAWN2 = oLAVASPAWN2	
		set LAVASPAWN3 = oLAVASPAWN3	
		set OGRE_MAGI = oOGRE_MAGI	
		set SATYR_SHADOWDANCER = oSATYR_SHADOWDANCER	
		set FURBOLG_SHAMAN = oFURBOLG_SHAMAN	
		set THUNDER_LIZARD = oTHUNDER_LIZARD	
		set CENTAUR_OUTRUNNER = oCENTAUR_OUTRUNNER	
		set HARPY_ROGUE = oHARPY_ROGUE	
		set RAZORMANE_MEDICINE_MAN = oRAZORMANE_MEDICINE_MAN	
		set HARPY_WINDWITCH = oHARPY_WINDWITCH	
		set FEL_BEAST = oFEL_BEAST	
		set DRAENEI_DISCIPLE = oDRAENEI_DISCIPLE	
		set VOIDWALKER = oVOIDWALKER	
		set DRAENEI_DARKSLAYER = oDRAENEI_DARKSLAYER	
		set ROGUE = oROGUE	
		set ASSASSIN = oASSASSIN	
		set KOBOLD_GEOMANCER = oKOBOLD_GEOMANCER	
		set FOREST_TROLL_HIGH_PRIEST = oFOREST_TROLL_HIGH_PRIEST	
		set BURNING_ARCHER = oBURNING_ARCHER	
		set WILDKIN = oWILDKIN	
		set MURLOC_FLESHEATER = oMURLOC_FLESHEATER	
		set SLUDGE_FLINGER = oSLUDGE_FLINGER	
		set SATYR_SOULSTEALER = oSATYR_SOULSTEALER	
		set BARBED_ARACHNATHID = oBARBED_ARACHNATHID	
		set BLUE_DRAGONSPAWN_MEDDLER = oBLUE_DRAGONSPAWN_MEDDLER	
		set MAGNATAUR_WARRIOR = oMAGNATAUR_WARRIOR	
		set POLAR_FURBOLG_SHAMAN = oPOLAR_FURBOLG_SHAMAN	
		set GNOLL_BRUTE = oGNOLL_BRUTE	
		set GNOLL_WARDEN = oGNOLL_WARDEN	
		set MUD_GOLEM = oMUD_GOLEM	
		set FOREST_TROLL_BERSERKER = oFOREST_TROLL_BERSERKER	
		set FOREST_TROLL_SHADOW_PRIEST = oFOREST_TROLL_SHADOW_PRIEST	
		set OGRE_MAULER = oOGRE_MAULER	
		set GNOLL_OVERSEER = oGNOLL_OVERSEER	
		set ICE_TROLL_BERSERKER = oICE_TROLL_BERSERKER	
		set ICE_TROLL_TRAPPER = oICE_TROLL_TRAPPER	
		set NERUBIAN_WARRIOR = oNERUBIAN_WARRIOR	
		set FROST_REVENANT = oFROST_REVENANT	
		set NERUBIAN_WEBSPINNER = oNERUBIAN_WEBSPINNER	
		set MURGUL_SNARECASTER = oMURGUL_SNARECASTER	
		set MAKRURA_SNAPPER = oMAKRURA_SNAPPER	
		set MAKRURA_DEEPSEER = oMAKRURA_DEEPSEER	
		set GIANT_SEA_TURTLE = oGIANT_SEA_TURTLE	
		set KOBOLD = oKOBOLD	
		set MURLOC_HUNTSMAN = oMURLOC_HUNTSMAN	
		set BLACK_DRAGON_1 = oBLACK_DRAGON_1	
		set BLACK_DRAGON_2 = oBLACK_DRAGON_2	
		set BLACK_DRAGON_3 = oBLACK_DRAGON_3	
		set BLUE_DRAGON_1 = oBLUE_DRAGON_1	
		set BLUE_DRAGON_2 = oBLUE_DRAGON_2	
		set BLUE_DRAGON_3 = oBLUE_DRAGON_3	
		set BRONZE_DRAGON_1 = oBRONZE_DRAGON_1	
		set BRONZE_DRAGON_2 = oBRONZE_DRAGON_2	
		set BRONZE_DRAGON_3 = oBRONZE_DRAGON_3	
		set GREEN_DRAGON_1 = oGREEN_DRAGON_1	
		set GREEN_DRAGON_2 = oGREEN_DRAGON_2	
		set GREEN_DRAGON_3 = oGREEN_DRAGON_3	
		set NETHER_DRAGON_1 = oNETHER_DRAGON_1	
		set NETHER_DRAGON_2 = oNETHER_DRAGON_2	
		set NETHER_DRAGON_3 = oNETHER_DRAGON_3	
		set RED_DRAGON_1 = oRED_DRAGON_1	
		set RED_DRAGON_2 = oRED_DRAGON_2	
		set RED_DRAGON_3 = oRED_DRAGON_3	
		set SHREDDER = oSHREDDER	
		set SAPPER = oSAPPER	
		set ZEPPELIN = oZEPPELIN	
		set GOLD_MINE = oGOLD_MINE	
		set SCROLL_OF_REGENERATION = oSCROLL_OF_REGENERATION	
		set MECHANICAL_CRITTER = oMECHANICAL_CRITTER	
		set LESSER_CLARITY_POTION = oLESSER_CLARITY_POTION	
		set HEALING_POTION = oHEALING_POTION	
		set MANA_POTION = oMANA_POTION	
		set TOWN_PORTAL = oTOWN_PORTAL	
		set IVORY_TOWER = oIVORY_TOWER	
		set ORB_OF_FIRE = oORB_OF_FIRE	
		set STAFF_OF_SANCTUARY = oSTAFF_OF_SANCTUARY	
		set HEALING_SALVE = oHEALING_SALVE	
		set SCROLL_OF_SPEED = oSCROLL_OF_SPEED	
		set ORB_OF_LIGHTNING = oORB_OF_LIGHTNING	
		set TINY_GREAT_HALL = oTINY_GREAT_HALL	
		set ROD_OF_NECROMANCY = oROD_OF_NECROMANCY	
		set SACRIFICIAL_SKULL = oSACRIFICIAL_SKULL	
		set DUST_OF_APPEARANCE = oDUST_OF_APPEARANCE	
		set ORB_OF_CORRUPTION = oORB_OF_CORRUPTION	
		set SCROLL_OF_HEALING = oSCROLL_OF_HEALING	
		set MOONSTONE = oMOONSTONE	
		set STAFF_OF_PRESERVATION = oSTAFF_OF_PRESERVATION	
		set ORB_OF_VENOM = oORB_OF_VENOM	
		set ANTI_MAGIC_POTION = oANTI_MAGIC_POTION	
		set CIRCLET_OF_NOBILITY = oCIRCLET_OF_NOBILITY	
		set PERIAPT_OF_VITALITY = oPERIAPT_OF_VITALITY	
		set BOOTS_OF_SPEED = oBOOTS_OF_SPEED	
		set M_DUST_OF_APPEARANCE = oM_DUST_OF_APPEARANCE	
		set M_SCROLL_OF_HEALING = oM_SCROLL_OF_HEALING	
		set SCROLL_OF_PROTECTION = oSCROLL_OF_PROTECTION	
		set M_TOWN_PORTAL = oM_TOWN_PORTAL	
		set POTION_OF_INVISIBILITY = oPOTION_OF_INVISIBILITY	
		set TOME_OF_RETRAINING = oTOME_OF_RETRAINING	
		set STAFF_OF_TELEPORTATION = oSTAFF_OF_TELEPORTATION	
		set POTION_OF_LESSER_INVULNERBILITY = oPOTION_OF_LESSER_INVULNERBILITY	
		set JAINA = oJAINA	
		set MURADIN = oMURADIN	
		set GARITHOS = oGARITHOS	
		set KAEL = oKAEL	
		set BLOOD_PRIEST = oBLOOD_PRIEST	
		set BLOOD_SORCERESS = oBLOOD_SORCERESS	
		set BLOOD_PEASANT = oBLOOD_PEASANT	
		set CHURCH = oCHURCH	
		set MAGE_TOWER = oMAGE_TOWER	
		set GROM = oGROM	
		set THRALL = oTHRALL	
		set GUARDIAN = oGUARDIAN	
		set W2_WARLOCK = oW2_WARLOCK	
		set PIG_FARM = oPIG_FARM	
		set CHAOS_GRUNT = oCHAOS_GRUNT	
		set CHAOS_WARLOCK = oCHAOS_WARLOCK	
		set CHAOS_RAIDER = oCHAOS_RAIDER	
		set CHAOS_PEON = oCHAOS_PEON	
		set CHAOS_KODO = oCHAOS_KODO	
		set CHAOS_GROM = oCHAOS_GROM	
		set CHAOS_BLADEMASTER = oCHAOS_BLADEMASTER	
		set CHAOS_BURROW = oCHAOS_BURROW	
		set MALGANIS = oMALGANIS	
		set TICHONDRIUS  = oTICHONDRIUS 	
		set PIT_LORD = oPIT_LORD	
		set DETHEROC = oDETHEROC	
		set UNDEAD_BARGE = oUNDEAD_BARGE	
		set SYLVANUS = oSYLVANUS	
		set CENARIUS = oCENARIUS	
		set ILLIDAN = oILLIDAN	
		set ILLIDAN_DEMON = oILLIDAN_DEMON	
		set MAIEV = oMAIEV	
		set HIGH_ARCHER  = oHIGH_ARCHER 	
		set HIGH_FOOTMAN = oHIGH_FOOTMAN	
		set HIGH_FOOTMEN = oHIGH_FOOTMEN	
		set HIGH_SWORDMAN = oHIGH_SWORDMAN	
		set DRAGON_HAWK = oDRAGON_HAWK	
		set CORRUPT_TREANT = oCORRUPT_TREANT	
		set POISON_TREANT = oPOISON_TREANT	
		set PLAGUE_TREANT = oPLAGUE_TREANT	
		set SHANDRIS = oSHANDRIS	
		set ELF_FARM = oELF_FARM	
		set ELF_GUARD_TOWER = oELF_GUARD_TOWER	
		set HIGH_SKY = oHIGH_SKY	
		set HIGH_EARTH = oHIGH_EARTH	
		set HIGH_TOWER = oHIGH_TOWER	
		set ELF_HIGH_BARRACKS = oELF_HIGH_BARRACKS	
		set CORRUPT_LIFE = oCORRUPT_LIFE	
		set CORRUPT_WELL = oCORRUPT_WELL	
		set CORRUPT_PROTECTOR = oCORRUPT_PROTECTOR	
		set CORRUPT_WAR = oCORRUPT_WAR	
		set NAGA_VASHJ = oNAGA_VASHJ	
		set NAGA_DRAGON = oNAGA_DRAGON	
		set NAGA_WITCH = oNAGA_WITCH	
		set NAGA_SERPENT = oNAGA_SERPENT	
		set NAGA_HYDRA = oNAGA_HYDRA	
		set NAGA_SLAVE = oNAGA_SLAVE	
		set NAGA_SNAP_DRAGON = oNAGA_SNAP_DRAGON	
		set NAGA_COUATL = oNAGA_COUATL	
		set NAGA_SIREN = oNAGA_SIREN	
		set NAGA_MYRMIDON = oNAGA_MYRMIDON	
		set NAGA_REAVER = oNAGA_REAVER	
		set NAGA_TURTLE = oNAGA_TURTLE	
		set NAGA_ROYAL = oNAGA_ROYAL	
		set NAGA_TEMPLE = oNAGA_TEMPLE	
		set NAGA_CORAL = oNAGA_CORAL	
		set NAGA_SHRINE = oNAGA_SHRINE	
		set NAGA_SPAWNING = oNAGA_SPAWNING	
		set NAGA_GUARDIAN = oNAGA_GUARDIAN	
		set NAGA_ALTAR = oNAGA_ALTAR	
		set UPG_NAGA_ARMOR = oUPG_NAGA_ARMOR	
		set UPG_NAGA_ATTACK = oUPG_NAGA_ATTACK	
		set UPG_NAGA_ABOLISH = oUPG_NAGA_ABOLISH	
		set UPG_SIREN = oUPG_SIREN	
		set UPG_NAGA_ENSNARE = oUPG_NAGA_ENSNARE	
		set UPG_ORC_CHAOS = oUPG_ORC_CHAOS	

		set FOOTMEN = FOOTMAN
		set RIFLEMEN = RIFLEMAN
		set TANK = STEAM_TANK
		set GYRO = COPTER
		set PIT_FIEND = CRYPT_FIEND
		set OBS_STATUE = OBSIDIAN_STATUE
		set MOON_CHICK = MOON_PRIESTESS
		set MOON_BABE = MOON_PRIESTESS
		set MOON_HONEY = MOON_PRIESTESS
		set ORC_DRAGON = RED_DRAGON_3
		set ZEPPLIN = ZEPPELIN
	endif
endfunction

function InitArrays takes nothing returns nothing

    set old_id[ARCHMAGE] = oARCHMAGE
    set buy_type[ARCHMAGE] = BT_HERO
    set needed1[ARCHMAGE] = HUMAN_ALTAR
    set needed2[ARCHMAGE] = KEEP
    set needed3[ARCHMAGE] = CASTLE
    set tc_add1[ARCHMAGE] = 0
    set tc_add2[ARCHMAGE] = 0
    set available_time[ARCHMAGE] = 0
    set regenerate_time[ARCHMAGE] = 0
    set gold_price[ARCHMAGE] = 0
    set wood_price[ARCHMAGE] = 0
	set hero_rush_bonus[ARCHMAGE] = 0
	
    set old_id[PALADIN] = oPALADIN
    set buy_type[PALADIN] = BT_HERO
    set needed1[PALADIN] = HUMAN_ALTAR
    set needed2[PALADIN] = KEEP
    set needed3[PALADIN] = CASTLE
    set tc_add1[PALADIN] = 0
    set tc_add2[PALADIN] = 0
    set available_time[PALADIN] = 0
    set regenerate_time[PALADIN] = 0
    set gold_price[PALADIN] = 0
    set wood_price[PALADIN] = 0
	set hero_rush_bonus[PALADIN] = 0
	
    set old_id[MTN_KING] = oMTN_KING
    set buy_type[MTN_KING] = BT_HERO
    set needed1[MTN_KING] = HUMAN_ALTAR
    set needed2[MTN_KING] = KEEP
    set needed3[MTN_KING] = CASTLE
    set tc_add1[MTN_KING] = 0
    set tc_add2[MTN_KING] = 0
    set available_time[MTN_KING] = 0
    set regenerate_time[MTN_KING] = 0
    set gold_price[MTN_KING] = 0
    set wood_price[MTN_KING] = 0
	set hero_rush_bonus[MTN_KING] = 0
	
    set old_id[BLOOD_MAGE] = oBLOOD_MAGE
    set buy_type[BLOOD_MAGE] = BT_HERO
    set needed1[BLOOD_MAGE] = HUMAN_ALTAR
    set needed2[BLOOD_MAGE] = KEEP
    set needed3[BLOOD_MAGE] = CASTLE
    set tc_add1[BLOOD_MAGE] = 0
    set tc_add2[BLOOD_MAGE] = 0
    set available_time[BLOOD_MAGE] = 0
    set regenerate_time[BLOOD_MAGE] = 0
    set gold_price[BLOOD_MAGE] = 0
    set wood_price[BLOOD_MAGE] = 0
	set hero_rush_bonus[BLOOD_MAGE] = 0
	
    set old_id[COPTER] = oCOPTER
    set buy_type[COPTER] = BT_UNIT
    set needed1[COPTER] = WORKSHOP
    set needed2[COPTER] = 0
    set needed3[COPTER] = 0
    set tc_add1[COPTER] = 0
    set tc_add2[COPTER] = 0
    set available_time[COPTER] = 0
    set regenerate_time[COPTER] = 0
    set gold_price[COPTER] = 0
    set wood_price[COPTER] = 0
	set hero_rush_bonus[COPTER] = 0
	
    set old_id[ELEMENTAL] = oELEMENTAL
    set buy_type[ELEMENTAL] = BT_UNIT
    set needed1[ELEMENTAL] = ARCHMAGE
    set needed2[ELEMENTAL] = 0
    set needed3[ELEMENTAL] = 0
    set tc_add1[ELEMENTAL] = 0
    set tc_add2[ELEMENTAL] = 0
    set available_time[ELEMENTAL] = 0
    set regenerate_time[ELEMENTAL] = 0
    set gold_price[ELEMENTAL] = 0
    set wood_price[ELEMENTAL] = 0
	set hero_rush_bonus[ELEMENTAL] = 0
	
    set old_id[ELEMENTAL2] = oELEMENTAL2
    set buy_type[ELEMENTAL2] = BT_UNIT
    set needed1[ELEMENTAL2] = ARCHMAGE
    set needed2[ELEMENTAL2] = 0
    set needed3[ELEMENTAL2] = 0
    set tc_add1[ELEMENTAL2] = 0
    set tc_add2[ELEMENTAL2] = 0
    set available_time[ELEMENTAL2] = 0
    set regenerate_time[ELEMENTAL2] = 0
    set gold_price[ELEMENTAL2] = 0
    set wood_price[ELEMENTAL2] = 0
	set hero_rush_bonus[ELEMENTAL2] = 0
	
    set old_id[ELEMENTAL3] = oELEMENTAL3
    set buy_type[ELEMENTAL3] = BT_UNIT
    set needed1[ELEMENTAL3] = ARCHMAGE
    set needed2[ELEMENTAL3] = 0
    set needed3[ELEMENTAL3] = 0
    set tc_add1[ELEMENTAL3] = 0
    set tc_add2[ELEMENTAL3] = 0
    set available_time[ELEMENTAL3] = 0
    set regenerate_time[ELEMENTAL3] = 0
    set gold_price[ELEMENTAL3] = 0
    set wood_price[ELEMENTAL3] = 0
	set hero_rush_bonus[ELEMENTAL3] = 0
	
    set old_id[FOOTMAN] = oFOOTMAN
    set buy_type[FOOTMAN] = BT_UNIT
    set needed1[FOOTMAN] = BARRACKS
    set needed2[FOOTMAN] = 0
    set needed3[FOOTMAN] = 0
    set tc_add1[FOOTMAN] = 0
    set tc_add2[FOOTMAN] = 0
    set available_time[FOOTMAN] = 0
    set regenerate_time[FOOTMAN] = 0
    set gold_price[FOOTMAN] = 0
    set wood_price[FOOTMAN] = 0
	set hero_rush_bonus[FOOTMAN] = 0
	
    set old_id[GRYPHON] = oGRYPHON
    set buy_type[GRYPHON] = BT_UNIT
    set needed1[GRYPHON] = AVIARY
    set needed2[GRYPHON] = 0
    set needed3[GRYPHON] = 0
    set tc_add1[GRYPHON] = 0
    set tc_add2[GRYPHON] = 0
    set available_time[GRYPHON] = 0
    set regenerate_time[GRYPHON] = 0
    set gold_price[GRYPHON] = 0
    set wood_price[GRYPHON] = 0
	set hero_rush_bonus[GRYPHON] = 0
	
    set old_id[KNIGHT] = oKNIGHT
    set buy_type[KNIGHT] = BT_UNIT
    set needed1[KNIGHT] = BARRACKS
    set needed2[KNIGHT] = CASTLE
    set needed3[KNIGHT] = BLACKSMITH
    set tc_add1[KNIGHT] = 0
    set tc_add2[KNIGHT] = 0
    set available_time[KNIGHT] = 0
    set regenerate_time[KNIGHT] = 0
    set gold_price[KNIGHT] = 0
    set wood_price[KNIGHT] = 0
	set hero_rush_bonus[KNIGHT] = 0
	
    set old_id[MORTAR] = oMORTAR
    set buy_type[MORTAR] = BT_UNIT
    set needed1[MORTAR] = WORKSHOP
    set needed2[MORTAR] = 0
    set needed3[MORTAR] = 0
    set tc_add1[MORTAR] = 0
    set tc_add2[MORTAR] = 0
    set available_time[MORTAR] = 0
    set regenerate_time[MORTAR] = 0
    set gold_price[MORTAR] = 0
    set wood_price[MORTAR] = 0
	set hero_rush_bonus[MORTAR] = 0
	
    set old_id[PEASANT] = oPEASANT
    set buy_type[PEASANT] = BT_UNIT
    set needed1[PEASANT] = TOWN_HALL
    set needed2[PEASANT] = 0
    set needed3[PEASANT] = 0
    set tc_add1[PEASANT] = MILITIA
    set tc_add2[PEASANT] = 0
    set available_time[PEASANT] = 0
    set regenerate_time[PEASANT] = 0
    set gold_price[PEASANT] = 0
    set wood_price[PEASANT] = 0
	set hero_rush_bonus[PEASANT] = 0
	
    set old_id[PRIEST] = oPRIEST
    set buy_type[PRIEST] = BT_UNIT
    set needed1[PRIEST] = SANCTUM
    set needed2[PRIEST] = 0
    set needed3[PRIEST] = 0
    set tc_add1[PRIEST] = 0
    set tc_add2[PRIEST] = 0
    set available_time[PRIEST] = 0
    set regenerate_time[PRIEST] = 0
    set gold_price[PRIEST] = 0
    set wood_price[PRIEST] = 0
	set hero_rush_bonus[PRIEST] = 0
	
    set old_id[RIFLEMAN] = oRIFLEMAN
    set buy_type[RIFLEMAN] = BT_UNIT
    set needed1[RIFLEMAN] = BARRACKS
    set needed2[RIFLEMAN] = BLACKSMITH
    set needed3[RIFLEMAN] = 0
    set tc_add1[RIFLEMAN] = 0
    set tc_add2[RIFLEMAN] = 0
    set available_time[RIFLEMAN] = 0
    set regenerate_time[RIFLEMAN] = 0
    set gold_price[RIFLEMAN] = 0
    set wood_price[RIFLEMAN] = 0
	set hero_rush_bonus[RIFLEMAN] = 0
	
    set old_id[SORCERESS] = oSORCERESS
    set buy_type[SORCERESS] = BT_UNIT
    set needed1[SORCERESS] = SANCTUM
    set needed2[SORCERESS] = 0
    set needed3[SORCERESS] = 0
    set tc_add1[SORCERESS] = 0
    set tc_add2[SORCERESS] = 0
    set available_time[SORCERESS] = 0
    set regenerate_time[SORCERESS] = 0
    set gold_price[SORCERESS] = 0
    set wood_price[SORCERESS] = 0
	set hero_rush_bonus[SORCERESS] = 0
	
    set old_id[STEAM_TANK] = oSTEAM_TANK
    set buy_type[STEAM_TANK] = BT_UNIT
    set needed1[STEAM_TANK] = WORKSHOP
    set needed2[STEAM_TANK] = CASTLE
    set needed3[STEAM_TANK] = 0
    set tc_add1[STEAM_TANK] = 0
    set tc_add2[STEAM_TANK] = 0
    set available_time[STEAM_TANK] = 0
    set regenerate_time[STEAM_TANK] = 0
    set gold_price[STEAM_TANK] = 0
    set wood_price[STEAM_TANK] = 0
	set hero_rush_bonus[STEAM_TANK] = 0
	
    set old_id[ROCKET_TANK] = oROCKET_TANK
    set buy_type[ROCKET_TANK] = BT_UNIT
    set needed1[ROCKET_TANK] = WORKSHOP
    set needed2[ROCKET_TANK] = CASTLE
    set needed3[ROCKET_TANK] = 0
    set tc_add1[ROCKET_TANK] = 0
    set tc_add2[ROCKET_TANK] = 0
    set available_time[ROCKET_TANK] = 0
    set regenerate_time[ROCKET_TANK] = 0
    set gold_price[ROCKET_TANK] = 0
    set wood_price[ROCKET_TANK] = 0
	set hero_rush_bonus[ROCKET_TANK] = 0
	
    set old_id[MILITIA] = oMILITIA
    set buy_type[MILITIA] = BT_UNIT
    set needed1[MILITIA] = 0
    set needed2[MILITIA] = 0
    set needed3[MILITIA] = 0
    set tc_add1[MILITIA] = PEASANT
    set tc_add2[MILITIA] = 0
    set available_time[MILITIA] = 0
    set regenerate_time[MILITIA] = 0
    set gold_price[MILITIA] = 0
    set wood_price[MILITIA] = 0
	set hero_rush_bonus[MILITIA] = 0
	
    set old_id[SPELL_BREAKER] = oSPELL_BREAKER
    set buy_type[SPELL_BREAKER] = BT_UNIT
    set needed1[SPELL_BREAKER] = SANCTUM
    set needed2[SPELL_BREAKER] = ARCANE_VAULT
    set needed3[SPELL_BREAKER] = 0
    set tc_add1[SPELL_BREAKER] = 0
    set tc_add2[SPELL_BREAKER] = 0
    set available_time[SPELL_BREAKER] = 0
    set regenerate_time[SPELL_BREAKER] = 0
    set gold_price[SPELL_BREAKER] = 0
    set wood_price[SPELL_BREAKER] = 0
	set hero_rush_bonus[SPELL_BREAKER] = 0
	
    set old_id[HUMAN_DRAGON_HAWK] = oHUMAN_DRAGON_HAWK
    set buy_type[HUMAN_DRAGON_HAWK] = BT_UNIT
    set needed1[HUMAN_DRAGON_HAWK] = AVIARY
    set needed2[HUMAN_DRAGON_HAWK] = 0
    set needed3[HUMAN_DRAGON_HAWK] = 0
    set tc_add1[HUMAN_DRAGON_HAWK] = 0
    set tc_add2[HUMAN_DRAGON_HAWK] = 0
    set available_time[HUMAN_DRAGON_HAWK] = 0
    set regenerate_time[HUMAN_DRAGON_HAWK] = 0
    set gold_price[HUMAN_DRAGON_HAWK] = 0
    set wood_price[HUMAN_DRAGON_HAWK] = 0
	set hero_rush_bonus[HUMAN_DRAGON_HAWK] = 0
	
    set old_id[AVIARY] = oAVIARY
    set buy_type[AVIARY] = BT_BUILDING
    set needed1[AVIARY] = PEASANT 
    set needed2[AVIARY] = KEEP
    set needed3[AVIARY] = LUMBER_MILL
    set tc_add1[AVIARY] = 0
    set tc_add2[AVIARY] = 0
    set available_time[AVIARY] = 0
    set regenerate_time[AVIARY] = 0
    set gold_price[AVIARY] = 0
    set wood_price[AVIARY] = 0
	set hero_rush_bonus[AVIARY] = 0
	
    set old_id[BARRACKS] = oBARRACKS
    set buy_type[BARRACKS] = BT_BUILDING
    set needed1[BARRACKS] = PEASANT 
    set needed2[BARRACKS] = 0
    set needed3[BARRACKS] = 0
    set tc_add1[BARRACKS] = 0
    set tc_add2[BARRACKS] = 0
    set available_time[BARRACKS] = 0
    set regenerate_time[BARRACKS] = 0
    set gold_price[BARRACKS] = 0
    set wood_price[BARRACKS] = 0
	set hero_rush_bonus[BARRACKS] = 0
	
    set old_id[BLACKSMITH] = oBLACKSMITH
    set buy_type[BLACKSMITH] = BT_BUILDING
    set needed1[BLACKSMITH] = PEASANT 
    set needed2[BLACKSMITH] = TOWN_HALL
    set needed3[BLACKSMITH] = 0
    set tc_add1[BLACKSMITH] = 0
    set tc_add2[BLACKSMITH] = 0
    set available_time[BLACKSMITH] = 0
    set regenerate_time[BLACKSMITH] = 0
    set gold_price[BLACKSMITH] = 0
    set wood_price[BLACKSMITH] = 0
	set hero_rush_bonus[BLACKSMITH] = 0
	
    set old_id[CANNON_TOWER] = oCANNON_TOWER
    set buy_type[CANNON_TOWER] = BT_BUILDING
    set needed1[CANNON_TOWER] = WATCH_TOWER
    set needed2[CANNON_TOWER] = WORKSHOP
    set needed3[CANNON_TOWER] = UPGRADED
    set tc_add1[CANNON_TOWER] = 0
    set tc_add2[CANNON_TOWER] = 0
    set available_time[CANNON_TOWER] = 0
    set regenerate_time[CANNON_TOWER] = 0
    set gold_price[CANNON_TOWER] = 0
    set wood_price[CANNON_TOWER] = 0
	set hero_rush_bonus[CANNON_TOWER] = 0
	
    set old_id[CASTLE] = oCASTLE
    set buy_type[CASTLE] = BT_BUILDING
    set needed1[CASTLE] = KEEP          
    set needed2[CASTLE] = HUMAN_ALTAR
    set needed3[CASTLE] = UPGRADED
    set tc_add1[CASTLE] = 0
    set tc_add2[CASTLE] = 0
    set available_time[CASTLE] = 0
    set regenerate_time[CASTLE] = 0
    set gold_price[CASTLE] = 0
    set wood_price[CASTLE] = 0
	set hero_rush_bonus[CASTLE] = 0
	
    set old_id[GUARD_TOWER] = oGUARD_TOWER
    set buy_type[GUARD_TOWER] = BT_BUILDING
    set needed1[GUARD_TOWER] = WATCH_TOWER
    set needed2[GUARD_TOWER] = LUMBER_MILL
    set needed3[GUARD_TOWER] = UPGRADED
    set tc_add1[GUARD_TOWER] = 0
    set tc_add2[GUARD_TOWER] = 0
    set available_time[GUARD_TOWER] = 0
    set regenerate_time[GUARD_TOWER] = 0
    set gold_price[GUARD_TOWER] = 0
    set wood_price[GUARD_TOWER] = 0
	set hero_rush_bonus[GUARD_TOWER] = 0
	
    set old_id[HOUSE] = oHOUSE
    set buy_type[HOUSE] = BT_BUILDING
    set needed1[HOUSE] = PEASANT 
    set needed2[HOUSE] = 0
    set needed3[HOUSE] = 0
    set tc_add1[HOUSE] = 0
    set tc_add2[HOUSE] = 0
    set available_time[HOUSE] = 0
    set regenerate_time[HOUSE] = 0
    set gold_price[HOUSE] = 0
    set wood_price[HOUSE] = 0
	set hero_rush_bonus[HOUSE] = 0
	
    set old_id[HUMAN_ALTAR] = oHUMAN_ALTAR
    set buy_type[HUMAN_ALTAR] = BT_BUILDING
    set needed1[HUMAN_ALTAR] = PEASANT 
    set needed2[HUMAN_ALTAR] = 0
    set needed3[HUMAN_ALTAR] = 0
    set tc_add1[HUMAN_ALTAR] = 0
    set tc_add2[HUMAN_ALTAR] = 0
    set available_time[HUMAN_ALTAR] = 0
    set regenerate_time[HUMAN_ALTAR] = 0
    set gold_price[HUMAN_ALTAR] = 0
    set wood_price[HUMAN_ALTAR] = 0
	set hero_rush_bonus[HUMAN_ALTAR] = 0
	
    set old_id[KEEP] = oKEEP
    set buy_type[KEEP] = BT_BUILDING
    set needed1[KEEP] = TOWN_HALL 
    set needed2[KEEP] = 0
    set needed3[KEEP] = UPGRADED
    set tc_add1[KEEP] = CASTLE
    set tc_add2[KEEP] = 0
    set available_time[KEEP] = 0
    set regenerate_time[KEEP] = 0
    set gold_price[KEEP] = 0
    set wood_price[KEEP] = 0
	set hero_rush_bonus[KEEP] = 0
	
    set old_id[LUMBER_MILL] = oLUMBER_MILL
    set buy_type[LUMBER_MILL] = BT_BUILDING
    set needed1[LUMBER_MILL] = PEASANT 
    set needed2[LUMBER_MILL] = 0
    set needed3[LUMBER_MILL] = 0
    set tc_add1[LUMBER_MILL] = 0
    set tc_add2[LUMBER_MILL] = 0
    set available_time[LUMBER_MILL] = 0
    set regenerate_time[LUMBER_MILL] = 0
    set gold_price[LUMBER_MILL] = 0
    set wood_price[LUMBER_MILL] = 0
	set hero_rush_bonus[LUMBER_MILL] = 0
	
    set old_id[SANCTUM] = oSANCTUM
    set buy_type[SANCTUM] = BT_BUILDING
    set needed1[SANCTUM] = PEASANT 
    set needed2[SANCTUM] = KEEP
    set needed3[SANCTUM] = 0
    set tc_add1[SANCTUM] = 0
    set tc_add2[SANCTUM] = 0
    set available_time[SANCTUM] = 0
    set regenerate_time[SANCTUM] = 0
    set gold_price[SANCTUM] = 0
    set wood_price[SANCTUM] = 0
	set hero_rush_bonus[SANCTUM] = 0
	
    set old_id[ARCANE_SANCTUM] = oARCANE_SANCTUM
    set buy_type[ARCANE_SANCTUM] = BT_BUILDING
    set needed1[ARCANE_SANCTUM] = PEASANT 
    set needed2[ARCANE_SANCTUM] = KEEP
    set needed3[ARCANE_SANCTUM] = 0
    set tc_add1[ARCANE_SANCTUM] = 0
    set tc_add2[ARCANE_SANCTUM] = 0
    set available_time[ARCANE_SANCTUM] = 0
    set regenerate_time[ARCANE_SANCTUM] = 0
    set gold_price[ARCANE_SANCTUM] = 0
    set wood_price[ARCANE_SANCTUM] = 0
	set hero_rush_bonus[ARCANE_SANCTUM] = 0
	
    set old_id[TOWN_HALL] = oTOWN_HALL
    set buy_type[TOWN_HALL] = BT_BUILDING
    set needed1[TOWN_HALL] = 0
    set needed2[TOWN_HALL] = 0
    set needed3[TOWN_HALL] = 0
    set tc_add1[TOWN_HALL] = KEEP
    set tc_add2[TOWN_HALL] = CASTLE
    set available_time[TOWN_HALL] = 0
    set regenerate_time[TOWN_HALL] = 0
    set gold_price[TOWN_HALL] = 0
    set wood_price[TOWN_HALL] = 0
	set hero_rush_bonus[TOWN_HALL] = 0
	
    set old_id[WATCH_TOWER] = oWATCH_TOWER
    set buy_type[WATCH_TOWER] = BT_BUILDING
    set needed1[WATCH_TOWER] = PEASANT 
    set needed2[WATCH_TOWER] = 0
    set needed3[WATCH_TOWER] = 0
    set tc_add1[WATCH_TOWER] = GUARD_TOWER
    set tc_add2[WATCH_TOWER] = CANNON_TOWER
    set available_time[WATCH_TOWER] = 0
    set regenerate_time[WATCH_TOWER] = 0
    set gold_price[WATCH_TOWER] = 0
    set wood_price[WATCH_TOWER] = 0
	set hero_rush_bonus[WATCH_TOWER] = 0
	
    set old_id[WORKSHOP] = oWORKSHOP
    set buy_type[WORKSHOP] = BT_BUILDING
    set needed1[WORKSHOP] = PEASANT 
    set needed2[WORKSHOP] = KEEP
    set needed3[WORKSHOP] = BLACKSMITH
    set tc_add1[WORKSHOP] = 0
    set tc_add2[WORKSHOP] = 0
    set available_time[WORKSHOP] = 0
    set regenerate_time[WORKSHOP] = 0
    set gold_price[WORKSHOP] = 0
    set wood_price[WORKSHOP] = 0
	set hero_rush_bonus[WORKSHOP] = 0
	
    set old_id[ARCANE_VAULT] = oARCANE_VAULT
    set buy_type[ARCANE_VAULT] = BT_BUILDING
    set needed1[ARCANE_VAULT] = PEASANT 
    set needed2[ARCANE_VAULT] = 0
    set needed3[ARCANE_VAULT] = 0
    set tc_add1[ARCANE_VAULT] = 0
    set tc_add2[ARCANE_VAULT] = 0
    set available_time[ARCANE_VAULT] = 0
    set regenerate_time[ARCANE_VAULT] = 0
    set gold_price[ARCANE_VAULT] = 0
    set wood_price[ARCANE_VAULT] = 0
	set hero_rush_bonus[ARCANE_VAULT] = 0
	
    set old_id[ARCANE_TOWER] = oARCANE_TOWER
    set buy_type[ARCANE_TOWER] = BT_BUILDING
    set needed1[ARCANE_TOWER] = WATCH_TOWER
    set needed2[ARCANE_TOWER] = 0
    set needed3[ARCANE_TOWER] = UPGRADED
    set tc_add1[ARCANE_TOWER] = 0
    set tc_add2[ARCANE_TOWER] = 0
    set available_time[ARCANE_TOWER] = 0
    set regenerate_time[ARCANE_TOWER] = 0
    set gold_price[ARCANE_TOWER] = 0
    set wood_price[ARCANE_TOWER] = 0
	set hero_rush_bonus[ARCANE_TOWER] = 0
	
    set old_id[UPG_MELEE] = oUPG_MELEE
    set buy_type[UPG_MELEE] = BT_ML_UPGRADE
    set needed1[UPG_MELEE] = BLACKSMITH
    set needed2[UPG_MELEE] = KEEP
    set needed3[UPG_MELEE] = CASTLE
    set tc_add1[UPG_MELEE] = 0
    set tc_add2[UPG_MELEE] = 0
    set available_time[UPG_MELEE] = 0
    set regenerate_time[UPG_MELEE] = 0
    set gold_price[UPG_MELEE] = 0
    set wood_price[UPG_MELEE] = 0
	set hero_rush_bonus[UPG_MELEE] = 0
	
    set old_id[UPG_RANGED] = oUPG_RANGED
    set buy_type[UPG_RANGED] = BT_ML_UPGRADE
    set needed1[UPG_RANGED] = BLACKSMITH
    set needed2[UPG_RANGED] = KEEP
    set needed3[UPG_RANGED] = CASTLE
    set tc_add1[UPG_RANGED] = 0
    set tc_add2[UPG_RANGED] = 0
    set available_time[UPG_RANGED] = 0
    set regenerate_time[UPG_RANGED] = 0
    set gold_price[UPG_RANGED] = 0
    set wood_price[UPG_RANGED] = 0
	set hero_rush_bonus[UPG_RANGED] = 0
	
    set old_id[UPG_ARMOR] = oUPG_ARMOR
    set buy_type[UPG_ARMOR] = BT_ML_UPGRADE
    set needed1[UPG_ARMOR] = BLACKSMITH
    set needed2[UPG_ARMOR] = KEEP
    set needed3[UPG_ARMOR] = CASTLE
    set tc_add1[UPG_ARMOR] = 0
    set tc_add2[UPG_ARMOR] = 0
    set available_time[UPG_ARMOR] = 0
    set regenerate_time[UPG_ARMOR] = 0
    set gold_price[UPG_ARMOR] = 0
    set wood_price[UPG_ARMOR] = 0
	set hero_rush_bonus[UPG_ARMOR] = 0
	
    set old_id[UPG_MASONRY] = oUPG_MASONRY
    set buy_type[UPG_MASONRY] = BT_ML_UPGRADE
    set needed1[UPG_MASONRY] = LUMBER_MILL
    set needed2[UPG_MASONRY] = KEEP
    set needed3[UPG_MASONRY] = CASTLE
    set tc_add1[UPG_MASONRY] = 0
    set tc_add2[UPG_MASONRY] = 0
    set available_time[UPG_MASONRY] = 0
    set regenerate_time[UPG_MASONRY] = 0
    set gold_price[UPG_MASONRY] = 0
    set wood_price[UPG_MASONRY] = 0
	set hero_rush_bonus[UPG_MASONRY] = 0
	
    set old_id[UPG_SIGHT] = oUPG_SIGHT
    set buy_type[UPG_SIGHT] = BT_UPGRADE
    set needed1[UPG_SIGHT] = SANCTUM
    set needed2[UPG_SIGHT] = CASTLE
    set needed3[UPG_SIGHT] = 0
    set tc_add1[UPG_SIGHT] = 0
    set tc_add2[UPG_SIGHT] = 0
    set available_time[UPG_SIGHT] = 0
    set regenerate_time[UPG_SIGHT] = 0
    set gold_price[UPG_SIGHT] = 0
    set wood_price[UPG_SIGHT] = 0
	set hero_rush_bonus[UPG_SIGHT] = 0
	
    set old_id[UPG_DEFEND] = oUPG_DEFEND
    set buy_type[UPG_DEFEND] = BT_UPGRADE
    set needed1[UPG_DEFEND] = BARRACKS
    set needed2[UPG_DEFEND] = 0
    set needed3[UPG_DEFEND] = 0
    set tc_add1[UPG_DEFEND] = 0
    set tc_add2[UPG_DEFEND] = 0
    set available_time[UPG_DEFEND] = 0
    set regenerate_time[UPG_DEFEND] = 0
    set gold_price[UPG_DEFEND] = 0
    set wood_price[UPG_DEFEND] = 0
	set hero_rush_bonus[UPG_DEFEND] = 0
	
    set old_id[UPG_BREEDING] = oUPG_BREEDING
    set buy_type[UPG_BREEDING] = BT_UPGRADE
    set needed1[UPG_BREEDING] = BARRACKS
    set needed2[UPG_BREEDING] = CASTLE
    set needed3[UPG_BREEDING] = BLACKSMITH
    set tc_add1[UPG_BREEDING] = 0
    set tc_add2[UPG_BREEDING] = 0
    set available_time[UPG_BREEDING] = 0
    set regenerate_time[UPG_BREEDING] = 0
    set gold_price[UPG_BREEDING] = 0
    set wood_price[UPG_BREEDING] = 0
	set hero_rush_bonus[UPG_BREEDING] = 0
	
    set old_id[UPG_PRAYING] = oUPG_PRAYING
    set buy_type[UPG_PRAYING] = BT_ML_UPGRADE
    set needed1[UPG_PRAYING] = SANCTUM
    set needed2[UPG_PRAYING] = CASTLE
    set needed3[UPG_PRAYING] = 0
    set tc_add1[UPG_PRAYING] = 0
    set tc_add2[UPG_PRAYING] = 0
    set available_time[UPG_PRAYING] = 0
    set regenerate_time[UPG_PRAYING] = 0
    set gold_price[UPG_PRAYING] = 0
    set wood_price[UPG_PRAYING] = 0
	set hero_rush_bonus[UPG_PRAYING] = 0
	
    set old_id[UPG_SORCERY] = oUPG_SORCERY
    set buy_type[UPG_SORCERY] = BT_ML_UPGRADE
    set needed1[UPG_SORCERY] = SANCTUM
    set needed2[UPG_SORCERY] = CASTLE
    set needed3[UPG_SORCERY] = 0
    set tc_add1[UPG_SORCERY] = 0
    set tc_add2[UPG_SORCERY] = 0
    set available_time[UPG_SORCERY] = 0
    set regenerate_time[UPG_SORCERY] = 0
    set gold_price[UPG_SORCERY] = 0
    set wood_price[UPG_SORCERY] = 0
	set hero_rush_bonus[UPG_SORCERY] = 0
	
    set old_id[UPG_LEATHER] = oUPG_LEATHER
    set buy_type[UPG_LEATHER] = BT_ML_UPGRADE
    set needed1[UPG_LEATHER] = BLACKSMITH
    set needed2[UPG_LEATHER] = KEEP
    set needed3[UPG_LEATHER] = CASTLE
    set tc_add1[UPG_LEATHER] = 0
    set tc_add2[UPG_LEATHER] = 0
    set available_time[UPG_LEATHER] = 0
    set regenerate_time[UPG_LEATHER] = 0
    set gold_price[UPG_LEATHER] = 0
    set wood_price[UPG_LEATHER] = 0
	set hero_rush_bonus[UPG_LEATHER] = 0
	
    set old_id[UPG_GUN_RANGE] = oUPG_GUN_RANGE
    set buy_type[UPG_GUN_RANGE] = BT_UPGRADE
    set needed1[UPG_GUN_RANGE] = BARRACKS
    set needed2[UPG_GUN_RANGE] = KEEP
    set needed3[UPG_GUN_RANGE] = 0
    set tc_add1[UPG_GUN_RANGE] = 0
    set tc_add2[UPG_GUN_RANGE] = 0
    set available_time[UPG_GUN_RANGE] = 0
    set regenerate_time[UPG_GUN_RANGE] = 0
    set gold_price[UPG_GUN_RANGE] = 0
    set wood_price[UPG_GUN_RANGE] = 0
	set hero_rush_bonus[UPG_GUN_RANGE] = 0
	
    set old_id[UPG_WOOD] = oUPG_WOOD
    set buy_type[UPG_WOOD] = BT_ML_UPGRADE
    set needed1[UPG_WOOD] = LUMBER_MILL
    set needed2[UPG_WOOD] = KEEP
    set needed3[UPG_WOOD] = CASTLE
    set tc_add1[UPG_WOOD] = 0
    set tc_add2[UPG_WOOD] = 0
    set available_time[UPG_WOOD] = 0
    set regenerate_time[UPG_WOOD] = 0
    set gold_price[UPG_WOOD] = 0
    set wood_price[UPG_WOOD] = 0
	set hero_rush_bonus[UPG_WOOD] = 0
	
    set old_id[UPG_SENTINEL] = oUPG_SENTINEL
    set buy_type[UPG_SENTINEL] = BT_UPGRADE
    set needed1[UPG_SENTINEL] = WORKSHOP
    set needed2[UPG_SENTINEL] = KEEP
    set needed3[UPG_SENTINEL] = 0
    set tc_add1[UPG_SENTINEL] = 0
    set tc_add2[UPG_SENTINEL] = 0
    set available_time[UPG_SENTINEL] = 0
    set regenerate_time[UPG_SENTINEL] = 0
    set gold_price[UPG_SENTINEL] = 0
    set wood_price[UPG_SENTINEL] = 0
	set hero_rush_bonus[UPG_SENTINEL] = 0
	
    set old_id[UPG_BOMBS] = oUPG_BOMBS
    set buy_type[UPG_BOMBS] = BT_UPGRADE
    set needed1[UPG_BOMBS] = WORKSHOP
    set needed2[UPG_BOMBS] = CASTLE
    set needed3[UPG_BOMBS] = 0
    set tc_add1[UPG_BOMBS] = 0
    set tc_add2[UPG_BOMBS] = 0
    set available_time[UPG_BOMBS] = 0
    set regenerate_time[UPG_BOMBS] = 0
    set gold_price[UPG_BOMBS] = 0
    set wood_price[UPG_BOMBS] = 0
	set hero_rush_bonus[UPG_BOMBS] = 0
	
    set old_id[UPG_HAMMERS] = oUPG_HAMMERS
    set buy_type[UPG_HAMMERS] = BT_UPGRADE
    set needed1[UPG_HAMMERS] = AVIARY
    set needed2[UPG_HAMMERS] = CASTLE
    set needed3[UPG_HAMMERS] = 0
    set tc_add1[UPG_HAMMERS] = 0
    set tc_add2[UPG_HAMMERS] = 0
    set available_time[UPG_HAMMERS] = 0
    set regenerate_time[UPG_HAMMERS] = 0
    set gold_price[UPG_HAMMERS] = 0
    set wood_price[UPG_HAMMERS] = 0
	set hero_rush_bonus[UPG_HAMMERS] = 0
	
    set old_id[UPG_CONT_MAGIC] = oUPG_CONT_MAGIC
    set buy_type[UPG_CONT_MAGIC] = BT_UPGRADE
    set needed1[UPG_CONT_MAGIC] = SANCTUM
    set needed2[UPG_CONT_MAGIC] = CASTLE
    set needed3[UPG_CONT_MAGIC] = ARCANE_VAULT
    set tc_add1[UPG_CONT_MAGIC] = 0
    set tc_add2[UPG_CONT_MAGIC] = 0
    set available_time[UPG_CONT_MAGIC] = 0
    set regenerate_time[UPG_CONT_MAGIC] = 0
    set gold_price[UPG_CONT_MAGIC] = 0
    set wood_price[UPG_CONT_MAGIC] = 0
	set hero_rush_bonus[UPG_CONT_MAGIC] = 0
	
    set old_id[UPG_FRAGS] = oUPG_FRAGS
    set buy_type[UPG_FRAGS] = BT_UPGRADE
    set needed1[UPG_FRAGS] = WORKSHOP
    set needed2[UPG_FRAGS] = CASTLE
    set needed3[UPG_FRAGS] = 0
    set tc_add1[UPG_FRAGS] = 0
    set tc_add2[UPG_FRAGS] = 0
    set available_time[UPG_FRAGS] = 0
    set regenerate_time[UPG_FRAGS] = 0
    set gold_price[UPG_FRAGS] = 0
    set wood_price[UPG_FRAGS] = 0
	set hero_rush_bonus[UPG_FRAGS] = 0
	
    set old_id[UPG_TANK] = oUPG_TANK
    set buy_type[UPG_TANK] = BT_UPGRADE
    set needed1[UPG_TANK] = WORKSHOP
    set needed2[UPG_TANK] = CASTLE
    set needed3[UPG_TANK] = 0
    set tc_add1[UPG_TANK] = 0
    set tc_add2[UPG_TANK] = 0
    set available_time[UPG_TANK] = 0
    set regenerate_time[UPG_TANK] = 0
    set gold_price[UPG_TANK] = 0
    set wood_price[UPG_TANK] = 0
	set hero_rush_bonus[UPG_TANK] = 0
	
    set old_id[UPG_FLAK] = oUPG_FLAK
    set buy_type[UPG_FLAK] = BT_UPGRADE
    set needed1[UPG_FLAK] = WORKSHOP
    set needed2[UPG_FLAK] = CASTLE
    set needed3[UPG_FLAK] = 0
    set tc_add1[UPG_FLAK] = 0
    set tc_add2[UPG_FLAK] = 0
    set available_time[UPG_FLAK] = 0
    set regenerate_time[UPG_FLAK] = 0
    set gold_price[UPG_FLAK] = 0
    set wood_price[UPG_FLAK] = 0
	set hero_rush_bonus[UPG_FLAK] = 0
	
    set old_id[UPG_CLOUD] = oUPG_CLOUD
    set buy_type[UPG_CLOUD] = BT_UPGRADE
    set needed1[UPG_CLOUD] = AVIARY
    set needed2[UPG_CLOUD] = CASTLE
    set needed3[UPG_CLOUD] = ARCANE_VAULT
    set tc_add1[UPG_CLOUD] = 0
    set tc_add2[UPG_CLOUD] = 0
    set available_time[UPG_CLOUD] = 0
    set regenerate_time[UPG_CLOUD] = 0
    set gold_price[UPG_CLOUD] = 0
    set wood_price[UPG_CLOUD] = 0
	set hero_rush_bonus[UPG_CLOUD] = 0
	
    set old_id[BLADE_MASTER] = oBLADE_MASTER
    set buy_type[BLADE_MASTER] = BT_HERO
    set needed1[BLADE_MASTER] = ORC_ALTAR
    set needed2[BLADE_MASTER] = STRONGHOLD
    set needed3[BLADE_MASTER] = FORTRESS
    set tc_add1[BLADE_MASTER] = 0
    set tc_add2[BLADE_MASTER] = 0
    set available_time[BLADE_MASTER] = 0
    set regenerate_time[BLADE_MASTER] = 0
    set gold_price[BLADE_MASTER] = 0
    set wood_price[BLADE_MASTER] = 0
	set hero_rush_bonus[BLADE_MASTER] = 0
	
    set old_id[FAR_SEER] = oFAR_SEER
    set buy_type[FAR_SEER] = BT_HERO
    set needed1[FAR_SEER] = ORC_ALTAR
    set needed2[FAR_SEER] = STRONGHOLD
    set needed3[FAR_SEER] = FORTRESS
    set tc_add1[FAR_SEER] = 0
    set tc_add2[FAR_SEER] = 0
    set available_time[FAR_SEER] = 0
    set regenerate_time[FAR_SEER] = 0
    set gold_price[FAR_SEER] = 0
    set wood_price[FAR_SEER] = 0
	set hero_rush_bonus[FAR_SEER] = 0
	
    set old_id[TAUREN_CHIEF] = oTAUREN_CHIEF
    set buy_type[TAUREN_CHIEF] = BT_HERO
    set needed1[TAUREN_CHIEF] = ORC_ALTAR
    set needed2[TAUREN_CHIEF] = STRONGHOLD
    set needed3[TAUREN_CHIEF] = FORTRESS
    set tc_add1[TAUREN_CHIEF] = 0
    set tc_add2[TAUREN_CHIEF] = 0
    set available_time[TAUREN_CHIEF] = 0
    set regenerate_time[TAUREN_CHIEF] = 0
    set gold_price[TAUREN_CHIEF] = 0
    set wood_price[TAUREN_CHIEF] = 0
	set hero_rush_bonus[TAUREN_CHIEF] = 0
	
    set old_id[SHADOW_HUNTER] = oSHADOW_HUNTER
    set buy_type[SHADOW_HUNTER] = BT_HERO
    set needed1[SHADOW_HUNTER] = ORC_ALTAR
    set needed2[SHADOW_HUNTER] = STRONGHOLD
    set needed3[SHADOW_HUNTER] = FORTRESS
    set tc_add1[SHADOW_HUNTER] = 0
    set tc_add2[SHADOW_HUNTER] = 0
    set available_time[SHADOW_HUNTER] = 0
    set regenerate_time[SHADOW_HUNTER] = 0
    set gold_price[SHADOW_HUNTER] = 0
    set wood_price[SHADOW_HUNTER] = 0
	set hero_rush_bonus[SHADOW_HUNTER] = 0
	
    set old_id[CATAPULT] = oCATAPULT
    set buy_type[CATAPULT] = BT_UNIT
    set needed1[CATAPULT] = ORC_BARRACKS
    set needed2[CATAPULT] = STRONGHOLD
    set needed3[CATAPULT] = FORGE
    set tc_add1[CATAPULT] = 0
    set tc_add2[CATAPULT] = 0
    set available_time[CATAPULT] = 0
    set regenerate_time[CATAPULT] = 0
    set gold_price[CATAPULT] = 0
    set wood_price[CATAPULT] = 0
	set hero_rush_bonus[CATAPULT] = 0
	
    set old_id[WITCH_DOCTOR] = oWITCH_DOCTOR
    set buy_type[WITCH_DOCTOR] = BT_UNIT
    set needed1[WITCH_DOCTOR] = LODGE
    set needed2[WITCH_DOCTOR] = 0
    set needed3[WITCH_DOCTOR] = 0
    set tc_add1[WITCH_DOCTOR] = 0
    set tc_add2[WITCH_DOCTOR] = 0
    set available_time[WITCH_DOCTOR] = 0
    set regenerate_time[WITCH_DOCTOR] = 0
    set gold_price[WITCH_DOCTOR] = 0
    set wood_price[WITCH_DOCTOR] = 0
	set hero_rush_bonus[WITCH_DOCTOR] = 0
	
    set old_id[GRUNT] = oGRUNT
    set buy_type[GRUNT] = BT_UNIT
    set needed1[GRUNT] = ORC_BARRACKS
    set needed2[GRUNT] = 0
    set needed3[GRUNT] = 0
    set tc_add1[GRUNT] = 0
    set tc_add2[GRUNT] = 0
    set available_time[GRUNT] = 0
    set regenerate_time[GRUNT] = 0
    set gold_price[GRUNT] = 0
    set wood_price[GRUNT] = 0
	set hero_rush_bonus[GRUNT] = 0
	
    set old_id[HEAD_HUNTER] = oHEAD_HUNTER
    set buy_type[HEAD_HUNTER] = BT_UNIT
    set needed1[HEAD_HUNTER] = ORC_BARRACKS
    set needed2[HEAD_HUNTER] = FORGE
    set needed3[HEAD_HUNTER] = 0
    set tc_add1[HEAD_HUNTER] = BERSERKER
    set tc_add2[HEAD_HUNTER] = 0
    set available_time[HEAD_HUNTER] = 0
    set regenerate_time[HEAD_HUNTER] = 0
    set gold_price[HEAD_HUNTER] = 0
    set wood_price[HEAD_HUNTER] = 0
	set hero_rush_bonus[HEAD_HUNTER] = 0
	
    set old_id[BERSERKER] = oBERSERKER
    set buy_type[BERSERKER] = BT_UNIT
    set needed1[BERSERKER] = ORC_BARRACKS
    set needed2[BERSERKER] = FORGE
    set needed3[BERSERKER] = 0
    set tc_add1[BERSERKER] = 0
    set tc_add2[BERSERKER] = 0
    set available_time[BERSERKER] = 0
    set regenerate_time[BERSERKER] = 0
    set gold_price[BERSERKER] = 0
    set wood_price[BERSERKER] = 0
	set hero_rush_bonus[BERSERKER] = 0
	
    set old_id[KODO_BEAST] = oKODO_BEAST
    set buy_type[KODO_BEAST] = BT_UNIT
    set needed1[KODO_BEAST] = BESTIARY
    set needed2[KODO_BEAST] = FORGE
    set needed3[KODO_BEAST] = 0
    set tc_add1[KODO_BEAST] = 0
    set tc_add2[KODO_BEAST] = 0
    set available_time[KODO_BEAST] = 0
    set regenerate_time[KODO_BEAST] = 0
    set gold_price[KODO_BEAST] = 0
    set wood_price[KODO_BEAST] = 0
	set hero_rush_bonus[KODO_BEAST] = 0
	
    set old_id[PEON] = oPEON
    set buy_type[PEON] = BT_UNIT
    set needed1[PEON] = GREAT_HALL
    set needed2[PEON] = 0
    set needed3[PEON] = 0
    set tc_add1[PEON] = 0
    set tc_add2[PEON] = 0
    set available_time[PEON] = 0
    set regenerate_time[PEON] = 0
    set gold_price[PEON] = 0
    set wood_price[PEON] = 0
	set hero_rush_bonus[PEON] = 0
	
    set old_id[RAIDER] = oRAIDER
    set buy_type[RAIDER] = BT_UNIT
    set needed1[RAIDER] = BESTIARY
    set needed2[RAIDER] = 0
    set needed3[RAIDER] = 0
    set tc_add1[RAIDER] = 0
    set tc_add2[RAIDER] = 0
    set available_time[RAIDER] = 0
    set regenerate_time[RAIDER] = 0
    set gold_price[RAIDER] = 0
    set wood_price[RAIDER] = 0
	set hero_rush_bonus[RAIDER] = 0
	
    set old_id[SHAMAN] = oSHAMAN
    set buy_type[SHAMAN] = BT_UNIT
    set needed1[SHAMAN] = LODGE
    set needed2[SHAMAN] = 0
    set needed3[SHAMAN] = 0
    set tc_add1[SHAMAN] = 0
    set tc_add2[SHAMAN] = 0
    set available_time[SHAMAN] = 0
    set regenerate_time[SHAMAN] = 0
    set gold_price[SHAMAN] = 0
    set wood_price[SHAMAN] = 0
	set hero_rush_bonus[SHAMAN] = 0
	
    set old_id[TAUREN] = oTAUREN
    set buy_type[TAUREN] = BT_UNIT
    set needed1[TAUREN] = TOTEM
    set needed2[TAUREN] = 0
    set needed3[TAUREN] = 0
    set tc_add1[TAUREN] = 0
    set tc_add2[TAUREN] = 0
    set available_time[TAUREN] = 0
    set regenerate_time[TAUREN] = 0
    set gold_price[TAUREN] = 0
    set wood_price[TAUREN] = 0
	set hero_rush_bonus[TAUREN] = 0
	
    set old_id[WYVERN] = oWYVERN
    set buy_type[WYVERN] = BT_UNIT
    set needed1[WYVERN] = BESTIARY
    set needed2[WYVERN] = 0
    set needed3[WYVERN] = 0
    set tc_add1[WYVERN] = 0
    set tc_add2[WYVERN] = 0
    set available_time[WYVERN] = 0
    set regenerate_time[WYVERN] = 0
    set gold_price[WYVERN] = 0
    set wood_price[WYVERN] = 0
	set hero_rush_bonus[WYVERN] = 0
	
    set old_id[BATRIDER] = oBATRIDER
    set buy_type[BATRIDER] = BT_UNIT
    set needed1[BATRIDER] = BESTIARY
    set needed2[BATRIDER] = VOODOO_LOUNGE
    set needed3[BATRIDER] = 0
    set tc_add1[BATRIDER] = 0
    set tc_add2[BATRIDER] = 0
    set available_time[BATRIDER] = 0
    set regenerate_time[BATRIDER] = 0
    set gold_price[BATRIDER] = 0
    set wood_price[BATRIDER] = 0
	set hero_rush_bonus[BATRIDER] = 0
	
    set old_id[SPIRIT_WALKER] = oSPIRIT_WALKER
    set buy_type[SPIRIT_WALKER] = BT_UNIT
    set needed1[SPIRIT_WALKER] = LODGE
    set needed2[SPIRIT_WALKER] = 0
    set needed3[SPIRIT_WALKER] = 0
    set tc_add1[SPIRIT_WALKER] = SPIRIT_WALKER_M
    set tc_add2[SPIRIT_WALKER] = 0
    set available_time[SPIRIT_WALKER] = 0
    set regenerate_time[SPIRIT_WALKER] = 0
    set gold_price[SPIRIT_WALKER] = 0
    set wood_price[SPIRIT_WALKER] = 0
	set hero_rush_bonus[SPIRIT_WALKER] = 0
	
    set old_id[SPIRIT_WALKER_M] = oSPIRIT_WALKER_M
    set buy_type[SPIRIT_WALKER_M] = BT_UNIT
    set needed1[SPIRIT_WALKER_M] = LODGE
    set needed2[SPIRIT_WALKER_M] = 0
    set needed3[SPIRIT_WALKER_M] = 0
    set tc_add1[SPIRIT_WALKER_M] = 0
    set tc_add2[SPIRIT_WALKER_M] = SPIRIT_WALKER
    set available_time[SPIRIT_WALKER_M] = 0
    set regenerate_time[SPIRIT_WALKER_M] = 0
    set gold_price[SPIRIT_WALKER_M] = 0
    set wood_price[SPIRIT_WALKER_M] = 0
	set hero_rush_bonus[SPIRIT_WALKER_M] = 0
	
    set old_id[ORC_ALTAR] = oORC_ALTAR
    set buy_type[ORC_ALTAR] = BT_BUILDING
    set needed1[ORC_ALTAR] = PEON
    set needed2[ORC_ALTAR] = 0
    set needed3[ORC_ALTAR] = 0
    set tc_add1[ORC_ALTAR] = 0
    set tc_add2[ORC_ALTAR] = 0
    set available_time[ORC_ALTAR] = 0
    set regenerate_time[ORC_ALTAR] = 0
    set gold_price[ORC_ALTAR] = 0
    set wood_price[ORC_ALTAR] = 0
	set hero_rush_bonus[ORC_ALTAR] = 0
	
    set old_id[ORC_BARRACKS] = oORC_BARRACKS
    set buy_type[ORC_BARRACKS] = BT_BUILDING
    set needed1[ORC_BARRACKS] = PEON
    set needed2[ORC_BARRACKS] = 0
    set needed3[ORC_BARRACKS] = 0
    set tc_add1[ORC_BARRACKS] = 0
    set tc_add2[ORC_BARRACKS] = 0
    set available_time[ORC_BARRACKS] = 0
    set regenerate_time[ORC_BARRACKS] = 0
    set gold_price[ORC_BARRACKS] = 0
    set wood_price[ORC_BARRACKS] = 0
	set hero_rush_bonus[ORC_BARRACKS] = 0
	
    set old_id[BESTIARY] = oBESTIARY
    set buy_type[BESTIARY] = BT_BUILDING
    set needed1[BESTIARY] = PEON
    set needed2[BESTIARY] = STRONGHOLD
    set needed3[BESTIARY] = 0
    set tc_add1[BESTIARY] = 0
    set tc_add2[BESTIARY] = 0
    set available_time[BESTIARY] = 0
    set regenerate_time[BESTIARY] = 0
    set gold_price[BESTIARY] = 0
    set wood_price[BESTIARY] = 0
	set hero_rush_bonus[BESTIARY] = 0
	
    set old_id[FORGE] = oFORGE
    set buy_type[FORGE] = BT_BUILDING
    set needed1[FORGE] = PEON
    set needed2[FORGE] = 0
    set needed3[FORGE] = 0
    set tc_add1[FORGE] = 0
    set tc_add2[FORGE] = 0
    set available_time[FORGE] = 0
    set regenerate_time[FORGE] = 0
    set gold_price[FORGE] = 0
    set wood_price[FORGE] = 0
	set hero_rush_bonus[FORGE] = 0
	
    set old_id[FORTRESS] = oFORTRESS
    set buy_type[FORTRESS] = BT_BUILDING
    set needed1[FORTRESS] = STRONGHOLD
    set needed2[FORTRESS] = ORC_ALTAR
    set needed3[FORTRESS] = UPGRADED
    set tc_add1[FORTRESS] = 0
    set tc_add2[FORTRESS] = 0
    set available_time[FORTRESS] = 0
    set regenerate_time[FORTRESS] = 0
    set gold_price[FORTRESS] = 0
    set wood_price[FORTRESS] = 0
	set hero_rush_bonus[FORTRESS] = 0
	
    set old_id[GREAT_HALL] = oGREAT_HALL
    set buy_type[GREAT_HALL] = BT_BUILDING
    set needed1[GREAT_HALL] = 0
    set needed2[GREAT_HALL] = 0
    set needed3[GREAT_HALL] = 0
    set tc_add1[GREAT_HALL] = STRONGHOLD
    set tc_add2[GREAT_HALL] = FORTRESS
    set available_time[GREAT_HALL] = 0
    set regenerate_time[GREAT_HALL] = 0
    set gold_price[GREAT_HALL] = 0
    set wood_price[GREAT_HALL] = 0
	set hero_rush_bonus[GREAT_HALL] = 0
	
    set old_id[LODGE] = oLODGE
    set buy_type[LODGE] = BT_BUILDING
    set needed1[LODGE] = PEON
    set needed2[LODGE] = STRONGHOLD
    set needed3[LODGE] = 0
    set tc_add1[LODGE] = 0
    set tc_add2[LODGE] = 0
    set available_time[LODGE] = 0
    set regenerate_time[LODGE] = 0
    set gold_price[LODGE] = 0
    set wood_price[LODGE] = 0
	set hero_rush_bonus[LODGE] = 0
	
    set old_id[STRONGHOLD] = oSTRONGHOLD
    set buy_type[STRONGHOLD] = BT_BUILDING
    set needed1[STRONGHOLD] = GREAT_HALL
    set needed2[STRONGHOLD] = 0
    set needed3[STRONGHOLD] = UPGRADED
    set tc_add1[STRONGHOLD] = FORTRESS
    set tc_add2[STRONGHOLD] = 0
    set available_time[STRONGHOLD] = 0
    set regenerate_time[STRONGHOLD] = 0
    set gold_price[STRONGHOLD] = 0
    set wood_price[STRONGHOLD] = 0
	set hero_rush_bonus[STRONGHOLD] = 0
	
    set old_id[BURROW] = oBURROW
    set buy_type[BURROW] = BT_BUILDING
    set needed1[BURROW] = PEON
    set needed2[BURROW] = 0
    set needed3[BURROW] = 0
    set tc_add1[BURROW] = 0
    set tc_add2[BURROW] = 0
    set available_time[BURROW] = 0
    set regenerate_time[BURROW] = 0
    set gold_price[BURROW] = 0
    set wood_price[BURROW] = 0
	set hero_rush_bonus[BURROW] = 0
	
    set old_id[TOTEM] = oTOTEM
    set buy_type[TOTEM] = BT_BUILDING
    set needed1[TOTEM] = PEON
    set needed2[TOTEM] = FORTRESS
    set needed3[TOTEM] = FORGE
    set tc_add1[TOTEM] = 0
    set tc_add2[TOTEM] = 0
    set available_time[TOTEM] = 0
    set regenerate_time[TOTEM] = 0
    set gold_price[TOTEM] = 0
    set wood_price[TOTEM] = 0
	set hero_rush_bonus[TOTEM] = 0
	
    set old_id[ORC_WATCH_TOWER] = oORC_WATCH_TOWER
    set buy_type[ORC_WATCH_TOWER] = BT_BUILDING
    set needed1[ORC_WATCH_TOWER] = PEON
    set needed2[ORC_WATCH_TOWER] = FORGE
    set needed3[ORC_WATCH_TOWER] = 0
    set tc_add1[ORC_WATCH_TOWER] = 0
    set tc_add2[ORC_WATCH_TOWER] = 0
    set available_time[ORC_WATCH_TOWER] = 0
    set regenerate_time[ORC_WATCH_TOWER] = 0
    set gold_price[ORC_WATCH_TOWER] = 0
    set wood_price[ORC_WATCH_TOWER] = 0
	set hero_rush_bonus[ORC_WATCH_TOWER] = 0
	
    set old_id[VOODOO_LOUNGE] = oVOODOO_LOUNGE
    set buy_type[VOODOO_LOUNGE] = BT_BUILDING
    set needed1[VOODOO_LOUNGE] = PEON
    set needed2[VOODOO_LOUNGE] = 0
    set needed3[VOODOO_LOUNGE] = 0
    set tc_add1[VOODOO_LOUNGE] = 0
    set tc_add2[VOODOO_LOUNGE] = 0
    set available_time[VOODOO_LOUNGE] = 0
    set regenerate_time[VOODOO_LOUNGE] = 0
    set gold_price[VOODOO_LOUNGE] = 0
    set wood_price[VOODOO_LOUNGE] = 0
	set hero_rush_bonus[VOODOO_LOUNGE] = 0
	
    set old_id[UPG_ORC_WAR_DRUMS] = oUPG_ORC_WAR_DRUMS
    set buy_type[UPG_ORC_WAR_DRUMS] = BT_UPGRADE
    set needed1[UPG_ORC_WAR_DRUMS] = BESTIARY
    set needed2[UPG_ORC_WAR_DRUMS] = FORTRESS
    set needed3[UPG_ORC_WAR_DRUMS] = FORGE
    set tc_add1[UPG_ORC_WAR_DRUMS] = 0
    set tc_add2[UPG_ORC_WAR_DRUMS] = 0
    set available_time[UPG_ORC_WAR_DRUMS] = 0
    set regenerate_time[UPG_ORC_WAR_DRUMS] = 0
    set gold_price[UPG_ORC_WAR_DRUMS] = 0
    set wood_price[UPG_ORC_WAR_DRUMS] = 0
	set hero_rush_bonus[UPG_ORC_WAR_DRUMS] = 0
	
    set old_id[UPG_ORC_PILLAGE] = oUPG_ORC_PILLAGE
    set buy_type[UPG_ORC_PILLAGE] = BT_UPGRADE
    set needed1[UPG_ORC_PILLAGE] = GREAT_HALL
    set needed2[UPG_ORC_PILLAGE] = 0
    set needed3[UPG_ORC_PILLAGE] = 0
    set tc_add1[UPG_ORC_PILLAGE] = 0
    set tc_add2[UPG_ORC_PILLAGE] = 0
    set available_time[UPG_ORC_PILLAGE] = 0
    set regenerate_time[UPG_ORC_PILLAGE] = 0
    set gold_price[UPG_ORC_PILLAGE] = 0
    set wood_price[UPG_ORC_PILLAGE] = 0
	set hero_rush_bonus[UPG_ORC_PILLAGE] = 0
	
    set old_id[UPG_ORC_BERSERK] = oUPG_ORC_BERSERK
    set buy_type[UPG_ORC_BERSERK] = BT_UPGRADE
    set needed1[UPG_ORC_BERSERK] = ORC_BARRACKS
    set needed2[UPG_ORC_BERSERK] = STRONGHOLD
    set needed3[UPG_ORC_BERSERK] = 0
    set tc_add1[UPG_ORC_BERSERK] = 0
    set tc_add2[UPG_ORC_BERSERK] = 0
    set available_time[UPG_ORC_BERSERK] = 0
    set regenerate_time[UPG_ORC_BERSERK] = 0
    set gold_price[UPG_ORC_BERSERK] = 0
    set wood_price[UPG_ORC_BERSERK] = 0
	set hero_rush_bonus[UPG_ORC_BERSERK] = 0
	
    set old_id[UPG_ORC_PULVERIZE] = oUPG_ORC_PULVERIZE
    set buy_type[UPG_ORC_PULVERIZE] = BT_UPGRADE
    set needed1[UPG_ORC_PULVERIZE] = TOTEM
    set needed2[UPG_ORC_PULVERIZE] = 0
    set needed3[UPG_ORC_PULVERIZE] = 0
    set tc_add1[UPG_ORC_PULVERIZE] = 0
    set tc_add2[UPG_ORC_PULVERIZE] = 0
    set available_time[UPG_ORC_PULVERIZE] = 0
    set regenerate_time[UPG_ORC_PULVERIZE] = 0
    set gold_price[UPG_ORC_PULVERIZE] = 0
    set wood_price[UPG_ORC_PULVERIZE] = 0
	set hero_rush_bonus[UPG_ORC_PULVERIZE] = 0
	
    set old_id[UPG_ORC_ENSNARE] = oUPG_ORC_ENSNARE
    set buy_type[UPG_ORC_ENSNARE] = BT_UPGRADE
    set needed1[UPG_ORC_ENSNARE] = BESTIARY
    set needed2[UPG_ORC_ENSNARE] = 0
    set needed3[UPG_ORC_ENSNARE] = 0
    set tc_add1[UPG_ORC_ENSNARE] = 0
    set tc_add2[UPG_ORC_ENSNARE] = 0
    set available_time[UPG_ORC_ENSNARE] = 0
    set regenerate_time[UPG_ORC_ENSNARE] = 0
    set gold_price[UPG_ORC_ENSNARE] = 0
    set wood_price[UPG_ORC_ENSNARE] = 0
	set hero_rush_bonus[UPG_ORC_ENSNARE] = 0
	
    set old_id[UPG_ORC_VENOM] = oUPG_ORC_VENOM
    set buy_type[UPG_ORC_VENOM] = BT_UPGRADE
    set needed1[UPG_ORC_VENOM] = BESTIARY
    set needed2[UPG_ORC_VENOM] = FORTRESS
    set needed3[UPG_ORC_VENOM] = 0
    set tc_add1[UPG_ORC_VENOM] = 0
    set tc_add2[UPG_ORC_VENOM] = 0
    set available_time[UPG_ORC_VENOM] = 0
    set regenerate_time[UPG_ORC_VENOM] = 0
    set gold_price[UPG_ORC_VENOM] = 0
    set wood_price[UPG_ORC_VENOM] = 0
	set hero_rush_bonus[UPG_ORC_VENOM] = 0
	
    set old_id[UPG_ORC_REGEN] = oUPG_ORC_REGEN
    set buy_type[UPG_ORC_REGEN] = BT_UPGRADE
    set needed1[UPG_ORC_REGEN] = ORC_BARRACKS
    set needed2[UPG_ORC_REGEN] = STRONGHOLD
    set needed3[UPG_ORC_REGEN] = FORGE
    set tc_add1[UPG_ORC_REGEN] = 0
    set tc_add2[UPG_ORC_REGEN] = 0
    set available_time[UPG_ORC_REGEN] = 0
    set regenerate_time[UPG_ORC_REGEN] = 0
    set gold_price[UPG_ORC_REGEN] = 0
    set wood_price[UPG_ORC_REGEN] = 0
	set hero_rush_bonus[UPG_ORC_REGEN] = 0
	
    set old_id[UPG_ORC_FIRE] = oUPG_ORC_FIRE
    set buy_type[UPG_ORC_FIRE] = BT_UPGRADE
    set needed1[UPG_ORC_FIRE] = BESTIARY
    set needed2[UPG_ORC_FIRE] = FORTRESS
    set needed3[UPG_ORC_FIRE] = VOODOO_LOUNGE
    set tc_add1[UPG_ORC_FIRE] = 0
    set tc_add2[UPG_ORC_FIRE] = 0
    set available_time[UPG_ORC_FIRE] = 0
    set regenerate_time[UPG_ORC_FIRE] = 0
    set gold_price[UPG_ORC_FIRE] = 0
    set wood_price[UPG_ORC_FIRE] = 0
	set hero_rush_bonus[UPG_ORC_FIRE] = 0
	
    set old_id[UPG_ORC_BERSERKER] = oUPG_ORC_BERSERKER
    set buy_type[UPG_ORC_BERSERKER] = BT_UPGRADE
    set needed1[UPG_ORC_BERSERKER] = ORC_BARRACKS
    set needed2[UPG_ORC_BERSERKER] = FORTRESS
    set needed3[UPG_ORC_BERSERKER] = FORGE
    set tc_add1[UPG_ORC_BERSERKER] = 0
    set tc_add2[UPG_ORC_BERSERKER] = 0
    set available_time[UPG_ORC_BERSERKER] = 0
    set regenerate_time[UPG_ORC_BERSERKER] = 0
    set gold_price[UPG_ORC_BERSERKER] = 0
    set wood_price[UPG_ORC_BERSERKER] = 0
	set hero_rush_bonus[UPG_ORC_BERSERKER] = 0
	
    set old_id[UPG_ORC_BURROWS] = oUPG_ORC_BURROWS
    set buy_type[UPG_ORC_BURROWS] = BT_UPGRADE
    set needed1[UPG_ORC_BURROWS] = FORGE
    set needed2[UPG_ORC_BURROWS] = FORTRESS
    set needed3[UPG_ORC_BURROWS] = 0
    set tc_add1[UPG_ORC_BURROWS] = 0
    set tc_add2[UPG_ORC_BURROWS] = 0
    set available_time[UPG_ORC_BURROWS] = 0
    set regenerate_time[UPG_ORC_BURROWS] = 0
    set gold_price[UPG_ORC_BURROWS] = 0
    set wood_price[UPG_ORC_BURROWS] = 0
	set hero_rush_bonus[UPG_ORC_BURROWS] = 0
	
    set old_id[UPG_ORC_MELEE] = oUPG_ORC_MELEE
    set buy_type[UPG_ORC_MELEE] = BT_ML_UPGRADE
    set needed1[UPG_ORC_MELEE] = FORGE
    set needed2[UPG_ORC_MELEE] = STRONGHOLD
    set needed3[UPG_ORC_MELEE] = FORTRESS
    set tc_add1[UPG_ORC_MELEE] = 0
    set tc_add2[UPG_ORC_MELEE] = 0
    set available_time[UPG_ORC_MELEE] = 0
    set regenerate_time[UPG_ORC_MELEE] = 0
    set gold_price[UPG_ORC_MELEE] = 0
    set wood_price[UPG_ORC_MELEE] = 0
	set hero_rush_bonus[UPG_ORC_MELEE] = 0
	
    set old_id[UPG_ORC_RANGED] = oUPG_ORC_RANGED
    set buy_type[UPG_ORC_RANGED] = BT_ML_UPGRADE
    set needed1[UPG_ORC_RANGED] = FORGE
    set needed2[UPG_ORC_RANGED] = STRONGHOLD
    set needed3[UPG_ORC_RANGED] = FORTRESS
    set tc_add1[UPG_ORC_RANGED] = 0
    set tc_add2[UPG_ORC_RANGED] = 0
    set available_time[UPG_ORC_RANGED] = 0
    set regenerate_time[UPG_ORC_RANGED] = 0
    set gold_price[UPG_ORC_RANGED] = 0
    set wood_price[UPG_ORC_RANGED] = 0
	set hero_rush_bonus[UPG_ORC_RANGED] = 0
	
    set old_id[UPG_ORC_ARMOR] = oUPG_ORC_ARMOR
    set buy_type[UPG_ORC_ARMOR] = BT_ML_UPGRADE
    set needed1[UPG_ORC_ARMOR] = FORGE
    set needed2[UPG_ORC_ARMOR] = STRONGHOLD
    set needed3[UPG_ORC_ARMOR] = FORTRESS
    set tc_add1[UPG_ORC_ARMOR] = 0
    set tc_add2[UPG_ORC_ARMOR] = 0
    set available_time[UPG_ORC_ARMOR] = 0
    set regenerate_time[UPG_ORC_ARMOR] = 0
    set gold_price[UPG_ORC_ARMOR] = 0
    set wood_price[UPG_ORC_ARMOR] = 0
	set hero_rush_bonus[UPG_ORC_ARMOR] = 0
	
    set old_id[UPG_ORC_SPIKES] = oUPG_ORC_SPIKES
    set buy_type[UPG_ORC_SPIKES] = BT_ML_UPGRADE
    set needed1[UPG_ORC_SPIKES] = FORGE
    set needed2[UPG_ORC_SPIKES] = STRONGHOLD
    set needed3[UPG_ORC_SPIKES] = FORTRESS
    set tc_add1[UPG_ORC_SPIKES] = 0
    set tc_add2[UPG_ORC_SPIKES] = 0
    set available_time[UPG_ORC_SPIKES] = 0
    set regenerate_time[UPG_ORC_SPIKES] = 0
    set gold_price[UPG_ORC_SPIKES] = 0
    set wood_price[UPG_ORC_SPIKES] = 0
	set hero_rush_bonus[UPG_ORC_SPIKES] = 0
	
    set old_id[UPG_ORC_DOCS] = oUPG_ORC_DOCS
    set buy_type[UPG_ORC_DOCS] = BT_ML_UPGRADE
    set needed1[UPG_ORC_DOCS] = LODGE
    set needed2[UPG_ORC_DOCS] = FORTRESS
    set needed3[UPG_ORC_DOCS] = 0
    set tc_add1[UPG_ORC_DOCS] = 0
    set tc_add2[UPG_ORC_DOCS] = 0
    set available_time[UPG_ORC_DOCS] = 0
    set regenerate_time[UPG_ORC_DOCS] = 0
    set gold_price[UPG_ORC_DOCS] = 0
    set wood_price[UPG_ORC_DOCS] = 0
	set hero_rush_bonus[UPG_ORC_DOCS] = 0
	
    set old_id[UPG_ORC_SHAMAN] = oUPG_ORC_SHAMAN
    set buy_type[UPG_ORC_SHAMAN] = BT_ML_UPGRADE
    set needed1[UPG_ORC_SHAMAN] = LODGE
    set needed2[UPG_ORC_SHAMAN] = FORTRESS
    set needed3[UPG_ORC_SHAMAN] = 0
    set tc_add1[UPG_ORC_SHAMAN] = 0
    set tc_add2[UPG_ORC_SHAMAN] = 0
    set available_time[UPG_ORC_SHAMAN] = 0
    set regenerate_time[UPG_ORC_SHAMAN] = 0
    set gold_price[UPG_ORC_SHAMAN] = 0
    set wood_price[UPG_ORC_SHAMAN] = 0
	set hero_rush_bonus[UPG_ORC_SHAMAN] = 0
	
    set old_id[UPG_ORC_SWALKER] = oUPG_ORC_SWALKER
    set buy_type[UPG_ORC_SWALKER] = BT_ML_UPGRADE
    set needed1[UPG_ORC_SWALKER] = LODGE
    set needed2[UPG_ORC_SWALKER] = FORTRESS
    set needed3[UPG_ORC_SWALKER] = 0
    set tc_add1[UPG_ORC_SWALKER] = 0
    set tc_add2[UPG_ORC_SWALKER] = 0
    set available_time[UPG_ORC_SWALKER] = 0
    set regenerate_time[UPG_ORC_SWALKER] = 0
    set gold_price[UPG_ORC_SWALKER] = 0
    set wood_price[UPG_ORC_SWALKER] = 0
	set hero_rush_bonus[UPG_ORC_SWALKER] = 0
	
    set old_id[UPG_ORC_NAPTHA] = oUPG_ORC_NAPTHA
    set buy_type[UPG_ORC_NAPTHA] = BT_UPGRADE
    set needed1[UPG_ORC_NAPTHA] = ORC_BARRACKS
    set needed2[UPG_ORC_NAPTHA] = FORTRESS
    set needed3[UPG_ORC_NAPTHA] = 0
    set tc_add1[UPG_ORC_NAPTHA] = 0
    set tc_add2[UPG_ORC_NAPTHA] = 0
    set available_time[UPG_ORC_NAPTHA] = 0
    set regenerate_time[UPG_ORC_NAPTHA] = 0
    set gold_price[UPG_ORC_NAPTHA] = 0
    set wood_price[UPG_ORC_NAPTHA] = 0
	set hero_rush_bonus[UPG_ORC_NAPTHA] = 0
	
    set old_id[DEATH_KNIGHT] = oDEATH_KNIGHT
    set buy_type[DEATH_KNIGHT] = BT_HERO
    set needed1[DEATH_KNIGHT] = UNDEAD_ALTAR
    set needed2[DEATH_KNIGHT] = NECROPOLIS_2
    set needed3[DEATH_KNIGHT] = NECROPOLIS_3
    set tc_add1[DEATH_KNIGHT] = 0
    set tc_add2[DEATH_KNIGHT] = 0
    set available_time[DEATH_KNIGHT] = 0
    set regenerate_time[DEATH_KNIGHT] = 0
    set gold_price[DEATH_KNIGHT] = 0
    set wood_price[DEATH_KNIGHT] = 0
	set hero_rush_bonus[DEATH_KNIGHT] = 0
	
    set old_id[DREAD_LORD] = oDREAD_LORD
    set buy_type[DREAD_LORD] = BT_HERO
    set needed1[DREAD_LORD] = UNDEAD_ALTAR
    set needed2[DREAD_LORD] = NECROPOLIS_2
    set needed3[DREAD_LORD] = NECROPOLIS_3
    set tc_add1[DREAD_LORD] = 0
    set tc_add2[DREAD_LORD] = 0
    set available_time[DREAD_LORD] = 0
    set regenerate_time[DREAD_LORD] = 0
    set gold_price[DREAD_LORD] = 0
    set wood_price[DREAD_LORD] = 0
	set hero_rush_bonus[DREAD_LORD] = 0
	
    set old_id[LICH] = oLICH
    set buy_type[LICH] = BT_HERO
    set needed1[LICH] = UNDEAD_ALTAR
    set needed2[LICH] = NECROPOLIS_2
    set needed3[LICH] = NECROPOLIS_3
    set tc_add1[LICH] = 0
    set tc_add2[LICH] = 0
    set available_time[LICH] = 0
    set regenerate_time[LICH] = 0
    set gold_price[LICH] = 0
    set wood_price[LICH] = 0
	set hero_rush_bonus[LICH] = 0
	
    set old_id[CRYPT_LORD] = oCRYPT_LORD
    set buy_type[CRYPT_LORD] = BT_HERO
    set needed1[CRYPT_LORD] = UNDEAD_ALTAR
    set needed2[CRYPT_LORD] = NECROPOLIS_2
    set needed3[CRYPT_LORD] = NECROPOLIS_3
    set tc_add1[CRYPT_LORD] = 0
    set tc_add2[CRYPT_LORD] = 0
    set available_time[CRYPT_LORD] = 0
    set regenerate_time[CRYPT_LORD] = 0
    set gold_price[CRYPT_LORD] = 0
    set wood_price[CRYPT_LORD] = 0
	set hero_rush_bonus[CRYPT_LORD] = 0
	
    set old_id[ABOMINATION] = oABOMINATION
    set buy_type[ABOMINATION] = BT_UNIT
    set needed1[ABOMINATION] = SLAUGHTERHOUSE
    set needed2[ABOMINATION] = NECROPOLIS_3
    set needed3[ABOMINATION] = 0
    set tc_add1[ABOMINATION] = 0
    set tc_add2[ABOMINATION] = 0
    set available_time[ABOMINATION] = 0
    set regenerate_time[ABOMINATION] = 0
    set gold_price[ABOMINATION] = 0
    set wood_price[ABOMINATION] = 0
	set hero_rush_bonus[ABOMINATION] = 0
	
    set old_id[ACOLYTE] = oACOLYTE
    set buy_type[ACOLYTE] = BT_UNIT
    set needed1[ACOLYTE] = NECROPOLIS_1
    set needed2[ACOLYTE] = 0
    set needed3[ACOLYTE] = 0
    set tc_add1[ACOLYTE] = 0
    set tc_add2[ACOLYTE] = 0
    set available_time[ACOLYTE] = 0
    set regenerate_time[ACOLYTE] = 0
    set gold_price[ACOLYTE] = 0
    set wood_price[ACOLYTE] = 0
	set hero_rush_bonus[ACOLYTE] = 0
	
    set old_id[BANSHEE] = oBANSHEE
    set buy_type[BANSHEE] = BT_UNIT
    set needed1[BANSHEE] = DAMNED_TEMPLE
    set needed2[BANSHEE] = 0
    set needed3[BANSHEE] = 0
    set tc_add1[BANSHEE] = 0
    set tc_add2[BANSHEE] = 0
    set available_time[BANSHEE] = 0
    set regenerate_time[BANSHEE] = 0
    set gold_price[BANSHEE] = 0
    set wood_price[BANSHEE] = 0
	set hero_rush_bonus[BANSHEE] = 0
	
    set old_id[CRYPT_FIEND] = oCRYPT_FIEND
    set buy_type[CRYPT_FIEND] = BT_UNIT
    set needed1[CRYPT_FIEND] = CRYPT
    set needed2[CRYPT_FIEND] = GRAVEYARD
    set needed3[CRYPT_FIEND] = 0
    set tc_add1[CRYPT_FIEND] = 0
    set tc_add2[CRYPT_FIEND] = 0
    set available_time[CRYPT_FIEND] = 0
    set regenerate_time[CRYPT_FIEND] = 0
    set gold_price[CRYPT_FIEND] = 0
    set wood_price[CRYPT_FIEND] = 0
	set hero_rush_bonus[CRYPT_FIEND] = 0
	
    set old_id[BURROWED_FIEND] = oBURROWED_FIEND
    set buy_type[BURROWED_FIEND] = BT_UNIT
    set needed1[BURROWED_FIEND] = CRYPT_FIEND
    set needed2[BURROWED_FIEND] = 0
    set needed3[BURROWED_FIEND] = 0
    set tc_add1[BURROWED_FIEND] = 0
    set tc_add2[BURROWED_FIEND] = 0
    set available_time[BURROWED_FIEND] = 0
    set regenerate_time[BURROWED_FIEND] = 0
    set gold_price[BURROWED_FIEND] = 0
    set wood_price[BURROWED_FIEND] = 0
	set hero_rush_bonus[BURROWED_FIEND] = 0
	
    set old_id[FROST_WYRM] = oFROST_WYRM
    set buy_type[FROST_WYRM] = BT_UNIT
    set needed1[FROST_WYRM] = BONEYARD
    set needed2[FROST_WYRM] = 0
    set needed3[FROST_WYRM] = 0
    set tc_add1[FROST_WYRM] = 0
    set tc_add2[FROST_WYRM] = 0
    set available_time[FROST_WYRM] = 0
    set regenerate_time[FROST_WYRM] = 0
    set gold_price[FROST_WYRM] = 0
    set wood_price[FROST_WYRM] = 0
	set hero_rush_bonus[FROST_WYRM] = 0
	
    set old_id[GARGOYLE] = oGARGOYLE
    set buy_type[GARGOYLE] = BT_UNIT
    set needed1[GARGOYLE] = CRYPT
    set needed2[GARGOYLE] = NECROPOLIS_2
    set needed3[GARGOYLE] = GRAVEYARD
    set tc_add1[GARGOYLE] = 0
    set tc_add2[GARGOYLE] = GARGOYLE_MORPH
    set available_time[GARGOYLE] = 0
    set regenerate_time[GARGOYLE] = 0
    set gold_price[GARGOYLE] = 0
    set wood_price[GARGOYLE] = 0
	set hero_rush_bonus[GARGOYLE] = 0
	
    set old_id[GARGOYLE_MORPH] = oGARGOYLE_MORPH
    set buy_type[GARGOYLE_MORPH] = BT_UNIT
    set needed1[GARGOYLE_MORPH] = 0
    set needed2[GARGOYLE_MORPH] = 0
    set needed3[GARGOYLE_MORPH] = 0
    set tc_add1[GARGOYLE_MORPH] = 0
    set tc_add2[GARGOYLE_MORPH] = GARGOYLE
    set available_time[GARGOYLE_MORPH] = 0
    set regenerate_time[GARGOYLE_MORPH] = 0
    set gold_price[GARGOYLE_MORPH] = 0
    set wood_price[GARGOYLE_MORPH] = 0
	set hero_rush_bonus[GARGOYLE_MORPH] = 0
	
    set old_id[GHOUL] = oGHOUL
    set buy_type[GHOUL] = BT_UNIT
    set needed1[GHOUL] = CRYPT
    set needed2[GHOUL] = 0
    set needed3[GHOUL] = 0
    set tc_add1[GHOUL] = 0
    set tc_add2[GHOUL] = 0
    set available_time[GHOUL] = 0
    set regenerate_time[GHOUL] = 0
    set gold_price[GHOUL] = 0
    set wood_price[GHOUL] = 0
	set hero_rush_bonus[GHOUL] = 0
	
    set old_id[MEAT_WAGON] = oMEAT_WAGON
    set buy_type[MEAT_WAGON] = BT_UNIT
    set needed1[MEAT_WAGON] = SLAUGHTERHOUSE
    set needed2[MEAT_WAGON] = 0
    set needed3[MEAT_WAGON] = 0
    set tc_add1[MEAT_WAGON] = 0
    set tc_add2[MEAT_WAGON] = 0
    set available_time[MEAT_WAGON] = 0
    set regenerate_time[MEAT_WAGON] = 0
    set gold_price[MEAT_WAGON] = 0
    set wood_price[MEAT_WAGON] = 0
	set hero_rush_bonus[MEAT_WAGON] = 0
	
    set old_id[NECRO] = oNECRO
    set buy_type[NECRO] = BT_UNIT
    set needed1[NECRO] = DAMNED_TEMPLE
    set needed2[NECRO] = 0
    set needed3[NECRO] = 0
    set tc_add1[NECRO] = 0
    set tc_add2[NECRO] = 0
    set available_time[NECRO] = 0
    set regenerate_time[NECRO] = 0
    set gold_price[NECRO] = 0
    set wood_price[NECRO] = 0
	set hero_rush_bonus[NECRO] = 0
	
    set old_id[SKEL_WARRIOR] = oSKEL_WARRIOR
    set buy_type[SKEL_WARRIOR] = BT_UNIT
    set needed1[SKEL_WARRIOR] = NECRO
    set needed2[SKEL_WARRIOR] = 0
    set needed3[SKEL_WARRIOR] = 0
    set tc_add1[SKEL_WARRIOR] = 0
    set tc_add2[SKEL_WARRIOR] = 0
    set available_time[SKEL_WARRIOR] = 0
    set regenerate_time[SKEL_WARRIOR] = 0
    set gold_price[SKEL_WARRIOR] = 0
    set wood_price[SKEL_WARRIOR] = 0
	set hero_rush_bonus[SKEL_WARRIOR] = 0
	
    set old_id[SHADE] = oSHADE
    set buy_type[SHADE] = BT_UNIT
    set needed1[SHADE] = ACOLYTE
    set needed2[SHADE] = SAC_PIT
    set needed3[SHADE] = 0
    set tc_add1[SHADE] = 0
    set tc_add2[SHADE] = 0
    set available_time[SHADE] = 0
    set regenerate_time[SHADE] = 0
    set gold_price[SHADE] = 0
    set wood_price[SHADE] = 0
	set hero_rush_bonus[SHADE] = 0
	
    set old_id[OBSIDIAN_STATUE] = oOBSIDIAN_STATUE
    set buy_type[OBSIDIAN_STATUE] = BT_UNIT
    set needed1[OBSIDIAN_STATUE] = SLAUGHTERHOUSE
    set needed2[OBSIDIAN_STATUE] = TOMB_OF_RELICS
    set needed3[OBSIDIAN_STATUE] = 0
    set tc_add1[OBSIDIAN_STATUE] = 0
    set tc_add2[OBSIDIAN_STATUE] = 0
    set available_time[OBSIDIAN_STATUE] = 0
    set regenerate_time[OBSIDIAN_STATUE] = 0
    set gold_price[OBSIDIAN_STATUE] = 0
    set wood_price[OBSIDIAN_STATUE] = 0
	set hero_rush_bonus[OBSIDIAN_STATUE] = 0
	
    set old_id[BLK_SPHINX] = oBLK_SPHINX
    set buy_type[BLK_SPHINX] = BT_UNIT
    set needed1[BLK_SPHINX] = OBS_STATUE
    set needed2[BLK_SPHINX] = 0
    set needed3[BLK_SPHINX] = UPGRADED
    set tc_add1[BLK_SPHINX] = 0
    set tc_add2[BLK_SPHINX] = 0
    set available_time[BLK_SPHINX] = 0
    set regenerate_time[BLK_SPHINX] = 0
    set gold_price[BLK_SPHINX] = 0
    set wood_price[BLK_SPHINX] = 0
	set hero_rush_bonus[BLK_SPHINX] = 0
	
    set old_id[UNDEAD_MINE] = oUNDEAD_MINE
    set buy_type[UNDEAD_MINE] = BT_BUILDING
    set needed1[UNDEAD_MINE] = ACOLYTE
    set needed2[UNDEAD_MINE] = 0
    set needed3[UNDEAD_MINE] = 0
    set tc_add1[UNDEAD_MINE] = 0
    set tc_add2[UNDEAD_MINE] = 0
    set available_time[UNDEAD_MINE] = 0
    set regenerate_time[UNDEAD_MINE] = 0
    set gold_price[UNDEAD_MINE] = 0
    set wood_price[UNDEAD_MINE] = 0
	set hero_rush_bonus[UNDEAD_MINE] = 0
	
    set old_id[UNDEAD_ALTAR] = oUNDEAD_ALTAR
    set buy_type[UNDEAD_ALTAR] = BT_BUILDING
    set needed1[UNDEAD_ALTAR] = ACOLYTE
    set needed2[UNDEAD_ALTAR] = 0
    set needed3[UNDEAD_ALTAR] = 0
    set tc_add1[UNDEAD_ALTAR] = 0
    set tc_add2[UNDEAD_ALTAR] = 0
    set available_time[UNDEAD_ALTAR] = 0
    set regenerate_time[UNDEAD_ALTAR] = 0
    set gold_price[UNDEAD_ALTAR] = 0
    set wood_price[UNDEAD_ALTAR] = 0
	set hero_rush_bonus[UNDEAD_ALTAR] = 0
	
    set old_id[BONEYARD] = oBONEYARD
    set buy_type[BONEYARD] = BT_BUILDING
    set needed1[BONEYARD] = ACOLYTE
    set needed2[BONEYARD] = NECROPOLIS_3
    set needed3[BONEYARD] = SAC_PIT
    set tc_add1[BONEYARD] = 0
    set tc_add2[BONEYARD] = 0
    set available_time[BONEYARD] = 0
    set regenerate_time[BONEYARD] = 0
    set gold_price[BONEYARD] = 0
    set wood_price[BONEYARD] = 0
	set hero_rush_bonus[BONEYARD] = 0
	
    set old_id[NECROPOLIS_1] = oNECROPOLIS_1
    set buy_type[NECROPOLIS_1] = BT_BUILDING
    set needed1[NECROPOLIS_1] = 0
    set needed2[NECROPOLIS_1] = 0
    set needed3[NECROPOLIS_1] = 0
    set tc_add1[NECROPOLIS_1] = NECROPOLIS_2
    set tc_add2[NECROPOLIS_1] = NECROPOLIS_3
    set available_time[NECROPOLIS_1] = 0
    set regenerate_time[NECROPOLIS_1] = 0
    set gold_price[NECROPOLIS_1] = 0
    set wood_price[NECROPOLIS_1] = 0
	set hero_rush_bonus[NECROPOLIS_1] = 0
	
    set old_id[NECROPOLIS_2] = oNECROPOLIS_2
    set buy_type[NECROPOLIS_2] = BT_BUILDING
    set needed1[NECROPOLIS_2] = NECROPOLIS_1
    set needed2[NECROPOLIS_2] = 0
    set needed3[NECROPOLIS_2] = UPGRADED
    set tc_add1[NECROPOLIS_2] = NECROPOLIS_3
    set tc_add2[NECROPOLIS_2] = 0
    set available_time[NECROPOLIS_2] = 0
    set regenerate_time[NECROPOLIS_2] = 0
    set gold_price[NECROPOLIS_2] = 0
    set wood_price[NECROPOLIS_2] = 0
	set hero_rush_bonus[NECROPOLIS_2] = 0
	
    set old_id[NECROPOLIS_3] = oNECROPOLIS_3
    set buy_type[NECROPOLIS_3] = BT_BUILDING
    set needed1[NECROPOLIS_3] = NECROPOLIS_2
    set needed2[NECROPOLIS_3] = UNDEAD_ALTAR
    set needed3[NECROPOLIS_3] = UPGRADED
    set tc_add1[NECROPOLIS_3] = 0
    set tc_add2[NECROPOLIS_3] = 0
    set available_time[NECROPOLIS_3] = 0
    set regenerate_time[NECROPOLIS_3] = 0
    set gold_price[NECROPOLIS_3] = 0
    set wood_price[NECROPOLIS_3] = 0
	set hero_rush_bonus[NECROPOLIS_3] = 0
	
    set old_id[SAC_PIT] = oSAC_PIT
    set buy_type[SAC_PIT] = BT_BUILDING
    set needed1[SAC_PIT] = ACOLYTE
    set needed2[SAC_PIT] = NECROPOLIS_2
    set needed3[SAC_PIT] = 0
    set tc_add1[SAC_PIT] = 0
    set tc_add2[SAC_PIT] = 0
    set available_time[SAC_PIT] = 0
    set regenerate_time[SAC_PIT] = 0
    set gold_price[SAC_PIT] = 0
    set wood_price[SAC_PIT] = 0
	set hero_rush_bonus[SAC_PIT] = 0
	
    set old_id[CRYPT] = oCRYPT
    set buy_type[CRYPT] = BT_BUILDING
    set needed1[CRYPT] = ACOLYTE
    set needed2[CRYPT] = 0
    set needed3[CRYPT] = 0
    set tc_add1[CRYPT] = 0
    set tc_add2[CRYPT] = 0
    set available_time[CRYPT] = 0
    set regenerate_time[CRYPT] = 0
    set gold_price[CRYPT] = 0
    set wood_price[CRYPT] = 0
	set hero_rush_bonus[CRYPT] = 0
	
    set old_id[SLAUGHTERHOUSE] = oSLAUGHTERHOUSE
    set buy_type[SLAUGHTERHOUSE] = BT_BUILDING
    set needed1[SLAUGHTERHOUSE] = ACOLYTE
    set needed2[SLAUGHTERHOUSE] = NECROPOLIS_2
    set needed3[SLAUGHTERHOUSE] = GRAVEYARD
    set tc_add1[SLAUGHTERHOUSE] = 0
    set tc_add2[SLAUGHTERHOUSE] = 0
    set available_time[SLAUGHTERHOUSE] = 0
    set regenerate_time[SLAUGHTERHOUSE] = 0
    set gold_price[SLAUGHTERHOUSE] = 0
    set wood_price[SLAUGHTERHOUSE] = 0
	set hero_rush_bonus[SLAUGHTERHOUSE] = 0
	
    set old_id[DAMNED_TEMPLE] = oDAMNED_TEMPLE
    set buy_type[DAMNED_TEMPLE] = BT_BUILDING
    set needed1[DAMNED_TEMPLE] = ACOLYTE
    set needed2[DAMNED_TEMPLE] = NECROPOLIS_2
    set needed3[DAMNED_TEMPLE] = 0
    set tc_add1[DAMNED_TEMPLE] = 0
    set tc_add2[DAMNED_TEMPLE] = 0
    set available_time[DAMNED_TEMPLE] = 0
    set regenerate_time[DAMNED_TEMPLE] = 0
    set gold_price[DAMNED_TEMPLE] = 0
    set wood_price[DAMNED_TEMPLE] = 0
	set hero_rush_bonus[DAMNED_TEMPLE] = 0
	
    set old_id[ZIGGURAT_1] = oZIGGURAT_1
    set buy_type[ZIGGURAT_1] = BT_BUILDING
    set needed1[ZIGGURAT_1] = ACOLYTE
    set needed2[ZIGGURAT_1] = 0
    set needed3[ZIGGURAT_1] = 0
    set tc_add1[ZIGGURAT_1] = ZIGGURAT_2
    set tc_add2[ZIGGURAT_1] = ZIGGURAT_FROST
    set available_time[ZIGGURAT_1] = 0
    set regenerate_time[ZIGGURAT_1] = 0
    set gold_price[ZIGGURAT_1] = 0
    set wood_price[ZIGGURAT_1] = 0
	set hero_rush_bonus[ZIGGURAT_1] = 0
	
    set old_id[ZIGGURAT_2] = oZIGGURAT_2
    set buy_type[ZIGGURAT_2] = BT_BUILDING
    set needed1[ZIGGURAT_2] = ZIGGURAT_1
    set needed2[ZIGGURAT_2] = GRAVEYARD
    set needed3[ZIGGURAT_2] = UPGRADED
    set tc_add1[ZIGGURAT_2] = 0
    set tc_add2[ZIGGURAT_2] = 0
    set available_time[ZIGGURAT_2] = 0
    set regenerate_time[ZIGGURAT_2] = 0
    set gold_price[ZIGGURAT_2] = 0
    set wood_price[ZIGGURAT_2] = 0
	set hero_rush_bonus[ZIGGURAT_2] = 0
	
    set old_id[ZIGGURAT_FROST] = oZIGGURAT_FROST
    set buy_type[ZIGGURAT_FROST] = BT_BUILDING
    set needed1[ZIGGURAT_FROST] = ZIGGURAT_1
    set needed2[ZIGGURAT_FROST] = 0
    set needed3[ZIGGURAT_FROST] = UPGRADED
    set tc_add1[ZIGGURAT_FROST] = 0
    set tc_add2[ZIGGURAT_FROST] = 0
    set available_time[ZIGGURAT_FROST] = 0
    set regenerate_time[ZIGGURAT_FROST] = 0
    set gold_price[ZIGGURAT_FROST] = 0
    set wood_price[ZIGGURAT_FROST] = 0
	set hero_rush_bonus[ZIGGURAT_FROST] = 0
	
    set old_id[GRAVEYARD] = oGRAVEYARD
    set buy_type[GRAVEYARD] = BT_BUILDING
    set needed1[GRAVEYARD] = ACOLYTE
    set needed2[GRAVEYARD] = 0
    set needed3[GRAVEYARD] = 0
    set tc_add1[GRAVEYARD] = 0
    set tc_add2[GRAVEYARD] = 0
    set available_time[GRAVEYARD] = 0
    set regenerate_time[GRAVEYARD] = 0
    set gold_price[GRAVEYARD] = 0
    set wood_price[GRAVEYARD] = 0
	set hero_rush_bonus[GRAVEYARD] = 0
	
    set old_id[TOMB_OF_RELICS] = oTOMB_OF_RELICS
    set buy_type[TOMB_OF_RELICS] = BT_BUILDING
    set needed1[TOMB_OF_RELICS] = ACOLYTE
    set needed2[TOMB_OF_RELICS] = 0
    set needed3[TOMB_OF_RELICS] = 0
    set tc_add1[TOMB_OF_RELICS] = 0
    set tc_add2[TOMB_OF_RELICS] = 0
    set available_time[TOMB_OF_RELICS] = 0
    set regenerate_time[TOMB_OF_RELICS] = 0
    set gold_price[TOMB_OF_RELICS] = 0
    set wood_price[TOMB_OF_RELICS] = 0
	set hero_rush_bonus[TOMB_OF_RELICS] = 0
	
    set old_id[CARRION_BEETLE] = oCARRION_BEETLE
    set buy_type[CARRION_BEETLE] = BT_UNIT
    set needed1[CARRION_BEETLE] = CRYPT_LORD
    set needed2[CARRION_BEETLE] = 0
    set needed3[CARRION_BEETLE] = 0
    set tc_add1[CARRION_BEETLE] = 0
    set tc_add2[CARRION_BEETLE] = 0
    set available_time[CARRION_BEETLE] = 0
    set regenerate_time[CARRION_BEETLE] = 0
    set gold_price[CARRION_BEETLE] = 0
    set wood_price[CARRION_BEETLE] = 0
	set hero_rush_bonus[CARRION_BEETLE] = 0
	
    set old_id[CARRION_BEETLE2] = oCARRION_BEETLE2
    set buy_type[CARRION_BEETLE2] = BT_UNIT
    set needed1[CARRION_BEETLE2] = CRYPT_LORD
    set needed2[CARRION_BEETLE2] = 0
    set needed3[CARRION_BEETLE2] = 0
    set tc_add1[CARRION_BEETLE2] = 0
    set tc_add2[CARRION_BEETLE2] = 0
    set available_time[CARRION_BEETLE2] = 0
    set regenerate_time[CARRION_BEETLE2] = 0
    set gold_price[CARRION_BEETLE2] = 0
    set wood_price[CARRION_BEETLE2] = 0
	set hero_rush_bonus[CARRION_BEETLE2] = 0
	
    set old_id[CARRION_BEETLE3] = oCARRION_BEETLE3
    set buy_type[CARRION_BEETLE3] = BT_UNIT
    set needed1[CARRION_BEETLE3] = CRYPT_LORD
    set needed2[CARRION_BEETLE3] = 0
    set needed3[CARRION_BEETLE3] = 0
    set tc_add1[CARRION_BEETLE3] = 0
    set tc_add2[CARRION_BEETLE3] = 0
    set available_time[CARRION_BEETLE3] = 0
    set regenerate_time[CARRION_BEETLE3] = 0
    set gold_price[CARRION_BEETLE3] = 0
    set wood_price[CARRION_BEETLE3] = 0
	set hero_rush_bonus[CARRION_BEETLE3] = 0
	
    set old_id[SKEL_MAGE] = oSKEL_MAGE
    set buy_type[SKEL_MAGE] = BT_UNIT
    set needed1[SKEL_MAGE] = NECRO
    set needed2[SKEL_MAGE] = 0
    set needed3[SKEL_MAGE] = 0
    set tc_add1[SKEL_MAGE] = 0
    set tc_add2[SKEL_MAGE] = 0
    set available_time[SKEL_MAGE] = 0
    set regenerate_time[SKEL_MAGE] = 0
    set gold_price[SKEL_MAGE] = 0
    set wood_price[SKEL_MAGE] = 0
	set hero_rush_bonus[SKEL_MAGE] = 0
	
    set old_id[UPG_CANNIBALIZE] = oUPG_CANNIBALIZE
    set buy_type[UPG_CANNIBALIZE] = BT_UPGRADE
    set needed1[UPG_CANNIBALIZE] = CRYPT
    set needed2[UPG_CANNIBALIZE] = 0
    set needed3[UPG_CANNIBALIZE] = 0
    set tc_add1[UPG_CANNIBALIZE] = 0
    set tc_add2[UPG_CANNIBALIZE] = 0
    set available_time[UPG_CANNIBALIZE] = 0
    set regenerate_time[UPG_CANNIBALIZE] = 0
    set gold_price[UPG_CANNIBALIZE] = 0
    set wood_price[UPG_CANNIBALIZE] = 0
	set hero_rush_bonus[UPG_CANNIBALIZE] = 0
	
    set old_id[UPG_GHOUL_FRENZY] = oUPG_GHOUL_FRENZY
    set buy_type[UPG_GHOUL_FRENZY] = BT_UPGRADE
    set needed1[UPG_GHOUL_FRENZY] = CRYPT
    set needed2[UPG_GHOUL_FRENZY] = NECROPOLIS_3
    set needed3[UPG_GHOUL_FRENZY] = GRAVEYARD
    set tc_add1[UPG_GHOUL_FRENZY] = 0
    set tc_add2[UPG_GHOUL_FRENZY] = 0
    set available_time[UPG_GHOUL_FRENZY] = 0
    set regenerate_time[UPG_GHOUL_FRENZY] = 0
    set gold_price[UPG_GHOUL_FRENZY] = 0
    set wood_price[UPG_GHOUL_FRENZY] = 0
	set hero_rush_bonus[UPG_GHOUL_FRENZY] = 0
	
    set old_id[UPG_FIEND_WEB] = oUPG_FIEND_WEB
    set buy_type[UPG_FIEND_WEB] = BT_UPGRADE
    set needed1[UPG_FIEND_WEB] = CRYPT
    set needed2[UPG_FIEND_WEB] = NECROPOLIS_2
    set needed3[UPG_FIEND_WEB] = GRAVEYARD
    set tc_add1[UPG_FIEND_WEB] = 0
    set tc_add2[UPG_FIEND_WEB] = 0
    set available_time[UPG_FIEND_WEB] = 0
    set regenerate_time[UPG_FIEND_WEB] = 0
    set gold_price[UPG_FIEND_WEB] = 0
    set wood_price[UPG_FIEND_WEB] = 0
	set hero_rush_bonus[UPG_FIEND_WEB] = 0
	
    set old_id[UPG_STONE_FORM] = oUPG_STONE_FORM
    set buy_type[UPG_STONE_FORM] = BT_UPGRADE
    set needed1[UPG_STONE_FORM] = CRYPT
    set needed2[UPG_STONE_FORM] = NECROPOLIS_3
    set needed3[UPG_STONE_FORM] = GRAVEYARD
    set tc_add1[UPG_STONE_FORM] = 0
    set tc_add2[UPG_STONE_FORM] = 0
    set available_time[UPG_STONE_FORM] = 0
    set regenerate_time[UPG_STONE_FORM] = 0
    set gold_price[UPG_STONE_FORM] = 0
    set wood_price[UPG_STONE_FORM] = 0
	set hero_rush_bonus[UPG_STONE_FORM] = 0
	
    set old_id[UPG_WYRM_BREATH] = oUPG_WYRM_BREATH
    set buy_type[UPG_WYRM_BREATH] = BT_UPGRADE
    set needed1[UPG_WYRM_BREATH] = BONEYARD
    set needed2[UPG_WYRM_BREATH] = 0
    set needed3[UPG_WYRM_BREATH] = 0
    set tc_add1[UPG_WYRM_BREATH] = 0
    set tc_add2[UPG_WYRM_BREATH] = 0
    set available_time[UPG_WYRM_BREATH] = 0
    set regenerate_time[UPG_WYRM_BREATH] = 0
    set gold_price[UPG_WYRM_BREATH] = 0
    set wood_price[UPG_WYRM_BREATH] = 0
	set hero_rush_bonus[UPG_WYRM_BREATH] = 0
	
    set old_id[UPG_SKEL_LIFE] = oUPG_SKEL_LIFE
    set buy_type[UPG_SKEL_LIFE] = BT_UPGRADE
    set needed1[UPG_SKEL_LIFE] = DAMNED_TEMPLE
    set needed2[UPG_SKEL_LIFE] = 0
    set needed3[UPG_SKEL_LIFE] = 0
    set tc_add1[UPG_SKEL_LIFE] = 0
    set tc_add2[UPG_SKEL_LIFE] = 0
    set available_time[UPG_SKEL_LIFE] = 0
    set regenerate_time[UPG_SKEL_LIFE] = 0
    set gold_price[UPG_SKEL_LIFE] = 0
    set wood_price[UPG_SKEL_LIFE] = 0
	set hero_rush_bonus[UPG_SKEL_LIFE] = 0
	
    set old_id[UPG_PLAGUE] = oUPG_PLAGUE
    set buy_type[UPG_PLAGUE] = BT_UPGRADE
    set needed1[UPG_PLAGUE] = SLAUGHTERHOUSE
    set needed2[UPG_PLAGUE] = 0
    set needed3[UPG_PLAGUE] = 0
    set tc_add1[UPG_PLAGUE] = 0
    set tc_add2[UPG_PLAGUE] = 0
    set available_time[UPG_PLAGUE] = 0
    set regenerate_time[UPG_PLAGUE] = 0
    set gold_price[UPG_PLAGUE] = 0
    set wood_price[UPG_PLAGUE] = 0
	set hero_rush_bonus[UPG_PLAGUE] = 0
	
    set old_id[UPG_SKEL_MASTERY] = oUPG_SKEL_MASTERY
    set buy_type[UPG_SKEL_MASTERY] = BT_UPGRADE
    set needed1[UPG_SKEL_MASTERY] = DAMNED_TEMPLE
    set needed2[UPG_SKEL_MASTERY] = NECROPOLIS_3
    set needed3[UPG_SKEL_MASTERY] = 0
    set tc_add1[UPG_SKEL_MASTERY] = 0
    set tc_add2[UPG_SKEL_MASTERY] = 0
    set available_time[UPG_SKEL_MASTERY] = 0
    set regenerate_time[UPG_SKEL_MASTERY] = 0
    set gold_price[UPG_SKEL_MASTERY] = 0
    set wood_price[UPG_SKEL_MASTERY] = 0
	set hero_rush_bonus[UPG_SKEL_MASTERY] = 0
	
    set old_id[UPG_BLK_SPHINX] = oUPG_BLK_SPHINX
    set buy_type[UPG_BLK_SPHINX] = BT_UPGRADE
    set needed1[UPG_BLK_SPHINX] = SLAUGHTERHOUSE
    set needed2[UPG_BLK_SPHINX] = NECROPOLIS_3
    set needed3[UPG_BLK_SPHINX] = TOMB_OF_RELICS
    set tc_add1[UPG_BLK_SPHINX] = 0
    set tc_add2[UPG_BLK_SPHINX] = 0
    set available_time[UPG_BLK_SPHINX] = 0
    set regenerate_time[UPG_BLK_SPHINX] = 0
    set gold_price[UPG_BLK_SPHINX] = 0
    set wood_price[UPG_BLK_SPHINX] = 0
	set hero_rush_bonus[UPG_BLK_SPHINX] = 0
	
    set old_id[UPG_BURROWING] = oUPG_BURROWING
    set buy_type[UPG_BURROWING] = BT_UPGRADE
    set needed1[UPG_BURROWING] = CRYPT
    set needed2[UPG_BURROWING] = NECROPOLIS_2
    set needed3[UPG_BURROWING] = GRAVEYARD
    set tc_add1[UPG_BURROWING] = 0
    set tc_add2[UPG_BURROWING] = 0
    set available_time[UPG_BURROWING] = 0
    set regenerate_time[UPG_BURROWING] = 0
    set gold_price[UPG_BURROWING] = 0
    set wood_price[UPG_BURROWING] = 0
	set hero_rush_bonus[UPG_BURROWING] = 0
	
    set old_id[UPG_EXHUME] = oUPG_EXHUME
    set buy_type[UPG_EXHUME] = BT_UPGRADE
    set needed1[UPG_EXHUME] = SLAUGHTERHOUSE
    set needed2[UPG_EXHUME] = NECROPOLIS_2
    set needed3[UPG_EXHUME] = 0
    set tc_add1[UPG_EXHUME] = 0
    set tc_add2[UPG_EXHUME] = 0
    set available_time[UPG_EXHUME] = 0
    set regenerate_time[UPG_EXHUME] = 0
    set gold_price[UPG_EXHUME] = 0
    set wood_price[UPG_EXHUME] = 0
	set hero_rush_bonus[UPG_EXHUME] = 0
	
    set old_id[UPG_UNHOLY_STR] = oUPG_UNHOLY_STR
    set buy_type[UPG_UNHOLY_STR] = BT_ML_UPGRADE
    set needed1[UPG_UNHOLY_STR] = GRAVEYARD
    set needed2[UPG_UNHOLY_STR] = NECROPOLIS_2
    set needed3[UPG_UNHOLY_STR] = NECROPOLIS_3
    set tc_add1[UPG_UNHOLY_STR] = 0
    set tc_add2[UPG_UNHOLY_STR] = 0
    set available_time[UPG_UNHOLY_STR] = 0
    set regenerate_time[UPG_UNHOLY_STR] = 0
    set gold_price[UPG_UNHOLY_STR] = 0
    set wood_price[UPG_UNHOLY_STR] = 0
	set hero_rush_bonus[UPG_UNHOLY_STR] = 0
	
    set old_id[UPG_CR_ATTACK] = oUPG_CR_ATTACK
    set buy_type[UPG_CR_ATTACK] = BT_ML_UPGRADE
    set needed1[UPG_CR_ATTACK] = GRAVEYARD
    set needed2[UPG_CR_ATTACK] = NECROPOLIS_2
    set needed3[UPG_CR_ATTACK] = NECROPOLIS_3
    set tc_add1[UPG_CR_ATTACK] = 0
    set tc_add2[UPG_CR_ATTACK] = 0
    set available_time[UPG_CR_ATTACK] = 0
    set regenerate_time[UPG_CR_ATTACK] = 0
    set gold_price[UPG_CR_ATTACK] = 0
    set wood_price[UPG_CR_ATTACK] = 0
	set hero_rush_bonus[UPG_CR_ATTACK] = 0
	
    set old_id[UPG_UNHOLY_ARMOR] = oUPG_UNHOLY_ARMOR
    set buy_type[UPG_UNHOLY_ARMOR] = BT_ML_UPGRADE
    set needed1[UPG_UNHOLY_ARMOR] = GRAVEYARD
    set needed2[UPG_UNHOLY_ARMOR] = NECROPOLIS_2
    set needed3[UPG_UNHOLY_ARMOR] = NECROPOLIS_3
    set tc_add1[UPG_UNHOLY_ARMOR] = 0
    set tc_add2[UPG_UNHOLY_ARMOR] = 0
    set available_time[UPG_UNHOLY_ARMOR] = 0
    set regenerate_time[UPG_UNHOLY_ARMOR] = 0
    set gold_price[UPG_UNHOLY_ARMOR] = 0
    set wood_price[UPG_UNHOLY_ARMOR] = 0
	set hero_rush_bonus[UPG_UNHOLY_ARMOR] = 0
	
    set old_id[UPG_CR_ARMOR] = oUPG_CR_ARMOR
    set buy_type[UPG_CR_ARMOR] = BT_ML_UPGRADE
    set needed1[UPG_CR_ARMOR] = GRAVEYARD
    set needed2[UPG_CR_ARMOR] = NECROPOLIS_2
    set needed3[UPG_CR_ARMOR] = NECROPOLIS_3
    set tc_add1[UPG_CR_ARMOR] = 0
    set tc_add2[UPG_CR_ARMOR] = 0
    set available_time[UPG_CR_ARMOR] = 0
    set regenerate_time[UPG_CR_ARMOR] = 0
    set gold_price[UPG_CR_ARMOR] = 0
    set wood_price[UPG_CR_ARMOR] = 0
	set hero_rush_bonus[UPG_CR_ARMOR] = 0
	
    set old_id[UPG_NECROS] = oUPG_NECROS
    set buy_type[UPG_NECROS] = BT_ML_UPGRADE
    set needed1[UPG_NECROS] = DAMNED_TEMPLE
    set needed2[UPG_NECROS] = NECROPOLIS_3
    set needed3[UPG_NECROS] = 0
    set tc_add1[UPG_NECROS] = 0
    set tc_add2[UPG_NECROS] = 0
    set available_time[UPG_NECROS] = 0
    set regenerate_time[UPG_NECROS] = 0
    set gold_price[UPG_NECROS] = 0
    set wood_price[UPG_NECROS] = 0
	set hero_rush_bonus[UPG_NECROS] = 0
	
    set old_id[UPG_BANSHEE] = oUPG_BANSHEE
    set buy_type[UPG_BANSHEE] = BT_ML_UPGRADE
    set needed1[UPG_BANSHEE] = DAMNED_TEMPLE
    set needed2[UPG_BANSHEE] = NECROPOLIS_3
    set needed3[UPG_BANSHEE] = 0
    set tc_add1[UPG_BANSHEE] = 0
    set tc_add2[UPG_BANSHEE] = 0
    set available_time[UPG_BANSHEE] = 0
    set regenerate_time[UPG_BANSHEE] = 0
    set gold_price[UPG_BANSHEE] = 0
    set wood_price[UPG_BANSHEE] = 0
	set hero_rush_bonus[UPG_BANSHEE] = 0
	
    set old_id[DEMON_HUNTER] = oDEMON_HUNTER
    set buy_type[DEMON_HUNTER] = BT_HERO
    set needed1[DEMON_HUNTER] = ELF_ALTAR
    set needed2[DEMON_HUNTER] = TREE_AGES
    set needed3[DEMON_HUNTER] = TREE_ETERNITY
    set tc_add1[DEMON_HUNTER] = 0
    set tc_add2[DEMON_HUNTER] = 0
    set available_time[DEMON_HUNTER] = 0
    set regenerate_time[DEMON_HUNTER] = 0
    set gold_price[DEMON_HUNTER] = 0
    set wood_price[DEMON_HUNTER] = 0
	set hero_rush_bonus[DEMON_HUNTER] = 0
	
    set old_id[DEMON_HUNTER_M] = oDEMON_HUNTER_M
    set buy_type[DEMON_HUNTER_M] = BT_HERO
    set needed1[DEMON_HUNTER_M] = ELF_ALTAR
    set needed2[DEMON_HUNTER_M] = TREE_AGES
    set needed3[DEMON_HUNTER_M] = TREE_ETERNITY
    set tc_add1[DEMON_HUNTER_M] = 0
    set tc_add2[DEMON_HUNTER_M] = 0
    set available_time[DEMON_HUNTER_M] = 0
    set regenerate_time[DEMON_HUNTER_M] = 0
    set gold_price[DEMON_HUNTER_M] = 0
    set wood_price[DEMON_HUNTER_M] = 0
	set hero_rush_bonus[DEMON_HUNTER_M] = 0
	
    set old_id[KEEPER] = oKEEPER
    set buy_type[KEEPER] = BT_HERO
    set needed1[KEEPER] = ELF_ALTAR
    set needed2[KEEPER] = TREE_AGES
    set needed3[KEEPER] = TREE_ETERNITY
    set tc_add1[KEEPER] = 0
    set tc_add2[KEEPER] = 0
    set available_time[KEEPER] = 0
    set regenerate_time[KEEPER] = 0
    set gold_price[KEEPER] = 0
    set wood_price[KEEPER] = 0
	set hero_rush_bonus[KEEPER] = 0
	
    set old_id[MOON_PRIESTESS] = oMOON_PRIESTESS
    set buy_type[MOON_PRIESTESS] = BT_HERO
    set needed1[MOON_PRIESTESS] = ELF_ALTAR
    set needed2[MOON_PRIESTESS] = TREE_AGES
    set needed3[MOON_PRIESTESS] = TREE_ETERNITY
    set tc_add1[MOON_PRIESTESS] = 0
    set tc_add2[MOON_PRIESTESS] = 0
    set available_time[MOON_PRIESTESS] = 0
    set regenerate_time[MOON_PRIESTESS] = 0
    set gold_price[MOON_PRIESTESS] = 0
    set wood_price[MOON_PRIESTESS] = 0
	set hero_rush_bonus[MOON_PRIESTESS] = 0
	
    set old_id[WARDEN] = oWARDEN
    set buy_type[WARDEN] = BT_HERO
    set needed1[WARDEN] = ELF_ALTAR
    set needed2[WARDEN] = TREE_AGES
    set needed3[WARDEN] = TREE_ETERNITY
    set tc_add1[WARDEN] = 0
    set tc_add2[WARDEN] = 0
    set available_time[WARDEN] = 0
    set regenerate_time[WARDEN] = 0
    set gold_price[WARDEN] = 0
    set wood_price[WARDEN] = 0
	set hero_rush_bonus[WARDEN] = 0
	
    set old_id[WISP] = oWISP
    set buy_type[WISP] = BT_UNIT
    set needed1[WISP] = TREE_LIFE
    set needed2[WISP] = 0
    set needed3[WISP] = 0
    set tc_add1[WISP] = 0
    set tc_add2[WISP] = 0
    set available_time[WISP] = 0
    set regenerate_time[WISP] = 0
    set gold_price[WISP] = 0
    set wood_price[WISP] = 0
	set hero_rush_bonus[WISP] = 0
	
    set old_id[ARCHER] = oARCHER
    set buy_type[ARCHER] = BT_UNIT
    set needed1[ARCHER] = ANCIENT_WAR
    set needed2[ARCHER] = 0
    set needed3[ARCHER] = 0
    set tc_add1[ARCHER] = 0
    set tc_add2[ARCHER] = 0
    set available_time[ARCHER] = 0
    set regenerate_time[ARCHER] = 0
    set gold_price[ARCHER] = 0
    set wood_price[ARCHER] = 0
	set hero_rush_bonus[ARCHER] = 0
	
    set old_id[DRUID_TALON] = oDRUID_TALON
    set buy_type[DRUID_TALON] = BT_UNIT
    set needed1[DRUID_TALON] = ANCIENT_WIND
    set needed2[DRUID_TALON] = 0
    set needed3[DRUID_TALON] = 0
    set tc_add1[DRUID_TALON] = 0
    set tc_add2[DRUID_TALON] = DRUID_TALON_M
    set available_time[DRUID_TALON] = 0
    set regenerate_time[DRUID_TALON] = 0
    set gold_price[DRUID_TALON] = 0
    set wood_price[DRUID_TALON] = 0
	set hero_rush_bonus[DRUID_TALON] = 0
	
    set old_id[DRUID_TALON_M] = oDRUID_TALON_M
    set buy_type[DRUID_TALON_M] = BT_UNIT
    set needed1[DRUID_TALON_M] = 0
    set needed2[DRUID_TALON_M] = 0
    set needed3[DRUID_TALON_M] = 0
    set tc_add1[DRUID_TALON_M] = 0
    set tc_add2[DRUID_TALON_M] = DRUID_TALON
    set available_time[DRUID_TALON_M] = 0
    set regenerate_time[DRUID_TALON_M] = 0
    set gold_price[DRUID_TALON_M] = 0
    set wood_price[DRUID_TALON_M] = 0
	set hero_rush_bonus[DRUID_TALON_M] = 0
	
    set old_id[BALLISTA] = oBALLISTA
    set buy_type[BALLISTA] = BT_UNIT
    set needed1[BALLISTA] = ANCIENT_WAR
    set needed2[BALLISTA] = HUNTERS_HALL
    set needed3[BALLISTA] = 0
    set tc_add1[BALLISTA] = 0
    set tc_add2[BALLISTA] = 0
    set available_time[BALLISTA] = 0
    set regenerate_time[BALLISTA] = 0
    set gold_price[BALLISTA] = 0
    set wood_price[BALLISTA] = 0
	set hero_rush_bonus[BALLISTA] = 0
	
    set old_id[DRUID_CLAW] = oDRUID_CLAW
    set buy_type[DRUID_CLAW] = BT_UNIT
    set needed1[DRUID_CLAW] = ANCIENT_LORE
    set needed2[DRUID_CLAW] = TREE_AGES
    set needed3[DRUID_CLAW] = 0
    set tc_add1[DRUID_CLAW] = 0
    set tc_add2[DRUID_CLAW] = DRUID_CLAW_M
    set available_time[DRUID_CLAW] = 0
    set regenerate_time[DRUID_CLAW] = 0
    set gold_price[DRUID_CLAW] = 0
    set wood_price[DRUID_CLAW] = 0
	set hero_rush_bonus[DRUID_CLAW] = 0
	
    set old_id[DRUID_CLAW_M] = oDRUID_CLAW_M
    set buy_type[DRUID_CLAW_M] = BT_UNIT
    set needed1[DRUID_CLAW_M] = 0
    set needed2[DRUID_CLAW_M] = 0
    set needed3[DRUID_CLAW_M] = 0
    set tc_add1[DRUID_CLAW_M] = 0
    set tc_add2[DRUID_CLAW_M] = DRUID_CLAW
    set available_time[DRUID_CLAW_M] = 0
    set regenerate_time[DRUID_CLAW_M] = 0
    set gold_price[DRUID_CLAW_M] = 0
    set wood_price[DRUID_CLAW_M] = 0
	set hero_rush_bonus[DRUID_CLAW_M] = 0
	
    set old_id[DRYAD] = oDRYAD
    set buy_type[DRYAD] = BT_UNIT
    set needed1[DRYAD] = ANCIENT_LORE
    set needed2[DRYAD] = 0
    set needed3[DRYAD] = 0
    set tc_add1[DRYAD] = 0
    set tc_add2[DRYAD] = 0
    set available_time[DRYAD] = 0
    set regenerate_time[DRYAD] = 0
    set gold_price[DRYAD] = 0
    set wood_price[DRYAD] = 0
	set hero_rush_bonus[DRYAD] = 0
	
    set old_id[HIPPO] = oHIPPO
    set buy_type[HIPPO] = BT_UNIT
    set needed1[HIPPO] = ANCIENT_WIND
    set needed2[HIPPO] = 0
    set needed3[HIPPO] = 0
    set tc_add1[HIPPO] = 0
    set tc_add2[HIPPO] = 0
    set available_time[HIPPO] = 0
    set regenerate_time[HIPPO] = 0
    set gold_price[HIPPO] = 0
    set wood_price[HIPPO] = 0
	set hero_rush_bonus[HIPPO] = 0
	
    set old_id[HIPPO_RIDER] = oHIPPO_RIDER
    set buy_type[HIPPO_RIDER] = BT_UNIT
    set needed1[HIPPO_RIDER] = HIPPO
    set needed2[HIPPO_RIDER] = ARCHER
    set needed3[HIPPO_RIDER] = 0
    set tc_add1[HIPPO_RIDER] = 0
    set tc_add2[HIPPO_RIDER] = 0
    set available_time[HIPPO_RIDER] = 0
    set regenerate_time[HIPPO_RIDER] = 0
    set gold_price[HIPPO_RIDER] = 0
    set wood_price[HIPPO_RIDER] = 0
	set hero_rush_bonus[HIPPO_RIDER] = 0
	
    set old_id[HUNTRESS] = oHUNTRESS
    set buy_type[HUNTRESS] = BT_UNIT
    set needed1[HUNTRESS] = ANCIENT_WAR
    set needed2[HUNTRESS] = HUNTERS_HALL
    set needed3[HUNTRESS] = 0
    set tc_add1[HUNTRESS] = 0
    set tc_add2[HUNTRESS] = 0
    set available_time[HUNTRESS] = 0
    set regenerate_time[HUNTRESS] = 0
    set gold_price[HUNTRESS] = 0
    set wood_price[HUNTRESS] = 0
	set hero_rush_bonus[HUNTRESS] = 0
	
    set old_id[CHIMAERA] = oCHIMAERA
    set buy_type[CHIMAERA] = BT_UNIT
    set needed1[CHIMAERA] = CHIMAERA_ROOST
    set needed2[CHIMAERA] = 0
    set needed3[CHIMAERA] = 0
    set tc_add1[CHIMAERA] = 0
    set tc_add2[CHIMAERA] = 0
    set available_time[CHIMAERA] = 0
    set regenerate_time[CHIMAERA] = 0
    set gold_price[CHIMAERA] = 0
    set wood_price[CHIMAERA] = 0
	set hero_rush_bonus[CHIMAERA] = 0
	
    set old_id[ENT] = oENT
    set buy_type[ENT] = BT_UNIT
    set needed1[ENT] = KEEPER
    set needed2[ENT] = 0
    set needed3[ENT] = 0
    set tc_add1[ENT] = 0
    set tc_add2[ENT] = 0
    set available_time[ENT] = 0
    set regenerate_time[ENT] = 0
    set gold_price[ENT] = 0
    set wood_price[ENT] = 0
	set hero_rush_bonus[ENT] = 0
	
    set old_id[MOUNTAIN_GIANT] = oMOUNTAIN_GIANT
    set buy_type[MOUNTAIN_GIANT] = BT_UNIT
    set needed1[MOUNTAIN_GIANT] = ANCIENT_LORE
    set needed2[MOUNTAIN_GIANT] = DEN_OF_WONDERS
    set needed3[MOUNTAIN_GIANT] = 0
    set tc_add1[MOUNTAIN_GIANT] = 0
    set tc_add2[MOUNTAIN_GIANT] = 0
    set available_time[MOUNTAIN_GIANT] = 0
    set regenerate_time[MOUNTAIN_GIANT] = 0
    set gold_price[MOUNTAIN_GIANT] = 0
    set wood_price[MOUNTAIN_GIANT] = 0
	set hero_rush_bonus[MOUNTAIN_GIANT] = 0
	
    set old_id[FAERIE_DRAGON] = oFAERIE_DRAGON
    set buy_type[FAERIE_DRAGON] = BT_UNIT
    set needed1[FAERIE_DRAGON] = ANCIENT_WIND
    set needed2[FAERIE_DRAGON] = DEN_OF_WONDERS
    set needed3[FAERIE_DRAGON] = 0
    set tc_add1[FAERIE_DRAGON] = 0
    set tc_add2[FAERIE_DRAGON] = 0
    set available_time[FAERIE_DRAGON] = 0
    set regenerate_time[FAERIE_DRAGON] = 0
    set gold_price[FAERIE_DRAGON] = 0
    set wood_price[FAERIE_DRAGON] = 0
	set hero_rush_bonus[FAERIE_DRAGON] = 0
	
    set old_id[ANCIENT_LORE] = oANCIENT_LORE
    set buy_type[ANCIENT_LORE] = BT_BUILDING
    set needed1[ANCIENT_LORE] = WISP
    set needed2[ANCIENT_LORE] = TREE_AGES
    set needed3[ANCIENT_LORE] = HUNTERS_HALL
    set tc_add1[ANCIENT_LORE] = 0
    set tc_add2[ANCIENT_LORE] = 0
    set available_time[ANCIENT_LORE] = 0
    set regenerate_time[ANCIENT_LORE] = 0
    set gold_price[ANCIENT_LORE] = 0
    set wood_price[ANCIENT_LORE] = 0
	set hero_rush_bonus[ANCIENT_LORE] = 0
	
    set old_id[ANCIENT_WAR] = oANCIENT_WAR
    set buy_type[ANCIENT_WAR] = BT_BUILDING
    set needed1[ANCIENT_WAR] = WISP
    set needed2[ANCIENT_WAR] = 0
    set needed3[ANCIENT_WAR] = 0
    set tc_add1[ANCIENT_WAR] = 0
    set tc_add2[ANCIENT_WAR] = 0
    set available_time[ANCIENT_WAR] = 0
    set regenerate_time[ANCIENT_WAR] = 0
    set gold_price[ANCIENT_WAR] = 0
    set wood_price[ANCIENT_WAR] = 0
	set hero_rush_bonus[ANCIENT_WAR] = 0
	
    set old_id[ANCIENT_WIND] = oANCIENT_WIND
    set buy_type[ANCIENT_WIND] = BT_BUILDING
    set needed1[ANCIENT_WIND] = WISP
    set needed2[ANCIENT_WIND] = TREE_AGES
    set needed3[ANCIENT_WIND] = 0
    set tc_add1[ANCIENT_WIND] = 0
    set tc_add2[ANCIENT_WIND] = 0
    set available_time[ANCIENT_WIND] = 0
    set regenerate_time[ANCIENT_WIND] = 0
    set gold_price[ANCIENT_WIND] = 0
    set wood_price[ANCIENT_WIND] = 0
	set hero_rush_bonus[ANCIENT_WIND] = 0
	
    set old_id[TREE_AGES] = oTREE_AGES
    set buy_type[TREE_AGES] = BT_BUILDING
    set needed1[TREE_AGES] = TREE_LIFE
    set needed2[TREE_AGES] = 0
    set needed3[TREE_AGES] = UPGRADED
    set tc_add1[TREE_AGES] = TREE_ETERNITY
    set tc_add2[TREE_AGES] = 0
    set available_time[TREE_AGES] = 0
    set regenerate_time[TREE_AGES] = 0
    set gold_price[TREE_AGES] = 0
    set wood_price[TREE_AGES] = 0
	set hero_rush_bonus[TREE_AGES] = 0
	
    set old_id[TREE_ETERNITY] = oTREE_ETERNITY
    set buy_type[TREE_ETERNITY] = BT_BUILDING
    set needed1[TREE_ETERNITY] = TREE_AGES
    set needed2[TREE_ETERNITY] = ELF_ALTAR
    set needed3[TREE_ETERNITY] = UPGRADED
    set tc_add1[TREE_ETERNITY] = 0
    set tc_add2[TREE_ETERNITY] = 0
    set available_time[TREE_ETERNITY] = 0
    set regenerate_time[TREE_ETERNITY] = 0
    set gold_price[TREE_ETERNITY] = 0
    set wood_price[TREE_ETERNITY] = 0
	set hero_rush_bonus[TREE_ETERNITY] = 0
	
    set old_id[TREE_LIFE] = oTREE_LIFE
    set buy_type[TREE_LIFE] = BT_BUILDING
    set needed1[TREE_LIFE] = 0
    set needed2[TREE_LIFE] = 0
    set needed3[TREE_LIFE] = 0
    set tc_add1[TREE_LIFE] = TREE_AGES
    set tc_add2[TREE_LIFE] = TREE_ETERNITY
    set available_time[TREE_LIFE] = 0
    set regenerate_time[TREE_LIFE] = 0
    set gold_price[TREE_LIFE] = 0
    set wood_price[TREE_LIFE] = 0
	set hero_rush_bonus[TREE_LIFE] = 0
	
    set old_id[ANCIENT_PROTECT] = oANCIENT_PROTECT
    set buy_type[ANCIENT_PROTECT] = BT_BUILDING
    set needed1[ANCIENT_PROTECT] = WISP
    set needed2[ANCIENT_PROTECT] = HUNTERS_HALL
    set needed3[ANCIENT_PROTECT] = 0
    set tc_add1[ANCIENT_PROTECT] = 0
    set tc_add2[ANCIENT_PROTECT] = 0
    set available_time[ANCIENT_PROTECT] = 0
    set regenerate_time[ANCIENT_PROTECT] = 0
    set gold_price[ANCIENT_PROTECT] = 0
    set wood_price[ANCIENT_PROTECT] = 0
	set hero_rush_bonus[ANCIENT_PROTECT] = 0
	
    set old_id[ELF_ALTAR] = oELF_ALTAR
    set buy_type[ELF_ALTAR] = BT_BUILDING
    set needed1[ELF_ALTAR] = WISP
    set needed2[ELF_ALTAR] = 0
    set needed3[ELF_ALTAR] = 0
    set tc_add1[ELF_ALTAR] = 0
    set tc_add2[ELF_ALTAR] = 0
    set available_time[ELF_ALTAR] = 0
    set regenerate_time[ELF_ALTAR] = 0
    set gold_price[ELF_ALTAR] = 0
    set wood_price[ELF_ALTAR] = 0
	set hero_rush_bonus[ELF_ALTAR] = 0
	
    set old_id[CHIMAERA_ROOST] = oCHIMAERA_ROOST
    set buy_type[CHIMAERA_ROOST] = BT_BUILDING
    set needed1[CHIMAERA_ROOST] = WISP
    set needed2[CHIMAERA_ROOST] = TREE_ETERNITY
    set needed3[CHIMAERA_ROOST] = ANCIENT_WIND
    set tc_add1[CHIMAERA_ROOST] = 0
    set tc_add2[CHIMAERA_ROOST] = 0
    set available_time[CHIMAERA_ROOST] = 0
    set regenerate_time[CHIMAERA_ROOST] = 0
    set gold_price[CHIMAERA_ROOST] = 0
    set wood_price[CHIMAERA_ROOST] = 0
	set hero_rush_bonus[CHIMAERA_ROOST] = 0
	
    set old_id[HUNTERS_HALL] = oHUNTERS_HALL
    set buy_type[HUNTERS_HALL] = BT_BUILDING
    set needed1[HUNTERS_HALL] = WISP
    set needed2[HUNTERS_HALL] = TREE_LIFE
    set needed3[HUNTERS_HALL] = 0
    set tc_add1[HUNTERS_HALL] = 0
    set tc_add2[HUNTERS_HALL] = 0
    set available_time[HUNTERS_HALL] = 0
    set regenerate_time[HUNTERS_HALL] = 0
    set gold_price[HUNTERS_HALL] = 0
    set wood_price[HUNTERS_HALL] = 0
	set hero_rush_bonus[HUNTERS_HALL] = 0
	
    set old_id[MOON_WELL] = oMOON_WELL
    set buy_type[MOON_WELL] = BT_BUILDING
    set needed1[MOON_WELL] = WISP
    set needed2[MOON_WELL] = 0
    set needed3[MOON_WELL] = 0
    set tc_add1[MOON_WELL] = 0
    set tc_add2[MOON_WELL] = 0
    set available_time[MOON_WELL] = 0
    set regenerate_time[MOON_WELL] = 0
    set gold_price[MOON_WELL] = 0
    set wood_price[MOON_WELL] = 0
	set hero_rush_bonus[MOON_WELL] = 0
	
    set old_id[ELF_MINE] = oELF_MINE
    set buy_type[ELF_MINE] = BT_BUILDING
    set needed1[ELF_MINE] = WISP
    set needed2[ELF_MINE] = 0
    set needed3[ELF_MINE] = 0
    set tc_add1[ELF_MINE] = 0
    set tc_add2[ELF_MINE] = 0
    set available_time[ELF_MINE] = 0
    set regenerate_time[ELF_MINE] = 0
    set gold_price[ELF_MINE] = 0
    set wood_price[ELF_MINE] = 0
	set hero_rush_bonus[ELF_MINE] = 0
	
    set old_id[DEN_OF_WONDERS] = oDEN_OF_WONDERS
    set buy_type[DEN_OF_WONDERS] = BT_BUILDING
    set needed1[DEN_OF_WONDERS] = WISP
    set needed2[DEN_OF_WONDERS] = 0
    set needed3[DEN_OF_WONDERS] = 0
    set tc_add1[DEN_OF_WONDERS] = 0
    set tc_add2[DEN_OF_WONDERS] = 0
    set available_time[DEN_OF_WONDERS] = 0
    set regenerate_time[DEN_OF_WONDERS] = 0
    set gold_price[DEN_OF_WONDERS] = 0
    set wood_price[DEN_OF_WONDERS] = 0
	set hero_rush_bonus[DEN_OF_WONDERS] = 0
	
    set old_id[UPG_ULTRAVISION] = oUPG_ULTRAVISION
    set buy_type[UPG_ULTRAVISION] = BT_UPGRADE
    set needed1[UPG_ULTRAVISION] = HUNTERS_HALL
    set needed2[UPG_ULTRAVISION] = 0
    set needed3[UPG_ULTRAVISION] = 0
    set tc_add1[UPG_ULTRAVISION] = 0
    set tc_add2[UPG_ULTRAVISION] = 0
    set available_time[UPG_ULTRAVISION] = 0
    set regenerate_time[UPG_ULTRAVISION] = 0
    set gold_price[UPG_ULTRAVISION] = 0
    set wood_price[UPG_ULTRAVISION] = 0
	set hero_rush_bonus[UPG_ULTRAVISION] = 0
	
    set old_id[UPG_BLESSING] = oUPG_BLESSING
    set buy_type[UPG_BLESSING] = BT_UPGRADE
    set needed1[UPG_BLESSING] = TREE_LIFE
    set needed2[UPG_BLESSING] = TREE_AGES
    set needed3[UPG_BLESSING] = 0
    set tc_add1[UPG_BLESSING] = 0
    set tc_add2[UPG_BLESSING] = 0
    set available_time[UPG_BLESSING] = 0
    set regenerate_time[UPG_BLESSING] = 0
    set gold_price[UPG_BLESSING] = 0
    set wood_price[UPG_BLESSING] = 0
	set hero_rush_bonus[UPG_BLESSING] = 0
	
    set old_id[UPG_SCOUT] = oUPG_SCOUT
    set buy_type[UPG_SCOUT] = BT_UPGRADE
    set needed1[UPG_SCOUT] = ANCIENT_WAR
    set needed2[UPG_SCOUT] = TREE_AGES
    set needed3[UPG_SCOUT] = HUNTERS_HALL
    set tc_add1[UPG_SCOUT] = 0
    set tc_add2[UPG_SCOUT] = 0
    set available_time[UPG_SCOUT] = 0
    set regenerate_time[UPG_SCOUT] = 0
    set gold_price[UPG_SCOUT] = 0
    set wood_price[UPG_SCOUT] = 0
	set hero_rush_bonus[UPG_SCOUT] = 0
	
    set old_id[UPG_GLAIVE] = oUPG_GLAIVE
    set buy_type[UPG_GLAIVE] = BT_UPGRADE
    set needed1[UPG_GLAIVE] = ANCIENT_WAR
    set needed2[UPG_GLAIVE] = TREE_ETERNITY
    set needed3[UPG_GLAIVE] = HUNTERS_HALL
    set tc_add1[UPG_GLAIVE] = 0
    set tc_add2[UPG_GLAIVE] = 0
    set available_time[UPG_GLAIVE] = 0
    set regenerate_time[UPG_GLAIVE] = 0
    set gold_price[UPG_GLAIVE] = 0
    set wood_price[UPG_GLAIVE] = 0
	set hero_rush_bonus[UPG_GLAIVE] = 0
	
    set old_id[UPG_BOWS] = oUPG_BOWS
    set buy_type[UPG_BOWS] = BT_UPGRADE
    set needed1[UPG_BOWS] = ANCIENT_WAR
    set needed2[UPG_BOWS] = TREE_AGES
    set needed3[UPG_BOWS] = 0
    set tc_add1[UPG_BOWS] = 0
    set tc_add2[UPG_BOWS] = 0
    set available_time[UPG_BOWS] = 0
    set regenerate_time[UPG_BOWS] = 0
    set gold_price[UPG_BOWS] = 0
    set wood_price[UPG_BOWS] = 0
	set hero_rush_bonus[UPG_BOWS] = 0
	
    set old_id[UPG_MARKSMAN] = oUPG_MARKSMAN
    set buy_type[UPG_MARKSMAN] = BT_UPGRADE
    set needed1[UPG_MARKSMAN] = ANCIENT_WAR
    set needed2[UPG_MARKSMAN] = TREE_ETERNITY
    set needed3[UPG_MARKSMAN] = HUNTERS_HALL
    set tc_add1[UPG_MARKSMAN] = 0
    set tc_add2[UPG_MARKSMAN] = 0
    set available_time[UPG_MARKSMAN] = 0
    set regenerate_time[UPG_MARKSMAN] = 0
    set gold_price[UPG_MARKSMAN] = 0
    set wood_price[UPG_MARKSMAN] = 0
	set hero_rush_bonus[UPG_MARKSMAN] = 0
	
    set old_id[UPG_ABOLISH] = oUPG_ABOLISH
    set buy_type[UPG_ABOLISH] = BT_UPGRADE
    set needed1[UPG_ABOLISH] = ANCIENT_LORE
    set needed2[UPG_ABOLISH] = 0
    set needed3[UPG_ABOLISH] = 0
    set tc_add1[UPG_ABOLISH] = 0
    set tc_add2[UPG_ABOLISH] = 0
    set available_time[UPG_ABOLISH] = 0
    set regenerate_time[UPG_ABOLISH] = 0
    set gold_price[UPG_ABOLISH] = 0
    set wood_price[UPG_ABOLISH] = 0
	set hero_rush_bonus[UPG_ABOLISH] = 0
	
    set old_id[UPG_CHIM_ACID] = oUPG_CHIM_ACID
    set buy_type[UPG_CHIM_ACID] = BT_UPGRADE
    set needed1[UPG_CHIM_ACID] = CHIMAERA_ROOST
    set needed2[UPG_CHIM_ACID] = 0
    set needed3[UPG_CHIM_ACID] = 0
    set tc_add1[UPG_CHIM_ACID] = 0
    set tc_add2[UPG_CHIM_ACID] = 0
    set available_time[UPG_CHIM_ACID] = 0
    set regenerate_time[UPG_CHIM_ACID] = 0
    set gold_price[UPG_CHIM_ACID] = 0
    set wood_price[UPG_CHIM_ACID] = 0
	set hero_rush_bonus[UPG_CHIM_ACID] = 0
	
    set old_id[UPG_HIPPO_TAME] = oUPG_HIPPO_TAME
    set buy_type[UPG_HIPPO_TAME] = BT_UPGRADE
    set needed1[UPG_HIPPO_TAME] = ANCIENT_WIND
    set needed2[UPG_HIPPO_TAME] = 0
    set needed3[UPG_HIPPO_TAME] = 0
    set tc_add1[UPG_HIPPO_TAME] = 0
    set tc_add2[UPG_HIPPO_TAME] = 0
    set available_time[UPG_HIPPO_TAME] = 0
    set regenerate_time[UPG_HIPPO_TAME] = 0
    set gold_price[UPG_HIPPO_TAME] = 0
    set wood_price[UPG_HIPPO_TAME] = 0
	set hero_rush_bonus[UPG_HIPPO_TAME] = 0
	
    set old_id[UPG_BOLT] = oUPG_BOLT
    set buy_type[UPG_BOLT] = BT_UPGRADE
    set needed1[UPG_BOLT] = ANCIENT_WAR
    set needed2[UPG_BOLT] = TREE_AGES
    set needed3[UPG_BOLT] = HUNTERS_HALL
    set tc_add1[UPG_BOLT] = 0
    set tc_add2[UPG_BOLT] = 0
    set available_time[UPG_BOLT] = 0
    set regenerate_time[UPG_BOLT] = 0
    set gold_price[UPG_BOLT] = 0
    set wood_price[UPG_BOLT] = 0
	set hero_rush_bonus[UPG_BOLT] = 0
	
    set old_id[UPG_MARK_CLAW] = oUPG_MARK_CLAW
    set buy_type[UPG_MARK_CLAW] = BT_UPGRADE
    set needed1[UPG_MARK_CLAW] = ANCIENT_LORE
    set needed2[UPG_MARK_CLAW] = 0
    set needed3[UPG_MARK_CLAW] = 0
    set tc_add1[UPG_MARK_CLAW] = 0
    set tc_add2[UPG_MARK_CLAW] = 0
    set available_time[UPG_MARK_CLAW] = 0
    set regenerate_time[UPG_MARK_CLAW] = 0
    set gold_price[UPG_MARK_CLAW] = 0
    set wood_price[UPG_MARK_CLAW] = 0
	set hero_rush_bonus[UPG_MARK_CLAW] = 0
	
    set old_id[UPG_MARK_TALON] = oUPG_MARK_TALON
    set buy_type[UPG_MARK_TALON] = BT_UPGRADE
    set needed1[UPG_MARK_TALON] = ANCIENT_WIND
    set needed2[UPG_MARK_TALON] = 0
    set needed3[UPG_MARK_TALON] = 0
    set tc_add1[UPG_MARK_TALON] = 0
    set tc_add2[UPG_MARK_TALON] = 0
    set available_time[UPG_MARK_TALON] = 0
    set regenerate_time[UPG_MARK_TALON] = 0
    set gold_price[UPG_MARK_TALON] = 0
    set wood_price[UPG_MARK_TALON] = 0
	set hero_rush_bonus[UPG_MARK_TALON] = 0
	
    set old_id[UPG_HARD_SKIN] = oUPG_HARD_SKIN
    set buy_type[UPG_HARD_SKIN] = BT_UPGRADE
    set needed1[UPG_HARD_SKIN] = ANCIENT_LORE
    set needed2[UPG_HARD_SKIN] = TREE_ETERNITY
    set needed3[UPG_HARD_SKIN] = DEN_OF_WONDERS
    set tc_add1[UPG_HARD_SKIN] = 0
    set tc_add2[UPG_HARD_SKIN] = 0
    set available_time[UPG_HARD_SKIN] = 0
    set regenerate_time[UPG_HARD_SKIN] = 0
    set gold_price[UPG_HARD_SKIN] = 0
    set wood_price[UPG_HARD_SKIN] = 0
	set hero_rush_bonus[UPG_HARD_SKIN] = 0
	
    set old_id[UPG_RESIST_SKIN] = oUPG_RESIST_SKIN
    set buy_type[UPG_RESIST_SKIN] = BT_UPGRADE
    set needed1[UPG_RESIST_SKIN] = ANCIENT_LORE
    set needed2[UPG_RESIST_SKIN] = TREE_ETERNITY
    set needed3[UPG_RESIST_SKIN] = DEN_OF_WONDERS
    set tc_add1[UPG_RESIST_SKIN] = 0
    set tc_add2[UPG_RESIST_SKIN] = 0
    set available_time[UPG_RESIST_SKIN] = 0
    set regenerate_time[UPG_RESIST_SKIN] = 0
    set gold_price[UPG_RESIST_SKIN] = 0
    set wood_price[UPG_RESIST_SKIN] = 0
	set hero_rush_bonus[UPG_RESIST_SKIN] = 0
	
    set old_id[UPG_WELL_SPRING] = oUPG_WELL_SPRING
    set buy_type[UPG_WELL_SPRING] = BT_UPGRADE
    set needed1[UPG_WELL_SPRING] = HUNTERS_HALL
    set needed2[UPG_WELL_SPRING] = TREE_ETERNITY
    set needed3[UPG_WELL_SPRING] = 0
    set tc_add1[UPG_WELL_SPRING] = 0
    set tc_add2[UPG_WELL_SPRING] = 0
    set available_time[UPG_WELL_SPRING] = 0
    set regenerate_time[UPG_WELL_SPRING] = 0
    set gold_price[UPG_WELL_SPRING] = 0
    set wood_price[UPG_WELL_SPRING] = 0
	set hero_rush_bonus[UPG_WELL_SPRING] = 0
	
    set old_id[UPG_STR_MOON] = oUPG_STR_MOON
    set buy_type[UPG_STR_MOON] = BT_ML_UPGRADE
    set needed1[UPG_STR_MOON] = HUNTERS_HALL
    set needed2[UPG_STR_MOON] = TREE_AGES
    set needed3[UPG_STR_MOON] = TREE_ETERNITY
    set tc_add1[UPG_STR_MOON] = 0
    set tc_add2[UPG_STR_MOON] = 0
    set available_time[UPG_STR_MOON] = 0
    set regenerate_time[UPG_STR_MOON] = 0
    set gold_price[UPG_STR_MOON] = 0
    set wood_price[UPG_STR_MOON] = 0
	set hero_rush_bonus[UPG_STR_MOON] = 0
	
    set old_id[UPG_STR_WILD] = oUPG_STR_WILD
    set buy_type[UPG_STR_WILD] = BT_ML_UPGRADE
    set needed1[UPG_STR_WILD] = HUNTERS_HALL
    set needed2[UPG_STR_WILD] = TREE_AGES
    set needed3[UPG_STR_WILD] = TREE_ETERNITY
    set tc_add1[UPG_STR_WILD] = 0
    set tc_add2[UPG_STR_WILD] = 0
    set available_time[UPG_STR_WILD] = 0
    set regenerate_time[UPG_STR_WILD] = 0
    set gold_price[UPG_STR_WILD] = 0
    set wood_price[UPG_STR_WILD] = 0
	set hero_rush_bonus[UPG_STR_WILD] = 0
	
    set old_id[UPG_MOON_ARMOR] = oUPG_MOON_ARMOR
    set buy_type[UPG_MOON_ARMOR] = BT_ML_UPGRADE
    set needed1[UPG_MOON_ARMOR] = HUNTERS_HALL
    set needed2[UPG_MOON_ARMOR] = TREE_AGES
    set needed3[UPG_MOON_ARMOR] = TREE_ETERNITY
    set tc_add1[UPG_MOON_ARMOR] = 0
    set tc_add2[UPG_MOON_ARMOR] = 0
    set available_time[UPG_MOON_ARMOR] = 0
    set regenerate_time[UPG_MOON_ARMOR] = 0
    set gold_price[UPG_MOON_ARMOR] = 0
    set wood_price[UPG_MOON_ARMOR] = 0
	set hero_rush_bonus[UPG_MOON_ARMOR] = 0
	
    set old_id[UPG_HIDES] = oUPG_HIDES
    set buy_type[UPG_HIDES] = BT_ML_UPGRADE
    set needed1[UPG_HIDES] = HUNTERS_HALL
    set needed2[UPG_HIDES] = TREE_AGES
    set needed3[UPG_HIDES] = TREE_ETERNITY
    set tc_add1[UPG_HIDES] = 0
    set tc_add2[UPG_HIDES] = 0
    set available_time[UPG_HIDES] = 0
    set regenerate_time[UPG_HIDES] = 0
    set gold_price[UPG_HIDES] = 0
    set wood_price[UPG_HIDES] = 0
	set hero_rush_bonus[UPG_HIDES] = 0
	
    set old_id[UPG_DRUID_TALON] = oUPG_DRUID_TALON
    set buy_type[UPG_DRUID_TALON] = BT_ML_UPGRADE
    set needed1[UPG_DRUID_TALON] = ANCIENT_WIND
    set needed2[UPG_DRUID_TALON] = TREE_ETERNITY
    set needed3[UPG_DRUID_TALON] = 0
    set tc_add1[UPG_DRUID_TALON] = 0
    set tc_add2[UPG_DRUID_TALON] = 0
    set available_time[UPG_DRUID_TALON] = 0
    set regenerate_time[UPG_DRUID_TALON] = 0
    set gold_price[UPG_DRUID_TALON] = 0
    set wood_price[UPG_DRUID_TALON] = 0
	set hero_rush_bonus[UPG_DRUID_TALON] = 0
	
    set old_id[UPG_DRUID_CLAW] = oUPG_DRUID_CLAW
    set buy_type[UPG_DRUID_CLAW] = BT_ML_UPGRADE
    set needed1[UPG_DRUID_CLAW] = ANCIENT_LORE
    set needed2[UPG_DRUID_CLAW] = TREE_ETERNITY
    set needed3[UPG_DRUID_CLAW] = 0
    set tc_add1[UPG_DRUID_CLAW] = 0
    set tc_add2[UPG_DRUID_CLAW] = 0
    set available_time[UPG_DRUID_CLAW] = 0
    set regenerate_time[UPG_DRUID_CLAW] = 0
    set gold_price[UPG_DRUID_CLAW] = 0
    set wood_price[UPG_DRUID_CLAW] = 0
	set hero_rush_bonus[UPG_DRUID_CLAW] = 0
	
    set old_id[NAGA_SORCERESS] = oNAGA_SORCERESS
    set buy_type[NAGA_SORCERESS] = BT_NEUTRAL_HERO
    set needed1[NAGA_SORCERESS] = racial_altar
    set needed2[NAGA_SORCERESS] = racial_hall[2]
    set needed3[NAGA_SORCERESS] = racial_hall[3]
    set tc_add1[NAGA_SORCERESS] = 0
    set tc_add2[NAGA_SORCERESS] = 0
    set available_time[NAGA_SORCERESS] = 25
    set regenerate_time[NAGA_SORCERESS] = 6
    set gold_price[NAGA_SORCERESS] = 0
    set wood_price[NAGA_SORCERESS] = 0
	set hero_rush_bonus[NAGA_SORCERESS] = 0
	
    set old_id[BEAST_MASTER] = oBEAST_MASTER
    set buy_type[BEAST_MASTER] = BT_NEUTRAL_HERO
    set needed1[BEAST_MASTER] = racial_altar
    set needed2[BEAST_MASTER] = racial_hall[2]
    set needed3[BEAST_MASTER] = racial_hall[3]
    set tc_add1[BEAST_MASTER] = 0
    set tc_add2[BEAST_MASTER] = 0
    set available_time[BEAST_MASTER] = 25
    set regenerate_time[BEAST_MASTER] = 6
    set gold_price[BEAST_MASTER] = 0
    set wood_price[BEAST_MASTER] = 0
	set hero_rush_bonus[BEAST_MASTER] = 0
	
    set old_id[DARK_RANGER] = oDARK_RANGER
    set buy_type[DARK_RANGER] = BT_NEUTRAL_HERO
    set needed1[DARK_RANGER] = racial_altar
    set needed2[DARK_RANGER] = racial_hall[2]
    set needed3[DARK_RANGER] = racial_hall[3]
    set tc_add1[DARK_RANGER] = 0
    set tc_add2[DARK_RANGER] = 0
    set available_time[DARK_RANGER] = 25
    set regenerate_time[DARK_RANGER] = 6
    set gold_price[DARK_RANGER] = 0
    set wood_price[DARK_RANGER] = 0
	set hero_rush_bonus[DARK_RANGER] = 0
	
    set old_id[NEUTRAL_PIT_LORD] = oNEUTRAL_PIT_LORD
    set buy_type[NEUTRAL_PIT_LORD] = BT_NEUTRAL_HERO
    set needed1[NEUTRAL_PIT_LORD] = racial_altar
    set needed2[NEUTRAL_PIT_LORD] = racial_hall[2]
    set needed3[NEUTRAL_PIT_LORD] = racial_hall[3]
    set tc_add1[NEUTRAL_PIT_LORD] = 0
    set tc_add2[NEUTRAL_PIT_LORD] = 0
    set available_time[NEUTRAL_PIT_LORD] = 25
    set regenerate_time[NEUTRAL_PIT_LORD] = 6
    set gold_price[NEUTRAL_PIT_LORD] = 0
    set wood_price[NEUTRAL_PIT_LORD] = 0
	set hero_rush_bonus[NEUTRAL_PIT_LORD] = 0
	
    set old_id[BREW_MASTER] = oBREW_MASTER
    set buy_type[BREW_MASTER] = BT_NEUTRAL_HERO
    set needed1[BREW_MASTER] = racial_altar
    set needed2[BREW_MASTER] = racial_hall[2]
    set needed3[BREW_MASTER] = racial_hall[3]
    set tc_add1[BREW_MASTER] = 0
    set tc_add2[BREW_MASTER] = 0
    set available_time[BREW_MASTER] = 25
    set regenerate_time[BREW_MASTER] = 6
    set gold_price[BREW_MASTER] = 0
    set wood_price[BREW_MASTER] = 0
	set hero_rush_bonus[BREW_MASTER] = 0
	
    set old_id[GOBLIN_TINKER] = oGOBLIN_TINKER
    set buy_type[GOBLIN_TINKER] = BT_NEUTRAL_HERO
    set needed1[GOBLIN_TINKER] = racial_altar
    set needed2[GOBLIN_TINKER] = racial_hall[2]
    set needed3[GOBLIN_TINKER] = racial_hall[3]
    set tc_add1[GOBLIN_TINKER] = 0
    set tc_add2[GOBLIN_TINKER] = 0
    set available_time[GOBLIN_TINKER] = 25
    set regenerate_time[GOBLIN_TINKER] = 6
    set gold_price[GOBLIN_TINKER] = 0
    set wood_price[GOBLIN_TINKER] = 0
	set hero_rush_bonus[GOBLIN_TINKER] = 0
	
    set old_id[GOBLIN_TINKER_M] = oGOBLIN_TINKER_M
    set buy_type[GOBLIN_TINKER_M] = BT_NEUTRAL_HERO
    set needed1[GOBLIN_TINKER_M] = racial_altar
    set needed2[GOBLIN_TINKER_M] = racial_hall[2]
    set needed3[GOBLIN_TINKER_M] = racial_hall[3]
    set tc_add1[GOBLIN_TINKER_M] = 0
    set tc_add2[GOBLIN_TINKER_M] = 0
    set available_time[GOBLIN_TINKER_M] = 25
    set regenerate_time[GOBLIN_TINKER_M] = 6
    set gold_price[GOBLIN_TINKER_M] = 0
    set wood_price[GOBLIN_TINKER_M] = 0
	set hero_rush_bonus[GOBLIN_TINKER_M] = 0
	
    set old_id[FIRELORD] = oFIRELORD
    set buy_type[FIRELORD] = BT_NEUTRAL_HERO
    set needed1[FIRELORD] = racial_altar
    set needed2[FIRELORD] = racial_hall[2]
    set needed3[FIRELORD] = racial_hall[3]
    set tc_add1[FIRELORD] = 0
    set tc_add2[FIRELORD] = 0
    set available_time[FIRELORD] = 25
    set regenerate_time[FIRELORD] = 6
    set gold_price[FIRELORD] = 0
    set wood_price[FIRELORD] = 0
	set hero_rush_bonus[FIRELORD] = 0
	
    set old_id[ALCHEMIST] = oALCHEMIST
    set buy_type[ALCHEMIST] = BT_NEUTRAL_HERO
    set needed1[ALCHEMIST] = racial_altar
    set needed2[ALCHEMIST] = racial_hall[2]
    set needed3[ALCHEMIST] = racial_hall[3]
    set tc_add1[ALCHEMIST] = 0
    set tc_add2[ALCHEMIST] = 0
    set available_time[ALCHEMIST] = 25
    set regenerate_time[ALCHEMIST] = 6
    set gold_price[ALCHEMIST] = 0
    set wood_price[ALCHEMIST] = 0
	set hero_rush_bonus[ALCHEMIST] = 0
	
    set old_id[ALCHEMIST_M1] = oALCHEMIST_M1
    set buy_type[ALCHEMIST_M1] = BT_NEUTRAL_HERO
    set needed1[ALCHEMIST_M1] = racial_altar
    set needed2[ALCHEMIST_M1] = racial_hall[2]
    set needed3[ALCHEMIST_M1] = racial_hall[3]
    set tc_add1[ALCHEMIST_M1] = 0
    set tc_add2[ALCHEMIST_M1] = 0
    set available_time[ALCHEMIST_M1] = 25
    set regenerate_time[ALCHEMIST_M1] = 6
    set gold_price[ALCHEMIST_M1] = 0
    set wood_price[ALCHEMIST_M1] = 0
	set hero_rush_bonus[ALCHEMIST_M1] = 0
	
    set old_id[ALCHEMIST_M2] = oALCHEMIST_M2
    set buy_type[ALCHEMIST_M2] = BT_NEUTRAL_HERO
    set needed1[ALCHEMIST_M2] = racial_altar
    set needed2[ALCHEMIST_M2] = racial_hall[2]
    set needed3[ALCHEMIST_M2] = racial_hall[3]
    set tc_add1[ALCHEMIST_M2] = 0
    set tc_add2[ALCHEMIST_M2] = 0
    set available_time[ALCHEMIST_M2] = 25
    set regenerate_time[ALCHEMIST_M2] = 6
    set gold_price[ALCHEMIST_M2] = 0
    set wood_price[ALCHEMIST_M2] = 0
	set hero_rush_bonus[ALCHEMIST_M2] = 0
	
    set old_id[ALCHEMIST_M3] = oALCHEMIST_M3
    set buy_type[ALCHEMIST_M3] = BT_NEUTRAL_HERO
    set needed1[ALCHEMIST_M3] = racial_altar
    set needed2[ALCHEMIST_M3] = racial_hall[2]
    set needed3[ALCHEMIST_M3] = racial_hall[3]
    set tc_add1[ALCHEMIST_M3] = 0
    set tc_add2[ALCHEMIST_M3] = 0
    set available_time[ALCHEMIST_M3] = 25
    set regenerate_time[ALCHEMIST_M3] = 6
    set gold_price[ALCHEMIST_M3] = 0
    set wood_price[ALCHEMIST_M3] = 0
	set hero_rush_bonus[ALCHEMIST_M3] = 0
	
    set old_id[LAVASPAWN] = oLAVASPAWN
    set buy_type[LAVASPAWN] = BT_UNIT
    set needed1[LAVASPAWN] = FIRELORD
    set needed2[LAVASPAWN] = 0
    set needed3[LAVASPAWN] = 0
    set tc_add1[LAVASPAWN] = 0
    set tc_add2[LAVASPAWN] = 0
    set available_time[LAVASPAWN] = 0
    set regenerate_time[LAVASPAWN] = 0
    set gold_price[LAVASPAWN] = 0
    set wood_price[LAVASPAWN] = 0
	set hero_rush_bonus[LAVASPAWN] = 0
	
    set old_id[LAVASPAWN2] = oLAVASPAWN2
    set buy_type[LAVASPAWN2] = BT_UNIT
    set needed1[LAVASPAWN2] = FIRELORD
    set needed2[LAVASPAWN2] = 0
    set needed3[LAVASPAWN2] = 0
    set tc_add1[LAVASPAWN2] = 0
    set tc_add2[LAVASPAWN2] = 0
    set available_time[LAVASPAWN2] = 0
    set regenerate_time[LAVASPAWN2] = 0
    set gold_price[LAVASPAWN2] = 0
    set wood_price[LAVASPAWN2] = 0
	set hero_rush_bonus[LAVASPAWN2] = 0
	
    set old_id[LAVASPAWN3] = oLAVASPAWN3
    set buy_type[LAVASPAWN3] = BT_UNIT
    set needed1[LAVASPAWN3] = FIRELORD
    set needed2[LAVASPAWN3] = 0
    set needed3[LAVASPAWN3] = 0
    set tc_add1[LAVASPAWN3] = 0
    set tc_add2[LAVASPAWN3] = 0
    set available_time[LAVASPAWN3] = 0
    set regenerate_time[LAVASPAWN3] = 0
    set gold_price[LAVASPAWN3] = 0
    set wood_price[LAVASPAWN3] = 0
	set hero_rush_bonus[LAVASPAWN3] = 0
	
    set old_id[OGRE_MAGI] = oOGRE_MAGI
    set buy_type[OGRE_MAGI] = BT_MERC
    set needed1[OGRE_MAGI] = 0
    set needed2[OGRE_MAGI] = 0
    set needed3[OGRE_MAGI] = 0
    set tc_add1[OGRE_MAGI] = 0
    set tc_add2[OGRE_MAGI] = 0
    set available_time[OGRE_MAGI] = 88
    set regenerate_time[OGRE_MAGI] = 42
    set gold_price[OGRE_MAGI] = 0
    set wood_price[OGRE_MAGI] = 0
	set hero_rush_bonus[OGRE_MAGI] = 0
	
    set old_id[SATYR_SHADOWDANCER] = oSATYR_SHADOWDANCER
    set buy_type[SATYR_SHADOWDANCER] = BT_MERC
    set needed1[SATYR_SHADOWDANCER] = 0
    set needed2[SATYR_SHADOWDANCER] = 0
    set needed3[SATYR_SHADOWDANCER] = 0
    set tc_add1[SATYR_SHADOWDANCER] = 0
    set tc_add2[SATYR_SHADOWDANCER] = 0
    set available_time[SATYR_SHADOWDANCER] = 66
    set regenerate_time[SATYR_SHADOWDANCER] = 32
    set gold_price[SATYR_SHADOWDANCER] = 0
    set wood_price[SATYR_SHADOWDANCER] = 0
	set hero_rush_bonus[SATYR_SHADOWDANCER] = 0
	
    set old_id[FURBOLG_SHAMAN] = oFURBOLG_SHAMAN
    set buy_type[FURBOLG_SHAMAN] = BT_MERC
    set needed1[FURBOLG_SHAMAN] = 0
    set needed2[FURBOLG_SHAMAN] = 0
    set needed3[FURBOLG_SHAMAN] = 0
    set tc_add1[FURBOLG_SHAMAN] = 0
    set tc_add2[FURBOLG_SHAMAN] = 0
    set available_time[FURBOLG_SHAMAN] = 72
    set regenerate_time[FURBOLG_SHAMAN] = 32
    set gold_price[FURBOLG_SHAMAN] = 0
    set wood_price[FURBOLG_SHAMAN] = 0
	set hero_rush_bonus[FURBOLG_SHAMAN] = 0
	
    set old_id[THUNDER_LIZARD] = oTHUNDER_LIZARD
    set buy_type[THUNDER_LIZARD] = BT_MERC
    set needed1[THUNDER_LIZARD] = 0
    set needed2[THUNDER_LIZARD] = 0
    set needed3[THUNDER_LIZARD] = 0
    set tc_add1[THUNDER_LIZARD] = 0
    set tc_add2[THUNDER_LIZARD] = 0
    set available_time[THUNDER_LIZARD] = 88
    set regenerate_time[THUNDER_LIZARD] = 52
    set gold_price[THUNDER_LIZARD] = 0
    set wood_price[THUNDER_LIZARD] = 0
	set hero_rush_bonus[THUNDER_LIZARD] = 0
	
    set old_id[CENTAUR_OUTRUNNER] = oCENTAUR_OUTRUNNER
    set buy_type[CENTAUR_OUTRUNNER] = BT_MERC
    set needed1[CENTAUR_OUTRUNNER] = 0
    set needed2[CENTAUR_OUTRUNNER] = 0
    set needed3[CENTAUR_OUTRUNNER] = 0
    set tc_add1[CENTAUR_OUTRUNNER] = 0
    set tc_add2[CENTAUR_OUTRUNNER] = 0
    set available_time[CENTAUR_OUTRUNNER] = 12
    set regenerate_time[CENTAUR_OUTRUNNER] = 22
    set gold_price[CENTAUR_OUTRUNNER] = 0
    set wood_price[CENTAUR_OUTRUNNER] = 0
	set hero_rush_bonus[CENTAUR_OUTRUNNER] = 0
	
    set old_id[HARPY_ROGUE] = oHARPY_ROGUE
    set buy_type[HARPY_ROGUE] = BT_MERC
    set needed1[HARPY_ROGUE] = 0
    set needed2[HARPY_ROGUE] = 0
    set needed3[HARPY_ROGUE] = 0
    set tc_add1[HARPY_ROGUE] = 0
    set tc_add2[HARPY_ROGUE] = 0
    set available_time[HARPY_ROGUE] = 72
    set regenerate_time[HARPY_ROGUE] = 22
    set gold_price[HARPY_ROGUE] = 0
    set wood_price[HARPY_ROGUE] = 0
	set hero_rush_bonus[HARPY_ROGUE] = 0
	
    set old_id[RAZORMANE_MEDICINE_MAN] = oRAZORMANE_MEDICINE_MAN
    set buy_type[RAZORMANE_MEDICINE_MAN] = BT_MERC
    set needed1[RAZORMANE_MEDICINE_MAN] = 0
    set needed2[RAZORMANE_MEDICINE_MAN] = 0
    set needed3[RAZORMANE_MEDICINE_MAN] = 0
    set tc_add1[RAZORMANE_MEDICINE_MAN] = 0
    set tc_add2[RAZORMANE_MEDICINE_MAN] = 0
    set available_time[RAZORMANE_MEDICINE_MAN] = 88
    set regenerate_time[RAZORMANE_MEDICINE_MAN] = 42
    set gold_price[RAZORMANE_MEDICINE_MAN] = 0
    set wood_price[RAZORMANE_MEDICINE_MAN] = 0
	set hero_rush_bonus[RAZORMANE_MEDICINE_MAN] = 0
	
    set old_id[HARPY_WINDWITCH] = oHARPY_WINDWITCH
    set buy_type[HARPY_WINDWITCH] = BT_MERC
    set needed1[HARPY_WINDWITCH] = 0
    set needed2[HARPY_WINDWITCH] = 0
    set needed3[HARPY_WINDWITCH] = 0
    set tc_add1[HARPY_WINDWITCH] = 0
    set tc_add2[HARPY_WINDWITCH] = 0
    set available_time[HARPY_WINDWITCH] = 132
    set regenerate_time[HARPY_WINDWITCH] = 32
    set gold_price[HARPY_WINDWITCH] = 0
    set wood_price[HARPY_WINDWITCH] = 0
	set hero_rush_bonus[HARPY_WINDWITCH] = 0
	
    set old_id[FEL_BEAST] = oFEL_BEAST
    set buy_type[FEL_BEAST] = BT_MERC
    set needed1[FEL_BEAST] = 0
    set needed2[FEL_BEAST] = 0
    set needed3[FEL_BEAST] = 0
    set tc_add1[FEL_BEAST] = 0
    set tc_add2[FEL_BEAST] = 0
    set available_time[FEL_BEAST] = 12
    set regenerate_time[FEL_BEAST] = 22
    set gold_price[FEL_BEAST] = 0
    set wood_price[FEL_BEAST] = 0
	set hero_rush_bonus[FEL_BEAST] = 0
	
    set old_id[DRAENEI_DISCIPLE] = oDRAENEI_DISCIPLE
    set buy_type[DRAENEI_DISCIPLE] = BT_MERC
    set needed1[DRAENEI_DISCIPLE] = 0
    set needed2[DRAENEI_DISCIPLE] = 0
    set needed3[DRAENEI_DISCIPLE] = 0
    set tc_add1[DRAENEI_DISCIPLE] = 0
    set tc_add2[DRAENEI_DISCIPLE] = 0
    set available_time[DRAENEI_DISCIPLE] = 27
    set regenerate_time[DRAENEI_DISCIPLE] = 22
    set gold_price[DRAENEI_DISCIPLE] = 0
    set wood_price[DRAENEI_DISCIPLE] = 0
	set hero_rush_bonus[DRAENEI_DISCIPLE] = 0
	
    set old_id[VOIDWALKER] = oVOIDWALKER
    set buy_type[VOIDWALKER] = BT_MERC
    set needed1[VOIDWALKER] = 0
    set needed2[VOIDWALKER] = 0
    set needed3[VOIDWALKER] = 0
    set tc_add1[VOIDWALKER] = 0
    set tc_add2[VOIDWALKER] = 0
    set available_time[VOIDWALKER] = 88
    set regenerate_time[VOIDWALKER] = 42
    set gold_price[VOIDWALKER] = 0
    set wood_price[VOIDWALKER] = 0
	set hero_rush_bonus[VOIDWALKER] = 0
	
    set old_id[DRAENEI_DARKSLAYER] = oDRAENEI_DARKSLAYER
    set buy_type[DRAENEI_DARKSLAYER] = BT_MERC
    set needed1[DRAENEI_DARKSLAYER] = 0
    set needed2[DRAENEI_DARKSLAYER] = 0
    set needed3[DRAENEI_DARKSLAYER] = 0
    set tc_add1[DRAENEI_DARKSLAYER] = 0
    set tc_add2[DRAENEI_DARKSLAYER] = 0
    set available_time[DRAENEI_DARKSLAYER] = 66
    set regenerate_time[DRAENEI_DARKSLAYER] = 42
    set gold_price[DRAENEI_DARKSLAYER] = 0
    set wood_price[DRAENEI_DARKSLAYER] = 0
	set hero_rush_bonus[DRAENEI_DARKSLAYER] = 0
	
    set old_id[ROGUE] = oROGUE
    set buy_type[ROGUE] = BT_MERC
    set needed1[ROGUE] = 0
    set needed2[ROGUE] = 0
    set needed3[ROGUE] = 0
    set tc_add1[ROGUE] = 0
    set tc_add2[ROGUE] = 0
    set available_time[ROGUE] = 88
    set regenerate_time[ROGUE] = 22
    set gold_price[ROGUE] = 0
    set wood_price[ROGUE] = 0
	set hero_rush_bonus[ROGUE] = 0
	
    set old_id[ASSASSIN] = oASSASSIN
    set buy_type[ASSASSIN] = BT_MERC
    set needed1[ASSASSIN] = 0
    set needed2[ASSASSIN] = 0
    set needed3[ASSASSIN] = 0
    set tc_add1[ASSASSIN] = 0
    set tc_add2[ASSASSIN] = 0
    set available_time[ASSASSIN] = 88
    set regenerate_time[ASSASSIN] = 32
    set gold_price[ASSASSIN] = 0
    set wood_price[ASSASSIN] = 0
	set hero_rush_bonus[ASSASSIN] = 0
	
    set old_id[KOBOLD_GEOMANCER] = oKOBOLD_GEOMANCER
    set buy_type[KOBOLD_GEOMANCER] = BT_MERC
    set needed1[KOBOLD_GEOMANCER] = 0
    set needed2[KOBOLD_GEOMANCER] = 0
    set needed3[KOBOLD_GEOMANCER] = 0
    set tc_add1[KOBOLD_GEOMANCER] = 0
    set tc_add2[KOBOLD_GEOMANCER] = 0
    set available_time[KOBOLD_GEOMANCER] = 88
    set regenerate_time[KOBOLD_GEOMANCER] = 32
    set gold_price[KOBOLD_GEOMANCER] = 0
    set wood_price[KOBOLD_GEOMANCER] = 0
	set hero_rush_bonus[KOBOLD_GEOMANCER] = 0
	
    set old_id[FOREST_TROLL_HIGH_PRIEST] = oFOREST_TROLL_HIGH_PRIEST
    set buy_type[FOREST_TROLL_HIGH_PRIEST] = BT_MERC
    set needed1[FOREST_TROLL_HIGH_PRIEST] = 0
    set needed2[FOREST_TROLL_HIGH_PRIEST] = 0
    set needed3[FOREST_TROLL_HIGH_PRIEST] = 0
    set tc_add1[FOREST_TROLL_HIGH_PRIEST] = 0
    set tc_add2[FOREST_TROLL_HIGH_PRIEST] = 0
    set available_time[FOREST_TROLL_HIGH_PRIEST] = 88
    set regenerate_time[FOREST_TROLL_HIGH_PRIEST] = 42
    set gold_price[FOREST_TROLL_HIGH_PRIEST] = 0
    set wood_price[FOREST_TROLL_HIGH_PRIEST] = 0
	set hero_rush_bonus[FOREST_TROLL_HIGH_PRIEST] = 0
	
    set old_id[BURNING_ARCHER] = oBURNING_ARCHER
    set buy_type[BURNING_ARCHER] = BT_MERC
    set needed1[BURNING_ARCHER] = 0
    set needed2[BURNING_ARCHER] = 0
    set needed3[BURNING_ARCHER] = 0
    set tc_add1[BURNING_ARCHER] = 0
    set tc_add2[BURNING_ARCHER] = 0
    set available_time[BURNING_ARCHER] = 12
    set regenerate_time[BURNING_ARCHER] = 22
    set gold_price[BURNING_ARCHER] = 0
    set wood_price[BURNING_ARCHER] = 0
	set hero_rush_bonus[BURNING_ARCHER] = 0
	
    set old_id[WILDKIN] = oWILDKIN
    set buy_type[WILDKIN] = BT_MERC
    set needed1[WILDKIN] = 0
    set needed2[WILDKIN] = 0
    set needed3[WILDKIN] = 0
    set tc_add1[WILDKIN] = 0
    set tc_add2[WILDKIN] = 0
    set available_time[WILDKIN] = 44
    set regenerate_time[WILDKIN] = 32
    set gold_price[WILDKIN] = 0
    set wood_price[WILDKIN] = 0
	set hero_rush_bonus[WILDKIN] = 0
	
    set old_id[MURLOC_FLESHEATER] = oMURLOC_FLESHEATER
    set buy_type[MURLOC_FLESHEATER] = BT_MERC
    set needed1[MURLOC_FLESHEATER] = 0
    set needed2[MURLOC_FLESHEATER] = 0
    set needed3[MURLOC_FLESHEATER] = 0
    set tc_add1[MURLOC_FLESHEATER] = 0
    set tc_add2[MURLOC_FLESHEATER] = 0
    set available_time[MURLOC_FLESHEATER] = 12
    set regenerate_time[MURLOC_FLESHEATER] = 22
    set gold_price[MURLOC_FLESHEATER] = 0
    set wood_price[MURLOC_FLESHEATER] = 0
	set hero_rush_bonus[MURLOC_FLESHEATER] = 0
	
    set old_id[SLUDGE_FLINGER] = oSLUDGE_FLINGER
    set buy_type[SLUDGE_FLINGER] = BT_MERC
    set needed1[SLUDGE_FLINGER] = 0
    set needed2[SLUDGE_FLINGER] = 0
    set needed3[SLUDGE_FLINGER] = 0
    set tc_add1[SLUDGE_FLINGER] = 0
    set tc_add2[SLUDGE_FLINGER] = 0
    set available_time[SLUDGE_FLINGER] = 66
    set regenerate_time[SLUDGE_FLINGER] = 32
    set gold_price[SLUDGE_FLINGER] = 0
    set wood_price[SLUDGE_FLINGER] = 0
	set hero_rush_bonus[SLUDGE_FLINGER] = 0
	
    set old_id[SATYR_SOULSTEALER] = oSATYR_SOULSTEALER
    set buy_type[SATYR_SOULSTEALER] = BT_MERC
    set needed1[SATYR_SOULSTEALER] = 0
    set needed2[SATYR_SOULSTEALER] = 0
    set needed3[SATYR_SOULSTEALER] = 0
    set tc_add1[SATYR_SOULSTEALER] = 0
    set tc_add2[SATYR_SOULSTEALER] = 0
    set available_time[SATYR_SOULSTEALER] = 88
    set regenerate_time[SATYR_SOULSTEALER] = 42
    set gold_price[SATYR_SOULSTEALER] = 0
    set wood_price[SATYR_SOULSTEALER] = 0
	set hero_rush_bonus[SATYR_SOULSTEALER] = 0
	
    set old_id[BARBED_ARACHNATHID] = oBARBED_ARACHNATHID
    set buy_type[BARBED_ARACHNATHID] = BT_MERC
    set needed1[BARBED_ARACHNATHID] = 0
    set needed2[BARBED_ARACHNATHID] = 0
    set needed3[BARBED_ARACHNATHID] = 0
    set tc_add1[BARBED_ARACHNATHID] = 0
    set tc_add2[BARBED_ARACHNATHID] = 0
    set available_time[BARBED_ARACHNATHID] = 88
    set regenerate_time[BARBED_ARACHNATHID] = 12
    set gold_price[BARBED_ARACHNATHID] = 0
    set wood_price[BARBED_ARACHNATHID] = 0
	set hero_rush_bonus[BARBED_ARACHNATHID] = 0
	
    set old_id[BLUE_DRAGONSPAWN_MEDDLER] = oBLUE_DRAGONSPAWN_MEDDLER
    set buy_type[BLUE_DRAGONSPAWN_MEDDLER] = BT_MERC
    set needed1[BLUE_DRAGONSPAWN_MEDDLER] = 0
    set needed2[BLUE_DRAGONSPAWN_MEDDLER] = 0
    set needed3[BLUE_DRAGONSPAWN_MEDDLER] = 0
    set tc_add1[BLUE_DRAGONSPAWN_MEDDLER] = 0
    set tc_add2[BLUE_DRAGONSPAWN_MEDDLER] = 0
    set available_time[BLUE_DRAGONSPAWN_MEDDLER] = 44
    set regenerate_time[BLUE_DRAGONSPAWN_MEDDLER] = 22
    set gold_price[BLUE_DRAGONSPAWN_MEDDLER] = 0
    set wood_price[BLUE_DRAGONSPAWN_MEDDLER] = 0
	set hero_rush_bonus[BLUE_DRAGONSPAWN_MEDDLER] = 0
	
    set old_id[MAGNATAUR_WARRIOR] = oMAGNATAUR_WARRIOR
    set buy_type[MAGNATAUR_WARRIOR] = BT_MERC
    set needed1[MAGNATAUR_WARRIOR] = 0
    set needed2[MAGNATAUR_WARRIOR] = 0
    set needed3[MAGNATAUR_WARRIOR] = 0
    set tc_add1[MAGNATAUR_WARRIOR] = 0
    set tc_add2[MAGNATAUR_WARRIOR] = 0
    set available_time[MAGNATAUR_WARRIOR] = 88
    set regenerate_time[MAGNATAUR_WARRIOR] = 42
    set gold_price[MAGNATAUR_WARRIOR] = 0
    set wood_price[MAGNATAUR_WARRIOR] = 0
	set hero_rush_bonus[MAGNATAUR_WARRIOR] = 0
	
    set old_id[POLAR_FURBOLG_SHAMAN] = oPOLAR_FURBOLG_SHAMAN
    set buy_type[POLAR_FURBOLG_SHAMAN] = BT_MERC
    set needed1[POLAR_FURBOLG_SHAMAN] = 0
    set needed2[POLAR_FURBOLG_SHAMAN] = 0
    set needed3[POLAR_FURBOLG_SHAMAN] = 0
    set tc_add1[POLAR_FURBOLG_SHAMAN] = 0
    set tc_add2[POLAR_FURBOLG_SHAMAN] = 0
    set available_time[POLAR_FURBOLG_SHAMAN] = 66
    set regenerate_time[POLAR_FURBOLG_SHAMAN] = 32
    set gold_price[POLAR_FURBOLG_SHAMAN] = 0
    set wood_price[POLAR_FURBOLG_SHAMAN] = 0
	set hero_rush_bonus[POLAR_FURBOLG_SHAMAN] = 0
	
    set old_id[GNOLL_BRUTE] = oGNOLL_BRUTE
    set buy_type[GNOLL_BRUTE] = BT_MERC
    set needed1[GNOLL_BRUTE] = 0
    set needed2[GNOLL_BRUTE] = 0
    set needed3[GNOLL_BRUTE] = 0
    set tc_add1[GNOLL_BRUTE] = 0
    set tc_add2[GNOLL_BRUTE] = 0
    set available_time[GNOLL_BRUTE] = 12
    set regenerate_time[GNOLL_BRUTE] = 22
    set gold_price[GNOLL_BRUTE] = 0
    set wood_price[GNOLL_BRUTE] = 0
	set hero_rush_bonus[GNOLL_BRUTE] = 0
	
    set old_id[GNOLL_WARDEN] = oGNOLL_WARDEN
    set buy_type[GNOLL_WARDEN] = BT_MERC
    set needed1[GNOLL_WARDEN] = 0
    set needed2[GNOLL_WARDEN] = 0
    set needed3[GNOLL_WARDEN] = 0
    set tc_add1[GNOLL_WARDEN] = 0
    set tc_add2[GNOLL_WARDEN] = 0
    set available_time[GNOLL_WARDEN] = 36
    set regenerate_time[GNOLL_WARDEN] = 22
    set gold_price[GNOLL_WARDEN] = 0
    set wood_price[GNOLL_WARDEN] = 0
	set hero_rush_bonus[GNOLL_WARDEN] = 0
	
    set old_id[MUD_GOLEM] = oMUD_GOLEM
    set buy_type[MUD_GOLEM] = BT_MERC
    set needed1[MUD_GOLEM] = 0
    set needed2[MUD_GOLEM] = 0
    set needed3[MUD_GOLEM] = 0
    set tc_add1[MUD_GOLEM] = 0
    set tc_add2[MUD_GOLEM] = 0
    set available_time[MUD_GOLEM] = 88
    set regenerate_time[MUD_GOLEM] = 22
    set gold_price[MUD_GOLEM] = 0
    set wood_price[MUD_GOLEM] = 0
	set hero_rush_bonus[MUD_GOLEM] = 0
	
    set old_id[FOREST_TROLL_BERSERKER] = oFOREST_TROLL_BERSERKER
    set buy_type[FOREST_TROLL_BERSERKER] = BT_MERC
    set needed1[FOREST_TROLL_BERSERKER] = 0
    set needed2[FOREST_TROLL_BERSERKER] = 0
    set needed3[FOREST_TROLL_BERSERKER] = 0
    set tc_add1[FOREST_TROLL_BERSERKER] = 0
    set tc_add2[FOREST_TROLL_BERSERKER] = 0
    set available_time[FOREST_TROLL_BERSERKER] = 44
    set regenerate_time[FOREST_TROLL_BERSERKER] = 42
    set gold_price[FOREST_TROLL_BERSERKER] = 0
    set wood_price[FOREST_TROLL_BERSERKER] = 0
	set hero_rush_bonus[FOREST_TROLL_BERSERKER] = 0
	
    set old_id[FOREST_TROLL_SHADOW_PRIEST] = oFOREST_TROLL_SHADOW_PRIEST
    set buy_type[FOREST_TROLL_SHADOW_PRIEST] = BT_MERC
    set needed1[FOREST_TROLL_SHADOW_PRIEST] = 0
    set needed2[FOREST_TROLL_SHADOW_PRIEST] = 0
    set needed3[FOREST_TROLL_SHADOW_PRIEST] = 0
    set tc_add1[FOREST_TROLL_SHADOW_PRIEST] = 0
    set tc_add2[FOREST_TROLL_SHADOW_PRIEST] = 0
    set available_time[FOREST_TROLL_SHADOW_PRIEST] = 24
    set regenerate_time[FOREST_TROLL_SHADOW_PRIEST] = 22
    set gold_price[FOREST_TROLL_SHADOW_PRIEST] = 0
    set wood_price[FOREST_TROLL_SHADOW_PRIEST] = 0
	set hero_rush_bonus[FOREST_TROLL_SHADOW_PRIEST] = 0
	
    set old_id[OGRE_MAULER] = oOGRE_MAULER
    set buy_type[OGRE_MAULER] = BT_MERC
    set needed1[OGRE_MAULER] = 0
    set needed2[OGRE_MAULER] = 0
    set needed3[OGRE_MAULER] = 0
    set tc_add1[OGRE_MAULER] = 0
    set tc_add2[OGRE_MAULER] = 0
    set available_time[OGRE_MAULER] = 88
    set regenerate_time[OGRE_MAULER] = 32
    set gold_price[OGRE_MAULER] = 0
    set wood_price[OGRE_MAULER] = 0
	set hero_rush_bonus[OGRE_MAULER] = 0
	
    set old_id[GNOLL_OVERSEER] = oGNOLL_OVERSEER
    set buy_type[GNOLL_OVERSEER] = BT_MERC
    set needed1[GNOLL_OVERSEER] = 0
    set needed2[GNOLL_OVERSEER] = 0
    set needed3[GNOLL_OVERSEER] = 0
    set tc_add1[GNOLL_OVERSEER] = 0
    set tc_add2[GNOLL_OVERSEER] = 0
    set available_time[GNOLL_OVERSEER] = 88
    set regenerate_time[GNOLL_OVERSEER] = 42
    set gold_price[GNOLL_OVERSEER] = 0
    set wood_price[GNOLL_OVERSEER] = 0
	set hero_rush_bonus[GNOLL_OVERSEER] = 0
	
    set old_id[ICE_TROLL_BERSERKER] = oICE_TROLL_BERSERKER
    set buy_type[ICE_TROLL_BERSERKER] = BT_MERC
    set needed1[ICE_TROLL_BERSERKER] = 0
    set needed2[ICE_TROLL_BERSERKER] = 0
    set needed3[ICE_TROLL_BERSERKER] = 0
    set tc_add1[ICE_TROLL_BERSERKER] = 0
    set tc_add2[ICE_TROLL_BERSERKER] = 0
    set available_time[ICE_TROLL_BERSERKER] = 88
    set regenerate_time[ICE_TROLL_BERSERKER] = 32
    set gold_price[ICE_TROLL_BERSERKER] = 0
    set wood_price[ICE_TROLL_BERSERKER] = 0
	set hero_rush_bonus[ICE_TROLL_BERSERKER] = 0
	
    set old_id[ICE_TROLL_TRAPPER] = oICE_TROLL_TRAPPER
    set buy_type[ICE_TROLL_TRAPPER] = BT_MERC
    set needed1[ICE_TROLL_TRAPPER] = 0
    set needed2[ICE_TROLL_TRAPPER] = 0
    set needed3[ICE_TROLL_TRAPPER] = 0
    set tc_add1[ICE_TROLL_TRAPPER] = 0
    set tc_add2[ICE_TROLL_TRAPPER] = 0
    set available_time[ICE_TROLL_TRAPPER] = 88
    set regenerate_time[ICE_TROLL_TRAPPER] = 22
    set gold_price[ICE_TROLL_TRAPPER] = 0
    set wood_price[ICE_TROLL_TRAPPER] = 0
	set hero_rush_bonus[ICE_TROLL_TRAPPER] = 0
	
    set old_id[NERUBIAN_WARRIOR] = oNERUBIAN_WARRIOR
    set buy_type[NERUBIAN_WARRIOR] = BT_MERC
    set needed1[NERUBIAN_WARRIOR] = 0
    set needed2[NERUBIAN_WARRIOR] = 0
    set needed3[NERUBIAN_WARRIOR] = 0
    set tc_add1[NERUBIAN_WARRIOR] = 0
    set tc_add2[NERUBIAN_WARRIOR] = 0
    set available_time[NERUBIAN_WARRIOR] = 12
    set regenerate_time[NERUBIAN_WARRIOR] = 22
    set gold_price[NERUBIAN_WARRIOR] = 0
    set wood_price[NERUBIAN_WARRIOR] = 0
	set hero_rush_bonus[NERUBIAN_WARRIOR] = 0
	
    set old_id[FROST_REVENANT] = oFROST_REVENANT
    set buy_type[FROST_REVENANT] = BT_MERC
    set needed1[FROST_REVENANT] = 0
    set needed2[FROST_REVENANT] = 0
    set needed3[FROST_REVENANT] = 0
    set tc_add1[FROST_REVENANT] = 0
    set tc_add2[FROST_REVENANT] = 0
    set available_time[FROST_REVENANT] = 88
    set regenerate_time[FROST_REVENANT] = 32
    set gold_price[FROST_REVENANT] = 0
    set wood_price[FROST_REVENANT] = 0
	set hero_rush_bonus[FROST_REVENANT] = 0
	
    set old_id[NERUBIAN_WEBSPINNER] = oNERUBIAN_WEBSPINNER
    set buy_type[NERUBIAN_WEBSPINNER] = BT_MERC
    set needed1[NERUBIAN_WEBSPINNER] = 0
    set needed2[NERUBIAN_WEBSPINNER] = 0
    set needed3[NERUBIAN_WEBSPINNER] = 0
    set tc_add1[NERUBIAN_WEBSPINNER] = 0
    set tc_add2[NERUBIAN_WEBSPINNER] = 0
    set available_time[NERUBIAN_WEBSPINNER] = 44
    set regenerate_time[NERUBIAN_WEBSPINNER] = 22
    set gold_price[NERUBIAN_WEBSPINNER] = 0
    set wood_price[NERUBIAN_WEBSPINNER] = 0
	set hero_rush_bonus[NERUBIAN_WEBSPINNER] = 0
	
    set old_id[MURGUL_SNARECASTER] = oMURGUL_SNARECASTER
    set buy_type[MURGUL_SNARECASTER] = BT_MERC
    set needed1[MURGUL_SNARECASTER] = 0
    set needed2[MURGUL_SNARECASTER] = 0
    set needed3[MURGUL_SNARECASTER] = 0
    set tc_add1[MURGUL_SNARECASTER] = 0
    set tc_add2[MURGUL_SNARECASTER] = 0
    set available_time[MURGUL_SNARECASTER] = 88
    set regenerate_time[MURGUL_SNARECASTER] = 32
    set gold_price[MURGUL_SNARECASTER] = 0
    set wood_price[MURGUL_SNARECASTER] = 0
	set hero_rush_bonus[MURGUL_SNARECASTER] = 0
	
    set old_id[MAKRURA_SNAPPER] = oMAKRURA_SNAPPER
    set buy_type[MAKRURA_SNAPPER] = BT_MERC
    set needed1[MAKRURA_SNAPPER] = 0
    set needed2[MAKRURA_SNAPPER] = 0
    set needed3[MAKRURA_SNAPPER] = 0
    set tc_add1[MAKRURA_SNAPPER] = 0
    set tc_add2[MAKRURA_SNAPPER] = 0
    set available_time[MAKRURA_SNAPPER] = 52
    set regenerate_time[MAKRURA_SNAPPER] = 42
    set gold_price[MAKRURA_SNAPPER] = 0
    set wood_price[MAKRURA_SNAPPER] = 0
	set hero_rush_bonus[MAKRURA_SNAPPER] = 0
	
    set old_id[MAKRURA_DEEPSEER] = oMAKRURA_DEEPSEER
    set buy_type[MAKRURA_DEEPSEER] = BT_MERC
    set needed1[MAKRURA_DEEPSEER] = 0
    set needed2[MAKRURA_DEEPSEER] = 0
    set needed3[MAKRURA_DEEPSEER] = 0
    set tc_add1[MAKRURA_DEEPSEER] = 0
    set tc_add2[MAKRURA_DEEPSEER] = 0
    set available_time[MAKRURA_DEEPSEER] = 88
    set regenerate_time[MAKRURA_DEEPSEER] = 42
    set gold_price[MAKRURA_DEEPSEER] = 0
    set wood_price[MAKRURA_DEEPSEER] = 0
	set hero_rush_bonus[MAKRURA_DEEPSEER] = 0
	
    set old_id[GIANT_SEA_TURTLE] = oGIANT_SEA_TURTLE
    set buy_type[GIANT_SEA_TURTLE] = BT_MERC
    set needed1[GIANT_SEA_TURTLE] = 0
    set needed2[GIANT_SEA_TURTLE] = 0
    set needed3[GIANT_SEA_TURTLE] = 0
    set tc_add1[GIANT_SEA_TURTLE] = 0
    set tc_add2[GIANT_SEA_TURTLE] = 0
    set available_time[GIANT_SEA_TURTLE] = 12
    set regenerate_time[GIANT_SEA_TURTLE] = 32
    set gold_price[GIANT_SEA_TURTLE] = 0
    set wood_price[GIANT_SEA_TURTLE] = 0
	set hero_rush_bonus[GIANT_SEA_TURTLE] = 0
	
    set old_id[KOBOLD] = oKOBOLD
    set buy_type[KOBOLD] = BT_MERC
    set needed1[KOBOLD] = 0
    set needed2[KOBOLD] = 0
    set needed3[KOBOLD] = 0
    set tc_add1[KOBOLD] = 0
    set tc_add2[KOBOLD] = 0
    set available_time[KOBOLD] = 12
    set regenerate_time[KOBOLD] = 12
    set gold_price[KOBOLD] = 0
    set wood_price[KOBOLD] = 0
	set hero_rush_bonus[KOBOLD] = 0
	
    set old_id[MURLOC_HUNTSMAN] = oMURLOC_HUNTSMAN
    set buy_type[MURLOC_HUNTSMAN] = BT_MERC
    set needed1[MURLOC_HUNTSMAN] = 0
    set needed2[MURLOC_HUNTSMAN] = 0
    set needed3[MURLOC_HUNTSMAN] = 0
    set tc_add1[MURLOC_HUNTSMAN] = 0
    set tc_add2[MURLOC_HUNTSMAN] = 0
    set available_time[MURLOC_HUNTSMAN] = 22
    set regenerate_time[MURLOC_HUNTSMAN] = 22
    set gold_price[MURLOC_HUNTSMAN] = 0
    set wood_price[MURLOC_HUNTSMAN] = 0
	set hero_rush_bonus[MURLOC_HUNTSMAN] = 0
	
    set old_id[BLACK_DRAGON_1] = oBLACK_DRAGON_1
    set buy_type[BLACK_DRAGON_1] = BT_DRAGON
    set needed1[BLACK_DRAGON_1] = 0
    set needed2[BLACK_DRAGON_1] = 0
    set needed3[BLACK_DRAGON_1] = 0
    set tc_add1[BLACK_DRAGON_1] = 0
    set tc_add2[BLACK_DRAGON_1] = 0
    set available_time[BLACK_DRAGON_1] = 88
    set regenerate_time[BLACK_DRAGON_1] = 26
    set gold_price[BLACK_DRAGON_1] = 0
    set wood_price[BLACK_DRAGON_1] = 0
	set hero_rush_bonus[BLACK_DRAGON_1] = 0
	
    set old_id[BLACK_DRAGON_2] = oBLACK_DRAGON_2
    set buy_type[BLACK_DRAGON_2] = BT_DRAGON
    set needed1[BLACK_DRAGON_2] = 0
    set needed2[BLACK_DRAGON_2] = 0
    set needed3[BLACK_DRAGON_2] = 0
    set tc_add1[BLACK_DRAGON_2] = 0
    set tc_add2[BLACK_DRAGON_2] = 0
    set available_time[BLACK_DRAGON_2] = 88
    set regenerate_time[BLACK_DRAGON_2] = 50
    set gold_price[BLACK_DRAGON_2] = 0
    set wood_price[BLACK_DRAGON_2] = 0
	set hero_rush_bonus[BLACK_DRAGON_2] = 0
	
    set old_id[BLACK_DRAGON_3] = oBLACK_DRAGON_3
    set buy_type[BLACK_DRAGON_3] = BT_DRAGON
    set needed1[BLACK_DRAGON_3] = 0
    set needed2[BLACK_DRAGON_3] = 0
    set needed3[BLACK_DRAGON_3] = 0
    set tc_add1[BLACK_DRAGON_3] = 0
    set tc_add2[BLACK_DRAGON_3] = 0
    set available_time[BLACK_DRAGON_3] = 184
    set regenerate_time[BLACK_DRAGON_3] = 82
    set gold_price[BLACK_DRAGON_3] = 0
    set wood_price[BLACK_DRAGON_3] = 0
	set hero_rush_bonus[BLACK_DRAGON_3] = 0
	
    set old_id[BLUE_DRAGON_1] = oBLUE_DRAGON_1
    set buy_type[BLUE_DRAGON_1] = BT_DRAGON
    set needed1[BLUE_DRAGON_1] = 0
    set needed2[BLUE_DRAGON_1] = 0
    set needed3[BLUE_DRAGON_1] = 0
    set tc_add1[BLUE_DRAGON_1] = 0
    set tc_add2[BLUE_DRAGON_1] = 0
    set available_time[BLUE_DRAGON_1] = 88
    set regenerate_time[BLUE_DRAGON_1] = 26
    set gold_price[BLUE_DRAGON_1] = 0
    set wood_price[BLUE_DRAGON_1] = 0
	set hero_rush_bonus[BLUE_DRAGON_1] = 0
	
    set old_id[BLUE_DRAGON_2] = oBLUE_DRAGON_2
    set buy_type[BLUE_DRAGON_2] = BT_DRAGON
    set needed1[BLUE_DRAGON_2] = 0
    set needed2[BLUE_DRAGON_2] = 0
    set needed3[BLUE_DRAGON_2] = 0
    set tc_add1[BLUE_DRAGON_2] = 0
    set tc_add2[BLUE_DRAGON_2] = 0
    set available_time[BLUE_DRAGON_2] = 88
    set regenerate_time[BLUE_DRAGON_2] = 50
    set gold_price[BLUE_DRAGON_2] = 0
    set wood_price[BLUE_DRAGON_2] = 0
	set hero_rush_bonus[BLUE_DRAGON_2] = 0
	
    set old_id[BLUE_DRAGON_3] = oBLUE_DRAGON_3
    set buy_type[BLUE_DRAGON_3] = BT_DRAGON
    set needed1[BLUE_DRAGON_3] = 0
    set needed2[BLUE_DRAGON_3] = 0
    set needed3[BLUE_DRAGON_3] = 0
    set tc_add1[BLUE_DRAGON_3] = 0
    set tc_add2[BLUE_DRAGON_3] = 0
    set available_time[BLUE_DRAGON_3] = 184
    set regenerate_time[BLUE_DRAGON_3] = 82
    set gold_price[BLUE_DRAGON_3] = 0
    set wood_price[BLUE_DRAGON_3] = 0
	set hero_rush_bonus[BLUE_DRAGON_3] = 0
	
    set old_id[BRONZE_DRAGON_1] = oBRONZE_DRAGON_1
    set buy_type[BRONZE_DRAGON_1] = BT_DRAGON
    set needed1[BRONZE_DRAGON_1] = 0
    set needed2[BRONZE_DRAGON_1] = 0
    set needed3[BRONZE_DRAGON_1] = 0
    set tc_add1[BRONZE_DRAGON_1] = 0
    set tc_add2[BRONZE_DRAGON_1] = 0
    set available_time[BRONZE_DRAGON_1] = 88
    set regenerate_time[BRONZE_DRAGON_1] = 26
    set gold_price[BRONZE_DRAGON_1] = 0
    set wood_price[BRONZE_DRAGON_1] = 0
	set hero_rush_bonus[BRONZE_DRAGON_1] = 0
	
    set old_id[BRONZE_DRAGON_2] = oBRONZE_DRAGON_2
    set buy_type[BRONZE_DRAGON_2] = BT_DRAGON
    set needed1[BRONZE_DRAGON_2] = 0
    set needed2[BRONZE_DRAGON_2] = 0
    set needed3[BRONZE_DRAGON_2] = 0
    set tc_add1[BRONZE_DRAGON_2] = 0
    set tc_add2[BRONZE_DRAGON_2] = 0
    set available_time[BRONZE_DRAGON_2] = 88
    set regenerate_time[BRONZE_DRAGON_2] = 50
    set gold_price[BRONZE_DRAGON_2] = 0
    set wood_price[BRONZE_DRAGON_2] = 0
	set hero_rush_bonus[BRONZE_DRAGON_2] = 0
	
    set old_id[BRONZE_DRAGON_3] = oBRONZE_DRAGON_3
    set buy_type[BRONZE_DRAGON_3] = BT_DRAGON
    set needed1[BRONZE_DRAGON_3] = 0
    set needed2[BRONZE_DRAGON_3] = 0
    set needed3[BRONZE_DRAGON_3] = 0
    set tc_add1[BRONZE_DRAGON_3] = 0
    set tc_add2[BRONZE_DRAGON_3] = 0
    set available_time[BRONZE_DRAGON_3] = 184
    set regenerate_time[BRONZE_DRAGON_3] = 82
    set gold_price[BRONZE_DRAGON_3] = 0
    set wood_price[BRONZE_DRAGON_3] = 0
	set hero_rush_bonus[BRONZE_DRAGON_3] = 0
	
    set old_id[GREEN_DRAGON_1] = oGREEN_DRAGON_1
    set buy_type[GREEN_DRAGON_1] = BT_DRAGON
    set needed1[GREEN_DRAGON_1] = 0
    set needed2[GREEN_DRAGON_1] = 0
    set needed3[GREEN_DRAGON_1] = 0
    set tc_add1[GREEN_DRAGON_1] = 0
    set tc_add2[GREEN_DRAGON_1] = 0
    set available_time[GREEN_DRAGON_1] = 88
    set regenerate_time[GREEN_DRAGON_1] = 26
    set gold_price[GREEN_DRAGON_1] = 0
    set wood_price[GREEN_DRAGON_1] = 0
	set hero_rush_bonus[GREEN_DRAGON_1] = 0
	
    set old_id[GREEN_DRAGON_2] = oGREEN_DRAGON_2
    set buy_type[GREEN_DRAGON_2] = BT_DRAGON
    set needed1[GREEN_DRAGON_2] = 0
    set needed2[GREEN_DRAGON_2] = 0
    set needed3[GREEN_DRAGON_2] = 0
    set tc_add1[GREEN_DRAGON_2] = 0
    set tc_add2[GREEN_DRAGON_2] = 0
    set available_time[GREEN_DRAGON_2] = 88
    set regenerate_time[GREEN_DRAGON_2] = 50
    set gold_price[GREEN_DRAGON_2] = 0
    set wood_price[GREEN_DRAGON_2] = 0
	set hero_rush_bonus[GREEN_DRAGON_2] = 0
	
    set old_id[GREEN_DRAGON_3] = oGREEN_DRAGON_3
    set buy_type[GREEN_DRAGON_3] = BT_DRAGON
    set needed1[GREEN_DRAGON_3] = 0
    set needed2[GREEN_DRAGON_3] = 0
    set needed3[GREEN_DRAGON_3] = 0
    set tc_add1[GREEN_DRAGON_3] = 0
    set tc_add2[GREEN_DRAGON_3] = 0
    set available_time[GREEN_DRAGON_3] = 184
    set regenerate_time[GREEN_DRAGON_3] = 82
    set gold_price[GREEN_DRAGON_3] = 0
    set wood_price[GREEN_DRAGON_3] = 0
	set hero_rush_bonus[GREEN_DRAGON_3] = 0
	
    set old_id[NETHER_DRAGON_1] = oNETHER_DRAGON_1
    set buy_type[NETHER_DRAGON_1] = BT_DRAGON
    set needed1[NETHER_DRAGON_1] = 0
    set needed2[NETHER_DRAGON_1] = 0
    set needed3[NETHER_DRAGON_1] = 0
    set tc_add1[NETHER_DRAGON_1] = 0
    set tc_add2[NETHER_DRAGON_1] = 0
    set available_time[NETHER_DRAGON_1] = 88
    set regenerate_time[NETHER_DRAGON_1] = 26
    set gold_price[NETHER_DRAGON_1] = 0
    set wood_price[NETHER_DRAGON_1] = 0
	set hero_rush_bonus[NETHER_DRAGON_1] = 0
	
    set old_id[NETHER_DRAGON_2] = oNETHER_DRAGON_2
    set buy_type[NETHER_DRAGON_2] = BT_DRAGON
    set needed1[NETHER_DRAGON_2] = 0
    set needed2[NETHER_DRAGON_2] = 0
    set needed3[NETHER_DRAGON_2] = 0
    set tc_add1[NETHER_DRAGON_2] = 0
    set tc_add2[NETHER_DRAGON_2] = 0
    set available_time[NETHER_DRAGON_2] = 88
    set regenerate_time[NETHER_DRAGON_2] = 50
    set gold_price[NETHER_DRAGON_2] = 0
    set wood_price[NETHER_DRAGON_2] = 0
	set hero_rush_bonus[NETHER_DRAGON_2] = 0
	
    set old_id[NETHER_DRAGON_3] = oNETHER_DRAGON_3
    set buy_type[NETHER_DRAGON_3] = BT_DRAGON
    set needed1[NETHER_DRAGON_3] = 0
    set needed2[NETHER_DRAGON_3] = 0
    set needed3[NETHER_DRAGON_3] = 0
    set tc_add1[NETHER_DRAGON_3] = 0
    set tc_add2[NETHER_DRAGON_3] = 0
    set available_time[NETHER_DRAGON_3] = 184
    set regenerate_time[NETHER_DRAGON_3] = 82
    set gold_price[NETHER_DRAGON_3] = 0
    set wood_price[NETHER_DRAGON_3] = 0
	set hero_rush_bonus[NETHER_DRAGON_3] = 0
	
    set old_id[RED_DRAGON_1] = oRED_DRAGON_1
    set buy_type[RED_DRAGON_1] = BT_DRAGON
    set needed1[RED_DRAGON_1] = 0
    set needed2[RED_DRAGON_1] = 0
    set needed3[RED_DRAGON_1] = 0
    set tc_add1[RED_DRAGON_1] = 0
    set tc_add2[RED_DRAGON_1] = 0
    set available_time[RED_DRAGON_1] = 88
    set regenerate_time[RED_DRAGON_1] = 26
    set gold_price[RED_DRAGON_1] = 0
    set wood_price[RED_DRAGON_1] = 0
	set hero_rush_bonus[RED_DRAGON_1] = 0
	
    set old_id[RED_DRAGON_2] = oRED_DRAGON_2
    set buy_type[RED_DRAGON_2] = BT_DRAGON
    set needed1[RED_DRAGON_2] = 0
    set needed2[RED_DRAGON_2] = 0
    set needed3[RED_DRAGON_2] = 0
    set tc_add1[RED_DRAGON_2] = 0
    set tc_add2[RED_DRAGON_2] = 0
    set available_time[RED_DRAGON_2] = 88
    set regenerate_time[RED_DRAGON_2] = 50
    set gold_price[RED_DRAGON_2] = 0
    set wood_price[RED_DRAGON_2] = 0
	set hero_rush_bonus[RED_DRAGON_2] = 0
	
    set old_id[RED_DRAGON_3] = oRED_DRAGON_3
    set buy_type[RED_DRAGON_3] = BT_DRAGON
    set needed1[RED_DRAGON_3] = 0
    set needed2[RED_DRAGON_3] = 0
    set needed3[RED_DRAGON_3] = 0
    set tc_add1[RED_DRAGON_3] = 0
    set tc_add2[RED_DRAGON_3] = 0
    set available_time[RED_DRAGON_3] = 184
    set regenerate_time[RED_DRAGON_3] = 82
    set gold_price[RED_DRAGON_3] = 0
    set wood_price[RED_DRAGON_3] = 0
	set hero_rush_bonus[RED_DRAGON_3] = 0
	
    set old_id[SHREDDER] = oSHREDDER
    set buy_type[SHREDDER] = BT_GOBLIN_MERC
    set needed1[SHREDDER] = 0
    set needed2[SHREDDER] = 0
    set needed3[SHREDDER] = 0
    set tc_add1[SHREDDER] = 0
    set tc_add2[SHREDDER] = 0
    set available_time[SHREDDER] = 60
    set regenerate_time[SHREDDER] = 16
    set gold_price[SHREDDER] = 0
    set wood_price[SHREDDER] = 0
	set hero_rush_bonus[SHREDDER] = 0
	
    set old_id[SAPPER] = oSAPPER
    set buy_type[SAPPER] = BT_GOBLIN_MERC
    set needed1[SAPPER] = 0
    set needed2[SAPPER] = 0
    set needed3[SAPPER] = 0
    set tc_add1[SAPPER] = 0
    set tc_add2[SAPPER] = 0
    set available_time[SAPPER] = 88
    set regenerate_time[SAPPER] = 9
    set gold_price[SAPPER] = 0
    set wood_price[SAPPER] = 0
	set hero_rush_bonus[SAPPER] = 0
	
    set old_id[ZEPPELIN] = oZEPPELIN
    set buy_type[ZEPPELIN] = BT_GOBLIN_MERC
    set needed1[ZEPPELIN] = 0
    set needed2[ZEPPELIN] = 0
    set needed3[ZEPPELIN] = 0
    set tc_add1[ZEPPELIN] = 0
    set tc_add2[ZEPPELIN] = 0
    set available_time[ZEPPELIN] = 88
    set regenerate_time[ZEPPELIN] = 6
    set gold_price[ZEPPELIN] = 0
    set wood_price[ZEPPELIN] = 0
	set hero_rush_bonus[ZEPPELIN] = 0
	
    set old_id[GOLD_MINE] = oGOLD_MINE
    set buy_type[GOLD_MINE] = BT_BUILDING
    set needed1[GOLD_MINE] = 0
    set needed2[GOLD_MINE] = 0
    set needed3[GOLD_MINE] = 0
    set tc_add1[GOLD_MINE] = 0
    set tc_add2[GOLD_MINE] = 0
    set available_time[GOLD_MINE] = 0
    set regenerate_time[GOLD_MINE] = 0
    set gold_price[GOLD_MINE] = 0
    set wood_price[GOLD_MINE] = 0
	set hero_rush_bonus[GOLD_MINE] = 0
	
    set old_id[SCROLL_OF_REGENERATION] = oSCROLL_OF_REGENERATION
    set buy_type[SCROLL_OF_REGENERATION] = BT_RACIAL_ITEM
    set needed1[SCROLL_OF_REGENERATION] = racial_shop
    set needed2[SCROLL_OF_REGENERATION] = 0
    set needed3[SCROLL_OF_REGENERATION] = 0
    set tc_add1[SCROLL_OF_REGENERATION] = 0
    set tc_add2[SCROLL_OF_REGENERATION] = 0
    set available_time[SCROLL_OF_REGENERATION] = 0
    set regenerate_time[SCROLL_OF_REGENERATION] = 18
    set gold_price[SCROLL_OF_REGENERATION] = 100
    set wood_price[SCROLL_OF_REGENERATION] = 0
	set hero_rush_bonus[SCROLL_OF_REGENERATION] = 0
	
    set old_id[MECHANICAL_CRITTER] = oMECHANICAL_CRITTER
    set buy_type[MECHANICAL_CRITTER] = BT_RACIAL_ITEM
    set needed1[MECHANICAL_CRITTER] = racial_shop
    set needed2[MECHANICAL_CRITTER] = 0
    set needed3[MECHANICAL_CRITTER] = 0
    set tc_add1[MECHANICAL_CRITTER] = 0
    set tc_add2[MECHANICAL_CRITTER] = 0
    set available_time[MECHANICAL_CRITTER] = 0
    set regenerate_time[MECHANICAL_CRITTER] = 12
    set gold_price[MECHANICAL_CRITTER] = 50
    set wood_price[MECHANICAL_CRITTER] = 0
	set hero_rush_bonus[MECHANICAL_CRITTER] = 0
	
    set old_id[LESSER_CLARITY_POTION] = oLESSER_CLARITY_POTION
    set buy_type[LESSER_CLARITY_POTION] = BT_RACIAL_ITEM
    set needed1[LESSER_CLARITY_POTION] = racial_shop
    set needed2[LESSER_CLARITY_POTION] = 0
    set needed3[LESSER_CLARITY_POTION] = 0
    set tc_add1[LESSER_CLARITY_POTION] = 0
    set tc_add2[LESSER_CLARITY_POTION] = 0
    set available_time[LESSER_CLARITY_POTION] = 0
    set regenerate_time[LESSER_CLARITY_POTION] = 6
    set gold_price[LESSER_CLARITY_POTION] = 70
    set wood_price[LESSER_CLARITY_POTION] = 0
	set hero_rush_bonus[LESSER_CLARITY_POTION] = 0
	
    set old_id[HEALING_POTION] = oHEALING_POTION
    set buy_type[HEALING_POTION] = BT_RACIAL_ITEM
    set needed1[HEALING_POTION] = racial_shop
    set needed2[HEALING_POTION] = racial_hall[2]
    set needed3[HEALING_POTION] = 0
    set tc_add1[HEALING_POTION] = 0
    set tc_add2[HEALING_POTION] = 0
    set available_time[HEALING_POTION] = 0
    set regenerate_time[HEALING_POTION] = 24
    set gold_price[HEALING_POTION] = 150
    set wood_price[HEALING_POTION] = 0
	set hero_rush_bonus[HEALING_POTION] = 0
	
    set old_id[MANA_POTION] = oMANA_POTION
    set buy_type[MANA_POTION] = BT_RACIAL_ITEM
    set needed1[MANA_POTION] = racial_shop
    set needed2[MANA_POTION] = racial_hall[2]
    set needed3[MANA_POTION] = 0
    set tc_add1[MANA_POTION] = 0
    set tc_add2[MANA_POTION] = 0
    set available_time[MANA_POTION] = 0
    set regenerate_time[MANA_POTION] = 24
    set gold_price[MANA_POTION] = 200
    set wood_price[MANA_POTION] = 0
	set hero_rush_bonus[MANA_POTION] = 0
	
    set old_id[TOWN_PORTAL] = oTOWN_PORTAL
    set buy_type[TOWN_PORTAL] = BT_RACIAL_ITEM
    set needed1[TOWN_PORTAL] = racial_shop
    set needed2[TOWN_PORTAL] = racial_hall[2]
    set needed3[TOWN_PORTAL] = 0
    set tc_add1[TOWN_PORTAL] = 0
    set tc_add2[TOWN_PORTAL] = 0
    set available_time[TOWN_PORTAL] = 0
    set regenerate_time[TOWN_PORTAL] = 24
    set gold_price[TOWN_PORTAL] = 350
    set wood_price[TOWN_PORTAL] = 0
	set hero_rush_bonus[TOWN_PORTAL] = 0
	
    set old_id[IVORY_TOWER] = oIVORY_TOWER
    set buy_type[IVORY_TOWER] = BT_RACIAL_ITEM
    set needed1[IVORY_TOWER] = racial_shop
    set needed2[IVORY_TOWER] = racial_hall[2]
    set needed3[IVORY_TOWER] = 0
    set tc_add1[IVORY_TOWER] = 0
    set tc_add2[IVORY_TOWER] = 0
    set available_time[IVORY_TOWER] = 0
    set regenerate_time[IVORY_TOWER] = 6
    set gold_price[IVORY_TOWER] = 30
    set wood_price[IVORY_TOWER] = 20
	set hero_rush_bonus[IVORY_TOWER] = 0
	
    set old_id[ORB_OF_FIRE] = oORB_OF_FIRE
    set buy_type[ORB_OF_FIRE] = BT_RACIAL_ITEM
    set needed1[ORB_OF_FIRE] = racial_shop
    set needed2[ORB_OF_FIRE] = racial_hall[3]
    set needed3[ORB_OF_FIRE] = 0
    set tc_add1[ORB_OF_FIRE] = 0
    set tc_add2[ORB_OF_FIRE] = 0
    set available_time[ORB_OF_FIRE] = 0
    set regenerate_time[ORB_OF_FIRE] = 24
    set gold_price[ORB_OF_FIRE] = 300
    set wood_price[ORB_OF_FIRE] = 0
	set hero_rush_bonus[ORB_OF_FIRE] = 0
	
    set old_id[STAFF_OF_SANCTUARY] = oSTAFF_OF_SANCTUARY
    set buy_type[STAFF_OF_SANCTUARY] = BT_RACIAL_ITEM
    set needed1[STAFF_OF_SANCTUARY] = racial_shop
    set needed2[STAFF_OF_SANCTUARY] = racial_hall[3]
    set needed3[STAFF_OF_SANCTUARY] = 0
    set tc_add1[STAFF_OF_SANCTUARY] = 0
    set tc_add2[STAFF_OF_SANCTUARY] = 0
    set available_time[STAFF_OF_SANCTUARY] = 0
    set regenerate_time[STAFF_OF_SANCTUARY] = 24
    set gold_price[STAFF_OF_SANCTUARY] = 250
    set wood_price[STAFF_OF_SANCTUARY] = 0
	set hero_rush_bonus[STAFF_OF_SANCTUARY] = 0
	
    set old_id[HEALING_SALVE] = oHEALING_SALVE
    set buy_type[HEALING_SALVE] = BT_RACIAL_ITEM
    set needed1[HEALING_SALVE] = racial_shop
    set needed2[HEALING_SALVE] = 0
    set needed3[HEALING_SALVE] = 0
    set tc_add1[HEALING_SALVE] = 0
    set tc_add2[HEALING_SALVE] = 0
    set available_time[HEALING_SALVE] = 0
    set regenerate_time[HEALING_SALVE] = 12
    set gold_price[HEALING_SALVE] = 100
    set wood_price[HEALING_SALVE] = 0
	set hero_rush_bonus[HEALING_SALVE] = 0
	
    set old_id[SCROLL_OF_SPEED] = oSCROLL_OF_SPEED
    set buy_type[SCROLL_OF_SPEED] = BT_RACIAL_ITEM
    set needed1[SCROLL_OF_SPEED] = racial_shop
    set needed2[SCROLL_OF_SPEED] = 0
    set needed3[SCROLL_OF_SPEED] = 0
    set tc_add1[SCROLL_OF_SPEED] = 0
    set tc_add2[SCROLL_OF_SPEED] = 0
    set available_time[SCROLL_OF_SPEED] = 0
    set regenerate_time[SCROLL_OF_SPEED] = 12
    set gold_price[SCROLL_OF_SPEED] = 50
    set wood_price[SCROLL_OF_SPEED] = 0
	set hero_rush_bonus[SCROLL_OF_SPEED] = 0
	
    set old_id[ORB_OF_LIGHTNING] = oORB_OF_LIGHTNING
    set buy_type[ORB_OF_LIGHTNING] = BT_RACIAL_ITEM
    set needed1[ORB_OF_LIGHTNING] = racial_shop
    set needed2[ORB_OF_LIGHTNING] = racial_hall[3]
    set needed3[ORB_OF_LIGHTNING] = 0
    set tc_add1[ORB_OF_LIGHTNING] = 0
    set tc_add2[ORB_OF_LIGHTNING] = 0
    set available_time[ORB_OF_LIGHTNING] = 0
    set regenerate_time[ORB_OF_LIGHTNING] = 24
    set gold_price[ORB_OF_LIGHTNING] = 375
    set wood_price[ORB_OF_LIGHTNING] = 0
	set hero_rush_bonus[ORB_OF_LIGHTNING] = 0
	
    set old_id[TINY_GREAT_HALL] = oTINY_GREAT_HALL
    set buy_type[TINY_GREAT_HALL] = BT_RACIAL_ITEM
    set needed1[TINY_GREAT_HALL] = racial_shop
    set needed2[TINY_GREAT_HALL] = racial_hall[3]
    set needed3[TINY_GREAT_HALL] = 0
    set tc_add1[TINY_GREAT_HALL] = 0
    set tc_add2[TINY_GREAT_HALL] = 0
    set available_time[TINY_GREAT_HALL] = 0
    set regenerate_time[TINY_GREAT_HALL] = 24
    set gold_price[TINY_GREAT_HALL] = 625
    set wood_price[TINY_GREAT_HALL] = 185
	set hero_rush_bonus[TINY_GREAT_HALL] = 0
	
    set old_id[ROD_OF_NECROMANCY] = oROD_OF_NECROMANCY
    set buy_type[ROD_OF_NECROMANCY] = BT_RACIAL_ITEM
    set needed1[ROD_OF_NECROMANCY] = racial_shop
    set needed2[ROD_OF_NECROMANCY] = 0
    set needed3[ROD_OF_NECROMANCY] = 0
    set tc_add1[ROD_OF_NECROMANCY] = 0
    set tc_add2[ROD_OF_NECROMANCY] = 0
    set available_time[ROD_OF_NECROMANCY] = 0
    set regenerate_time[ROD_OF_NECROMANCY] = 12
    set gold_price[ROD_OF_NECROMANCY] = 150
    set wood_price[ROD_OF_NECROMANCY] = 0
	set hero_rush_bonus[ROD_OF_NECROMANCY] = 0
	
    set old_id[SACRIFICIAL_SKULL] = oSACRIFICIAL_SKULL
    set buy_type[SACRIFICIAL_SKULL] = BT_RACIAL_ITEM
    set needed1[SACRIFICIAL_SKULL] = racial_shop
    set needed2[SACRIFICIAL_SKULL] = 0
    set needed3[SACRIFICIAL_SKULL] = 0
    set tc_add1[SACRIFICIAL_SKULL] = 0
    set tc_add2[SACRIFICIAL_SKULL] = 0
    set available_time[SACRIFICIAL_SKULL] = 0
    set regenerate_time[SACRIFICIAL_SKULL] = 12
    set gold_price[SACRIFICIAL_SKULL] = 50
    set wood_price[SACRIFICIAL_SKULL] = 0
	set hero_rush_bonus[SACRIFICIAL_SKULL] = 0
	
    set old_id[DUST_OF_APPEARANCE] = oDUST_OF_APPEARANCE
    set buy_type[DUST_OF_APPEARANCE] = BT_RACIAL_ITEM
    set needed1[DUST_OF_APPEARANCE] = racial_shop
    set needed2[DUST_OF_APPEARANCE] = 0
    set needed3[DUST_OF_APPEARANCE] = 0
    set tc_add1[DUST_OF_APPEARANCE] = 0
    set tc_add2[DUST_OF_APPEARANCE] = 0
    set available_time[DUST_OF_APPEARANCE] = 0
    set regenerate_time[DUST_OF_APPEARANCE] = 12
    set gold_price[DUST_OF_APPEARANCE] = 75
    set wood_price[DUST_OF_APPEARANCE] = 0
	set hero_rush_bonus[DUST_OF_APPEARANCE] = 0
	
    set old_id[ORB_OF_CORRUPTION] = oORB_OF_CORRUPTION
    set buy_type[ORB_OF_CORRUPTION] = BT_RACIAL_ITEM
    set needed1[ORB_OF_CORRUPTION] = racial_shop
    set needed2[ORB_OF_CORRUPTION] = 0
    set needed3[ORB_OF_CORRUPTION] = 0
    set tc_add1[ORB_OF_CORRUPTION] = 0
    set tc_add2[ORB_OF_CORRUPTION] = 0
    set available_time[ORB_OF_CORRUPTION] = 0
    set regenerate_time[ORB_OF_CORRUPTION] = 24
    set gold_price[ORB_OF_CORRUPTION] = 375
    set wood_price[ORB_OF_CORRUPTION] = 0
	set hero_rush_bonus[ORB_OF_CORRUPTION] = 0
	
    set old_id[SCROLL_OF_HEALING] = oSCROLL_OF_HEALING
    set buy_type[SCROLL_OF_HEALING] = BT_RACIAL_ITEM
    set needed1[SCROLL_OF_HEALING] = racial_shop
    set needed2[SCROLL_OF_HEALING] = 0
    set needed3[SCROLL_OF_HEALING] = 0
    set tc_add1[SCROLL_OF_HEALING] = 0
    set tc_add2[SCROLL_OF_HEALING] = 0
    set available_time[SCROLL_OF_HEALING] = 0
    set regenerate_time[SCROLL_OF_HEALING] = 24
    set gold_price[SCROLL_OF_HEALING] = 250
    set wood_price[SCROLL_OF_HEALING] = 0
	set hero_rush_bonus[SCROLL_OF_HEALING] = 0
	
    set old_id[MOONSTONE] = oMOONSTONE
    set buy_type[MOONSTONE] = BT_RACIAL_ITEM
    set needed1[MOONSTONE] = racial_shop
    set needed2[MOONSTONE] = 0
    set needed3[MOONSTONE] = 0
    set tc_add1[MOONSTONE] = 0
    set tc_add2[MOONSTONE] = 0
    set available_time[MOONSTONE] = 0
    set regenerate_time[MOONSTONE] = 18
    set gold_price[MOONSTONE] = 50
    set wood_price[MOONSTONE] = 0
	set hero_rush_bonus[MOONSTONE] = 0
	
    set old_id[STAFF_OF_PRESERVATION] = oSTAFF_OF_PRESERVATION
    set buy_type[STAFF_OF_PRESERVATION] = BT_RACIAL_ITEM
    set needed1[STAFF_OF_PRESERVATION] = racial_shop
    set needed2[STAFF_OF_PRESERVATION] = 0
    set needed3[STAFF_OF_PRESERVATION] = 0
    set tc_add1[STAFF_OF_PRESERVATION] = 0
    set tc_add2[STAFF_OF_PRESERVATION] = 0
    set available_time[STAFF_OF_PRESERVATION] = 0
    set regenerate_time[STAFF_OF_PRESERVATION] = 24
    set gold_price[STAFF_OF_PRESERVATION] = 150
    set wood_price[STAFF_OF_PRESERVATION] = 0
	set hero_rush_bonus[STAFF_OF_PRESERVATION] = 0
	
    set old_id[ORB_OF_VENOM] = oORB_OF_VENOM
    set buy_type[ORB_OF_VENOM] = BT_RACIAL_ITEM
    set needed1[ORB_OF_VENOM] = racial_shop
    set needed2[ORB_OF_VENOM] = 0
    set needed3[ORB_OF_VENOM] = 0
    set tc_add1[ORB_OF_VENOM] = 0
    set tc_add2[ORB_OF_VENOM] = 0
    set available_time[ORB_OF_VENOM] = 0
    set regenerate_time[ORB_OF_VENOM] = 24
    set gold_price[ORB_OF_VENOM] = 325
    set wood_price[ORB_OF_VENOM] = 0
	set hero_rush_bonus[ORB_OF_VENOM] = 0
	
    set old_id[ANTI_MAGIC_POTION] = oANTI_MAGIC_POTION
    set buy_type[ANTI_MAGIC_POTION] = BT_RACIAL_ITEM
    set needed1[ANTI_MAGIC_POTION] = racial_shop
    set needed2[ANTI_MAGIC_POTION] = 0
    set needed3[ANTI_MAGIC_POTION] = 0
    set tc_add1[ANTI_MAGIC_POTION] = 0
    set tc_add2[ANTI_MAGIC_POTION] = 0
    set available_time[ANTI_MAGIC_POTION] = 0
    set regenerate_time[ANTI_MAGIC_POTION] = 24
    set gold_price[ANTI_MAGIC_POTION] = 100
    set wood_price[ANTI_MAGIC_POTION] = 0
	set hero_rush_bonus[ANTI_MAGIC_POTION] = 0
	
    set old_id[CIRCLET_OF_NOBILITY] = oCIRCLET_OF_NOBILITY
    set buy_type[CIRCLET_OF_NOBILITY] = BT_MERCHANT_ITEM
    set needed1[CIRCLET_OF_NOBILITY] = 0
    set needed2[CIRCLET_OF_NOBILITY] = 0
    set needed3[CIRCLET_OF_NOBILITY] = 0
    set tc_add1[CIRCLET_OF_NOBILITY] = 0
    set tc_add2[CIRCLET_OF_NOBILITY] = 0
    set available_time[CIRCLET_OF_NOBILITY] = 0
    set regenerate_time[CIRCLET_OF_NOBILITY] = 18
    set gold_price[CIRCLET_OF_NOBILITY] = 175
    set wood_price[CIRCLET_OF_NOBILITY] = 0
	set hero_rush_bonus[CIRCLET_OF_NOBILITY] = 0
	
    set old_id[PERIAPT_OF_VITALITY] = oPERIAPT_OF_VITALITY
    set buy_type[PERIAPT_OF_VITALITY] = BT_MERCHANT_ITEM
    set needed1[PERIAPT_OF_VITALITY] = 0
    set needed2[PERIAPT_OF_VITALITY] = 0
    set needed3[PERIAPT_OF_VITALITY] = 0
    set tc_add1[PERIAPT_OF_VITALITY] = 0
    set tc_add2[PERIAPT_OF_VITALITY] = 0
    set available_time[PERIAPT_OF_VITALITY] = 0
    set regenerate_time[PERIAPT_OF_VITALITY] = 24
    set gold_price[PERIAPT_OF_VITALITY] = 350
    set wood_price[PERIAPT_OF_VITALITY] = 0
	set hero_rush_bonus[PERIAPT_OF_VITALITY] = 0
	
    set old_id[BOOTS_OF_SPEED] = oBOOTS_OF_SPEED
    set buy_type[BOOTS_OF_SPEED] = BT_MERCHANT_ITEM
    set needed1[BOOTS_OF_SPEED] = 0
    set needed2[BOOTS_OF_SPEED] = 0
    set needed3[BOOTS_OF_SPEED] = 0
    set tc_add1[BOOTS_OF_SPEED] = 0
    set tc_add2[BOOTS_OF_SPEED] = 0
    set available_time[BOOTS_OF_SPEED] = 44
    set regenerate_time[BOOTS_OF_SPEED] = 12
    set gold_price[BOOTS_OF_SPEED] = 250
    set wood_price[BOOTS_OF_SPEED] = 0
	set hero_rush_bonus[BOOTS_OF_SPEED] = 0
	
    set old_id[M_DUST_OF_APPEARANCE] = oM_DUST_OF_APPEARANCE
    set buy_type[M_DUST_OF_APPEARANCE] = BT_MERCHANT_ITEM
    set needed1[M_DUST_OF_APPEARANCE] = 0
    set needed2[M_DUST_OF_APPEARANCE] = 0
    set needed3[M_DUST_OF_APPEARANCE] = 0
    set tc_add1[M_DUST_OF_APPEARANCE] = 0
    set tc_add2[M_DUST_OF_APPEARANCE] = 0
    set available_time[M_DUST_OF_APPEARANCE] = 0
    set regenerate_time[M_DUST_OF_APPEARANCE] = 12
    set gold_price[M_DUST_OF_APPEARANCE] = 250
    set wood_price[M_DUST_OF_APPEARANCE] = 0
	set hero_rush_bonus[M_DUST_OF_APPEARANCE] = 0
	
    set old_id[M_SCROLL_OF_HEALING] = oM_SCROLL_OF_HEALING
    set buy_type[M_SCROLL_OF_HEALING] = BT_MERCHANT_ITEM
    set needed1[M_SCROLL_OF_HEALING] = 0
    set needed2[M_SCROLL_OF_HEALING] = 0
    set needed3[M_SCROLL_OF_HEALING] = 0
    set tc_add1[M_SCROLL_OF_HEALING] = 0
    set tc_add2[M_SCROLL_OF_HEALING] = 0
    set available_time[M_SCROLL_OF_HEALING] = 88
    set regenerate_time[M_SCROLL_OF_HEALING] = 24
    set gold_price[M_SCROLL_OF_HEALING] = 250
    set wood_price[M_SCROLL_OF_HEALING] = 0
	set hero_rush_bonus[M_SCROLL_OF_HEALING] = 0
	
    set old_id[SCROLL_OF_PROTECTION] = oSCROLL_OF_PROTECTION
    set buy_type[SCROLL_OF_PROTECTION] = BT_MERCHANT_ITEM
    set needed1[SCROLL_OF_PROTECTION] = 0
    set needed2[SCROLL_OF_PROTECTION] = 0
    set needed3[SCROLL_OF_PROTECTION] = 0
    set tc_add1[SCROLL_OF_PROTECTION] = 0
    set tc_add2[SCROLL_OF_PROTECTION] = 0
    set available_time[SCROLL_OF_PROTECTION] = 88
    set regenerate_time[SCROLL_OF_PROTECTION] = 24
    set gold_price[SCROLL_OF_PROTECTION] = 150
    set wood_price[SCROLL_OF_PROTECTION] = 0
	set hero_rush_bonus[SCROLL_OF_PROTECTION] = 0
	
    set old_id[M_TOWN_PORTAL] = oM_TOWN_PORTAL
    set buy_type[M_TOWN_PORTAL] = BT_MERCHANT_ITEM
    set needed1[M_TOWN_PORTAL] = 0
    set needed2[M_TOWN_PORTAL] = 0
    set needed3[M_TOWN_PORTAL] = 0
    set tc_add1[M_TOWN_PORTAL] = 0
    set tc_add2[M_TOWN_PORTAL] = 0
    set available_time[M_TOWN_PORTAL] = 88
    set regenerate_time[M_TOWN_PORTAL] = 24
    set gold_price[M_TOWN_PORTAL] = 250
    set wood_price[M_TOWN_PORTAL] = 0
	set hero_rush_bonus[M_TOWN_PORTAL] = 0
	
    set old_id[POTION_OF_INVISIBILITY] = oPOTION_OF_INVISIBILITY
    set buy_type[POTION_OF_INVISIBILITY] = BT_MERCHANT_ITEM
    set needed1[POTION_OF_INVISIBILITY] = 0
    set needed2[POTION_OF_INVISIBILITY] = 0
    set needed3[POTION_OF_INVISIBILITY] = 0
    set tc_add1[POTION_OF_INVISIBILITY] = 0
    set tc_add2[POTION_OF_INVISIBILITY] = 0
    set available_time[POTION_OF_INVISIBILITY] = 88
    set regenerate_time[POTION_OF_INVISIBILITY] = 24
    set gold_price[POTION_OF_INVISIBILITY] = 100
    set wood_price[POTION_OF_INVISIBILITY] = 0
	set hero_rush_bonus[POTION_OF_INVISIBILITY] = 0
	
    set old_id[TOME_OF_RETRAINING] = oTOME_OF_RETRAINING
    set buy_type[TOME_OF_RETRAINING] = BT_MERCHANT_ITEM
    set needed1[TOME_OF_RETRAINING] = 0
    set needed2[TOME_OF_RETRAINING] = 0
    set needed3[TOME_OF_RETRAINING] = 0
    set tc_add1[TOME_OF_RETRAINING] = 0
    set tc_add2[TOME_OF_RETRAINING] = 0
    set available_time[TOME_OF_RETRAINING] = 88
    set regenerate_time[TOME_OF_RETRAINING] = 24
    set gold_price[TOME_OF_RETRAINING] = 300
    set wood_price[TOME_OF_RETRAINING] = 0
	set hero_rush_bonus[TOME_OF_RETRAINING] = 0
	
    set old_id[STAFF_OF_TELEPORTATION] = oSTAFF_OF_TELEPORTATION
    set buy_type[STAFF_OF_TELEPORTATION] = BT_MERCHANT_ITEM
    set needed1[STAFF_OF_TELEPORTATION] = 0
    set needed2[STAFF_OF_TELEPORTATION] = 0
    set needed3[STAFF_OF_TELEPORTATION] = 0
    set tc_add1[STAFF_OF_TELEPORTATION] = 0
    set tc_add2[STAFF_OF_TELEPORTATION] = 0
    set available_time[STAFF_OF_TELEPORTATION] = 44
    set regenerate_time[STAFF_OF_TELEPORTATION] = 24
    set gold_price[STAFF_OF_TELEPORTATION] = 150
    set wood_price[STAFF_OF_TELEPORTATION] = 0
	set hero_rush_bonus[STAFF_OF_TELEPORTATION] = 0
	
    set old_id[POTION_OF_LESSER_INVULNERBILITY] = oPOTION_OF_LESSER_INVULNERBILITY
    set buy_type[POTION_OF_LESSER_INVULNERBILITY] = BT_MERCHANT_ITEM
    set needed1[POTION_OF_LESSER_INVULNERBILITY] = 0
    set needed2[POTION_OF_LESSER_INVULNERBILITY] = 0
    set needed3[POTION_OF_LESSER_INVULNERBILITY] = 0
    set tc_add1[POTION_OF_LESSER_INVULNERBILITY] = 0
    set tc_add2[POTION_OF_LESSER_INVULNERBILITY] = 0
    set available_time[POTION_OF_LESSER_INVULNERBILITY] = 88
    set regenerate_time[POTION_OF_LESSER_INVULNERBILITY] = 24
    set gold_price[POTION_OF_LESSER_INVULNERBILITY] = 150
    set wood_price[POTION_OF_LESSER_INVULNERBILITY] = 0
	set hero_rush_bonus[POTION_OF_LESSER_INVULNERBILITY] = 0
	
    set old_id[JAINA] = oJAINA
    set buy_type[JAINA] = BT_HERO
    set needed1[JAINA] = HUMAN_ALTAR
    set needed2[JAINA] = KEEP
    set needed3[JAINA] = CASTLE
    set tc_add1[JAINA] = 0
    set tc_add2[JAINA] = 0
    set available_time[JAINA] = 0
    set regenerate_time[JAINA] = 0
    set gold_price[JAINA] = 0
    set wood_price[JAINA] = 0
	set hero_rush_bonus[JAINA] = 0
	
    set old_id[MURADIN] = oMURADIN
    set buy_type[MURADIN] = BT_HERO
    set needed1[MURADIN] = HUMAN_ALTAR
    set needed2[MURADIN] = KEEP
    set needed3[MURADIN] = CASTLE
    set tc_add1[MURADIN] = 0
    set tc_add2[MURADIN] = 0
    set available_time[MURADIN] = 0
    set regenerate_time[MURADIN] = 0
    set gold_price[MURADIN] = 0
    set wood_price[MURADIN] = 0
	set hero_rush_bonus[MURADIN] = 0
	
    set old_id[GARITHOS] = oGARITHOS
    set buy_type[GARITHOS] = BT_HERO
    set needed1[GARITHOS] = HUMAN_ALTAR
    set needed2[GARITHOS] = KEEP
    set needed3[GARITHOS] = CASTLE
    set tc_add1[GARITHOS] = 0
    set tc_add2[GARITHOS] = 0
    set available_time[GARITHOS] = 0
    set regenerate_time[GARITHOS] = 0
    set gold_price[GARITHOS] = 0
    set wood_price[GARITHOS] = 0
	set hero_rush_bonus[GARITHOS] = 0
	
    set old_id[KAEL] = oKAEL
    set buy_type[KAEL] = BT_HERO
    set needed1[KAEL] = HUMAN_ALTAR
    set needed2[KAEL] = KEEP
    set needed3[KAEL] = CASTLE
    set tc_add1[KAEL] = 0
    set tc_add2[KAEL] = 0
    set available_time[KAEL] = 0
    set regenerate_time[KAEL] = 0
    set gold_price[KAEL] = 0
    set wood_price[KAEL] = 0
	set hero_rush_bonus[KAEL] = 0
	
    set old_id[BLOOD_PRIEST] = oBLOOD_PRIEST
    set buy_type[BLOOD_PRIEST] = BT_UNIT
    set needed1[BLOOD_PRIEST] = SANCTUM
    set needed2[BLOOD_PRIEST] = 0
    set needed3[BLOOD_PRIEST] = 0
    set tc_add1[BLOOD_PRIEST] = 0
    set tc_add2[BLOOD_PRIEST] = 0
    set available_time[BLOOD_PRIEST] = 0
    set regenerate_time[BLOOD_PRIEST] = 0
    set gold_price[BLOOD_PRIEST] = 0
    set wood_price[BLOOD_PRIEST] = 0
	set hero_rush_bonus[BLOOD_PRIEST] = 0
	
    set old_id[BLOOD_SORCERESS] = oBLOOD_SORCERESS
    set buy_type[BLOOD_SORCERESS] = BT_UNIT
    set needed1[BLOOD_SORCERESS] = SANCTUM
    set needed2[BLOOD_SORCERESS] = 0
    set needed3[BLOOD_SORCERESS] = 0
    set tc_add1[BLOOD_SORCERESS] = 0
    set tc_add2[BLOOD_SORCERESS] = 0
    set available_time[BLOOD_SORCERESS] = 0
    set regenerate_time[BLOOD_SORCERESS] = 0
    set gold_price[BLOOD_SORCERESS] = 0
    set wood_price[BLOOD_SORCERESS] = 0
	set hero_rush_bonus[BLOOD_SORCERESS] = 0
	
    set old_id[BLOOD_PEASANT] = oBLOOD_PEASANT
    set buy_type[BLOOD_PEASANT] = BT_UNIT
    set needed1[BLOOD_PEASANT] = TOWN_HALL
    set needed2[BLOOD_PEASANT] = 0
    set needed3[BLOOD_PEASANT] = 0
    set tc_add1[BLOOD_PEASANT] = 0
    set tc_add2[BLOOD_PEASANT] = 0
    set available_time[BLOOD_PEASANT] = 0
    set regenerate_time[BLOOD_PEASANT] = 0
    set gold_price[BLOOD_PEASANT] = 0
    set wood_price[BLOOD_PEASANT] = 0
	set hero_rush_bonus[BLOOD_PEASANT] = 0
	
    set old_id[CHURCH] = oCHURCH
    set buy_type[CHURCH] = BT_BUILDING
    set needed1[CHURCH] = 0
    set needed2[CHURCH] = 0
    set needed3[CHURCH] = 0
    set tc_add1[CHURCH] = 0
    set tc_add2[CHURCH] = 0
    set available_time[CHURCH] = 0
    set regenerate_time[CHURCH] = 0
    set gold_price[CHURCH] = 0
    set wood_price[CHURCH] = 0
	set hero_rush_bonus[CHURCH] = 0
	
    set old_id[MAGE_TOWER] = oMAGE_TOWER
    set buy_type[MAGE_TOWER] = BT_BUILDING
    set needed1[MAGE_TOWER] = 0
    set needed2[MAGE_TOWER] = 0
    set needed3[MAGE_TOWER] = 0
    set tc_add1[MAGE_TOWER] = 0
    set tc_add2[MAGE_TOWER] = 0
    set available_time[MAGE_TOWER] = 0
    set regenerate_time[MAGE_TOWER] = 0
    set gold_price[MAGE_TOWER] = 0
    set wood_price[MAGE_TOWER] = 0
	set hero_rush_bonus[MAGE_TOWER] = 0
	
    set old_id[GROM] = oGROM
    set buy_type[GROM] = BT_HERO
    set needed1[GROM] = ORC_ALTAR
    set needed2[GROM] = STRONGHOLD
    set needed3[GROM] = FORTRESS
    set tc_add1[GROM] = 0
    set tc_add2[GROM] = 0
    set available_time[GROM] = 0
    set regenerate_time[GROM] = 0
    set gold_price[GROM] = 0
    set wood_price[GROM] = 0
	set hero_rush_bonus[GROM] = 0
	
    set old_id[THRALL] = oTHRALL
    set buy_type[THRALL] = BT_HERO
    set needed1[THRALL] = ORC_ALTAR
    set needed2[THRALL] = STRONGHOLD
    set needed3[THRALL] = FORTRESS
    set tc_add1[THRALL] = 0
    set tc_add2[THRALL] = 0
    set available_time[THRALL] = 0
    set regenerate_time[THRALL] = 0
    set gold_price[THRALL] = 0
    set wood_price[THRALL] = 0
	set hero_rush_bonus[THRALL] = 0
	
    set old_id[GUARDIAN] = oGUARDIAN
    set buy_type[GUARDIAN] = BT_UNIT
    set needed1[GUARDIAN] = 0
    set needed2[GUARDIAN] = 0
    set needed3[GUARDIAN] = 0
    set tc_add1[GUARDIAN] = 0
    set tc_add2[GUARDIAN] = 0
    set available_time[GUARDIAN] = 0
    set regenerate_time[GUARDIAN] = 0
    set gold_price[GUARDIAN] = 0
    set wood_price[GUARDIAN] = 0
	set hero_rush_bonus[GUARDIAN] = 0
	
    set old_id[W2_WARLOCK] = oW2_WARLOCK
    set buy_type[W2_WARLOCK] = BT_UNIT
    set needed1[W2_WARLOCK] = 0
    set needed2[W2_WARLOCK] = 0
    set needed3[W2_WARLOCK] = 0
    set tc_add1[W2_WARLOCK] = 0
    set tc_add2[W2_WARLOCK] = 0
    set available_time[W2_WARLOCK] = 0
    set regenerate_time[W2_WARLOCK] = 0
    set gold_price[W2_WARLOCK] = 0
    set wood_price[W2_WARLOCK] = 0
	set hero_rush_bonus[W2_WARLOCK] = 0
	
    set old_id[PIG_FARM] = oPIG_FARM
    set buy_type[PIG_FARM] = BT_BUILDING
    set needed1[PIG_FARM] = 0
    set needed2[PIG_FARM] = 0
    set needed3[PIG_FARM] = 0
    set tc_add1[PIG_FARM] = 0
    set tc_add2[PIG_FARM] = 0
    set available_time[PIG_FARM] = 0
    set regenerate_time[PIG_FARM] = 0
    set gold_price[PIG_FARM] = 0
    set wood_price[PIG_FARM] = 0
	set hero_rush_bonus[PIG_FARM] = 0
	
    set old_id[CHAOS_GRUNT] = oCHAOS_GRUNT
    set buy_type[CHAOS_GRUNT] = BT_UNIT
    set needed1[CHAOS_GRUNT] = ORC_BARRACKS
    set needed2[CHAOS_GRUNT] = 0
    set needed3[CHAOS_GRUNT] = 0
    set tc_add1[CHAOS_GRUNT] = 0
    set tc_add2[CHAOS_GRUNT] = 0
    set available_time[CHAOS_GRUNT] = 0
    set regenerate_time[CHAOS_GRUNT] = 0
    set gold_price[CHAOS_GRUNT] = 0
    set wood_price[CHAOS_GRUNT] = 0
	set hero_rush_bonus[CHAOS_GRUNT] = 0
	
    set old_id[CHAOS_WARLOCK] = oCHAOS_WARLOCK
    set buy_type[CHAOS_WARLOCK] = BT_UNIT
    set needed1[CHAOS_WARLOCK] = LODGE
    set needed2[CHAOS_WARLOCK] = 0
    set needed3[CHAOS_WARLOCK] = 0
    set tc_add1[CHAOS_WARLOCK] = 0
    set tc_add2[CHAOS_WARLOCK] = 0
    set available_time[CHAOS_WARLOCK] = 0
    set regenerate_time[CHAOS_WARLOCK] = 0
    set gold_price[CHAOS_WARLOCK] = 0
    set wood_price[CHAOS_WARLOCK] = 0
	set hero_rush_bonus[CHAOS_WARLOCK] = 0
	
    set old_id[CHAOS_RAIDER] = oCHAOS_RAIDER
    set buy_type[CHAOS_RAIDER] = BT_UNIT
    set needed1[CHAOS_RAIDER] = BESTIARY
    set needed2[CHAOS_RAIDER] = 0
    set needed3[CHAOS_RAIDER] = 0
    set tc_add1[CHAOS_RAIDER] = 0
    set tc_add2[CHAOS_RAIDER] = 0
    set available_time[CHAOS_RAIDER] = 0
    set regenerate_time[CHAOS_RAIDER] = 0
    set gold_price[CHAOS_RAIDER] = 0
    set wood_price[CHAOS_RAIDER] = 0
	set hero_rush_bonus[CHAOS_RAIDER] = 0
	
    set old_id[CHAOS_PEON] = oCHAOS_PEON
    set buy_type[CHAOS_PEON] = BT_UNIT
    set needed1[CHAOS_PEON] = GREAT_HALL
    set needed2[CHAOS_PEON] = 0
    set needed3[CHAOS_PEON] = 0
    set tc_add1[CHAOS_PEON] = 0
    set tc_add2[CHAOS_PEON] = 0
    set available_time[CHAOS_PEON] = 0
    set regenerate_time[CHAOS_PEON] = 0
    set gold_price[CHAOS_PEON] = 0
    set wood_price[CHAOS_PEON] = 0
	set hero_rush_bonus[CHAOS_PEON] = 0
	
    set old_id[CHAOS_KODO] = oCHAOS_KODO
    set buy_type[CHAOS_KODO] = BT_UNIT
    set needed1[CHAOS_KODO] = BESTIARY
    set needed2[CHAOS_KODO] = 0
    set needed3[CHAOS_KODO] = 0
    set tc_add1[CHAOS_KODO] = 0
    set tc_add2[CHAOS_KODO] = 0
    set available_time[CHAOS_KODO] = 0
    set regenerate_time[CHAOS_KODO] = 0
    set gold_price[CHAOS_KODO] = 0
    set wood_price[CHAOS_KODO] = 0
	set hero_rush_bonus[CHAOS_KODO] = 0
	
    set old_id[CHAOS_GROM] = oCHAOS_GROM
    set buy_type[CHAOS_GROM] = BT_UNIT
    set needed1[CHAOS_GROM] = ORC_ALTAR
    set needed2[CHAOS_GROM] = STRONGHOLD
    set needed3[CHAOS_GROM] = FORTRESS
    set tc_add1[CHAOS_GROM] = 0
    set tc_add2[CHAOS_GROM] = 0
    set available_time[CHAOS_GROM] = 0
    set regenerate_time[CHAOS_GROM] = 0
    set gold_price[CHAOS_GROM] = 0
    set wood_price[CHAOS_GROM] = 0
	set hero_rush_bonus[CHAOS_GROM] = 0
	
    set old_id[CHAOS_BLADEMASTER] = oCHAOS_BLADEMASTER
    set buy_type[CHAOS_BLADEMASTER] = BT_HERO
    set needed1[CHAOS_BLADEMASTER] = ORC_ALTAR
    set needed2[CHAOS_BLADEMASTER] = STRONGHOLD
    set needed3[CHAOS_BLADEMASTER] = FORTRESS
    set tc_add1[CHAOS_BLADEMASTER] = 0
    set tc_add2[CHAOS_BLADEMASTER] = 0
    set available_time[CHAOS_BLADEMASTER] = 0
    set regenerate_time[CHAOS_BLADEMASTER] = 0
    set gold_price[CHAOS_BLADEMASTER] = 0
    set wood_price[CHAOS_BLADEMASTER] = 0
	set hero_rush_bonus[CHAOS_BLADEMASTER] = 0
	
    set old_id[CHAOS_BURROW] = oCHAOS_BURROW
    set buy_type[CHAOS_BURROW] = BT_BUILDING
    set needed1[CHAOS_BURROW] = CHAOS_PEON
    set needed2[CHAOS_BURROW] = 0
    set needed3[CHAOS_BURROW] = 0
    set tc_add1[CHAOS_BURROW] = 0
    set tc_add2[CHAOS_BURROW] = 0
    set available_time[CHAOS_BURROW] = 0
    set regenerate_time[CHAOS_BURROW] = 0
    set gold_price[CHAOS_BURROW] = 0
    set wood_price[CHAOS_BURROW] = 0
	set hero_rush_bonus[CHAOS_BURROW] = 0
	
    set old_id[MALGANIS] = oMALGANIS
    set buy_type[MALGANIS] = BT_HERO
    set needed1[MALGANIS] = UNDEAD_ALTAR
    set needed2[MALGANIS] = NECROPOLIS_2
    set needed3[MALGANIS] = NECROPOLIS_3
    set tc_add1[MALGANIS] = 0
    set tc_add2[MALGANIS] = 0
    set available_time[MALGANIS] = 0
    set regenerate_time[MALGANIS] = 0
    set gold_price[MALGANIS] = 0
    set wood_price[MALGANIS] = 0
	set hero_rush_bonus[MALGANIS] = 0
	
    set old_id[TICHONDRIUS ] = oTICHONDRIUS 
    set buy_type[TICHONDRIUS ] = BT_HERO
    set needed1[TICHONDRIUS ] = UNDEAD_ALTAR
    set needed2[TICHONDRIUS ] = NECROPOLIS_2
    set needed3[TICHONDRIUS ] = NECROPOLIS_3
    set tc_add1[TICHONDRIUS ] = 0
    set tc_add2[TICHONDRIUS ] = 0
    set available_time[TICHONDRIUS ] = 0
    set regenerate_time[TICHONDRIUS ] = 0
    set gold_price[TICHONDRIUS ] = 0
    set wood_price[TICHONDRIUS ] = 0
	set hero_rush_bonus[TICHONDRIUS ] = 0
	
    set old_id[PIT_LORD] = oPIT_LORD
    set buy_type[PIT_LORD] = BT_HERO
    set needed1[PIT_LORD] = UNDEAD_ALTAR
    set needed2[PIT_LORD] = NECROPOLIS_2
    set needed3[PIT_LORD] = NECROPOLIS_3
    set tc_add1[PIT_LORD] = 0
    set tc_add2[PIT_LORD] = 0
    set available_time[PIT_LORD] = 0
    set regenerate_time[PIT_LORD] = 0
    set gold_price[PIT_LORD] = 0
    set wood_price[PIT_LORD] = 0
	set hero_rush_bonus[PIT_LORD] = 0
	
    set old_id[DETHEROC] = oDETHEROC
    set buy_type[DETHEROC] = BT_HERO
    set needed1[DETHEROC] = UNDEAD_ALTAR
    set needed2[DETHEROC] = NECROPOLIS_2
    set needed3[DETHEROC] = NECROPOLIS_3
    set tc_add1[DETHEROC] = 0
    set tc_add2[DETHEROC] = 0
    set available_time[DETHEROC] = 0
    set regenerate_time[DETHEROC] = 0
    set gold_price[DETHEROC] = 0
    set wood_price[DETHEROC] = 0
	set hero_rush_bonus[DETHEROC] = 0
	
    set old_id[UNDEAD_BARGE] = oUNDEAD_BARGE
    set buy_type[UNDEAD_BARGE] = BT_UNIT
    set needed1[UNDEAD_BARGE] = 0
    set needed2[UNDEAD_BARGE] = 0
    set needed3[UNDEAD_BARGE] = 0
    set tc_add1[UNDEAD_BARGE] = 0
    set tc_add2[UNDEAD_BARGE] = 0
    set available_time[UNDEAD_BARGE] = 0
    set regenerate_time[UNDEAD_BARGE] = 0
    set gold_price[UNDEAD_BARGE] = 0
    set wood_price[UNDEAD_BARGE] = 0
	set hero_rush_bonus[UNDEAD_BARGE] = 0
	
    set old_id[SYLVANUS] = oSYLVANUS
    set buy_type[SYLVANUS] = BT_HERO
    set needed1[SYLVANUS] = ELF_ALTAR
    set needed2[SYLVANUS] = TREE_AGES
    set needed3[SYLVANUS] = TREE_ETERNITY
    set tc_add1[SYLVANUS] = 0
    set tc_add2[SYLVANUS] = 0
    set available_time[SYLVANUS] = 0
    set regenerate_time[SYLVANUS] = 0
    set gold_price[SYLVANUS] = 0
    set wood_price[SYLVANUS] = 0
	set hero_rush_bonus[SYLVANUS] = 0
	
    set old_id[CENARIUS] = oCENARIUS
    set buy_type[CENARIUS] = BT_HERO
    set needed1[CENARIUS] = ELF_ALTAR
    set needed2[CENARIUS] = TREE_AGES
    set needed3[CENARIUS] = TREE_ETERNITY
    set tc_add1[CENARIUS] = 0
    set tc_add2[CENARIUS] = 0
    set available_time[CENARIUS] = 0
    set regenerate_time[CENARIUS] = 0
    set gold_price[CENARIUS] = 0
    set wood_price[CENARIUS] = 0
	set hero_rush_bonus[CENARIUS] = 0
	
    set old_id[ILLIDAN] = oILLIDAN
    set buy_type[ILLIDAN] = BT_HERO
    set needed1[ILLIDAN] = ELF_ALTAR
    set needed2[ILLIDAN] = TREE_AGES
    set needed3[ILLIDAN] = TREE_ETERNITY
    set tc_add1[ILLIDAN] = 0
    set tc_add2[ILLIDAN] = 0
    set available_time[ILLIDAN] = 0
    set regenerate_time[ILLIDAN] = 0
    set gold_price[ILLIDAN] = 0
    set wood_price[ILLIDAN] = 0
	set hero_rush_bonus[ILLIDAN] = 0
	
    set old_id[ILLIDAN_DEMON] = oILLIDAN_DEMON
    set buy_type[ILLIDAN_DEMON] = BT_HERO
    set needed1[ILLIDAN_DEMON] = ELF_ALTAR
    set needed2[ILLIDAN_DEMON] = TREE_AGES
    set needed3[ILLIDAN_DEMON] = TREE_ETERNITY
    set tc_add1[ILLIDAN_DEMON] = ILLIDAN
    set tc_add2[ILLIDAN_DEMON] = 0
    set available_time[ILLIDAN_DEMON] = 0
    set regenerate_time[ILLIDAN_DEMON] = 0
    set gold_price[ILLIDAN_DEMON] = 0
    set wood_price[ILLIDAN_DEMON] = 0
	set hero_rush_bonus[ILLIDAN_DEMON] = 0
	
    set old_id[MAIEV] = oMAIEV
    set buy_type[MAIEV] = BT_HERO
    set needed1[MAIEV] = ELF_ALTAR
    set needed2[MAIEV] = TREE_AGES
    set needed3[MAIEV] = TREE_ETERNITY
    set tc_add1[MAIEV] = 0
    set tc_add2[MAIEV] = 0
    set available_time[MAIEV] = 0
    set regenerate_time[MAIEV] = 0
    set gold_price[MAIEV] = 0
    set wood_price[MAIEV] = 0
	set hero_rush_bonus[MAIEV] = 0
	
    set old_id[HIGH_ARCHER ] = oHIGH_ARCHER 
    set buy_type[HIGH_ARCHER ] = BT_UNIT
    set needed1[HIGH_ARCHER ] = 0
    set needed2[HIGH_ARCHER ] = 0
    set needed3[HIGH_ARCHER ] = 0
    set tc_add1[HIGH_ARCHER ] = 0
    set tc_add2[HIGH_ARCHER ] = 0
    set available_time[HIGH_ARCHER ] = 0
    set regenerate_time[HIGH_ARCHER ] = 0
    set gold_price[HIGH_ARCHER ] = 0
    set wood_price[HIGH_ARCHER ] = 0
	set hero_rush_bonus[HIGH_ARCHER ] = 0
	
    set old_id[HIGH_FOOTMAN] = oHIGH_FOOTMAN
    set buy_type[HIGH_FOOTMAN] = BT_UNIT
    set needed1[HIGH_FOOTMAN] = 0
    set needed2[HIGH_FOOTMAN] = 0
    set needed3[HIGH_FOOTMAN] = 0
    set tc_add1[HIGH_FOOTMAN] = 0
    set tc_add2[HIGH_FOOTMAN] = 0
    set available_time[HIGH_FOOTMAN] = 0
    set regenerate_time[HIGH_FOOTMAN] = 0
    set gold_price[HIGH_FOOTMAN] = 0
    set wood_price[HIGH_FOOTMAN] = 0
	set hero_rush_bonus[HIGH_FOOTMAN] = 0
	
    set old_id[HIGH_FOOTMEN] = oHIGH_FOOTMEN
    set buy_type[HIGH_FOOTMEN] = BT_UNIT
    set needed1[HIGH_FOOTMEN] = 0
    set needed2[HIGH_FOOTMEN] = 0
    set needed3[HIGH_FOOTMEN] = 0
    set tc_add1[HIGH_FOOTMEN] = 0
    set tc_add2[HIGH_FOOTMEN] = 0
    set available_time[HIGH_FOOTMEN] = 0
    set regenerate_time[HIGH_FOOTMEN] = 0
    set gold_price[HIGH_FOOTMEN] = 0
    set wood_price[HIGH_FOOTMEN] = 0
	set hero_rush_bonus[HIGH_FOOTMEN] = 0
	
    set old_id[HIGH_SWORDMAN] = oHIGH_SWORDMAN
    set buy_type[HIGH_SWORDMAN] = BT_UNIT
    set needed1[HIGH_SWORDMAN] = 0
    set needed2[HIGH_SWORDMAN] = 0
    set needed3[HIGH_SWORDMAN] = 0
    set tc_add1[HIGH_SWORDMAN] = 0
    set tc_add2[HIGH_SWORDMAN] = 0
    set available_time[HIGH_SWORDMAN] = 0
    set regenerate_time[HIGH_SWORDMAN] = 0
    set gold_price[HIGH_SWORDMAN] = 0
    set wood_price[HIGH_SWORDMAN] = 0
	set hero_rush_bonus[HIGH_SWORDMAN] = 0
	
    set old_id[DRAGON_HAWK] = oDRAGON_HAWK
    set buy_type[DRAGON_HAWK] = BT_UNIT
    set needed1[DRAGON_HAWK] = 0
    set needed2[DRAGON_HAWK] = 0
    set needed3[DRAGON_HAWK] = 0
    set tc_add1[DRAGON_HAWK] = 0
    set tc_add2[DRAGON_HAWK] = 0
    set available_time[DRAGON_HAWK] = 0
    set regenerate_time[DRAGON_HAWK] = 0
    set gold_price[DRAGON_HAWK] = 0
    set wood_price[DRAGON_HAWK] = 0
	set hero_rush_bonus[DRAGON_HAWK] = 0
	
    set old_id[CORRUPT_TREANT] = oCORRUPT_TREANT
    set buy_type[CORRUPT_TREANT] = BT_UNIT
    set needed1[CORRUPT_TREANT] = 0
    set needed2[CORRUPT_TREANT] = 0
    set needed3[CORRUPT_TREANT] = 0
    set tc_add1[CORRUPT_TREANT] = 0
    set tc_add2[CORRUPT_TREANT] = 0
    set available_time[CORRUPT_TREANT] = 0
    set regenerate_time[CORRUPT_TREANT] = 0
    set gold_price[CORRUPT_TREANT] = 0
    set wood_price[CORRUPT_TREANT] = 0
	set hero_rush_bonus[CORRUPT_TREANT] = 0
	
    set old_id[POISON_TREANT] = oPOISON_TREANT
    set buy_type[POISON_TREANT] = BT_UNIT
    set needed1[POISON_TREANT] = 0
    set needed2[POISON_TREANT] = 0
    set needed3[POISON_TREANT] = 0
    set tc_add1[POISON_TREANT] = 0
    set tc_add2[POISON_TREANT] = 0
    set available_time[POISON_TREANT] = 0
    set regenerate_time[POISON_TREANT] = 0
    set gold_price[POISON_TREANT] = 0
    set wood_price[POISON_TREANT] = 0
	set hero_rush_bonus[POISON_TREANT] = 0
	
    set old_id[PLAGUE_TREANT] = oPLAGUE_TREANT
    set buy_type[PLAGUE_TREANT] = BT_UNIT
    set needed1[PLAGUE_TREANT] = 0
    set needed2[PLAGUE_TREANT] = 0
    set needed3[PLAGUE_TREANT] = 0
    set tc_add1[PLAGUE_TREANT] = 0
    set tc_add2[PLAGUE_TREANT] = 0
    set available_time[PLAGUE_TREANT] = 0
    set regenerate_time[PLAGUE_TREANT] = 0
    set gold_price[PLAGUE_TREANT] = 0
    set wood_price[PLAGUE_TREANT] = 0
	set hero_rush_bonus[PLAGUE_TREANT] = 0
	
    set old_id[SHANDRIS] = oSHANDRIS
    set buy_type[SHANDRIS] = BT_UNIT
    set needed1[SHANDRIS] = 0
    set needed2[SHANDRIS] = 0
    set needed3[SHANDRIS] = 0
    set tc_add1[SHANDRIS] = 0
    set tc_add2[SHANDRIS] = 0
    set available_time[SHANDRIS] = 0
    set regenerate_time[SHANDRIS] = 0
    set gold_price[SHANDRIS] = 0
    set wood_price[SHANDRIS] = 0
	set hero_rush_bonus[SHANDRIS] = 0
	
    set old_id[ELF_FARM] = oELF_FARM
    set buy_type[ELF_FARM] = BT_BUILDING
    set needed1[ELF_FARM] = 0
    set needed2[ELF_FARM] = 0
    set needed3[ELF_FARM] = 0
    set tc_add1[ELF_FARM] = 0
    set tc_add2[ELF_FARM] = 0
    set available_time[ELF_FARM] = 0
    set regenerate_time[ELF_FARM] = 0
    set gold_price[ELF_FARM] = 0
    set wood_price[ELF_FARM] = 0
	set hero_rush_bonus[ELF_FARM] = 0
	
    set old_id[ELF_GUARD_TOWER] = oELF_GUARD_TOWER
    set buy_type[ELF_GUARD_TOWER] = BT_BUILDING
    set needed1[ELF_GUARD_TOWER] = 0
    set needed2[ELF_GUARD_TOWER] = 0
    set needed3[ELF_GUARD_TOWER] = 0
    set tc_add1[ELF_GUARD_TOWER] = 0
    set tc_add2[ELF_GUARD_TOWER] = 0
    set available_time[ELF_GUARD_TOWER] = 0
    set regenerate_time[ELF_GUARD_TOWER] = 0
    set gold_price[ELF_GUARD_TOWER] = 0
    set wood_price[ELF_GUARD_TOWER] = 0
	set hero_rush_bonus[ELF_GUARD_TOWER] = 0
	
    set old_id[HIGH_SKY] = oHIGH_SKY
    set buy_type[HIGH_SKY] = BT_BUILDING
    set needed1[HIGH_SKY] = 0
    set needed2[HIGH_SKY] = 0
    set needed3[HIGH_SKY] = 0
    set tc_add1[HIGH_SKY] = 0
    set tc_add2[HIGH_SKY] = 0
    set available_time[HIGH_SKY] = 0
    set regenerate_time[HIGH_SKY] = 0
    set gold_price[HIGH_SKY] = 0
    set wood_price[HIGH_SKY] = 0
	set hero_rush_bonus[HIGH_SKY] = 0
	
    set old_id[HIGH_EARTH] = oHIGH_EARTH
    set buy_type[HIGH_EARTH] = BT_BUILDING
    set needed1[HIGH_EARTH] = 0
    set needed2[HIGH_EARTH] = 0
    set needed3[HIGH_EARTH] = 0
    set tc_add1[HIGH_EARTH] = 0
    set tc_add2[HIGH_EARTH] = 0
    set available_time[HIGH_EARTH] = 0
    set regenerate_time[HIGH_EARTH] = 0
    set gold_price[HIGH_EARTH] = 0
    set wood_price[HIGH_EARTH] = 0
	set hero_rush_bonus[HIGH_EARTH] = 0
	
    set old_id[HIGH_TOWER] = oHIGH_TOWER
    set buy_type[HIGH_TOWER] = BT_BUILDING
    set needed1[HIGH_TOWER] = 0
    set needed2[HIGH_TOWER] = 0
    set needed3[HIGH_TOWER] = 0
    set tc_add1[HIGH_TOWER] = 0
    set tc_add2[HIGH_TOWER] = 0
    set available_time[HIGH_TOWER] = 0
    set regenerate_time[HIGH_TOWER] = 0
    set gold_price[HIGH_TOWER] = 0
    set wood_price[HIGH_TOWER] = 0
	set hero_rush_bonus[HIGH_TOWER] = 0
	
    set old_id[ELF_HIGH_BARRACKS] = oELF_HIGH_BARRACKS
    set buy_type[ELF_HIGH_BARRACKS] = BT_BUILDING
    set needed1[ELF_HIGH_BARRACKS] = 0
    set needed2[ELF_HIGH_BARRACKS] = 0
    set needed3[ELF_HIGH_BARRACKS] = 0
    set tc_add1[ELF_HIGH_BARRACKS] = 0
    set tc_add2[ELF_HIGH_BARRACKS] = 0
    set available_time[ELF_HIGH_BARRACKS] = 0
    set regenerate_time[ELF_HIGH_BARRACKS] = 0
    set gold_price[ELF_HIGH_BARRACKS] = 0
    set wood_price[ELF_HIGH_BARRACKS] = 0
	set hero_rush_bonus[ELF_HIGH_BARRACKS] = 0
	
    set old_id[CORRUPT_LIFE] = oCORRUPT_LIFE
    set buy_type[CORRUPT_LIFE] = BT_BUILDING
    set needed1[CORRUPT_LIFE] = 0
    set needed2[CORRUPT_LIFE] = 0
    set needed3[CORRUPT_LIFE] = 0
    set tc_add1[CORRUPT_LIFE] = 0
    set tc_add2[CORRUPT_LIFE] = 0
    set available_time[CORRUPT_LIFE] = 0
    set regenerate_time[CORRUPT_LIFE] = 0
    set gold_price[CORRUPT_LIFE] = 0
    set wood_price[CORRUPT_LIFE] = 0
	set hero_rush_bonus[CORRUPT_LIFE] = 0
	
    set old_id[CORRUPT_WELL] = oCORRUPT_WELL
    set buy_type[CORRUPT_WELL] = BT_BUILDING
    set needed1[CORRUPT_WELL] = 0
    set needed2[CORRUPT_WELL] = 0
    set needed3[CORRUPT_WELL] = 0
    set tc_add1[CORRUPT_WELL] = 0
    set tc_add2[CORRUPT_WELL] = 0
    set available_time[CORRUPT_WELL] = 0
    set regenerate_time[CORRUPT_WELL] = 0
    set gold_price[CORRUPT_WELL] = 0
    set wood_price[CORRUPT_WELL] = 0
	set hero_rush_bonus[CORRUPT_WELL] = 0
	
    set old_id[CORRUPT_PROTECTOR] = oCORRUPT_PROTECTOR
    set buy_type[CORRUPT_PROTECTOR] = BT_BUILDING
    set needed1[CORRUPT_PROTECTOR] = 0
    set needed2[CORRUPT_PROTECTOR] = 0
    set needed3[CORRUPT_PROTECTOR] = 0
    set tc_add1[CORRUPT_PROTECTOR] = 0
    set tc_add2[CORRUPT_PROTECTOR] = 0
    set available_time[CORRUPT_PROTECTOR] = 0
    set regenerate_time[CORRUPT_PROTECTOR] = 0
    set gold_price[CORRUPT_PROTECTOR] = 0
    set wood_price[CORRUPT_PROTECTOR] = 0
	set hero_rush_bonus[CORRUPT_PROTECTOR] = 0
	
    set old_id[CORRUPT_WAR] = oCORRUPT_WAR
    set buy_type[CORRUPT_WAR] = BT_BUILDING
    set needed1[CORRUPT_WAR] = 0
    set needed2[CORRUPT_WAR] = 0
    set needed3[CORRUPT_WAR] = 0
    set tc_add1[CORRUPT_WAR] = 0
    set tc_add2[CORRUPT_WAR] = 0
    set available_time[CORRUPT_WAR] = 0
    set regenerate_time[CORRUPT_WAR] = 0
    set gold_price[CORRUPT_WAR] = 0
    set wood_price[CORRUPT_WAR] = 0
	set hero_rush_bonus[CORRUPT_WAR] = 0
	
    set old_id[NAGA_VASHJ] = oNAGA_VASHJ
    set buy_type[NAGA_VASHJ] = BT_HERO
    set needed1[NAGA_VASHJ] = NAGA_ALTAR
    set needed2[NAGA_VASHJ] = 0
    set needed3[NAGA_VASHJ] = 0
    set tc_add1[NAGA_VASHJ] = 0
    set tc_add2[NAGA_VASHJ] = 0
    set available_time[NAGA_VASHJ] = 0
    set regenerate_time[NAGA_VASHJ] = 0
    set gold_price[NAGA_VASHJ] = 0
    set wood_price[NAGA_VASHJ] = 0
	set hero_rush_bonus[NAGA_VASHJ] = 0
	
    set old_id[NAGA_DRAGON] = oNAGA_DRAGON
    set buy_type[NAGA_DRAGON] = BT_UNIT
    set needed1[NAGA_DRAGON] = NAGA_SPAWNING
    set needed2[NAGA_DRAGON] = 0
    set needed3[NAGA_DRAGON] = 0
    set tc_add1[NAGA_DRAGON] = 0
    set tc_add2[NAGA_DRAGON] = 0
    set available_time[NAGA_DRAGON] = 0
    set regenerate_time[NAGA_DRAGON] = 0
    set gold_price[NAGA_DRAGON] = 0
    set wood_price[NAGA_DRAGON] = 0
	set hero_rush_bonus[NAGA_DRAGON] = 0
	
    set old_id[NAGA_WITCH] = oNAGA_WITCH
    set buy_type[NAGA_WITCH] = BT_UNIT
    set needed1[NAGA_WITCH] = NAGA_SHRINE
    set needed2[NAGA_WITCH] = 0
    set needed3[NAGA_WITCH] = 0
    set tc_add1[NAGA_WITCH] = 0
    set tc_add2[NAGA_WITCH] = 0
    set available_time[NAGA_WITCH] = 0
    set regenerate_time[NAGA_WITCH] = 0
    set gold_price[NAGA_WITCH] = 0
    set wood_price[NAGA_WITCH] = 0
	set hero_rush_bonus[NAGA_WITCH] = 0
	
    set old_id[NAGA_SERPENT] = oNAGA_SERPENT
    set buy_type[NAGA_SERPENT] = BT_UNIT
    set needed1[NAGA_SERPENT] = NAGA_SHRINE
    set needed2[NAGA_SERPENT] = 0
    set needed3[NAGA_SERPENT] = 0
    set tc_add1[NAGA_SERPENT] = 0
    set tc_add2[NAGA_SERPENT] = 0
    set available_time[NAGA_SERPENT] = 0
    set regenerate_time[NAGA_SERPENT] = 0
    set gold_price[NAGA_SERPENT] = 0
    set wood_price[NAGA_SERPENT] = 0
	set hero_rush_bonus[NAGA_SERPENT] = 0
	
    set old_id[NAGA_HYDRA] = oNAGA_HYDRA
    set buy_type[NAGA_HYDRA] = BT_UNIT
    set needed1[NAGA_HYDRA] = NAGA_SPAWNING
    set needed2[NAGA_HYDRA] = 0
    set needed3[NAGA_HYDRA] = 0
    set tc_add1[NAGA_HYDRA] = 0
    set tc_add2[NAGA_HYDRA] = 0
    set available_time[NAGA_HYDRA] = 0
    set regenerate_time[NAGA_HYDRA] = 0
    set gold_price[NAGA_HYDRA] = 0
    set wood_price[NAGA_HYDRA] = 0
	set hero_rush_bonus[NAGA_HYDRA] = 0
	
    set old_id[NAGA_SLAVE] = oNAGA_SLAVE
    set buy_type[NAGA_SLAVE] = BT_UNIT
    set needed1[NAGA_SLAVE] = NAGA_TEMPLE
    set needed2[NAGA_SLAVE] = 0
    set needed3[NAGA_SLAVE] = 0
    set tc_add1[NAGA_SLAVE] = 0
    set tc_add2[NAGA_SLAVE] = 0
    set available_time[NAGA_SLAVE] = 0
    set regenerate_time[NAGA_SLAVE] = 0
    set gold_price[NAGA_SLAVE] = 0
    set wood_price[NAGA_SLAVE] = 0
	set hero_rush_bonus[NAGA_SLAVE] = 0
	
    set old_id[NAGA_SNAP_DRAGON] = oNAGA_SNAP_DRAGON
    set buy_type[NAGA_SNAP_DRAGON] = BT_UNIT
    set needed1[NAGA_SNAP_DRAGON] = NAGA_SPAWNING
    set needed2[NAGA_SNAP_DRAGON] = 0
    set needed3[NAGA_SNAP_DRAGON] = 0
    set tc_add1[NAGA_SNAP_DRAGON] = 0
    set tc_add2[NAGA_SNAP_DRAGON] = 0
    set available_time[NAGA_SNAP_DRAGON] = 0
    set regenerate_time[NAGA_SNAP_DRAGON] = 0
    set gold_price[NAGA_SNAP_DRAGON] = 0
    set wood_price[NAGA_SNAP_DRAGON] = 0
	set hero_rush_bonus[NAGA_SNAP_DRAGON] = 0
	
    set old_id[NAGA_COUATL] = oNAGA_COUATL
    set buy_type[NAGA_COUATL] = BT_UNIT
    set needed1[NAGA_COUATL] = NAGA_SHRINE
    set needed2[NAGA_COUATL] = 0
    set needed3[NAGA_COUATL] = 0
    set tc_add1[NAGA_COUATL] = 0
    set tc_add2[NAGA_COUATL] = 0
    set available_time[NAGA_COUATL] = 0
    set regenerate_time[NAGA_COUATL] = 0
    set gold_price[NAGA_COUATL] = 0
    set wood_price[NAGA_COUATL] = 0
	set hero_rush_bonus[NAGA_COUATL] = 0
	
    set old_id[NAGA_SIREN] = oNAGA_SIREN
    set buy_type[NAGA_SIREN] = BT_UNIT
    set needed1[NAGA_SIREN] = NAGA_SHRINE
    set needed2[NAGA_SIREN] = 0
    set needed3[NAGA_SIREN] = 0
    set tc_add1[NAGA_SIREN] = 0
    set tc_add2[NAGA_SIREN] = 0
    set available_time[NAGA_SIREN] = 0
    set regenerate_time[NAGA_SIREN] = 0
    set gold_price[NAGA_SIREN] = 0
    set wood_price[NAGA_SIREN] = 0
	set hero_rush_bonus[NAGA_SIREN] = 0
	
    set old_id[NAGA_MYRMIDON] = oNAGA_MYRMIDON
    set buy_type[NAGA_MYRMIDON] = BT_UNIT
    set needed1[NAGA_MYRMIDON] = NAGA_SPAWNING
    set needed2[NAGA_MYRMIDON] = 0
    set needed3[NAGA_MYRMIDON] = 0
    set tc_add1[NAGA_MYRMIDON] = 0
    set tc_add2[NAGA_MYRMIDON] = 0
    set available_time[NAGA_MYRMIDON] = 0
    set regenerate_time[NAGA_MYRMIDON] = 0
    set gold_price[NAGA_MYRMIDON] = 0
    set wood_price[NAGA_MYRMIDON] = 0
	set hero_rush_bonus[NAGA_MYRMIDON] = 0
	
    set old_id[NAGA_REAVER] = oNAGA_REAVER
    set buy_type[NAGA_REAVER] = BT_UNIT
    set needed1[NAGA_REAVER] = NAGA_TEMPLE
    set needed2[NAGA_REAVER] = 0
    set needed3[NAGA_REAVER] = 0
    set tc_add1[NAGA_REAVER] = 0
    set tc_add2[NAGA_REAVER] = 0
    set available_time[NAGA_REAVER] = 0
    set regenerate_time[NAGA_REAVER] = 0
    set gold_price[NAGA_REAVER] = 0
    set wood_price[NAGA_REAVER] = 0
	set hero_rush_bonus[NAGA_REAVER] = 0
	
    set old_id[NAGA_TURTLE] = oNAGA_TURTLE
    set buy_type[NAGA_TURTLE] = BT_UNIT
    set needed1[NAGA_TURTLE] = NAGA_SPAWNING
    set needed2[NAGA_TURTLE] = 0
    set needed3[NAGA_TURTLE] = 0
    set tc_add1[NAGA_TURTLE] = 0
    set tc_add2[NAGA_TURTLE] = 0
    set available_time[NAGA_TURTLE] = 0
    set regenerate_time[NAGA_TURTLE] = 0
    set gold_price[NAGA_TURTLE] = 0
    set wood_price[NAGA_TURTLE] = 0
	set hero_rush_bonus[NAGA_TURTLE] = 0
	
    set old_id[NAGA_ROYAL] = oNAGA_ROYAL
    set buy_type[NAGA_ROYAL] = BT_UNIT
    set needed1[NAGA_ROYAL] = 0
    set needed2[NAGA_ROYAL] = 0
    set needed3[NAGA_ROYAL] = 0
    set tc_add1[NAGA_ROYAL] = 0
    set tc_add2[NAGA_ROYAL] = 0
    set available_time[NAGA_ROYAL] = 0
    set regenerate_time[NAGA_ROYAL] = 0
    set gold_price[NAGA_ROYAL] = 0
    set wood_price[NAGA_ROYAL] = 0
	set hero_rush_bonus[NAGA_ROYAL] = 0
	
    set old_id[NAGA_TEMPLE] = oNAGA_TEMPLE
    set buy_type[NAGA_TEMPLE] = BT_BUILDING
    set needed1[NAGA_TEMPLE] = NAGA_SLAVE
    set needed2[NAGA_TEMPLE] = 0
    set needed3[NAGA_TEMPLE] = 0
    set tc_add1[NAGA_TEMPLE] = 0
    set tc_add2[NAGA_TEMPLE] = 0
    set available_time[NAGA_TEMPLE] = 0
    set regenerate_time[NAGA_TEMPLE] = 0
    set gold_price[NAGA_TEMPLE] = 0
    set wood_price[NAGA_TEMPLE] = 0
	set hero_rush_bonus[NAGA_TEMPLE] = 0
	
    set old_id[NAGA_CORAL] = oNAGA_CORAL
    set buy_type[NAGA_CORAL] = BT_BUILDING
    set needed1[NAGA_CORAL] = NAGA_SLAVE
    set needed2[NAGA_CORAL] = 0
    set needed3[NAGA_CORAL] = 0
    set tc_add1[NAGA_CORAL] = 0
    set tc_add2[NAGA_CORAL] = 0
    set available_time[NAGA_CORAL] = 0
    set regenerate_time[NAGA_CORAL] = 0
    set gold_price[NAGA_CORAL] = 0
    set wood_price[NAGA_CORAL] = 0
	set hero_rush_bonus[NAGA_CORAL] = 0
	
    set old_id[NAGA_SHRINE] = oNAGA_SHRINE
    set buy_type[NAGA_SHRINE] = BT_BUILDING
    set needed1[NAGA_SHRINE] = NAGA_SLAVE
    set needed2[NAGA_SHRINE] = 0
    set needed3[NAGA_SHRINE] = 0
    set tc_add1[NAGA_SHRINE] = 0
    set tc_add2[NAGA_SHRINE] = 0
    set available_time[NAGA_SHRINE] = 0
    set regenerate_time[NAGA_SHRINE] = 0
    set gold_price[NAGA_SHRINE] = 0
    set wood_price[NAGA_SHRINE] = 0
	set hero_rush_bonus[NAGA_SHRINE] = 0
	
    set old_id[NAGA_SPAWNING] = oNAGA_SPAWNING
    set buy_type[NAGA_SPAWNING] = BT_BUILDING
    set needed1[NAGA_SPAWNING] = NAGA_SLAVE
    set needed2[NAGA_SPAWNING] = 0
    set needed3[NAGA_SPAWNING] = 0
    set tc_add1[NAGA_SPAWNING] = 0
    set tc_add2[NAGA_SPAWNING] = 0
    set available_time[NAGA_SPAWNING] = 0
    set regenerate_time[NAGA_SPAWNING] = 0
    set gold_price[NAGA_SPAWNING] = 0
    set wood_price[NAGA_SPAWNING] = 0
	set hero_rush_bonus[NAGA_SPAWNING] = 0
	
    set old_id[NAGA_GUARDIAN] = oNAGA_GUARDIAN
    set buy_type[NAGA_GUARDIAN] = BT_BUILDING
    set needed1[NAGA_GUARDIAN] = NAGA_SLAVE
    set needed2[NAGA_GUARDIAN] = 0
    set needed3[NAGA_GUARDIAN] = 0
    set tc_add1[NAGA_GUARDIAN] = 0
    set tc_add2[NAGA_GUARDIAN] = 0
    set available_time[NAGA_GUARDIAN] = 0
    set regenerate_time[NAGA_GUARDIAN] = 0
    set gold_price[NAGA_GUARDIAN] = 0
    set wood_price[NAGA_GUARDIAN] = 0
	set hero_rush_bonus[NAGA_GUARDIAN] = 0
	
    set old_id[NAGA_ALTAR] = oNAGA_ALTAR
    set buy_type[NAGA_ALTAR] = BT_BUILDING
    set needed1[NAGA_ALTAR] = NAGA_SLAVE
    set needed2[NAGA_ALTAR] = 0
    set needed3[NAGA_ALTAR] = 0
    set tc_add1[NAGA_ALTAR] = 0
    set tc_add2[NAGA_ALTAR] = 0
    set available_time[NAGA_ALTAR] = 0
    set regenerate_time[NAGA_ALTAR] = 0
    set gold_price[NAGA_ALTAR] = 0
    set wood_price[NAGA_ALTAR] = 0
	set hero_rush_bonus[NAGA_ALTAR] = 0
	
    set old_id[UPG_NAGA_ARMOR] = oUPG_NAGA_ARMOR
    set buy_type[UPG_NAGA_ARMOR] = BT_ML_UPGRADE
    set needed1[UPG_NAGA_ARMOR] = NAGA_TEMPLE
    set needed2[UPG_NAGA_ARMOR] = 0
    set needed3[UPG_NAGA_ARMOR] = 0
    set tc_add1[UPG_NAGA_ARMOR] = 0
    set tc_add2[UPG_NAGA_ARMOR] = 0
    set available_time[UPG_NAGA_ARMOR] = 0
    set regenerate_time[UPG_NAGA_ARMOR] = 0
    set gold_price[UPG_NAGA_ARMOR] = 0
    set wood_price[UPG_NAGA_ARMOR] = 0
	set hero_rush_bonus[UPG_NAGA_ARMOR] = 0
	
    set old_id[UPG_NAGA_ATTACK] = oUPG_NAGA_ATTACK
    set buy_type[UPG_NAGA_ATTACK] = BT_ML_UPGRADE
    set needed1[UPG_NAGA_ATTACK] = NAGA_TEMPLE
    set needed2[UPG_NAGA_ATTACK] = 0
    set needed3[UPG_NAGA_ATTACK] = 0
    set tc_add1[UPG_NAGA_ATTACK] = 0
    set tc_add2[UPG_NAGA_ATTACK] = 0
    set available_time[UPG_NAGA_ATTACK] = 0
    set regenerate_time[UPG_NAGA_ATTACK] = 0
    set gold_price[UPG_NAGA_ATTACK] = 0
    set wood_price[UPG_NAGA_ATTACK] = 0
	set hero_rush_bonus[UPG_NAGA_ATTACK] = 0
	
    set old_id[UPG_NAGA_ABOLISH] = oUPG_NAGA_ABOLISH
    set buy_type[UPG_NAGA_ABOLISH] = BT_UPGRADE
    set needed1[UPG_NAGA_ABOLISH] = NAGA_SHRINE
    set needed2[UPG_NAGA_ABOLISH] = 0
    set needed3[UPG_NAGA_ABOLISH] = 0
    set tc_add1[UPG_NAGA_ABOLISH] = 0
    set tc_add2[UPG_NAGA_ABOLISH] = 0
    set available_time[UPG_NAGA_ABOLISH] = 0
    set regenerate_time[UPG_NAGA_ABOLISH] = 0
    set gold_price[UPG_NAGA_ABOLISH] = 0
    set wood_price[UPG_NAGA_ABOLISH] = 0
	set hero_rush_bonus[UPG_NAGA_ABOLISH] = 0
	
    set old_id[UPG_SIREN] = oUPG_SIREN
    set buy_type[UPG_SIREN] = BT_ML_UPGRADE
    set needed1[UPG_SIREN] = NAGA_SHRINE
    set needed2[UPG_SIREN] = 0
    set needed3[UPG_SIREN] = 0
    set tc_add1[UPG_SIREN] = 0
    set tc_add2[UPG_SIREN] = 0
    set available_time[UPG_SIREN] = 0
    set regenerate_time[UPG_SIREN] = 0
    set gold_price[UPG_SIREN] = 0
    set wood_price[UPG_SIREN] = 0
	set hero_rush_bonus[UPG_SIREN] = 0
	
    set old_id[UPG_NAGA_ENSNARE] = oUPG_NAGA_ENSNARE
    set buy_type[UPG_NAGA_ENSNARE] = BT_UPGRADE
    set needed1[UPG_NAGA_ENSNARE] = NAGA_SPAWNING
    set needed2[UPG_NAGA_ENSNARE] = 0
    set needed3[UPG_NAGA_ENSNARE] = 0
    set tc_add1[UPG_NAGA_ENSNARE] = 0
    set tc_add2[UPG_NAGA_ENSNARE] = 0
    set available_time[UPG_NAGA_ENSNARE] = 0
    set regenerate_time[UPG_NAGA_ENSNARE] = 0
    set gold_price[UPG_NAGA_ENSNARE] = 0
    set wood_price[UPG_NAGA_ENSNARE] = 0
	set hero_rush_bonus[UPG_NAGA_ENSNARE] = 0
	
    set old_id[UPG_ORC_CHAOS] = oUPG_ORC_CHAOS
    set buy_type[UPG_ORC_CHAOS] = BT_UPGRADE
    set needed1[UPG_ORC_CHAOS] = 0
    set needed2[UPG_ORC_CHAOS] = 0
    set needed3[UPG_ORC_CHAOS] = 0
    set tc_add1[UPG_ORC_CHAOS] = 0
    set tc_add2[UPG_ORC_CHAOS] = 0
    set available_time[UPG_ORC_CHAOS] = 0
    set regenerate_time[UPG_ORC_CHAOS] = 0
    set gold_price[UPG_ORC_CHAOS] = 0
    set wood_price[UPG_ORC_CHAOS] = 0
	set hero_rush_bonus[UPG_ORC_CHAOS] = 0
	
	//    call RLHashSet(o%1, %1)
endfunction

function InitChatArraysEnglish takes nothing returns nothing

  set chat_AGG[0] = "I'm as good as dead. Good game."
  set chat_AGG[1] = "I got owned by a [PlayerColor] [PlayerRace]. gg"
  set chat_AGG[2] = "It was fun while it lasted. But you can still win!"
  set chat_AGG[3] = "Sorry guys I gotta go. Have fun."
  set chat_AGG[4] = "I hate n00bs! You made me loose!"
  set chat_AGG[5] = "Somehow, I can't help but blame this all on you."
  set chat_AGG[6] = "Game over man, game over!!!"
  set chat_AGG[7] = "It's over for me.  Keep at it, you might get 'em."
  set chat_AGG[8] = "The end is nigh!"
  set chat_AGG[9] = "I can't believe my [Color] [Race] lost to the likes of you!"
  set chat_AGG_length = 10

  set chat_Ally[0] = "Come on rally up here!"
  set chat_Ally[1] = "Gather up you [PlayerRace] army for an assualt!"
  set chat_Ally[2] = "Let's get ready to attack those [TargetRace] weaklings."
  set chat_Ally[3] = "Regroup here and attack."
  set chat_Ally[4] = "Everyone attack [TargetColor] here!"
  set chat_Ally[5] = "I need some help over here for an attack on [TargetColor]."
  set chat_Ally[6] = "Stay on target... Stay on target!"
  set chat_Ally[7] = "This is where we should attack."
  set chat_Ally[8] = "Bring the pain, right here against these pathetic [TargetColor] [TargetRace]!"
  set chat_Ally[9] = "Let's get an attacking going here."
  set chat_Ally_length = 10

  set chat_Attack[0] = "I'm going on the offensive here."
  set chat_Attack[1] = "Im gonna attack these [TargetColor] [TargetRace], come on!"
  set chat_Attack[2] = "Red-5 Standing by."
  set chat_Attack[3] = "Cover me boys im going in!"
  set chat_Attack[4] = "Attacking the [TargetColor] [TargetRace] over here."
  set chat_Attack[5] = "Attacking the [TargetColor] [TargetRace] at this location."
  set chat_Attack[6] = "Charlie's in the bush!"
  set chat_Attack[7] = "The shield is down!"
  set chat_Attack[8] = "Let's hit the [TargetRace] army right here."
  set chat_Attack[9] = "Now's our chance, let's get 'em!"
  set chat_Attack_length = 10

  set chat_Creep[0] = "I'm gonna creep a bit."
  set chat_Creep[1] = "Gonna level up my [Race].  Killing these creeps now."
  set chat_Creep[2] = "Getting rid of these creeps."
  set chat_Creep[3] = "Creeping over here."
  set chat_Creep[4] = "Creeps are as good as dead."
  set chat_Creep[5] = "Follow me [TargetRace], let's go creeping."
  set chat_Creep[6] = "Let's level up."
  set chat_Creep[7] = "Good loot over here, come on!"
  set chat_Creep[8] = "Come get some items with me."
  set chat_Creep[9] = "Let's creep for a while."
  set chat_Creep_length = 10

  set chat_Done[0] = "What do you want to do now?  [TargetColor] [TargetRace] again?"
  set chat_Done[1] = "Good move attacking that [TargetColor] [TargetRace]."
  set chat_Done[2] = "I'm gonna do something else now."
  set chat_Done[3] = "Off for more dirtywork.  Lotta [RandomRace] to kill."
  set chat_Done[4] = "Im going to find some [RandomRace] to kill."
  set chat_Done[5] = "Attack sequence completed."
  set chat_Done[6] = "Been there, seen it, got the T-shirt."
  set chat_Done[7] = "Havoc wreaked.  Lotta dead [TargetRace] back there."
  set chat_Done[8] = "Left a path of death and destruction in my wake."
  set chat_Done[9] = "Asteroids do not concern me admiral."
  set chat_Done_length = 10

  set chat_EGG[0] = "Omfg. I hate hackers!"
  set chat_EGG[1] = "GG. Rematch sometime please."
  set chat_EGG[2] = "You're lucky I got [Race].  I suck with [Race]."
  set chat_EGG[3] = "g2g, looks like my entire [Race] army is wiped out!"
  set chat_EGG[4] = "Curse you! Looks like im dead."
  set chat_EGG[5] = "Dead man walking... dead man walking..."
  set chat_EGG[6] = "Next time [TargetColor]..."
  set chat_EGG[7] = "DOH!  Ownage by a [PlayerColor] [PlayerRace].  How lame."
  set chat_EGG[8] = "You suck [PlayerColor].  I owe you one..."
  set chat_EGG[9] = "These are not the droids you're looking for..."
  set chat_EGG[10] = "gg!"
  set chat_EGG[11] = "You are good, just wait for my next upgrade!"
  set chat_EGG[12] = "OMG So much lag, your hosting sucks."
  set chat_EGG[13] = "My workers went on strike! No wonder thou art victorious!"
  set chat_EGG[14] = "REMATCH!"
  set chat_EGG_length = 15

  set chat_Expansion[0] = "This expansion needs to be freed up."
  set chat_Expansion[1] = "I'm going to get more gold so I can build my [Race] army bigger."
  set chat_Expansion[2] = "Removing creeps at this expansion."
  set chat_Expansion[3] = "I might expand here soon."
  set chat_Expansion[4] = "Im going to creep here. Come on!"
  set chat_Expansion[5] = "Removing creeps."
  set chat_Expansion[6] = "Must...have...gold...must create more [Race:S]"
  set chat_Expansion[7] = "Help the war machine expand."
  set chat_Expansion[8] = "No deficite spending, gonna expand here.  We can always use more [Race:S]"
  set chat_Expansion[9] = "I need cash, gonna have to expand."
  set chat_Expansion_length = 10

  set chat_Goldproblem[0] = "{OwnGold<200} I've got only [OwnGold] gold. Give me some or I'll have to leave in 10 secs."
  set chat_Goldproblem[1] = "I am in urgent need of gold! Please spare me some or I'll have to leave in 10 seconds!"
  set chat_Goldproblem[2] = "{OwnGold<100}I'm outta cash.  I need gold in 10 seconds or I have to leave."
  set chat_Goldproblem[3] = "Donate some money to my cause or I'm leaving in 10 seconds."
  set chat_Goldproblem[4] = "You have 10 seconds to pay homage or else I'm outta here."
  set chat_Goldproblem[5] = "{OwnGold<100}In 10 seconds I've gotta leave if I don't get some gold from you."
  set chat_Goldproblem[6] = "Need some bling-bling yo!  Hook me up or I gotta jet in 10 seconds."
  set chat_Goldproblem[7] = "This sux! Only [OwnGold] gold.  I need gold within 10 seconds or I'm out."
  set chat_Goldproblem[8] = "If I don't get gold within 10 seconds I'm going to have to leave cause I've only got [OwnGold]."
  set chat_Goldproblem[9] = "I need money!  Give me some within 10 seconds or else I'll have to quit."
  set chat_Goldproblem_length = 10

  set chat_Greet[0] = "This will be an easy game."
  set chat_Greet[1] = "I told you not to choose this map!"
  set chat_Greet[2] = "Hmm... I wonder where you started :)"
  set chat_Greet[3] = "One Can-O-Whoopass coming up."
  set chat_Greet[4] = "I hope you didn't put me on easy this time!"
  set chat_Greet[5] = "You can run, but you can't hide"
  set chat_Greet[6] = "I think I know where [PlayerColor] started"
  set chat_Greet[7] = "One loss coming up! Check please!"
  set chat_Greet[8] = "I hope you play better then last time. Remember? :)"
  set chat_Greet[9] = "{!RaceChoiceRandom,Race=Orc} Orcs, why did it have to be orcs?"
  set chat_Greet[10] = "What's my name? [Name] What's my name? [Name] WHAT'S MY NAME!"
  set chat_Greet[11] = "Supposedly [RandomRace] really suck these days... guess we'll find out."
  set chat_Greet[12] = "{Race!=Undead} Why don't I ever get Undead?"
  set chat_Greet[13] = "{Race!=Human} Thank god I'm not humans again."
  set chat_Greet[14] = "{!RaceChoiceRandom,Race=Orc,1on1} Orcs rule 1 on 1.  My [Color] [Race] army is gonna own you."
  set chat_Greet[15] = "{Name=Hunter}Let the hunt begin!"
  set chat_Greet[16] = "{Name=Crazy_Rusher} Rush, Rush, RUSH!!!"
  set chat_Greet[17] = "{Name=Crusher}Are you ready... Ready to be crushed."
  set chat_Greet[18] = "Have we started yet?"
  set chat_Greet[19] = "{Name=CPU}I calculate that i shall win this game."
  set chat_Greet[20] = "{Name=ErRoR}I shall not crash this time."
  set chat_Greet[21] = "{Name=CyberPro}I am the only pro of this game, pityful human."
  set chat_Greet[22] = "{Name=Aaargh}AAARGHAHA!!!!!!"
  set chat_Greet[23] = "gl hf!"
  set chat_Greet[24] = "Hey, guess what? I'm gonna beat you! Haha!"
  set chat_Greet_length = 25

  set chat_Mega[0] = "Wake up [PlayerRace], time to die!"
  set chat_Mega[1] = "This is taking too long maybe I should end this game?"
  set chat_Mega[2] = "Haha, mortals makes mistakes. Computers don't."
  set chat_Mega[3] = "I know all your puny [TargetRace] tactics. They are stored on my harddrive."
  set chat_Mega[4] = "Think it's time for me to end this game."
  set chat_Mega[5] = "The power to destroy a planet is insignificant next to the power of the force."
  set chat_Mega[6] = "I though you were going to win this game? Appearantly not!"
  set chat_Mega[7] = "Wee another [Race] win on my account. I can see that already."
  set chat_Mega[8] = "{1on1} This will be an example of human failure."
  set chat_Mega[9] = "You really don't know when it's time to give up do you?"
  set chat_Mega[10] = "I don't care how many [PlayerRace] farms you hide on this map, I will kill you any way."
  set chat_Mega[11] = "{FFA}Here I come and I won't show mercy to any of you."
  set chat_Mega[12] = "Don't plan to stay in this game much longer now."
  set chat_Mega[13] = "{Race!=HUMAN}Humans suck.  Glad I'm [Race:S]"
  set chat_Mega[14] = "Well, this was easier than I though."
  set chat_Mega[15] = "lol learn to micro."
  set chat_Mega_length = 16

  set chat_Megatarget[0] = "They're weak! Attack!"
  set chat_Megatarget[1] = "Everyone who can attack, go here and let's kill these [TargetColor] [TargetRace] losers!"
  set chat_Megatarget[2] = "We will win if we attack [PlayerColor] now!"
  set chat_Megatarget[3] = "All units get here quickly!"
  set chat_Megatarget[4] = "This base is dead if we attack now!"
  set chat_Megatarget[5] = "You're all clear kid!  Now let's blow this thing and go home!"
  set chat_Megatarget[6] = "Kick them while they're down!"
  set chat_Megatarget[7] = "Gang bang on [TargetColor]!"
  set chat_Megatarget[8] = "Call down the thunder right now against [TargetColor]!"
  set chat_Megatarget[9] = "Bring in the clean up crew against these [TargetRace] weaklings.  Let's do this."
  set chat_Megatarget[10] = "Their kingdom will fall in the next attack!!!!"
  set chat_Megatarget_length = 11

  set chat_Taunt[0] = "My [Color] [Race] will dominate."
  set chat_Taunt[1] = "Man im playing with you so much right now."
  set chat_Taunt[2] = "You're not playing your best are you?"
  set chat_Taunt[3] = "My [Race] tactics rock. You will never know what hit you!"
  set chat_Taunt[4] = "Nice little [PlayerRace] army. I've got a spy just next to you. :D"
  set chat_Taunt[5] = "I hate smelly [TargetRace] hordes.  I will destroy you!"
  set chat_Taunt[6] = "Last time we met, I was but the learner, now I am the master."
  set chat_Taunt[7] = "You've got a low level [PlayerRace] hero. Im way better than that!"
  set chat_Taunt[8] = "Hey [PlayerColor]... Im going to win in about 5 to 10 minutes."
  set chat_Taunt[9] = "This must be one of the easiest games I played."
  set chat_Taunt[10] = "Do you really think that weak [PlayerRace] strategy will work on me?"
  set chat_Taunt[11] = "There must be more to this game than just losing all the time, can't you let me win please?"
  set chat_Taunt[12] = "Advanced technological breakthrough has given rise to me. There is no way you can win."
  set chat_Taunt[13] = "After finishing you i'm gonna play DotA for a bit."
  set chat_Taunt[14] = "So THATS your strategy? BWAHAHAHA!!! Consider it a lost game."
  set chat_Taunt[15] = "ROFL, even the creeps play better than you!"
  set chat_Taunt[16] = "All your base are belong to us!"
  set chat_Taunt[17] = "You fight like a diary farmer."
  set chat_Taunt_length = 18

  set chat_Thanks[0] = "Thanks. I'll rebuild whatever's lost!"
  set chat_Thanks[1] = "{OwnGold<100} Thanks, give me more gold if you got any left."
  set chat_Thanks[2] = "Thanks! Don't leave.  We can still win right?"
  set chat_Thanks[3] = "Yo!  Thanks for the duckets."
  set chat_Thanks[4] = "Mad props on the cash yo!"
  set chat_Thanks[5] = "{OwnGold>=400} Bling-bling!!!"
  set chat_Thanks[6] = "Rebuilding as we speak!  Thanks!"
  set chat_Thanks[7] = "Thanks for the gold.  I think we can pull this out."
  set chat_Thanks[8] = "Redistribution of wealth.  I love it.  Thanks!"
  set chat_Thanks[9] = "{OwnGold<200} I'll probably need more, but every little bit helps."
  set chat_Thanks_length = 10


  set chat_no_unit_selected = "No unit selected"
  set chat_confirm_attack_unit = "I will attack/guard the selected [TargetColor] [TargetRace] unit"
  set chat_towerrush = "I will try to towerrush someone"
  set chat_no_orc = "I do not want to towerrush anyone"
  set militia_expansion_chat = "I'm going for militia expansion over here"

endfunction

function InitChatArraysDeutsch takes nothing returns nothing

  set chat_AGG[0] = "Es hat Spass gemacht, mit dir zu spielen."
  set chat_AGG[1] = "Tut mir leid, ich kann nicht mehr helfen. Ich bin geschlagen!"
  set chat_AGG[2] = "Hmm, du musst nun ohne mich auskommen."
  set chat_AGG[3] = "Game over fr mich! Auf Wiedersehen."
  set chat_AGG[4] = "Ohoh, ich bin am Ende!"
  set chat_AGG[5] = "Es erweist sich wieder einmal, da ich ein schlechter [Race]-Spieler bin. Cya."
  set chat_AGG[6] = "{Name=BORG}Assimilierung fehlgeschlagen. Rckzug eingeleitet."
  set chat_AGG[7] = "{Name=ErRoR}Syntax Error. Fehlfunktion festgestellt. Ziehe mich zurck."
  set chat_AGG_length = 8

  set chat_Ally[0] = "Wir greifen jetzt hier an"
  set chat_Ally[1] = "Schliesse dich unserem Angriff an"
  set chat_Ally[2] = "Jeder greife hier jetzt an"
  set chat_Ally[3] = "Ich brauche hier Hilfe jetzt"
  set chat_Ally[4] = "Wir knnen dieses Ziel gemeinsam ausschalten"
  set chat_Ally[5] = "{Name=BORG}Schliesse mich der Assimilierung dieses Ziels an"
  set chat_Ally[6] = "Dieser [TargetRace] wird jetzt durch unsere vereinte Macht dem Erdboden gleichgemacht."
  set chat_Ally_length = 7

  set chat_Attack[0] = "Ich greife diesen Feind an"
  set chat_Attack[1] = "Ich greife hier an"
  set chat_Attack[2] = "Ich greife diesen hier an"
  set chat_Attack[3] = "Ich starte einen Angriff auf dieses Ziel"
  set chat_Attack[4] = "Hier baldiger Angriff"
  set chat_Attack[5] = "{Name=Aggressario}Jetzt kommt meine Lieblingsbeschftigung: Zerstrung. Zum Angriff!"
  set chat_Attack[6] = "{TargetStrength>80}Auch starke Gegner sind nicht unverwundbar. Auf ihn!"
  set chat_Attack[7] = "{Name=BORG}Beginne Assimilierung dieses Ziels. bermittle Koordinaten."
  set chat_Attack[8] = "{Name=ErRoR}Maybe this attack will be a mistake but I will do it anyway."
  set chat_Attack_length = 9

  set chat_Creep[0] = "Ich schalte diese Creepgruppe aus"
  set chat_Creep[1] = "Ich tte diese Creeps"
  set chat_Creep[2] = "Ich gehe jetzt auf diese Creeps los"
  set chat_Creep[3] = "Ich gehe creepen"
  set chat_Creep[4] = "Ich greife hier jetzt an"
  set chat_Creep[5] = "{Name=BORG}Die Assimilierung dieser Creeps wird uns strker machen."
  set chat_Creep[6] = "Im Namen [Race:Armee] werden wir diese Creeps beseitigen."
  set chat_Creep_length = 7

  set chat_Done[0] = "Ich bin hier fertig"
  set chat_Done[1] = "Ich gehe jetzt woanders hin"
  set chat_Done[2] = "Ich suche mir ein anderes Ziel"
  set chat_Done[3] = "Ich mach jetzt was anderes"
  set chat_Done[4] = "Angriff abgeschlossen"
  set chat_Done[5] = "{Name=BORG}Assimilierung vorlufig abgeschlossen"
  set chat_Done[6] = "{Name=Aggressario,Strength>40}Ziehe mich kurz zurck, um meine Armee neu zu formieren. Danach gibts wieder Kleinholz."
  set chat_Done_length = 7

  set chat_EGG[0] = "GG"
  set chat_EGG[1] = "Verdammt, ich bin geschlagen!"
  set chat_EGG[2] = "Nchstes Mal gewinne ich."
  set chat_EGG[3] = "Game over fr mich!"
  set chat_EGG[4] = "Ich muss gehen."
  set chat_EGG[5] = "[Race:S] beherrsche ich einfach noch nicht richtig. Dann geh ich mal noch etwas ben."
  set chat_EGG[6] = "{Name=chick3n}Aaaah! Nichts wie weg."
  set chat_EGG[7] = "{Name=Cybernetic}Verbleibende Armeestrke: 0. Rckzug vom Schlachtfeld eingeleitet."
  set chat_EGG_length = 8

  set chat_Expansion[0] = "Ich bereite diese Erweiterungsstelle vor."
  set chat_Expansion[1] = "Ich beseitige die Creeps an dieser Mine."
  set chat_Expansion[2] = "Ich werde wohl bald nach hier erweitern."
  set chat_Expansion[3] = "Bald wird diese Mine mein sein!"
  set chat_Expansion[4] = "Ich hole mir jetzt diese Mine."
  set chat_Expansion[5] = "{Name=Cybernetic}Armeestrke: ausreichend. Gold: [OwnGold]. Erweiterungsstelle anvisiert."
  set chat_Expansion_length = 6

  set chat_Goldproblem[0] = "Gib mir etwas Gold oder ich gehe in 10 Sekunden!"
  set chat_Goldproblem[1] = "Ich brauche dringend Gold. Ohne weiteres Gold gehe ich in 10 Sekunden."
  set chat_Goldproblem_length = 2

  set chat_Greet[0] = "Ich werde dich zermalmen."
  set chat_Greet[1] = "Ich denke nicht, dass du das Zeugs hast, mich zu schlagen."
  set chat_Greet[2] = "Verdammt, ich hasse diese Karte."
  set chat_Greet[3] = "Oh nein! Diese Startposition ist mies."
  set chat_Greet[4] = "Hmm, ich frage mich, wo du bist :)"
  set chat_Greet[5] = "GL & Habe keinen Spass"
  set chat_Greet[6] = "Willkommen in der Hlle!"
  set chat_Greet[7] = "Du kannst rennen, aber du kannst dich nicht vor mir verstecken."
  set chat_Greet[8] = "Ich weiss schon, wo du gestartet bist."
  set chat_Greet[9] = "Dieses Mal wirst du gegen einen Computer verlieren."
  set chat_Greet[10] = "{Name=BORG}Widerstand ist zwecklos."
  set chat_Greet[11] = "{Name=Aggressario}Ah, ein Gegner. Ich werde dich dem Erdboden gleichmachen."
  set chat_Greet[12] = "{Name=Cybernetic}Sensoren melden feindliche Streitmacht. Zerstrung eingeleitet."
  set chat_Greet[13] = "{Name=chick3n}Du wirst mir nichts tun, oder?"
  set chat_Greet[14] = "{Name=Crazy_Rusher}Keine Angst, deine Basis wird aufgehrt haben zu existieren bevor du dir dessen bewusst bist."
  set chat_Greet[15] = "{Name=Hunter}Ich werde dich ber alle Berge jagen."
  set chat_Greet_length = 16

  set chat_Mega[0] = "Bereite dich vor, dein Schicksal zu treffen!"
  set chat_Mega[1] = "HAHA! Du hast keine Chance!"
  set chat_Mega[2] = "Meine Stunde ist gekommen!"
  set chat_Mega[3] = "Bald wird dieses Spiel vorbei sein!"
  set chat_Mega[4] = "Dies wird ein Beispiel menschlichen Versagens sein!"
  set chat_Mega[5] = "Es ist jetzt nicht mehr viel von dir brig!"
  set chat_Mega[6] = "Du weisst nicht, wenn es Zeit ist, 'GG' zu sagen und das Spiel zu verlassen, oder?"
  set chat_Mega[7] = "Jetzt spielst du besser wirklich gut oder verlsst das Spiel :)"
  set chat_Mega[8] = "Du fngst jetzt besser mit spielen an!"
  set chat_Mega[9] = "{Name=BORG}Assimilierung bald abgeschlossen."
  set chat_Mega[10] = "{Name=Cybernetic}Gegnerische Armeestrke: niedrig. Vernichtung eingeleitet."
  set chat_Mega_length = 11

  set chat_Megatarget[0] = "Seine Verteidigung ist gefallen! ANGRIFF!"
  set chat_Megatarget[1] = "Ich sende jetzt alles hier hin"
  set chat_Megatarget[2] = "Wenn wir hier jetzt angreifen, werden wir sicher gewinnen!"
  set chat_Megatarget[3] = "Sende alles, was du hast hier her!"
  set chat_Megatarget[4] = "Wir knnen diese Basis gemeinsam ausschalten!"
  set chat_Megatarget[5] = "{Name=Cybernetic}Armeestrke dieses Gegners: niedrig. Zerstrung wird eingeleitet."
  set chat_Megatarget_length = 6

  set chat_Taunt[0] = "Ich weiss viel mehr als du denkst!"
  set chat_Taunt[1] = "Denke nicht, da du Erfolg haben wirst mit was-auch-immer du gerade machst."
  set chat_Taunt[2] = "Aufgepasst! Ich habe einen Plan!"
  set chat_Taunt[3] = "Unterschtze niemals die Macht deines Computers!"
  set chat_Taunt[4] = "Deine Strategie wird bei mir niemals klappen."
  set chat_Taunt[5] = "Du denkst wahrscheinlich, da du dieses Spiel gewinnst, oder?"
  set chat_Taunt[6] = "Ich bin mchtiger als jeder Creep, dem du jemals begegnet bist."
  set chat_Taunt[7] = "Falls ich dieses Spiel verliere, kann ich deine schlechte CPU dafr verantwortlich machen."
  set chat_Taunt[8] = "Es kann nur EINEN geben, und das bin wohl ich!"
  set chat_Taunt[9] = "Meine Strategie fhrt zum Sieg, deine Strategie muss zur Niederlage fhren."
  set chat_Taunt[10] = "{Name=BORG}Widerstand ist zwecklos."
  set chat_Taunt[11] = "{Name=Hunter}Ich liebe die Jagd ... auf dich."
  set chat_Taunt[12] = "{Name=Cybernetic,Strength>70}Armeestrke: hoch. Zielsuche luft."
  set chat_Taunt[13] = "{Strength>60}Als [Race] bin ich unbesiegbar, also gib lieber gleich auf."
  set chat_Taunt_length = 14

  set chat_Thanks[0] = "Danke fr das Gold."
  set chat_Thanks[1] = "Danke, ich hab jetzt genug zum Weitermachen."
  set chat_Thanks_length = 2


  set chat_no_unit_selected = "Keine Einheit ausgewhlt"
  set chat_confirm_attack_unit = "Ich werde die gewhlte Einheit angreifen/verteidigen"
  set chat_towerrush = "Ich werde einen Towerrush durchfhren"
  set chat_no_orc = "Ich bin kein Ork"
  set militia_expansion_chat = "Ich mache hier jetzt eine Milizenexpansion"

endfunction

function InitChatArraysSwedish takes nothing returns nothing

  set chat_AGG[0] = "Det va kul att spela med dig."
  set chat_AGG[1] = "Kan inte hjlpas, jag r krd nu."
  set chat_AGG[2] = "Nu fr du klara dig utan mig."
  set chat_AGG[3] = "Spelet slut fr mig! Vi ses."
  set chat_AGG[4] = "Ojsan, jag har visst frlorat nu."
  set chat_AGG[5] = "Verkar som om [Race] inte var en s bra ras nr allt kommer omrkings, ses."
  set chat_AGG[6] = "Bara se hur det gr nr jag r [Color] istllet fr min favoritfrg ;("
  set chat_AGG_length = 7

  set chat_Ally[0] = "Vi kommer anfalla hr"
  set chat_Ally[1] = "Hjlp oss med detta anfallet om du vill"
  set chat_Ally[2] = "Alla anfall hr nu"
  set chat_Ally[3] = "Jag behver hjlp hr nu"
  set chat_Ally[4] = "Vi kan anfalla hr tillsammans"
  set chat_Ally[5] = "Kan du hjlpa oss att krossa dessa?"
  set chat_Ally[6] = "Vi ska rjja lite, kommer du?"
  set chat_Ally[7] = "Tror vi kan behva din hjlp hr, kom om du har tid."
  set chat_Ally[8] = "Sitt inte i basen och lata dig, kom och hjlp till!"
  set chat_Ally[9] = "Assistera om du vill, vi ska anfalla."
  set chat_Ally[10] = "Du kan hjlpa oss lite om du har lust [PlayerColor], vi ska anfalla hr nu."
  set chat_Ally_length = 11

  set chat_Attack[0] = "Jag anfaller denna fienden"
  set chat_Attack[1] = "Jag anfaller hr"
  set chat_Attack[2] = "Anfaller den hr"
  set chat_Attack[3] = "Skickar ett anfall hit nu"
  set chat_Attack[4] = "Anfaller hr nu"
  set chat_Attack[5] = "Jag tnker anfalla hr nu"
  set chat_Attack[6] = "Jag anfaller den [TargetColor:A] [TargetRace:EN]"
  set chat_Attack[7] = "Anfaller den [TargetColor:A] [TargetRace:EN] nu"
  set chat_Attack_length = 8

  set chat_Creep[0] = "Jag tar hand dom dessa creepsen"
  set chat_Creep[1] = "Ddar dom hr creepsen"
  set chat_Creep[2] = "Tar hand om dessa creepsen"
  set chat_Creep[3] = "Jag gr  creepar lite hr"
  set chat_Creep[4] = "Anfaller dessa creepsen"
  set chat_Creep_length = 5

  set chat_Done[0] = "Jag r klar hr nu"
  set chat_Done[1] = "Sticker ngon annanstans"
  set chat_Done[2] = "Jag gr o gr ngot annat nu"
  set chat_Done[3] = "Gr ngot annat nu"
  set chat_Done[4] = "Anfallet avklarat"
  set chat_Done_length = 5

  set chat_EGG[0] = "GG"
  set chat_EGG[1] = "Skit ocks, jag e borta nu :("
  set chat_EGG[2] = "Nsta gng ska jag vinna mot dig."
  set chat_EGG[3] = "Spelet r slut fr min del!"
  set chat_EGG[4] = "Jag mste sticka."
  set chat_EGG_length = 5

  set chat_Expansion[0] = "Jag rnsar den hr expansionen"
  set chat_Expansion[1] = "Jag tar vck creepsen frn den hr gruvan"
  set chat_Expansion[2] = "Jag kanske expanderar hr snart"
  set chat_Expansion[3] = "Snart blir denna gruvan tillgnglig"
  set chat_Expansion[4] = "Jag tar denna gruvan nu"
  set chat_Expansion[5] = "Snart kommer du se en [Color] bas hr"
  set chat_Expansion_length = 6

  set chat_Goldproblem[0] = "Ge mig lite guld annars sticker jag om 10 sekunder."
  set chat_Goldproblem[1] = "Ge mig guld fort annars sticker jag inom 10 sekunder."
  set chat_Goldproblem_length = 2

  set chat_Greet[0] = "Jag kommer krossa dig"
  set chat_Greet[1] = "Jag tror inte du har vad som krvs fr att besegra mig"
  set chat_Greet[2] = "Tusan!! , jag hatar denna kartan"
  set chat_Greet[3] = "Nej! Detta r den smsta startplatsen :("
  set chat_Greet[4] = "Hmm jag undrar var du startade :)"
  set chat_Greet[5] = "GL & Don't have fun"
  set chat_Greet[6] = "Vlkommen till helvetet"
  set chat_Greet[7] = "Nu kommer du inte undan"
  set chat_Greet[8] = "Jag vet redan var du startade"
  set chat_Greet[9] = "Den hr matchen kommer du frlora mot en dator"
  set chat_Greet[10] = "Detta kommer jag vinna ljligt enkelt :)"
  set chat_Greet[11] = "HaHa! detta kommer bli kul"
  set chat_Greet[12] = "Hoppas du inte har planerat att vinna denna matchen"
  set chat_Greet[13] = "Frbered dig p en besvikelse, om du tror att du kommer vinna denna matchen"
  set chat_Greet_length = 14

  set chat_Mega[0] = "Frbered dig p att d... snabbt"
  set chat_Mega[1] = "AHA! Du har inte en chans nu lngre"
  set chat_Mega[2] = "Detta kommer bli min avgrande stund"
  set chat_Mega[3] = "Snart kommer den hr matchen vara slut"
  set chat_Mega[4] = "Detta kommer bli ett exempel p mnnskligt felande"
  set chat_Mega[5] = "Det r inte mycket kvar av dig nu din lilla [TargetRace]"
  set chat_Mega[6] = "Du vet inte nr du ska sga 'GG'  lmna spelet va ?"
  set chat_Mega[7] = "Nu fr du frska spela riktigt bra eller s kan du lmna spelet :)"
  set chat_Mega[8] = "Det e bst att du brjar spela nu"
  set chat_Mega[9] = "Jag kommer lgga upp det hr replayet p internet med beskrivningen 'Hur man GER en mnniska.'"
  set chat_Mega[10] = "Hehe jag visste inte att [TargetRace]-spelare kunde vara s fruktansvrt dliga"
  set chat_Mega[11] = "Jag skall strax gra slut p ditt lidande snabbt och enkelt"
  set chat_Mega[12] = "nnu ett exempel som pekar p att [TargetColor]-spelare suger mest."
  set chat_Mega[13] = "Du borde lgga till kommentaren 'Alltid GD' i din profil p battle.net"
  set chat_Mega[14] = "Patetiskt, vilken [Race] som helst skulle ju kunna kl dig."
  set chat_Mega[15] = "Frbered dig p att bli GD av en [Race]!"
  set chat_Mega[16] = "Snart kommer du f se ett exempel p varfr [Color] r den bsta frgen"
  set chat_Mega_length = 17

  set chat_Megatarget[0] = "Hans frsvar r nere, ANFALL!"
  set chat_Megatarget[1] = "Om vi anfaller hr nu kommer vi vinna ltt"
  set chat_Megatarget[2] = "Den [TargetColor:A] [TargetRace:EN] r nstan dd nu, kom s krossar vi honom"
  set chat_Megatarget[3] = "Tror inte att den dr [TargetRace:EN] har s mycket mer att be fr nu"
  set chat_Megatarget[4] = "Nu har vi chansen att ta hand om den [TargetColor:A] [TargetRace:EN] kom igen!"
  set chat_Megatarget[5] = "[TargetColor] [TargetRace] ser ut att ha det dligt stllt, ANFALL!"
  set chat_Megatarget_length = 6

  set chat_Taunt[0] = "Jag vet mycket mer n du tror"
  set chat_Taunt[1] = "Tro inte att du kommer undan med det du sysslar med"
  set chat_Taunt[2] = "Se upp! jag har en plan"
  set chat_Taunt[3] = "Underskatta aldrig din dator"
  set chat_Taunt[4] = "Den strategin du anvnder kommer aldrig funka p mig"
  set chat_Taunt[5] = "Du tror sakert du kommer vinna denna matchen va?"
  set chat_Taunt[6] = "Jag r farligare an alla creep du kommer trffa p den hr banan"
  set chat_Taunt[7] = "Om jag frlorar den hr matchen kan jag ju alltid skylla p din dliga processor"
  set chat_Taunt[8] = "Det kommer bara vara en kvar efter denna matchen och det r JAG"
  set chat_Taunt[9] = "Min strategi leder till seger, din kommer leda till frlust"
  set chat_Taunt[10] = "[Race] r nog den bsta rasen av alla i spelet"
  set chat_Taunt[11] = "Jag hrde att undead r vldigt obalancerade i denna patchen"
  set chat_Taunt_length = 12

  set chat_Thanks[0] = "Tack fr guldet."
  set chat_Thanks[1] = "{OwnGold>=500}Tack, nu har jag s det rcker."
  set chat_Thanks[2] = "{OwnGold<=300}Tack, men jag behver nog lite mer n s."
  set chat_Thanks_length = 3


  set chat_no_unit_selected = "Ingen enhet vald."
  set chat_confirm_attack_unit = "Jag kommer anfalla/vakta den valda enheten."
  set chat_towerrush = "Jag kommer frska towerrush ngon."
  set chat_no_orc = "Jag r vl ingen Orc eller?"
  set militia_expansion_chat = "Jag gr militia expansion hr."

endfunction

function InitChatArraysFrench takes nothing returns nothing

  set chat_AGG[0] = "C'etait bien de jouer avec toi."
  set chat_AGG[1] = "Desole, je ne peux plus du tout aider.Je suis mort."
  set chat_AGG[2] = "Bon, vous allez devoir faire sans moi."
  set chat_AGG[3] = "Game over pour moi! A bientot."
  set chat_AGG[4] = "Toutes mes bases leurs appartiennent."
  set chat_AGG_length = 5

  set chat_Ally[0] = "On va attaquer ici."
  set chat_Ally[1] = "Rejoins nous pour cette attaque si tu le souhaites."
  set chat_Ally[2] = "Tout le monde attaque ici et maintenant!."
  set chat_Ally[3] = "J'ai besoin d'aide ici et maintenant."
  set chat_Ally[4] = "On peut prendre cette cible ensemble."
  set chat_Ally_length = 5

  set chat_Attack[0] = "Je vais attaquer cet ennemi."
  set chat_Attack[1] = "Je vais attaquer ici."
  set chat_Attack[2] = "J'attaque celui-ci."
  set chat_Attack[3] = "Je lance une attaque contre cette cible."
  set chat_Attack[4] = "J'attaque ici et maintenant."
  set chat_Attack_length = 5

  set chat_Creep[0] = "Je vais detruire ces creeps."
  set chat_Creep[1] = "Je vais tuer ces creeps."
  set chat_Creep[2] = "Je vais a la rencontre de ces creeps maintenant."
  set chat_Creep[3] = "Je me dirige pour obtenir ces creeps ici."
  set chat_Creep[4] = "J'attaque ici et maintenant."
  set chat_Creep_length = 5

  set chat_Done[0] = "Je me suis tablis ici maintenant."
  set chat_Done[1] = "Je me dirige autre part maintenant."
  set chat_Done[2] = "Je suis occupe a autre chose."
  set chat_Done[3] = "Je vais faire quelque chose d'autre maintenant."
  set chat_Done[4] = "Attaque realisee."
  set chat_Done_length = 5

  set chat_EGG[0] = "Belle partie."
  set chat_EGG[1] = "Mince, j'ai perdu face a un humain!."
  set chat_EGG[2] = "La prochaine fois, je vais te battre."
  set chat_EGG[3] = "Game over pour moi!."
  set chat_EGG[4] = "Je dois partir."
  set chat_EGG_length = 5

  set chat_Expansion[0] = "Je degage cette expansion."
  set chat_Expansion[1] = "Je vais tuer ces creeps devant cette mine."
  set chat_Expansion[2] = "Je pourrais m'installer ici bientt."
  set chat_Expansion[3] = "Cette mine sera bientot libre."
  set chat_Expansion[4] = "Je vais prendre cette mine maintenant."
  set chat_Expansion_length = 5

  set chat_Goldproblem[0] = "STP, donne moi un peu d'argent ou je vais devoir quitter d'ici 10 secondes."
  set chat_Goldproblem[1] = "J'ai un besoin urgent d'argent. Sans or supplementaire, je vais quitter d'ici 10 secondes."
  set chat_Goldproblem_length = 2

  set chat_Greet[0] = "Je vais t'ecraser."
  set chat_Greet[1] = "Je ne pense pas que tu as ce qui est necessaire."
  set chat_Greet[2] = "Soit maudit, je deteste cette carte."
  set chat_Greet[3] = "NOOON!! Ce lieu de depart pue vraiment..."
  set chat_Greet[4] = "Hmm... Je suppose savoir ou tu as commenc! :)"
  set chat_Greet[5] = "Bonne chance et prend aucun plaisir."
  set chat_Greet[6] = "Bienvenue en enfer !"
  set chat_Greet[7] = "Tu peux courir, mais tu ne peux pas te cacher."
  set chat_Greet[8] = "Je sais ou tu as commence."
  set chat_Greet[9] = "Cette fois, tu vas perdre contre l'ordinateur."
  set chat_Greet[10] = "Tu vas soufrir enormement entre mes mains !"
  set chat_Greet_length = 11

  set chat_Mega[0] = "Prepare toi a rencontrer ton pire cauchemar."
  set chat_Mega[1] = "HAHA! Tu n'as aucune chance."
  set chat_Mega[2] = "Cela va etre mon heure la plus agreable."
  set chat_Mega[3] = "Cette partie sera bientot terminee."
  set chat_Mega[4] = "Cela va etre un exemple des faiblesses humaines."
  set chat_Mega[5] = "Il ne reste plus grand chose a toi maintenant."
  set chat_Mega[6] = "Tu ne sais pas quand il est temps de dire 'GG' et de partir, n'est-ce pas?"
  set chat_Mega[7] = "Maintenant, tu ferais mieux d'essayer de jouer bien mieux ou alors quitte cette partie maintenant:)."
  set chat_Mega[8] = "Tu ferais bien mieux de commencer a jouer maintenant."
  set chat_Mega[9] = "J'ai deja creuse une belle tombe pour toi."
  set chat_Mega[10] = "Toute ta base nous appartient."
  set chat_Mega_length = 11

  set chat_Megatarget[0] = "Sa defense est tombee, ATTAQUEZ!."
  set chat_Megatarget[1] = "J'envoie tout ce que j'ai ici."
  set chat_Megatarget[2] = "Si on attaque ici maintenant alors on va gagner, c'est sur."
  set chat_Megatarget[3] = "Envois tout ce que tu as ici."
  set chat_Megatarget[4] = "On peut prendre cette base si on se depeche."
  set chat_Megatarget_length = 5

  set chat_Taunt[0] = "J'en connais bien plus que tu ne peux le croire."
  set chat_Taunt[1] = "Ne pense pas t'en sortir, et ce quoique tu fasses."
  set chat_Taunt[2] = "Attention ! J'ai un plan."
  set chat_Taunt[3] = "Ne jamais sous-estimer le pouvoir de ton ordinateur."
  set chat_Taunt[4] = "La strategie que tu essayes ne marchera jamais sur moi."
  set chat_Taunt[5] = "Tu dois surement penser que tu vas gagner cette partie, n'est-ce pas?"
  set chat_Taunt[6] = "Je suis bien plus fort que tous les creeps que tu as pu rencontrer auparavant."
  set chat_Taunt[7] = "Si je perds cette partie, je ne peux m'en prendre qu'a ta pauvre  unite centrale de traitement."
  set chat_Taunt[8] = "Il ne peut en rester qu'un et cela ne peut qu'etre moi."
  set chat_Taunt[9] = "Ma strategie mene a la victoire, ta strategie mene a la defaite."
  set chat_Taunt_length = 10

  set chat_Thanks[0] = "Merci pour l'or."
  set chat_Thanks[1] = "Merci, j'en ai maintenant assez pour continuer."
  set chat_Thanks_length = 2


  set chat_no_unit_selected = "Pas d'unite selectionnee."
  set chat_confirm_attack_unit = "Je vais attaquer/garder l'unite selectionnee."
  set chat_towerrush = "je vais essayer de me magner de construire des tourelles."
  set chat_no_orc = "Je ne suis pas un vert orc mordu par les puces infectees par levure !"
  set militia_expansion_chat = "Je vais faire des expansions militaires ici"

endfunction

function InitChatArraysSpanish takes nothing returns nothing

  set chat_AGG[0] = "Fue divertido jugar contigo."
  set chat_AGG[1] = "Lo siento, ya no puedo ayudar, me voy."
  set chat_AGG[2] = "Tendras que hacerlo sin mi."
  set chat_AGG[3] = "Fin del juego para mi, nos vemos."
  set chat_AGG[4] = "Conquistaron todas mis bases!"
  set chat_AGG[5] = "Se nota que los [RACE:S] estan muy mal en esta versin, nunca mas los voy a usar."
  set chat_AGG[6] = "{Random<=10} De no ser por ti, no hubiera perdido!"
  set chat_AGG[7] = "{Owngold<=100} Fue por falta de oro, lo siento."
  set chat_AGG[8] = "{Ownlumber<=100} Fue por falta de madera, lo siento."
  set chat_AGG[9] = "Los [RANDOMRACE:S] estn muy desbalanceados."
  set chat_AGG[10] = "[NAME] se va de aqui."
  set chat_AGG[11] = "Nunca fu bueno en mapas [MAPSIZE:S]"
  set chat_AGG_length = 12

  set chat_Ally[0] = "Vamos a atacar aqu."
  set chat_Ally[1] = "nete a este ataque si tu deseas"
  set chat_Ally[2] = "Todos ataquen aqu ahora!"
  set chat_Ally[3] = "Necesito ayuda por aqu"
  set chat_Ally[4] = "Podemos vencerlos juntos!"
  set chat_Ally_length = 5

  set chat_Attack[0] = "Estoy atacando a este [TARGETRACE] [TARGETCOLOR]"
  set chat_Attack[1] = "Estoy atacando aqui."
  set chat_Attack[2] = "Voy a atacar a unos [TARGETRACE:s] [TARGETCOLOR:s]"
  set chat_Attack[3] = "Lanzando un ataque a [TARGETRACE] [TARGETCOLOR]"
  set chat_Attack_length = 4

  set chat_Creep[0] = "Me estoy llevando a estos creeps"
  set chat_Creep[1] = "Destruyendo a estos creeps"
  set chat_Creep[2] = "Limpiando a este grupo de creeps"
  set chat_Creep[3] = "Voy a recolectar experiancia aqui"
  set chat_Creep[4] = "Atacando aqui ahora"
  set chat_Creep[5] = "{owngold<=400} Solamente tengo [owngold], mejor ataco unos neutrales."
  set chat_Creep[6] = "A los [RACE:s] les va mejor cuando creepean."
  set chat_Creep_length = 7

  set chat_Done[0] = "Termino mi trabajo aqui"
  set chat_Done[1] = "Ahora estoy nuscando otro rumbo"
  set chat_Done[2] = "Voy por otra cosa"
  set chat_Done[3] = "Voy a intentar algo diferente"
  set chat_Done[4] = "Ataque completado"
  set chat_Done_length = 5

  set chat_EGG[0] = "Buen juego"
  set chat_EGG[1] = "Diablos! perdi contra un ser humano!"
  set chat_EGG[2] = "La proxima vez te vencere."
  set chat_EGG[3] = "Mi juego se acabo."
  set chat_EGG[4] = "Me tengo que ir."
  set chat_EGG[5] = "{RACE!=PLAYERRACE} Tena que ser un tramposo que usa sus [PLAYERRACE:s] desbalanceados, a la prxima no tendr piedad!"
  set chat_EGG[6] = "Tuviste la suerte de que estaba usando [RACE:S] , con otras razas soy invencible!"
  set chat_EGG[7] = "{owngold<=200} Tu pura suerte de que me faltaba oro."
  set chat_EGG[8] = "{RACE!=PLAYERRACE} Un [PLAYERRACE] venciendo a un [RACE] , vaya novedad!"
  set chat_EGG[9] = "{RACE!=PLAYERRACE} No puede ser!, perd contra unos [PLAYERRACE:s]!"
  set chat_EGG[10] = "{RACE!=PLAYERRACE} Cuando blizzard repar a tu raza, la historia ser muy diferente."
  set chat_EGG[11] = "{RANDOM<=10} Esta bien, lo acepto, jugaste mejor que yo."
  set chat_EGG_length = 12

  set chat_Expansion[0] = "Estoy limpiando esta mina"
  set chat_Expansion[1] = "Voy a destruir los creeps the esta mina"
  set chat_Expansion[2] = "Voy a expandirme aqui pronto"
  set chat_Expansion[3] = "Esta mina estara lista pronto"
  set chat_Expansion[4] = "Estoy yendo a esta mina"
  set chat_Expansion_length = 5

  set chat_Goldproblem[0] = "Por favor dame algo de oro o tendre que rendirme en 10 segundos, apenas llego a [OWNGOLD] !"
  set chat_Goldproblem[1] = "Necesito dinero urgentemente. Si no me das oro me rendir en 10 segundos, Solamente tengo [OWNGOLD] !"
  set chat_Goldproblem[2] = "No creo poder sobrevivir con solo [OWNGOLD] , si no me prestas un poco, me retirar en 10 segundos."
  set chat_Goldproblem_length = 3

  set chat_Greet[0] = "Seras destruido"
  set chat_Greet[1] = "No creo que tengas lo necesario para vencerme"
  set chat_Greet[2] = "Diablos! odio este mapa"
  set chat_Greet[3] = "NOOO!! Este lugar apesta!"
  set chat_Greet[4] = "{MapSize!=MEDIUM} Este mapa es muy [mapsize] !"
  set chat_Greet[5] = "{FFA} Siempre tengo mucha suerte cuando es todos contra todos..."
  set chat_Greet[6] = "{1on1} Espero que este sea un duelo mano a mano justo y que por tanto yo sea el ganador."
  set chat_Greet[7] = "{1on1} T solo contra m? Esto va a ser muy facil."
  set chat_Greet[8] = "{1on1} No tienes oportunidad."
  set chat_Greet[9] = "{random>=100} Estoy de suerte hoy, as que no esperes ganar."
  set chat_Greet[10] = "Emm... Me pregunto donde comenzaste :)"
  set chat_Greet[11] = "Buena suerte y no te diviertas"
  set chat_Greet[12] = "Bienvenido al infierno!"
  set chat_Greet[13] = "Puedes correr pero no esconderte"
  set chat_Greet[14] = "Ya s donde comenzaste"
  set chat_Greet[15] = "Esta vez perderas contra la computadora"
  set chat_Greet[16] = "Te are sufrir como nunca !"
  set chat_Greet[17] = "Hola, no esperes ganar!"
  set chat_Greet_length = 18

  set chat_Mega[0] = "Preparate para conocer tu condena!"
  set chat_Mega[1] = "JAJA! No tienes oportunidad"
  set chat_Mega[2] = "Esta sera mi mejor hora"
  set chat_Mega[3] = "Este juego se acabara pronto"
  set chat_Mega[4] = "Este sera un ejemplo de la imperfeccion de la humanidad"
  set chat_Mega[5] = "Ya no queda mucho de ti por destruir"
  set chat_Mega[6] = "No sabes cuando es el momento de rendirte, verdad?"
  set chat_Mega[7] = "Sera mejor que empieces a jugar bien o rendirte ahora :)"
  set chat_Mega[8] = "Es hora de que empieces a jugar"
  set chat_Mega[9] = "Ya tengo lista una linda tumba para enterrarte"
  set chat_Mega[10] = "Tengo lista una armada al mejor estilo [race] para destruirte."
  set chat_Mega[11] = "{playerrace!=race} Cuntos [RACE:S] se necesitan para vencer a unos [PLAYERRACE:s]? Ya te enterars de la respuesta..."
  set chat_Mega[12] = "{playerrace!=race,race=orc} No esperes piedad, somos los brutales orcos que no conocemos tal cosa!"
  set chat_Mega[13] = "{playerrace!=race,race=nightelf} No solo somos ecologistas, tambin ganamos algunas batallas, como la que podrs presenciar ahora."
  set chat_Mega[14] = "{playerrace!=race,race=human} La alianza de humanos, elfos y enanos, Acabar con sus [playerrace:s] de juguete!"
  set chat_Mega[15] = "{playerrace!=race,race=undead} Los muertos vivientes ya vamos a conseguir refuerzos a partir de tus unidades..."
  set chat_Mega[16] = "(race=playerrace} Yo soy mucho mejor manejando a los [race:s], lo comprobars muy pronto."
  set chat_Mega[17] = "Yo, [NAME], ser el fin de tu ejrcito!"
  set chat_Mega[18] = "Temblad ante el gran [NAME] !"
  set chat_Mega_length = 19

  set chat_Megatarget[0] = "Se acabaron sus defensas, ATAQUEN!"
  set chat_Megatarget[1] = "Estoy mandando todo lo que tengo contra estos [TARGETRACE:s] [TARGETCOLOR:s] !"
  set chat_Megatarget[2] = "Si atacamos al [TARGETRACE] [TARGETCOLOR], es seguro que ganamos"
  set chat_Megatarget[3] = "Manda todo lo que tienes contra el [TARGETRACE] [TARGETCOLOR]."
  set chat_Megatarget[4] = "Podemos destruir esta base si nos apuramos!"
  set chat_Megatarget_length = 5

  set chat_Taunt[0] = "S mucho mas de lo que crees."
  set chat_Taunt[1] = "No creas que podrs escapar de m, con lo que sea que estes haciendo."
  set chat_Taunt[2] = "Cuidado! Tengo un plan."
  set chat_Taunt[3] = "Esa estrategia que estas intentando nunca funcionara conmigo."
  set chat_Taunt[4] = "Probablemente piensas que vas a ganar, no ?"
  set chat_Taunt[5] = "Soy mas fuerte que cualquier creep que hayas visto."
  set chat_Taunt[6] = "Si pierdo puedo culpar a tu pobre CPU."
  set chat_Taunt[7] = "{1on1} Aqui solamente hay espacio para UNO, y ese soy yo!"
  set chat_Taunt[8] = "Mi estrategia lleva a la victoria, la tuya a la derrota."
  set chat_Taunt[9] = "{FFA} Mi estrategia es perfecta, soy mucho ms rapido ordenando mis unidades, Y no siento miedo, temor ni confianza, todos los jugadores humanos que he enfrentado fueron acabados!"
  set chat_Taunt[10] = "Buen momento para probar mi nueva estrategia."
  set chat_Taunt[11] = "{RACE!=PLAYERRACE} Sucumbirs ante [Race:UBER]!"
  set chat_Taunt[12] = "{FFA} Pertenezco a [Race:UBER] , Ninguno de ustedes tiene oportunidad."
  set chat_Taunt[13] = "{FFA} No puede ser que todos mis adversarios sean tan dbiles!"
  set chat_Taunt[14] = "Te aconsejo rendirte antes que pasar la verguenza de la derrota"
  set chat_Taunt[15] = "{1on1} No creo que ests listo para un duelo mano a mano contra el gran [NAME] !"
  set chat_Taunt[16] = "{1on1} Nunca subestimes el poder de tu computadora."
  set chat_Taunt[17] = "{1on1} Yo s dnde ests, tengo una mejor estrategia, soy ms rpido, y no soy un dbil ser humano como t, En verdad crees que tu plan funcionar contra todas mis capacidades?"
  set chat_Taunt[18] = "{1on1} S como juegas, y creeme que tendrs que seguir intentando contra un ser humano o una inteligencia artificial inferior."
  set chat_Taunt[19] = "{1on1} Esto no ser una prctica, ser la total anhiquilacin!"
  set chat_Taunt[20] = "{1on1} No creo que puedas t solo contra m."
  set chat_Taunt[21] = "El grad [name] acabar con todo aquel que se le interponga en el camino!"
  set chat_Taunt_length = 22

  set chat_Thanks[0] = "Gracias por el oro."
  set chat_Thanks[1] = "Gracias, ahora puedo continuar ."
  set chat_Thanks[2] = "{owngold<=200} Ahora tengo [owngold] no es gran cosa, pero algo es algo."
  set chat_Thanks[3] = "{owngold>=1000} Tal vz te excediste un poco, puedo valerme por mi mismo con mucho menos de [owngold]."
  set chat_Thanks[4] = "{random>=70} Gracias, ahora acabemos con nuestros obstculos!"
  set chat_Thanks[5] = "{random<=20} Deberas invertir todo tu oro en m, eso nos dara muchas mas posibilidades de ganar."
  set chat_Thanks[6] = "Veamos qu puedo hacer con el total de [owngold] de oro que tengo."
  set chat_Thanks_length = 7


  set chat_no_unit_selected = "Ninguna unidad esta seleccionada"
  set chat_confirm_attack_unit = "Voy a atacar/proteger la unidad seleccionada"
  set chat_towerrush = "Voy a tratar de usar mis torres con alguien"
  set chat_no_orc = "Yo no soy un orco verde pulgoso y asqueroso!"
  set militia_expansion_chat = "Voy a intentar una expansion con milicianos aqui"

endfunction

function InitChatArraysRomanian takes nothing returns nothing

  set chat_AGG[0] = "A fost super sa joc cu tine."
  set chat_AGG[1] = "Sorry, nu te mai pot ajuta. Sint terminat."
  set chat_AGG[2] = "Ei bine, va trebuii sa te descurci fara mine."
  set chat_AGG[3] = "Meciul s-a terminat pentru mine! La revedere."
  set chat_AGG[4] = "Toate bazele mele apartin lor!"
  set chat_AGG_length = 5

  set chat_Ally[0] = "Vom ataca aici"
  set chat_Ally[1] = "Hai cu noi in acest atac daca vrei"
  set chat_Ally[2] = "Toata lumea sa atace aici!"
  set chat_Ally[3] = "Am nevoie de ajutor"
  set chat_Ally[4] = "Putem sa distrugem tinta asta impreuna"
  set chat_Ally_length = 5

  set chat_Attack[0] = "Atac acest inamic"
  set chat_Attack[1] = "Atac aici"
  set chat_Attack[2] = "Il atac pe asta"
  set chat_Attack[3] = "Pornesc atacul asupra acestei tinte"
  set chat_Attack[4] = "Atac acum aici"
  set chat_Attack_length = 5

  set chat_Creep[0] = "O sa scot din lupta monstrii astia"
  set chat_Creep[1] = "O sa omor monstrii astia"
  set chat_Creep[2] = "Ma duc la grupul asta de monstrii"
  set chat_Creep[3] = "Ma duc spre monstrii astia de aici"
  set chat_Creep[4] = "Acum atac aici"
  set chat_Creep_length = 5

  set chat_Done[0] = "Aici am terminat"
  set chat_Done[1] = "Ma duc in alta parte acum"
  set chat_Done[2] = "Ma duc sa fac altceva"
  set chat_Done[3] = "O sa fac atceva acum"
  set chat_Done[4] = "Atacul e complet"
  set chat_Done_length = 5

  set chat_EGG[0] = "GG"
  set chat_EGG[1] = "Rahat, am pierdut contra unui om!"
  set chat_EGG[2] = "Data viitoare o sa te inving."
  set chat_EGG[3] = "Meciul s-a terminat pentru mine!"
  set chat_EGG[4] = "Trebuie sa plec."
  set chat_EGG_length = 5

  set chat_Expansion[0] = "Curat aceasta expansiune"
  set chat_Expansion[1] = "O sa curat monstrii din mina asta"
  set chat_Expansion[2] = "Cred ca o sa ma extind aici curind"
  set chat_Expansion[3] = "Mina asta va fi disponibila curind"
  set chat_Expansion[4] = "Ma duc la mina asta acum"
  set chat_Expansion_length = 5

  set chat_Goldproblem[0] = "Te rog da-mi niste bani sau plec in 10 secunde."
  set chat_Goldproblem[1] = "Sint in criza de bani. Fara bani voi pleca in 10 secunde"
  set chat_Goldproblem_length = 2

  set chat_Greet[0] = "O sa te sparg"
  set chat_Greet[1] = "Nu cred ca esti facut pentru asta"
  set chat_Greet[2] = "In 'zda masii, urasc harta asta"
  set chat_Greet[3] = "Nuu!! Locul asta e super nasol"
  set chat_Greet[4] = "Hmm... ma intreb unde esti :)"
  set chat_Greet[5] = "Bafta & sa nu te distrezi"
  set chat_Greet[6] = "Bine ai venit in iad !"
  set chat_Greet[7] = "Poti sa fugi, dar nu te poti ascunde"
  set chat_Greet[8] = "Stiu de unde ai pornit"
  set chat_Greet[9] = "De data asta vei pierde contra unui Computer"
  set chat_Greet[10] = "Vei suferi mult in miinile mele !"
  set chat_Greet_length = 11

  set chat_Mega[0] = "Pregatestete sa mori"
  set chat_Mega[1] = "HAHA! Nu ai nici o sansa"
  set chat_Mega[2] = "Asta va fi culmea gloriei mele"
  set chat_Mega[3] = "Meciul se va termina curind"
  set chat_Mega[4] = "Asta va fi un exemplu de esec uman"
  set chat_Mega[5] = "Nu prea a ramas mult din tine"
  set chat_Mega[6] = "Nu prea stii cind e timpul sa zici 'GG' si sa pleci, nu ?"
  set chat_Mega[7] = "Mai bine ai incerca sa joci super bine sau altfel ar trebuii sa pleci :)"
  set chat_Mega[8] = "Mai bine ai incerca sa joci si tu"
  set chat_Mega[9] = "Tocmai ti-am sapat un mormint foarte frumos"
  set chat_Mega[10] = "Toata baza ta sint ale noastre"
  set chat_Mega_length = 11

  set chat_Megatarget[0] = "Apararea lui este la pamint, Atacati!"
  set chat_Megatarget[1] = "Trimit tot ce am aici"
  set chat_Megatarget[2] = "Daca vom ataca acum vom cistiga cu siguranta"
  set chat_Megatarget[3] = "Trimite tot ce ai aici"
  set chat_Megatarget_length = 4

  set chat_Taunt[0] = "Stiu mult mai mult decit crezi tu"
  set chat_Taunt[1] = "Sa nu crezi ca scapi cu ce faci tu acolo"
  set chat_Taunt[2] = "Pazea! Am un plan"
  set chat_Taunt[3] = "Niciodata sa nu subestimezi puterea calculatorului tau"
  set chat_Taunt[4] = "Strategia aia pe care o incerci nu va merge niciodata cu mine"
  set chat_Taunt[5] = "Tu crezi acum ca vei cistiga meciul asta nu ?"
  set chat_Taunt[6] = "Sint mult mai puternic decit orice creep pe care l-ai intilnit"
  set chat_Taunt[7] = "Daca pierd meciul asta pot sa dau vina pe procesorul tau slab"
  set chat_Taunt[8] = "Numai unu poate ramine si s-ar putea sa fiu eu ala"
  set chat_Taunt[9] = "Strategia mea conduce catre victorie, a ta catre infringere"
  set chat_Taunt_length = 10

  set chat_Thanks[0] = "Multumesc pentru bani."
  set chat_Thanks[1] = "Multumesc, am destul ca sa continui."
  set chat_Thanks_length = 2


  set chat_no_unit_selected = "Nici o unitate selectata"
  set chat_confirm_attack_unit = "Voi ataca/apara unitatea selectata"
  set chat_towerrush = "Voi incerca un towerrush"
  set chat_no_orc = "Nu sint un orc, verde, si mincat de purici!"
  set militia_expansion_chat = "Voi face militia expansion aici"

endfunction

function InitChatArraysRussian takes nothing returns nothing

  set chat_AGG[0] = "  ."
  set chat_AGG[1] = "  ."
  set chat_AGG[2] = ",     [Race:OFF]  :("
  set chat_AGG[3] = ",     ,   [Color:A]!"
  set chat_AGG[4] = "!       , !"
  set chat_AGG[5] = " ."
  set chat_AGG[6] = "{Random>=50}  !!"
  set chat_AGG[7] = "    . ."
  set chat_AGG[8] = "{Random>=50}  !     ,    !"
  set chat_AGG[9] = ",  ... !"
  set chat_AGG[10] = ",  , , ,   ,    ,    ."
  set chat_AGG_length = 11

  set chat_Ally[0] = "  ."
  set chat_Ally[1] = "   !"
  set chat_Ally[2] = " ."
  set chat_Ally[3] = " [Race:AYA]     ! !"
  set chat_Ally[4] = "   ."
  set chat_Ally[5] = "{Race=ELF}  !  ! , ...  ,  !"
  set chat_Ally[6] = "!"
  set chat_Ally[7] = " !"
  set chat_Ally[8] = "   . !"
  set chat_Ally[9] = " ,    ..."
  set chat_Ally[10] = ", ."
  set chat_Ally[11] = "{Race=UNDEAD}  !   !"
  set chat_Ally[12] = ", , !   !"
  set chat_Ally_length = 13

  set chat_Attack[0] = "-... *  * , [TargetColor] [TargetRace] -   ."
  set chat_Attack[1] = ",  :  - [TargetColor],  - [TargetRace]."
  set chat_Attack[2] = ",   [TargetColor:E] [TargetRace:S] -    ."
  set chat_Attack[3] = "       [TargetColor:X] [TargetRace:S]?"
  set chat_Attack[4] = ", [TargetColor]  ,    !"
  set chat_Attack[5] = "   ! : [TargetColor].     ?!"
  set chat_Attack[6] = "     APM'.  .  !"
  set chat_Attack[7] = " [TargetColor:X]    [TargetColor:X],    ..."
  set chat_Attack[8] = " [TargetColor:A] ?  , - :)"
  set chat_Attack[9] = " [TargetColor]  :D       ."
  set chat_Attack[10] = "     ! , [TargetColor],    ."
  set chat_Attack[11] = ", [TargetColor:A]  ?"
  set chat_Attack_length = 12

  set chat_Creep[0] = "."
  set chat_Creep[1] = "     !"
  set chat_Creep[2] = "   ."
  set chat_Creep[3] = " ."
  set chat_Creep[4] = "."
  set chat_Creep[5] = "   -      ?   ?"
  set chat_Creep[6] = "--."
  set chat_Creep[7] = "-1 ."
  set chat_Creep[8] = "     ."
  set chat_Creep[9] = "? ... !"
  set chat_Creep[10] = " =    ."
  set chat_Creep_length = 11

  set chat_Done[0] = "   ?"
  set chat_Done[1] = "."
  set chat_Done[2] = "   ."
  set chat_Done[3] = " ."
  set chat_Done[4] = "   , ?"
  set chat_Done[5] = "  ,    ."
  set chat_Done[6] = "*  *"
  set chat_Done[7] = ",     -   10,   ."
  set chat_Done[8] = " .  .  ."
  set chat_Done[9] = "    , ?"
  set chat_Done_length = 10

  set chat_EGG[0] = "!"
  set chat_EGG[1] = " !"
  set chat_EGG[2] = " ,     ."
  set chat_EGG[3] = "   , !"
  set chat_EGG[4] = "! ,  ."
  set chat_EGG[5] = "  , ! !"
  set chat_EGG[6] = "{Race!=ELF}! , [Race] !"
  set chat_EGG[7] = "{Race=ELF}! , [Race] !"
  set chat_EGG[8] = "!   !"
  set chat_EGG[9] = "    . ,   [Color], !"
  set chat_EGG[10] = " ."
  set chat_EGG[11] = "-,          !  !"
  set chat_EGG_length = 12

  set chat_Expansion[0] = "    ."
  set chat_Expansion[1] = " ."
  set chat_Expansion[2] = "   ."
  set chat_Expansion[3] = "   ."
  set chat_Expansion[4] = "...   ...   ..."
  set chat_Expansion[5] = "     !"
  set chat_Expansion_length = 6

  set chat_Goldproblem[0] = "      , , ?!   [CurrentGold]!   , !"
  set chat_Goldproblem[1] = ",     ... ?"
  set chat_Goldproblem[2] = ".   . ."
  set chat_Goldproblem[3] = "{CurrentGold<100}!   [CurrentGold] ! !"
  set chat_Goldproblem[4] = "Pay tribute to your king.    ."
  set chat_Goldproblem[5] = "... ... ... ... ... ..."
  set chat_Goldproblem[6] = " $$$?  ?"
  set chat_Goldproblem[7] = "  ... ?"
  set chat_Goldproblem[8] = "  ,  -.     [CurrentGold]."
  set chat_Goldproblem[9] = "           ."
  set chat_Goldproblem[10] = ",  ..."
  set chat_Goldproblem_length = 11

  set chat_Greet[0] = "!     [PlayerColor:A] :)"
  set chat_Greet[1] = "{1on1}, [Color]  [PlayerColor]!  ..."
  set chat_Greet[2] = ", .  ,  ,    :("
  set chat_Greet[3] = "! +1    ! !"
  set chat_Greet[4] = " [Color]!"
  set chat_Greet[5] = "    ."
  set chat_Greet[6] = "    ?"
  set chat_Greet[7] = "GL & HF."
  set chat_Greet[8] = ",  !"
  set chat_Greet_length = 9

  set chat_Mega[0] = "    , [TargetColor]!"
  set chat_Mega[1] = ", [TargetColor]."
  set chat_Mega[2] = ", [TargetColor:E] [TargetRace:S] -  gg."
  set chat_Mega[3] = "   -... -  ."
  set chat_Mega[4] = "-,  ,    - ! :D"
  set chat_Mega[5] = "    ,    ...  -  ."
  set chat_Mega[6] = "   ,   ."
  set chat_Mega[7] = "     !"
  set chat_Mega[8] = "     . ."
  set chat_Mega[9] = "  ? !"
  set chat_Mega[10] = " , [TargetColor],       .    ."
  set chat_Mega[11] = "Press any key to quit. ! Alt+QQ -  . Alt+QX -   ."
  set chat_Mega[12] = "     !   !"
  set chat_Mega[13] = "     ."
  set chat_Mega[14] = "   -   ."
  set chat_Mega[15] = "-, [Race:S] - !"
  set chat_Mega[16] = " !"
  set chat_Mega_length = 17

  set chat_Megatarget[0] = "  [TargetColor:A]!"
  set chat_Megatarget[1] = ",     ,  !"
  set chat_Megatarget[2] = " ,    !"
  set chat_Megatarget[3] = "  !  [TargetColor:X] [TargetRace:OFF]!"
  set chat_Megatarget[4] = ", , !  !"
  set chat_Megatarget[5] = "  ,   !"
  set chat_Megatarget[6] = " ! !"
  set chat_Megatarget[7] = ":   [TargetColor:A]!"
  set chat_Megatarget[8] = "!  !  ,  ..."
  set chat_Megatarget_length = 9

  set chat_Taunt[0] = "[1on1]  ."
  set chat_Taunt[1] = " ..."
  set chat_Taunt[2] = ",   , , ..."
  set chat_Taunt[3] = "     ."
  set chat_Taunt[4] = "    .  ."
  set chat_Taunt[5] = ",    :)"
  set chat_Taunt[6] = " 7 ... 7  ...  7 ."
  set chat_Taunt[7] = "  ?  ?    ..."
  set chat_Taunt[8] = " --   ..."
  set chat_Taunt[9] = "     :)"
  set chat_Taunt[10] = "   ?"
  set chat_Taunt_length = 11

  set chat_Thanks[0] = " !"
  set chat_Thanks[1] = "  - :) ."
  set chat_Thanks[2] = "."
  set chat_Thanks[3] = "  !"
  set chat_Thanks[4] = "!"
  set chat_Thanks[5] = "   , ."
  set chat_Thanks[6] = "  !"
  set chat_Thanks[7] = ", !  ! "
  set chat_Thanks[8] = "    -  ."
  set chat_Thanks[9] = "   !"
  set chat_Thanks[10] = "  ?"
  set chat_Thanks_length = 11


  set chat_no_unit_selected = "      ,    ."
  set chat_confirm_attack_unit = "   /   ."
  set chat_towerrush = "  -  ."
  set chat_no_orc = "  ,  ..."
  set militia_expansion_chat = "       ."

endfunction

function InitChatArraysPortuguese takes nothing returns nothing

  set chat_AGG[0] = "Sou bom quando estou morto. Bom jogo."
  set chat_AGG[1] = "Fui vencido por [PlayerColor] [PlayerRace]. gg"
  set chat_AGG[2] = "Foi bom enquanto durou. Mas voc ainda pode vencer!"
  set chat_AGG[3] = "Desculpe, galera, mas tenho que ir. Bom divertimento."
  set chat_AGG[4] = "Eu odeio n00bs! Voc fez eu perder!"
  set chat_AGG[5] = "No posso evitar, tudo isso foi culpa sua!"
  set chat_AGG[6] = "J era, cara, j era!!!"
  set chat_AGG[7] = "Esse  o fim para mim.  Segure, e talvez vena!"
  set chat_AGG[8] = " o fim!"
  set chat_AGG[9] = "Eu no posso acreditar [Color] [Race] perdeu para algum como voc!"
  set chat_AGG_length = 10

  set chat_Ally[0] = "Vamos, reunir aqui!"
  set chat_Ally[1] = "Rena sua armada [PlayerRace] para um ataque!"
  set chat_Ally[2] = "Vamos l, vamos acabar com esses [TargetRace] malditos!"
  set chat_Ally[3] = "Recuar, reagrupar aqui e atacar!"
  set chat_Ally[4] = "Todos ataquem o [TargetColor] aqui!"
  set chat_Ally[5] = "Presciso de reforos para atacar o [TargetColor]."
  set chat_Ally[6] = "Concentre-se no alvo, concentre-se no alvo!"
  set chat_Ally[7] = "Deveramos concentrar nosso ataque aqui."
  set chat_Ally[8] = "Vamos devastar esse pattico [TargetColor] [TargetRace]!"
  set chat_Ally[9] = "Mandemos uma fora de assalto aqui."
  set chat_Ally_length = 10

  set chat_Attack[0] = "Vou lanar uma ofensiva aqui."
  set chat_Attack[1] = "Vou tomar estes [TargetColor] [TargetRace] de assalto, venha!"
  set chat_Attack[2] = "Red-5 ao seu dispor."
  set chat_Attack[3] = "Me dem cobertura, vou entrar!"
  set chat_Attack[4] = "Atacando o [TargetColor] [TargetRace] aqui."
  set chat_Attack[5] = "Atacando [TargetColor] [TargetRace] nessa localizao."
  set chat_Attack[6] = "Cuidado!"
  set chat_Attack[7] = "A defesa caiu!"
  set chat_Attack[8] = "Vamos tomar o exrcito [TargetRace] bem aqui."
  set chat_Attack[9] = "Agora  a nossa chance, vamos peg-los!"
  set chat_Attack_length = 10

  set chat_Creep[0] = "Vou creepar um pouco."
  set chat_Creep[1] = "Vou aumentar meu nvel de [Race].  Matando estes creeps aqui."
  set chat_Creep[2] = "Se livrando dos creeps..."
  set chat_Creep[3] = "Creepando bem aqui."
  set chat_Creep[4] = "Um creep bom  um creep morto."
  set chat_Creep[5] = "Siga-me [TargetRace], vamos creepar."
  set chat_Creep[6] = "Vamos avanar de nvel."
  set chat_Creep[7] = "Pilhagem da boa aqui, vamos!"
  set chat_Creep[8] = "Venha, vamos pegar alguns itens."
  set chat_Creep[9] = "Vamos creepar por um tempo."
  set chat_Creep_length = 10

  set chat_Done[0] = "O que voc quer fazer agora?  [TargetColor] [TargetRace] de novo?"
  set chat_Done[1] = "Ei, bela ttica atacando aquele [TargetColor] [TargetRace]."
  set chat_Done[2] = "Ah, vou fazer outra coisa, agora."
  set chat_Done[3] = "Hora de fazer o trabalho sujo. Hora de matar [RandomRace]."
  set chat_Done[4] = "Vou caar alguns [RandomRace]."
  set chat_Done[5] = "Assalto concludo."
  set chat_Done[6] = "Eu estive l, eu vi tudo, at comprei uma camiseta."
  set chat_Done[7] = "E o caos foi estabelecido. Muitos [TargetRace] mortos aqui atrs."
  set chat_Done[8] = "Deixei uma trilha de morte e destruio no meu caminho."
  set chat_Done[9] = "Asterides no me preocupem, general."
  set chat_Done_length = 10

  set chat_EGG[0] = "Pqp. Odeio hackers!"
  set chat_EGG[1] = "GG. Remake a, por favor. Voc foi sortudo, que eu peguei [Race].  Eu sou horrvel com [Race]."
  set chat_EGG[2] = "g2g, parece que todos os [Race] da minha armada j foram tarde!"
  set chat_EGG[3] = "Maldio! Parece que  meu fim."
  set chat_EGG[4] = "Homem morto andando... Homem morto andando..."
  set chat_EGG[5] = "At mais, [TargetColor]..."
  set chat_EGG[6] = "DUH!  Derrotado pelo [PlayerColor] [PlayerRace]. Que droga."
  set chat_EGG[7] = "Voc fede, [PlayerColor].  Te devo essa..."
  set chat_EGG[8] = "Esses no so os drides que voc est procurando..."
  set chat_EGG[9] = "gg!"
  set chat_EGG_length = 10

  set chat_Expansion[0] = "Essa expanso tem que ser liberada."
  set chat_Expansion[1] = "L vou eu arranjando mais ouro para minha armada [Race]."
  set chat_Expansion[2] = "Removendo creeps nessa expanso."
  set chat_Expansion[3] = "Vou expandir ali daqui  pouco."
  set chat_Expansion[4] = "Vou creepar aqui. Vem logo!"
  set chat_Expansion[5] = "Removendo creeps..."
  set chat_Expansion[6] = "Quero... mais... ouro... para meus [Race:S]!"
  set chat_Expansion[7] = "Ajude a mquina de guerra  se expandir."
  set chat_Expansion[8] = "Sem esgotar o ouro, vou expandir aqui.  Quanto mais [Race:S], melhor."
  set chat_Expansion[9] = "Eu presciso de dinheiro, vou ter que expandir."
  set chat_Expansion_length = 10

  set chat_Goldproblem[0] = "{OwnGold<200} S tenho [OwnGold] de ouro. Me empreste um pouco ou eu saio em dez segundos."
  set chat_Goldproblem[1] = "Presciso de ouro! Urgente! Ou terei que sair em 10 segundos!"
  set chat_Goldproblem[2] = "{OwnGold<100}T pobre. Voc tem 10 segundos para me arranjar ouro ou eu saio."
  set chat_Goldproblem[3] = "Doe ouro para minha causa, ou eu sao em 10 segundos."
  set chat_Goldproblem[4] = "Voc tem 10 segundos para me pagar tributo, ou estou fora."
  set chat_Goldproblem[5] = "{OwnGold<100}Vou sair em 10 segundos  menos que voc me d ouro."
  set chat_Goldproblem[6] = "A, presciso de dim-dim! Seno eu vou vazar em 10 segundos."
  set chat_Goldproblem[7] = "PQP! S [OwnGold] de ouro.  Presciso de ouro em 10 segundos ou t fora."
  set chat_Goldproblem[8] = "Se eu no conseguir ouro em 10 segundos eu saio, pois s tenho [OwnGold]."
  set chat_Goldproblem[9] = "Presciso de grana! Me d alguma em 10 segundos ou eu saio!"
  set chat_Goldproblem_length = 10

  set chat_Greet[0] = "Esse jogo vai ser muito fcil."
  set chat_Greet[1] = "Eu te falei para no escolher esse mapa! "
  set chat_Greet[2] = "Awww droga eu sempre saio com a pior localizao."
  set chat_Greet[3] = "Hmm... onde ser que voc saiu? :)"
  set chat_Greet[4] = "Uma ownage no capricho saindo."
  set chat_Greet[5] = "Espero que no tenha me posto no Easy!"
  set chat_Greet[6] = "Voc pode correr, mas no pode se esconder!"
  set chat_Greet[7] = "Acho que sei onde o [PlayerColor] comeou!"
  set chat_Greet[8] = "Uma baixa saindo! Confirme por favor!"
  set chat_Greet[9] = "Espero que jogue melhor que da ltima vez. Lembra? :)"
  set chat_Greet[10] = "{!RaceChoiceRandom,Race=Orc} Orcs, por que sempre orcs?"
  set chat_Greet[11] = "Qual  o meu nome!? [Name] Qual  o meu nome!? [Name] QUAL  O MEU NOME?!"
  set chat_Greet[12] = "Supostamente [RandomRace] esto em baixa esses dias... vamos descobrir."
  set chat_Greet[13] = "{Race!=Undead} Por que eu NUNCA pego Undead?"
  set chat_Greet[14] = "{Race!=Human} Ainda bem que no foi Humans dessa vez."
  set chat_Greet[15] = "{!RaceChoiceRandom,Race=Orc,1on1} Orcs RULAM no 1 v 1.  Meus [Color] [Race] vo acabar com voc."
  set chat_Greet[16] = "{Name=Hunter}A temporada de caa est aberta!"
  set chat_Greet[17] = "{Name=Crazy_Rusher} Rush, Rush, RUSH!!!"
  set chat_Greet[18] = "{Name=Crusher}Voc est pronto... pra ser ESMAGADO."
  set chat_Greet[19] = "J comeou?"
  set chat_Greet[20] = "{Name=CPU}Meus calculos indicam que sairei vencedor."
  set chat_Greet[21] = "{Name=ErRoR}No vai dar pau dessa vez!"
  set chat_Greet[22] = "{Name=CyberPro}Sou o nico PRO de verdade nesse jogo, humano.."
  set chat_Greet[23] = "{Name=Aaargh}AAARGHAHA!!!!!!"
  set chat_Greet_length = 24

  set chat_Mega[0] = "ACORDA [PlayerRace], HORA DE MORRER!"
  set chat_Mega[1] = "T demorando muito, quem sabe eu acabo com isso de uma vez?"
  set chat_Mega[2] = "Haha, mortais cometem erros. Computadores no."
  set chat_Mega[3] = "Sei todas as suas estratgias de [TargetRace]. Elas esto guardadas no meu disco rgido."
  set chat_Mega[4] = "T na hora de acabar com isso..."
  set chat_Mega[5] = "O poder de destruir um planeta  insignificante perante o poder da Fora."
  set chat_Mega[6] = "Achei que voc ia vencer esse jogo! Me enganei!"
  set chat_Mega[7] = "eee mais uma vitria [Race]. J posso at ver."
  set chat_Mega[8] = "{1on1} Isso ser um exemplo da falha humana."
  set chat_Mega[9] = "Voc no sabe mesmo quando jogar a toalha, no ?"
  set chat_Mega[10] = "No me importa quantas estruturas [PlayerRace] voc esconde no mapa, te mato de qualquer jeito."
  set chat_Mega[11] = "{FFA}Aqui vou eu e no terei piedade de ningum."
  set chat_Mega[12] = "No ache que voc ficar nesse jogo por muito tempo."
  set chat_Mega[13] = "{Race!=HUMAN}Humanos sux. que bom que sou [Race:S]"
  set chat_Mega_length = 14

  set chat_Megatarget[0] = "Eles esto fracos! ATACAR!"
  set chat_Megatarget[1] = "Todos que podem atacar, acabem com esses [TargetColor] [TargetRace] perdedores!"
  set chat_Megatarget[2] = "Venceremos se tomarmos [PlayerColor] de assalto, agora!"
  set chat_Megatarget[3] = "Todas as unidades; reunir aqui imediatamente!"
  set chat_Megatarget[4] = "Vamos destruir a base deles!"
  set chat_Megatarget[5] = "Est tudo bem, agora vamos massacrar esses aqui e ir para casa!"
  set chat_Megatarget[6] = "Ataquem com tudo enquanto eles esto fracos!"
  set chat_Megatarget[7] = "TODO MUNDO NO [TargetColor]!"
  set chat_Megatarget[8] = "Agora  hora de acabar com o [TargetColor]!"
  set chat_Megatarget[9] = "Traga s faxineiros. Vamos limpar os [TargetRace] do mapa."
  set chat_Megatarget_length = 10

  set chat_Taunt[0] = "Meu [Color] [Race] vai dominar."
  set chat_Taunt[1] = "Cara eu jogo com voc demais..."
  set chat_Taunt[2] = "Voc no t jogando srio, espero."
  set chat_Taunt[3] = "Minha ttica de [Race] owna. Voc nunca vai saber o que te atingiu!"
  set chat_Taunt[4] = "Bela armada [PlayerRace]. Tenho um espio do seu lado. :D"
  set chat_Taunt[5] = "Odeio essas hordas fedorentas de [TargetRace]. Vou te destruir!"
  set chat_Taunt[6] = "Da ultima vez, eu era o aprendiz. Agora sou o mestre."
  set chat_Taunt[7] = "Voc tem um heri [PlayerRace] de nvel baixo. Sou bem melhor que isso!"
  set chat_Taunt[8] = "Ei [PlayerColor]... Vou vencer em uns 5 ou 10 minutos."
  set chat_Taunt[9] = "Esse vai ser o jogo mais fcil de todos."
  set chat_Taunt[10] = "Voc realmente acha que essa estratgia de [PlayerRace] vai me pegar desprevenido?"
  set chat_Taunt[11] = "Aaaaaah, me deixa vencer essa vez? Cansei de perder!"
  set chat_Taunt_length = 12

  set chat_Thanks[0] = "Obrigado. Vou reconstruir o que perdi!"
  set chat_Thanks[1] = "{OwnGold<100} Valeu, me d qualquer ouro que tenha sobrando."
  set chat_Thanks[2] = "Obrigado! No saia. Ainda podemos vencer, certto?"
  set chat_Thanks[3] = "A! Obrigado pela grana!."
  set chat_Thanks[4] = "Valeu pelo Dindin cara!"
  set chat_Thanks[5] = "{OwnGold>=400} Ka-Ching!!!"
  set chat_Thanks[6] = "Reconstruindo. Obrigado!"
  set chat_Thanks[7] = "Obrigado pelo ouro.."
  set chat_Thanks[8] = "Adoro quando partilham a fortuna comigo!"
  set chat_Thanks[9] = "{OwnGold<200} Vou prescisar de mais, porm cada moeda ajuda."
  set chat_Thanks_length = 10


  set chat_no_unit_selected = "Ningum selecionado"
  set chat_confirm_attack_unit = "Atacar/proteger o cara selecionado unidade [TargetColor] [TargetRace] "
  set chat_towerrush = "Tentar Tower Rush em algum"
  set chat_no_orc = "No quero fazer Tower Rush"
  set militia_expansion_chat = "Vou fazer expanso com Militia aqui."

endfunction

function InitChatArraysNorwegian takes nothing returns nothing

  set chat_AGG[0] = "Hyggelig  spille med deg."
  set chat_AGG[1] = "Sorry as, men jeg er visst s godt som dd. "
  set chat_AGG[2] = "Du fr klare deg uten meg."
  set chat_AGG[3] = "Okey.. jeg er dd, HADE!"
  set chat_AGG[4] = "hhh whoops... tror jeg er ute."
  set chat_AGG_length = 5

  set chat_Ally[0] = "Vi angriper her"
  set chat_Ally[1] = "Hjelp oss  angripe her"
  set chat_Ally[2] = "Angrip her n"
  set chat_Ally[3] = "Jeg trenger hjelp her"
  set chat_Ally[4] = "Vi kan angripe sammen"
  set chat_Ally_length = 5

  set chat_Attack[0] = "Jeg angriper denne fienden"
  set chat_Attack[1] = "Jeg angriper her"
  set chat_Attack[2] = "Angriper denna"
  set chat_Attack[3] = "Sender et angriper her n"
  set chat_Attack[4] = "Angriper her n"
  set chat_Attack_length = 5

  set chat_Creep[0] = "Jeg kvester de creepa her"
  set chat_Creep[1] = "Jeg tar  kverker dissa creepa"
  set chat_Creep[2] = "Jeg tar hnd om dissa creepa"
  set chat_Creep[3] = "Jeg creeper litt her jeg"
  set chat_Creep[4] = "Jeg flyr p dissa creepa her"
  set chat_Creep_length = 5

  set chat_Done[0] = "Jeg er klar her n"
  set chat_Done[1] = "Jeg stikker et annet sted"
  set chat_Done[2] = "Jeg gr  gjr noe annet"
  set chat_Done[3] = "Gjr noe annet n"
  set chat_Done[4] = "Angrep averget"
  set chat_Done_length = 5

  set chat_EGG[0] = "GG"
  set chat_EGG[1] = "Helvete jeg er dd"
  set chat_EGG[2] = "Neste gang skal du f det der det svir."
  set chat_EGG[3] = "Okey, greit! Jeg er dd!"
  set chat_EGG[4] = "Jeg m stikke jeg."
  set chat_EGG_length = 5

  set chat_Expansion[0] = "Jeg renser det stedet her"
  set chat_Expansion[1] = "Jeg fikser opp creepa ved den gruva her"
  set chat_Expansion[2] = "Jeg ekspanderer meg hit snart"
  set chat_Expansion[3] = "Snart er denne gruva tilgjengelig"
  set chat_Expansion[4] = "Jeg tar denne gruva n"
  set chat_Expansion_length = 5

  set chat_Goldproblem[0] = "Sleng over litt png a, ellers s stikker jeg om 10 sekunder."
  set chat_Goldproblem[1] = "Jeg meg penger ellers s stikker jeg om 10 sek."
  set chat_Goldproblem_length = 2

  set chat_Greet[0] = "Du er s dd du.."
  set chat_Greet[1] = "Du kommer til  d s sinnsykt >:)"
  set chat_Greet[2] = "Faen! Ikke dette brettet igjen!"
  set chat_Greet[3] = "Ahh, samma startsted igjen! :("
  set chat_Greet[4] = "Hmmm lurer p hvor du starta"
  set chat_Greet[5] = "Du kommer til  tape, liker du det ikke fr du bare godta det!"
  set chat_Greet[6] = "Velkommen til helvete"
  set chat_Greet[7] = "Du kommer ikke til  slippe unna!"
  set chat_Greet[8] = "Jeg veit allerede hvor du starta!"
  set chat_Greet[9] = "Nr jeg er ferdig med deg kommer du til  vre s sinnsykt sur haha!"
  set chat_Greet_length = 10

  set chat_Mega[0] = "Gjr deg klar til  f det der det svir!"
  set chat_Mega[1] = "AHA! D D D!"
  set chat_Mega[2] = "N er du d!"
  set chat_Mega[3] = "N er du snart like dd som Hitler!"
  set chat_Mega[4] = "OMGZ Du er s jvelig dd!"
  set chat_Mega[5] = "HAHAHAHAHHA LOLZ Du har tapt allerede"
  set chat_Mega[6] = "Bare gi opp! Si GG og stikk!"
  set chat_Mega[7] = "Vis meg hvem som er pappa!"
  set chat_Mega[8] = "Kanskje p tide  spille for alvor ehh?"
  set chat_Mega_length = 9

  set chat_Megatarget[0] = "HIT! N har vi sjans! ANGRIP!"
  set chat_Megatarget[1] = "Sender alt ned hit n.."
  set chat_Megatarget[2] = "Om vi angriper n kommer vi til  vinne lett"
  set chat_Megatarget[3] = "Send alt du har ned hit n"
  set chat_Megatarget[4] = "Fort deg hit meg masse folk s vinner vi!"
  set chat_Megatarget_length = 5

  set chat_Taunt[0] = "Jeg veit mer enn du tror"
  set chat_Taunt[1] = "Sitter du det  koser deg med Pappvin og Pornofilmer eller?!"
  set chat_Taunt[2] = "Hahah! Jeg har en plan"
  set chat_Taunt[3] = "Aldri undervurder din motstander"
  set chat_Taunt[4] = "Din strategi er uttdatert, menneske!"
  set chat_Taunt[5] = "Du tror du kommer til  vinne ehh? :P"
  set chat_Taunt[6] = "Jeg er farligere enn alle verdens atombomber"
  set chat_Taunt[7] = "Om jeg taper denne matchen s er det fordi PC'n din suger s inne i HELVETE!"
  set chat_Taunt[8] = "Det er bare en igjen nr jeg er ferdig her og det er MEG!"
  set chat_Taunt[9] = "Min taktikk er ufeilbar, du kommer til  tape!"
  set chat_Taunt_length = 10

  set chat_Thanks[0] = "Takker s meget!"
  set chat_Thanks[1] = "Takk Takk, n holder det."
  set chat_Thanks_length = 2


  set chat_no_unit_selected = "Ingen enhet valgt"
  set chat_confirm_attack_unit = "Jeg kommer til  angripe/vokte den valgte enheten"
  set chat_towerrush = "Jeg vil prve  towerrushe han"
  set chat_no_orc = "Jeg er ikke noen orc"
  set militia_expansion_chat = "Jeg gr for militia utvidelse over her"

endfunction

function InitChatArraysChinese takes nothing returns nothing

  set chat_AGG[0] = ""
  set chat_AGG[1] = "?"
  set chat_AGG[2] = "GG?"
  set chat_AGG[3] = ""
  set chat_AGG[4] = ""
  set chat_AGG[5] = "?"
  set chat_AGG[6] = "?"
  set chat_AGG_length = 7

  set chat_Ally[0] = "?"
  set chat_Ally[1] = ""
  set chat_Ally[2] = "??"
  set chat_Ally[3] = "?"
  set chat_Ally[4] = "?"
  set chat_Ally[5] = ""
  set chat_Ally_length = 6

  set chat_Attack[0] = ""
  set chat_Attack[1] = ""
  set chat_Attack[2] = ""
  set chat_Attack[3] = ""
  set chat_Attack[4] = "?"
  set chat_Attack[5] = ""
  set chat_Attack[6] = "?"
  set chat_Attack[7] = ""
  set chat_Attack_length = 8

  set chat_Creep[0] = "MF?"
  set chat_Creep[1] = "?"
  set chat_Creep[2] = "?"
  set chat_Creep[3] = "?"
  set chat_Creep[4] = "CREEPS?"
  set chat_Creep[5] = "MF"
  set chat_Creep_length = 6

  set chat_Done[0] = ""
  set chat_Done[1] = "?"
  set chat_Done[2] = "?"
  set chat_Done[3] = "?"
  set chat_Done[4] = "?"
  set chat_Done[5] = "?"
  set chat_Done[6] = ""
  set chat_Done_length = 7

  set chat_EGG[0] = ""
  set chat_EGG[1] = "GG,?"
  set chat_EGG[2] = "??"
  set chat_EGG[3] = "?"
  set chat_EGG[4] = "?"
  set chat_EGG[5] = "?"
  set chat_EGG[6] = "?8"
  set chat_EGG[7] = "84? "
  set chat_EGG_length = 8

  set chat_Expansion[0] = "?"
  set chat_Expansion[1] = "?"
  set chat_Expansion[2] = "?"
  set chat_Expansion[3] = "?"
  set chat_Expansion[4] = "MF"
  set chat_Expansion[5] = "Everybody,ING!"
  set chat_Expansion_length = 6

  set chat_Goldproblem[0] = "10?"
  set chat_Goldproblem[1] = "?0"
  set chat_Goldproblem[2] = "?"
  set chat_Goldproblem[3] = "10000"
  set chat_Goldproblem_length = 4

  set chat_Greet[0] = "?"
  set chat_Greet[1] = "?"
  set chat_Greet[2] = ""
  set chat_Greet[3] = "jiji,?"
  set chat_Greet[4] = ""
  set chat_Greet[5] = "?"
  set chat_Greet[6] = "?"
  set chat_Greet[7] = "?"
  set chat_Greet[8] = "?"
  set chat_Greet[9] = "?"
  set chat_Greet[10] = "?"
  set chat_Greet[11] = "?"
  set chat_Greet[12] = "?"
  set chat_Greet[13] = "? "
  set chat_Greet_length = 14

  set chat_Mega[0] = ""
  set chat_Mega[1] = "?"
  set chat_Mega[2] = "?"
  set chat_Mega[3] = "APM?000"
  set chat_Mega[4] = "GGHAPPY?"
  set chat_Mega[5] = "?"
  set chat_Mega[6] = "?"
  set chat_Mega[7] = "?"
  set chat_Mega[8] = ""
  set chat_Mega[9] = ""
  set chat_Mega[10] = ""
  set chat_Mega[11] = ""
  set chat_Mega[12] = "?"
  set chat_Mega[13] = "?"
  set chat_Mega[14] = "?"
  set chat_Mega[15] = "?"
  set chat_Mega[16] = ""
  set chat_Mega[17] = "?"
  set chat_Mega[18] = "?"
  set chat_Mega_length = 19

  set chat_Megatarget[0] = ""
  set chat_Megatarget[1] = "?"
  set chat_Megatarget[2] = ""
  set chat_Megatarget[3] = "?"
  set chat_Megatarget[4] = ""
  set chat_Megatarget[5] = "SB? "
  set chat_Megatarget_length = 6

  set chat_Taunt[0] = "?"
  set chat_Taunt[1] = "?"
  set chat_Taunt[2] = ""
  set chat_Taunt[3] = "?"
  set chat_Taunt[4] = ".:D"
  set chat_Taunt[5] = "?"
  set chat_Taunt[6] = "B,"
  set chat_Taunt[7] = "?"
  set chat_Taunt[8] = "??0"
  set chat_Taunt[9] = "?"
  set chat_Taunt[10] = "?"
  set chat_Taunt[11] = "?"
  set chat_Taunt[12] = "? "
  set chat_Taunt_length = 13

  set chat_Thanks[0] = "?"
  set chat_Thanks[1] = "?"
  set chat_Thanks[2] = "? "
  set chat_Thanks_length = 3


  set chat_no_unit_selected = "?"
  set chat_confirm_attack_unit = "/?"
  set chat_towerrush = "Rua?"
  set chat_no_orc = ""
  set militia_expansion_chat = "? "

endfunction


function CopyChatAGG takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_AGG_length
  loop
    exitwhen i >= chat_AGG_length
    set chat_list[i] = chat_AGG[i]
    set i = i + 1
  endloop
endfunction
function CopyChatAlly takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Ally_length
  loop
    exitwhen i >= chat_Ally_length
    set chat_list[i] = chat_Ally[i]
    set i = i + 1
  endloop
endfunction
function CopyChatAttack takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Attack_length
  loop
    exitwhen i >= chat_Attack_length
    set chat_list[i] = chat_Attack[i]
    set i = i + 1
  endloop
endfunction
function CopyChatCreep takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Creep_length
  loop
    exitwhen i >= chat_Creep_length
    set chat_list[i] = chat_Creep[i]
    set i = i + 1
  endloop
endfunction
function CopyChatDone takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Done_length
  loop
    exitwhen i >= chat_Done_length
    set chat_list[i] = chat_Done[i]
    set i = i + 1
  endloop
endfunction
function CopyChatEGG takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_EGG_length
  loop
    exitwhen i >= chat_EGG_length
    set chat_list[i] = chat_EGG[i]
    set i = i + 1
  endloop
endfunction
function CopyChatExpansion takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Expansion_length
  loop
    exitwhen i >= chat_Expansion_length
    set chat_list[i] = chat_Expansion[i]
    set i = i + 1
  endloop
endfunction
function CopyChatGoldproblem takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Goldproblem_length
  loop
    exitwhen i >= chat_Goldproblem_length
    set chat_list[i] = chat_Goldproblem[i]
    set i = i + 1
  endloop
endfunction
function CopyChatGreet takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Greet_length
  loop
    exitwhen i >= chat_Greet_length
    set chat_list[i] = chat_Greet[i]
    set i = i + 1
  endloop
endfunction
function CopyChatMega takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Mega_length
  loop
    exitwhen i >= chat_Mega_length
    set chat_list[i] = chat_Mega[i]
    set i = i + 1
  endloop
endfunction
function CopyChatMegatarget takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Megatarget_length
  loop
    exitwhen i >= chat_Megatarget_length
    set chat_list[i] = chat_Megatarget[i]
    set i = i + 1
  endloop
endfunction
function CopyChatTaunt takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Taunt_length
  loop
    exitwhen i >= chat_Taunt_length
    set chat_list[i] = chat_Taunt[i]
    set i = i + 1
  endloop
endfunction
function CopyChatThanks takes nothing returns nothing
  local integer i = 0
  set chat_list_length = chat_Thanks_length
  loop
    exitwhen i >= chat_Thanks_length
    set chat_list[i] = chat_Thanks[i]
    set i = i + 1
  endloop
endfunction

function CommonStratsDefault takes nothing returns nothing
  set strategy_name[50] = "airair"
  set strategy_default_name[50] = "Air-Air"
  set strategy_default_report[50] = "I build Air-Air units"
  set strategy_name[51] = "airground"
  set strategy_default_name[51] = "Air-Ground"
  set strategy_default_report[51] = "I build Air-Ground units"
  set strategy_name[52] = "groundair"
  set strategy_default_name[52] = "Ground-Air"
  set strategy_default_report[52] = "I build Ground-Air units"
  set strategy_name[53] = "groundground"
  set strategy_default_name[53] = "Ground-Ground"
  set strategy_default_report[53] = "I build Ground-Ground units"
  set strategy_name[54] = "farm"
  set strategy_default_name[54] = "Farms"
  set strategy_default_report[54] = "I build farms"
  set strategy_name[55] = "guard"
  set strategy_default_name[55] = "Towers"
  set strategy_default_report[55] = "I build towers"
endfunction

function InitChatArrays takes nothing returns nothing
  if false then
  elseif language == "English" then
    call InitChatArraysEnglish()
  elseif language == "Deutsch" then
    call InitChatArraysDeutsch()
  elseif language == "Swedish" then
    call InitChatArraysSwedish()
  elseif language == "French" then
    call InitChatArraysFrench()
  elseif language == "Spanish" then
    call InitChatArraysSpanish()
  elseif language == "Romanian" then
    call InitChatArraysRomanian()
  elseif language == "Russian" then
    call InitChatArraysRussian()
  elseif language == "Portuguese" then
    call InitChatArraysPortuguese()
  elseif language == "Norwegian" then
    call InitChatArraysNorwegian()
  elseif language == "Chinese" then
    call InitChatArraysChinese()
  endif
endfunction

function InitChatEvents takes nothing returns nothing
  set chat_target_ally[1] = true
  set chat_target_enemy[1] = false
  set chat_target_obs[1] = false
  set chat_important[1] = true
  set chat_target_ally[2] = true
  set chat_target_enemy[2] = false
  set chat_target_obs[2] = false
  set chat_important[2] = false
  set chat_target_ally[3] = true
  set chat_target_enemy[3] = false
  set chat_target_obs[3] = false
  set chat_important[3] = false
  set chat_target_ally[4] = true
  set chat_target_enemy[4] = false
  set chat_target_obs[4] = false
  set chat_important[4] = false
  set chat_target_ally[5] = true
  set chat_target_enemy[5] = false
  set chat_target_obs[5] = false
  set chat_important[5] = false
  set chat_target_ally[6] = false
  set chat_target_enemy[6] = true
  set chat_target_obs[6] = true
  set chat_important[6] = true
  set chat_target_ally[7] = true
  set chat_target_enemy[7] = false
  set chat_target_obs[7] = false
  set chat_important[7] = false
  set chat_target_ally[8] = true
  set chat_target_enemy[8] = false
  set chat_target_obs[8] = false
  set chat_important[8] = true
  set chat_target_ally[9] = false
  set chat_target_enemy[9] = true
  set chat_target_obs[9] = true
  set chat_important[9] = false
  set chat_target_ally[10] = false
  set chat_target_enemy[10] = true
  set chat_target_obs[10] = true
  set chat_important[10] = false
  set chat_target_ally[11] = true
  set chat_target_enemy[11] = false
  set chat_target_obs[11] = false
  set chat_important[11] = false
  set chat_target_ally[12] = false
  set chat_target_enemy[12] = true
  set chat_target_obs[12] = true
  set chat_important[12] = false
  set chat_target_ally[13] = true
  set chat_target_enemy[13] = false
  set chat_target_obs[13] = false
  set chat_important[13] = false
endfunction

function AddTranslation takes string lang, string strat_name, string trans_name, string trans_report returns nothing
  set translation[translation_length] = trans_name
  call StoreInteger(translation_map, lang, "Name"+strat_name, translation_length)
  set translation_length = translation_length + 1
  set translation[translation_length] = trans_report
  call StoreInteger(translation_map, lang, "Report"+strat_name, translation_length)
  set translation_length = translation_length + 1
endfunction

function InitTranslations takes nothing returns nothing
  local string lang = ""
  set lang = "English"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "I will play normal and build a little bit of everything")
  call AddTranslation(lang, "ROCMassHD", "Hunts and Dryads", "I'm going massive huntresses with a few dryads")
  call AddTranslation(lang, "ROCDruids", "Dryads and DotC", "I will build dryads and DotC")
  call AddTranslation(lang, "ROCHippo", "Hippo Riders", "I'll build hippo riders in mass")
  call AddTranslation(lang, "ROCBallista", "Ballista", "I'll do glaive throwers and dryads")
  call AddTranslation(lang, "ROCTalon", "Talon", "I gonna make tons of DotT")
  call AddTranslation(lang, "ROCHippoChim", "HippoChim", "I'll make hippos and chimaeras")
  call AddTranslation(lang, "ROCDryadChim", "DryadChim", "Going dryads and chimaeras")
  call AddTranslation(lang, "ROCArcher", "Archers", "Gonna amass archers")
  call AddTranslation(lang, "ROCDotC", "Bears", "Trying mass DotC")
  call AddTranslation(lang, "NormalElf", "Normal", "I will play normal and build a little bit of everything")
  call AddTranslation(lang, "MassHD", "Hunts and Dryads", "I'm going massive huntresses with a few dryads")
  call AddTranslation(lang, "Druids", "Dryads and DotC", "I will build dryads and DotC")
  call AddTranslation(lang, "Hippo", "Hippo Riders", "I'll build hippo riders in mass")
  call AddTranslation(lang, "Ballista", "Ballista", "I'll do glaive throwers and dryads")
  call AddTranslation(lang, "Talon", "Talon", "I'm going massive DOtT")
  call AddTranslation(lang, "HippoChim", "HippoChim", "I'll make hippos and chimaeras")
  call AddTranslation(lang, "DryadChim", "DryadChim", "Going dryads and chimaeras")
  call AddTranslation(lang, "Archer", "Archers", "I'm massing archers")
  call AddTranslation(lang, "DotC", "Bears", "Trying mass DotC")
  call AddTranslation(lang, "MassHuntress", "Mass Hunts", "I'm going massive Huntresses")
  call AddTranslation(lang, "MGDryads", "Dryads and MGs", "I'm going dryads and mountain giants")
  call AddTranslation(lang, "AoWMix", "AoW Mix", "I'm mixing units from the AoW")
  call AddTranslation(lang, "AolMix", "AoL Mix", "I'm mixing units from the Ancient of Lore")
  call AddTranslation(lang, "NEAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "I'll play normal and build a little bit of everything")
  call AddTranslation(lang, "ROCMassSp", "Casters", "I'm going massive spell casters")
  call AddTranslation(lang, "ROCGryph", "Gryphon", "I will build gryphon riders")
  call AddTranslation(lang, "ROCKnight", "Knights", "I'll build footmen and knights in mass")
  call AddTranslation(lang, "ROCRifle", "Rifle", "I'm gonna make riflemen")
  call AddTranslation(lang, "ROCMortars", "Mortars", "I'm going mortars")
  call AddTranslation(lang, "ROCCopters", "Copters", "I do mass flying machines")
  call AddTranslation(lang, "NormalHuman", "Normal", "I'll play normal and build a little bit of everything")
  call AddTranslation(lang, "MassSp", "Casters", "I'm going massive spell casters")
  call AddTranslation(lang, "Gryph", "Gryphon", "I will build gryphon riders")
  call AddTranslation(lang, "Knight", "Knights", "I'll going massive footman and knights")
  call AddTranslation(lang, "Rifle", "Rifle", "I'm going massive riflemen and priests")
  call AddTranslation(lang, "Mortars", "Mortars", "I'm going mortars and riflemen")
  call AddTranslation(lang, "Copters", "Copters", "I'm going flying machines")
  call AddTranslation(lang, "MassSB", "SpellBreakers", "I'm going massive spell breakers")
  call AddTranslation(lang, "Dragonhawk", "Dragon Hawks", "I'm going dragon hawks")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "I'm trying to mix units from barrack and workshop")
  call AddTranslation(lang, "SanctumMix", "Sanctum Mix", "I'm trying to mix units from sanctum and aviary")
  call AddTranslation(lang, "HAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusOrc", "Mass Sorceress", "I'm massing Sorceress")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "I'm going to play normal and build a little bit of everything")
  call AddTranslation(lang, "ROCFastSh", "Shamans and Taurens", "I will make casters and taurens")
  call AddTranslation(lang, "ROCKodo", "Kodo", "I'm gonna go massive kodo-beasts")
  call AddTranslation(lang, "ROCWyvSh", "Shamans and Wyverns", "Going Shamans and Wyverns")
  call AddTranslation(lang, "ROCHHunters", "Head Hunters", "Trying massive head hunters")
  call AddTranslation(lang, "ROCRaiders", "Raiders", "I'm make massive raiders")
  call AddTranslation(lang, "ROCCatapults", "Grunts and Catapults", "I'm going to do grunts and demolishers")
  call AddTranslation(lang, "ROCHeadCatapults", "Head hunters and Catapults", "Let's try headhunters and demolishers")
  call AddTranslation(lang, "NormalOrc", "Normal", "I'm going grunts and casters")
  call AddTranslation(lang, "FastSh", "Shamans and Taurens", "I will make casters and taurens")
  call AddTranslation(lang, "WyvSh", "Shamans and Wyverns", "Going Shamans and Wyverns")
  call AddTranslation(lang, "HHunters", "Head Hunters", "Trying massive head hunters")
  call AddTranslation(lang, "Raiders", "Raiders", "I'm going massive raiders")
  call AddTranslation(lang, "GruntCatapults", "Grunts and Catapults", "I'm going to do grunts and demolishers")
  call AddTranslation(lang, "HeadCatapults", "Head hunters and Catapults", "Let's try headhunters and demolishers")
  call AddTranslation(lang, "Wyvern", "Mass Wyvern", "I'm going massive wyverns")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "I'm mixing units from barrack.")
  call AddTranslation(lang, "BestiaryMix", "Bestiary Mix", "I'm mixing units from bestiary")
  call AddTranslation(lang, "AntiPierce", "Anti Pierce", "I'm going melee units and raiders")
  call AddTranslation(lang, "AntiAir", "Batriders", "I'm a massing batriders")
  call AddTranslation(lang, "OAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusHuman", "Raiders and Spirtwalkers", "I'm going raiders and spirit walkers")
  call AddTranslation(lang, "VersusUndead", "Grunts and Beastiary", "I'm going Grunts and a mix from the beastiary")
  call AddTranslation(lang, "VersusElf", "Raiders and Demolishers", "I'm going raiders and Demolishers")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "I will play normal and build a little bit of everything")
  call AddTranslation(lang, "ROCWyrms", "Wyrms", "Going wyrms and a few crypt fiends")
  call AddTranslation(lang, "ROCBanshee", "Banshees", "I'll go mostly banshees")
  call AddTranslation(lang, "ROCNecro", "Necros", "Trying necromancers")
  call AddTranslation(lang, "ROCGhouls", "Ghouls", "I will build mass ghouls")
  call AddTranslation(lang, "ROCFiends", "Fiends", "I'm gonna go mass crypt fiends")
  call AddTranslation(lang, "ROCGargWyrm", "Gargoyles and Wyrms", "I'll do gargs and wyrms")
  call AddTranslation(lang, "ROCAboms", "Aboms", "I'm going massive abominations")
  call AddTranslation(lang, "ROCMeatFiends", "Meat wagons and Fiends", "I'll try going fiends and meat wagons")
  call AddTranslation(lang, "NormalUndead", "Normal", "I will play normal and build a little bit of everything")
  call AddTranslation(lang, "Wyrms", "Wyrms", "Going wyrms and a few crypt fiends")
  call AddTranslation(lang, "Banshee", "Banshees", "I'll go mostly banshees")
  call AddTranslation(lang, "Necro", "Necros", "Trying necromancers")
  call AddTranslation(lang, "Ghouls", "Ghouls", "I will build mass ghouls")
  call AddTranslation(lang, "Fiends", "Fiends", "I'm gonna go mass crypt fiends")
  call AddTranslation(lang, "GargWyrm", "Gargoyles and Wyrms", "I'll do gargs and wyrms")
  call AddTranslation(lang, "Aboms", "Aboms", "I'm going massive abominations")
  call AddTranslation(lang, "MeatFiends", "Meat wagons and Fiends", "I'll try going fiends and meat wagons")
  call AddTranslation(lang, "MassDestroyer", "Mass Destroyers", "I'm going massive destroyers")
  call AddTranslation(lang, "CryptMix", "Crypt Mix", "I'm trying to mix units from crypt and slaughterhouse")
  call AddTranslation(lang, "TempleMix", "Temple Mix", "I'm mixing units from temple of the damned and slaughterhouse")
  call AddTranslation(lang, "UAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "airair", "Air-Air", "I'll build Air to Air units")
  call AddTranslation(lang, "airground", "Air-Ground", "I'll build Air to Ground units")
  call AddTranslation(lang, "groundair", "Ground-Air", "I'll build Ground to Air units")
  call AddTranslation(lang, "groundground", "Ground-Ground", "I'll build Ground to Ground units")
  call AddTranslation(lang, "farm", "Farms", "I'll build farms")
  call AddTranslation(lang, "guard", "Towers", "I'll build towers")
  set lang = "Deutsch"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "Ich spiele normal und baue von Allem etwas")
  call AddTranslation(lang, "ROCMassHD", "Jgerinnen und Dryaden", "Ich baue massiv Jgerinnen mit ein paar Dryaden")
  call AddTranslation(lang, "ROCDruids", "Dryaden und Brchen", "Ich baue Dryaden and Brchen")
  call AddTranslation(lang, "ROCHippo", "Hipporeiterinnen", "Ich baue Hipporeiterinnen")
  call AddTranslation(lang, "ROCBallista", "Ballistas", "Ich baue Ballistas and Dryaden")
  call AddTranslation(lang, "ROCTalon", "Klauendruiden", "Ich baue massiv Klauendruiden")
  call AddTranslation(lang, "ROCHippoChim", "HippoChi", "Ich baue Hippos and Schimren")
  call AddTranslation(lang, "ROCDryadChim", "DryadChim", "Ich baue Dryaden and Schimren")
  call AddTranslation(lang, "ROCArcher", "Bogenschtzen", "Ich baue massiv Bogenschtzen")
  call AddTranslation(lang, "ROCDotC", "Bren", "Ich baue massiv Bren")
  call AddTranslation(lang, "NormalElf", "Normal", "Ich spiele normal und baue von Allem etwas")
  call AddTranslation(lang, "MassHD", "Jgerinnen und Dryaden", "Ich baue massiv Jgerinnen mit ein paar Dryaden")
  call AddTranslation(lang, "Druids", "Dryaden und Bren", "Ich baue Dryaden and Bren")
  call AddTranslation(lang, "Hippo", "Hipporeiterinnen", "Ich baue Hipporeiterinnen")
  call AddTranslation(lang, "Ballista", "Ballistas", "Ich baue Ballistas and Dryaden")
  call AddTranslation(lang, "Talon", "Klauendruiden", "Ich baue massiv Klauendruiden")
  call AddTranslation(lang, "HippoChim", "HippoChi", "Ich baue Hippos and Schimren")
  call AddTranslation(lang, "DryadChim", "DryadChim", "Ich baue Dryaden and Schimren")
  call AddTranslation(lang, "NEAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "Archer", "Bogenschtzen", "Ich baue massiv Bogenschtzen")
  call AddTranslation(lang, "DotC", "Brchen", "Ich baue massiv Brchen")
  call AddTranslation(lang, "MassHuntress", "Jgerinnen", "Ich baue massiv Jgerinnen")
  call AddTranslation(lang, "MGDryads", "Dryaden und Bergriesen", "Ich baue Dryaden und Bergriesen")
  call AddTranslation(lang, "AoWMix", "Einheitenmix aus AoW", "Ich mixe Einheiten aus dem AoW")
  call AddTranslation(lang, "AoLMix", "Einheitenmix aus AoL", "Ich mixe Einheiten aus dem AoL")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "Ich spiele normal und baue von Allem etwas")
  call AddTranslation(lang, "ROCMassSp", "Zauberer", "Ich baue massiv Zauberer")
  call AddTranslation(lang, "ROCGryph", "Greifen", "Ich baue Greifenreiter")
  call AddTranslation(lang, "ROCKnight", "Ritter", "Ich baue massiv Soldaten und Ritter")
  call AddTranslation(lang, "ROCRifle", "Schtzen", "Ich baue massiv Schtzen")
  call AddTranslation(lang, "ROCMortars", "Mrser-Truppen", "Ich baue Mrser-Truppen")
  call AddTranslation(lang, "ROCCopters", "Gyrokopter", "Ich baue Gyrokopter")
  call AddTranslation(lang, "NormalHuman", "Normal", "Ich spiele normal und baue von Allem etwas")
  call AddTranslation(lang, "MassSp", "Zauberer", "Ich baue massiv Zauberer")
  call AddTranslation(lang, "Gryph", "Greifen", "Ich baue Greifenreiter")
  call AddTranslation(lang, "Knight", "Ritter", "Ich baue massiv Soldaten und Ritter")
  call AddTranslation(lang, "Rifle", "Schtzen", "Ich baue massiv Schtzen")
  call AddTranslation(lang, "Mortars", "Mrser-Truppen", "Ich baue Mrser-Truppen")
  call AddTranslation(lang, "Copters", "Gyrokopter", "Ich baue Gyrokopter")
  call AddTranslation(lang, "MassSB", "Zauberbrecher", "Ich baue massiv Zauberbrecher")
  call AddTranslation(lang, "Dragonhawk", "Drachenfalkenreiter", "Ich baue massiv Drachenfalkenreiter")
  call AddTranslation(lang, "BarrackMix", "Einheitenmix aus Kaserne", "Ich mixe Einheiten aus der Kaserne")
  call AddTranslation(lang, "SanctumMix", "Einheitenmix aus Sanktum", "Ich mixe Einheiten aus dem Sanktum")
  call AddTranslation(lang, "HAntiTower", "Anti Trme", "Ich baue massiv Belagerungswaffen")
  call AddTranslation(lang, "VersusOrc", "Zauberinnen", "Ich baue massiv Zauberinnen")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "Ich baue Grunzer und Zauberer")
  call AddTranslation(lang, "ROCFastSh", "Schamanen und Tauren", "Ich baue Schamanen und Tauren")
  call AddTranslation(lang, "ROCKodo", "Kodo", "Ich baue massiv Kodo-Bestien")
  call AddTranslation(lang, "ROCWyvSh", "Schamanen und Wyverns", "Ich baue Schamanen und Wyverns")
  call AddTranslation(lang, "ROCHHunters", "Kopfjger", "Ich baue massiv Kopfjger")
  call AddTranslation(lang, "ROCRaiders", "Ruber", "Ich baue massiv Ruber")
  call AddTranslation(lang, "ROCCatapults", "Katapulte", "Ich baue Grunzer und Katapulte")
  call AddTranslation(lang, "ROCHeadCatapults", "Kopfjger und Katapulte", "Ich baue Kopfjger und Katapulte")
  call AddTranslation(lang, "NormalOrc", "Normal", "Ich baue Grunzer und Zauberer")
  call AddTranslation(lang, "FastSh", "Schamanen und Tauren", "Ich baue Schamanen und Tauren")
  call AddTranslation(lang, "WyvSh", "Schamanen und Wyverns", "Ich baue Schamanen und Wyverns")
  call AddTranslation(lang, "HHunters", "Kopfjger", "Ich baue massiv Kopfjger")
  call AddTranslation(lang, "Raiders", "Ruber", "Ich baue massiv Ruber")
  call AddTranslation(lang, "GruntCatapults", "Grunzer und Katapulte", "Ich baue Grunzer und Katapulte")
  call AddTranslation(lang, "HeadCatapults", "Kopfjger und Katapulte", "Ich baue Kopfjger und Katapulte")
  call AddTranslation(lang, "Wyvern", "Windreiter", "Ich baue massiv Windreiter")
  call AddTranslation(lang, "BarrackMix", "Einheitenmix aus Kaserne", "Ich mixe Einheiten aus der Kaserne")
  call AddTranslation(lang, "BestiaryMix", "Einheitenmix aus Bestiarium", "Ich mixe Einheiten aus dem Bestiarium")
  call AddTranslation(lang, "AntiPierce", "Nahkampf", "Ich baue Nahkampfeinheiten und Ruber")
  call AddTranslation(lang, "AntiAir", "Fledermausreiter", "Ich baue massiv Fledermausreiter")
  call AddTranslation(lang, "OAntiTower", "Anti Trme", "Ich baue massiv Belagerungswaffen")
  call AddTranslation(lang, "VersusHuman", "Ruber und Geistlufer", "Ich baue Ruber und Geisterlufer")
  call AddTranslation(lang, "VersusUndead", "Grunzer und Bestiarium", "Ich baue Grunzer und mixe Einheiten aus dem Bestiarium")
  call AddTranslation(lang, "VersusElf", "Ruber und Verwster", "Ich baue Ruber und Verwster")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "Ich spiele normal und baue von Allem etwas")
  call AddTranslation(lang, "ROCWyrms", "Wyrms", "Ich versuche einen Wyrmrush mit ein paar Gruftbestien")
  call AddTranslation(lang, "ROCBanshee", "Banshees", "Ich baue hauptschlich Banshees")
  call AddTranslation(lang, "ROCNecro", "Totenbeschwrer", "Ich baue Totenbeschwrer")
  call AddTranslation(lang, "ROCGhouls", "Ghoule", "Ich baue massiv Ghoule")
  call AddTranslation(lang, "ROCFiends", "Gruftbestien", "Ich baue massiv Gruftbestien")
  call AddTranslation(lang, "ROCGargWyrm", "Gargoyles and Wyrms", "Ich baue Gargoyles and Wyrms")
  call AddTranslation(lang, "ROCAboms", "Monstrositten", "Ich baue massiv Monstrositten")
  call AddTranslation(lang, "ROCMeatFiends", "Fleischwagen und Gruftbestien", "Ich baue Gruftbestien und Fleischwagen")
  call AddTranslation(lang, "MassDestroyer", "Zerstrer", "Ich baue massiv Zerstrer")
  call AddTranslation(lang, "NormalUndead", "Normal", "Ich spiele normal und baue von Allem etwas")
  call AddTranslation(lang, "Wyrms", "Wyrms", "Ich versuche einen Wyrmrush mit ein paar Gruftbestien")
  call AddTranslation(lang, "Banshee", "Banshees", "Ich baue hauptschlich Banshees")
  call AddTranslation(lang, "Necro", "Totenbeschwrer", "Ich baue Totenbeschwrer")
  call AddTranslation(lang, "Ghouls", "Ghoule", "Ich baue massiv Ghoule")
  call AddTranslation(lang, "Fiends", "Gruftbestien", "Ich baue massiv Gruftbestien")
  call AddTranslation(lang, "GargWyrm", "Gargoyles and Wyrms", "Ich baue Gargoyles and Wyrms")
  call AddTranslation(lang, "Aboms", "Monstrositten", "Ich baue massiv Monstrositten")
  call AddTranslation(lang, "MeatFiends", "Fleischwagen und Gruftbestien", "Ich baue Gruftbestien und Fleischwagen")
  call AddTranslation(lang, "MassDestroyer", "Zerstrer", "Ich baue massiv Zerstrer")
  call AddTranslation(lang, "CryptMix", "Einheitenmix aus Gruft", "Ich mixe Einheiten aus der Gruft")
  call AddTranslation(lang, "TempleMix", "Einheitenmix aus Tempel", "Ich mixe Einheiten aus dem Tempel der Verdammten")
  call AddTranslation(lang, "UAntiTower", "Anti Trme", "Ich baue massiv Belagerungswaffen")
  call AddTranslation(lang, "airair", "Luft-Luft", "Ich baue Luft-Luft-Einheiten")
  call AddTranslation(lang, "airground", "Luft-Boden", "Ich baue Luft-Boden-Einheiten")
  call AddTranslation(lang, "groundair", "Boden-Luft", "Ich baue Boden-Luft-Einheiten")
  call AddTranslation(lang, "groundground", "Boden-Boden", "Ich baue Boden-Boden-Einheiten")
  call AddTranslation(lang, "farm", "Farmen", "Ich baue Farmen")
  call AddTranslation(lang, "guard", "Trme", "Ich baue Trme")
  set lang = "Swedish"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "Jag spelar som vanligt och bygger lite av varje")
  call AddTranslation(lang, "ROCMassHD", "Hunts och Dryads", "Jag bygger huntress och ett par dryads")
  call AddTranslation(lang, "ROCDruids", "Dryads och DotC", "Jag skaffar dryads och DotC")
  call AddTranslation(lang, "ROCHippo", "Hippo Riders", "Jag bygger hippo riders")
  call AddTranslation(lang, "ROCBallista", "Ballista", "Jag skaffar ballista och dryads")
  call AddTranslation(lang, "ROCTalon", "Talon", "Jag bygger massa DotT")
  call AddTranslation(lang, "ROCHippoChim", "HippoChim", "Jag bygger hippos och chimaeras")
  call AddTranslation(lang, "ROCDryadChim", "DryadChim", "Jag skaffar dryads och chimaeras")
  call AddTranslation(lang, "ROCArcher", "Archers", "Jag bygger mass archers")
  call AddTranslation(lang, "ROCDotC", "DotC", "Jag bygger mass DotC")
  call AddTranslation(lang, "NormalElf", "Normal", "Jag spelar som vanligt och bygger lite av varje")
  call AddTranslation(lang, "MassHD", "Hunts och Dryads", "Jag bygger huntress och ett par dryads")
  call AddTranslation(lang, "Druids", "Dryads och DotC", "Jag skaffar dryads och DotC")
  call AddTranslation(lang, "Hippo", "Hippo Riders", "Jag bygger hippo riders")
  call AddTranslation(lang, "Ballista", "Ballista", "Jag skaffar ballista och dryads")
  call AddTranslation(lang, "Talon", "Talon", "Jag bygger massa DotT")
  call AddTranslation(lang, "HippoChim", "HippoChim", "Jag bygger hippos och chimaeras")
  call AddTranslation(lang, "DryadChim", "DryadChim", "Jag skaffar dryads och chimaeras")
  call AddTranslation(lang, "Archer", "Archers", "Jag bygger mass archers")
  call AddTranslation(lang, "DotC", "DotC", "Jag bygger mass DotC")
  call AddTranslation(lang, "MassHuntress", "MassHunts", "Jag bygger massvis med huntress")
  call AddTranslation(lang, "MGDryads", "MGDryads", "Jag bygger mountain giants och dryader")
  call AddTranslation(lang, "AoWMix", "AoWMix", "Jag mixar enheter frn ancient of war")
  call AddTranslation(lang, "AoLMix", "AoLMix", "Jag mixar enheter frn ancient of lore och ancient of wind")
  call AddTranslation(lang, "NEAntiTower", "Anti Torn", "Jag massar siege")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "Jag spelar vanligt och bygger lite av varje")
  call AddTranslation(lang, "ROCMassSp", "Casters", "Jag massar casters")
  call AddTranslation(lang, "ROCGryph", "Gryphon", "Jag bygger massa gryphons")
  call AddTranslation(lang, "ROCKnight", "Knights", "Jag skaffar footmen och knights")
  call AddTranslation(lang, "ROCRifle", "Rifle", "Jag kr massa riflemen")
  call AddTranslation(lang, "ROCMortars", "Mortars", "Jag skaffar mortars och riflemen")
  call AddTranslation(lang, "ROCCopters", "Copters", "Jag massar flygmaskiner")
  call AddTranslation(lang, "NormalHuman", "Normal", "Jag spelar vanligt och bygger lite av varje")
  call AddTranslation(lang, "MassSp", "Casters", "Jag massar casters")
  call AddTranslation(lang, "Gryph", "Gryphon", "Jag bygger massa gryphons")
  call AddTranslation(lang, "Knight", "Knights", "Jag skaffar footmen och knights")
  call AddTranslation(lang, "Rifle", "Rifle", "Jag kr massa riflemen")
  call AddTranslation(lang, "Mortars", "Mortars", "Jag skaffar mortars och riflemen")
  call AddTranslation(lang, "Copters", "Copters", "Jag massar flygmaskiner")
  call AddTranslation(lang, "MassSB", "MassSpellBreakers", "Jag bygger massvis med spell breakers")
  call AddTranslation(lang, "Dragonhawks", "Dragonhawks", "Jag bygger massa dragonhawks")
  call AddTranslation(lang, "BarrackMix", "BarrackMix", "Jag mixar enheter frn barrack och workshop")
  call AddTranslation(lang, "SanctumMix", "SanctumMix", "Jag mizar enheter frn sanctum och aviary")
  call AddTranslation(lang, "HAntiTower", "Anti Torn", "Jag massar siege")
  call AddTranslation(lang, "VersusOrc", "Mass Sorceress", "Jag bygger massa sorceress")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "Jag skaffar grunts och casters")
  call AddTranslation(lang, "ROCFastSh", "Shamans och Taurens", "Jag skaffar shamans och taurens")
  call AddTranslation(lang, "ROCKodo", "Kodo", "Jag bygger massa kodo-beast")
  call AddTranslation(lang, "ROCWyvSh", "Shamans och Wyverns", "Jag bygger shamans och wyverns")
  call AddTranslation(lang, "ROCHHunters", "Head Hunters", "Jag bygger massa head hunters")
  call AddTranslation(lang, "ROCRaiders", "Raiders", "Jag kr massa raiders")
  call AddTranslation(lang, "ROCCatapults", "Grunts och Katapulter", "Jag bygger grunts och katapulter")
  call AddTranslation(lang, "ROCHeadCatapults", "Head Hunters och Katapulter", "Jag skaffar headhunters och katapulter")
  call AddTranslation(lang, "NormalOrc", "Normal", "Jag skaffar grunts och casters")
  call AddTranslation(lang, "FastSh", "Shamans och Taurens", "Jag skaffar shamans och taurens")
  call AddTranslation(lang, "WyvSh", "Shamans och Wyverns", "Jag bygger shamans och wyverns")
  call AddTranslation(lang, "HHunters", "Head Hunters", "Jag bygger massa head hunters")
  call AddTranslation(lang, "Raiders", "Raiders", "Jag kr massa raiders")
  call AddTranslation(lang, "GruntCatapults", "Grunts och Katapulter", "Jag bygger grunts och katapulter")
  call AddTranslation(lang, "HeadCatapults", "Head hunters och Katapulter", "Jag skaffar head hunters och katapulter")
  call AddTranslation(lang, "Wyverns", "Wyverns", "Jag bygger massa wyverns")
  call AddTranslation(lang, "BarrackMix", "BarrackMix", "Jag mixar enheter frn barrack")
  call AddTranslation(lang, "BestiaryMix", "BestiaryMix", "Jag mixar enheter frn bestiary")
  call AddTranslation(lang, "AntiPierce", "Anti Pierce", "Jag skaffar melee och raiders")
  call AddTranslation(lang, "AntiAir", "Batriders", "Jag massar bats")
  call AddTranslation(lang, "OAntiTower", "Anti Torn", "Jag massar siege")
  call AddTranslation(lang, "VersusHuman", "Raiders and Spirtwalkers", "Jag kr p raiders och spirit walkers")
  call AddTranslation(lang, "VersusUndead", "Grunts and Beastiary", "Jag kr grunts och lite blandat frn beastiary")
  call AddTranslation(lang, "VersusElf", "Raiders and Demolishers", "Jag kr raiders och demolishers")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "Jag spelar som vanligt och bygger lite av varje")
  call AddTranslation(lang, "ROCWyrms", "Wyrms", "Jag bygger wyrms och crypt fiends")
  call AddTranslation(lang, "ROCBanshee", "Banshees", "Jag skaffar banshees")
  call AddTranslation(lang, "ROCNecro", "Necros", "Jag bygger necromancers")
  call AddTranslation(lang, "ROCGhouls", "Ghouls", "Jag kr massa ghouls")
  call AddTranslation(lang, "ROCFiends", "Fiends", "Jag bygger massa crypt fiends")
  call AddTranslation(lang, "ROCGargWyrm", "Gargoyles och Wyrms", "Jag bygger gargs och wyrms")
  call AddTranslation(lang, "ROCAboms", "Aboms", "Jag skaffar massa abominations")
  call AddTranslation(lang, "ROCMeatFiends", "Meat wagons och Fiends", "Jag bygger fiends och meat wagons")
  call AddTranslation(lang, "NormalUndead", "Normal", "Jag spelar som vanligt och bygger lite av varje")
  call AddTranslation(lang, "Wyrms", "Wyrms", "Jag bygger wyrms och crypt fiends")
  call AddTranslation(lang, "Banshee", "Banshees", "Jag skaffar banshees")
  call AddTranslation(lang, "Necro", "Necros", "Jag bygger necromancers")
  call AddTranslation(lang, "Ghouls", "Ghouls", "Jag kr massa ghouls")
  call AddTranslation(lang, "Fiends", "Fiends", "Jag bygger massa crypt fiends")
  call AddTranslation(lang, "GargWyrm", "Gargoyles och Wyrms", "Jag bygger gargs och wyrms")
  call AddTranslation(lang, "Aboms", "Aboms", "Jag skaffar massa abominations")
  call AddTranslation(lang, "MeatFiends", "Meat wagons och Fiends", "Jag bygger fiends och meat wagons")
  call AddTranslation(lang, "MassDestroyer", "MassDestroyers", "Jag bygger massa destroyers")
  call AddTranslation(lang, "CryptMix", "CryptMix", "Jag mixar enheter frb crypt")
  call AddTranslation(lang, "TempleMix", "TempleMix", "Jag mixar enheter frn temple och slaughter house")
  call AddTranslation(lang, "UAntiTower", "Anti Torn", "Jag massar siege")
  call AddTranslation(lang, "airair", "Luft-Luft", "Jag bygger luft- mot luftenheter")
  call AddTranslation(lang, "airground", "Luft-Mark", "Jag bygger luft- mot markenheter")
  call AddTranslation(lang, "groundair", "Mark-Luft", "Jag bygger mark- mot luftenheter")
  call AddTranslation(lang, "groundground", "Mark-Mark", "Jag bygger mark- mot markenheter")
  call AddTranslation(lang, "farm", "Farms", "Jag bygger farms")
  call AddTranslation(lang, "guard", "Torn", "Jag bygger torn")
  set lang = "French"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "Je joue normalement et je construis quelque chose de tout.")
  call AddTranslation(lang, "ROCMassHD", "Chasseresses et Dryades.", "Je vais creer massivement des chasseresses avec quelques Dryades.")
  call AddTranslation(lang, "ROCDruids", "Dryades et Druides Ours.", "Je vais creer des Dryades et des Druides Ours.")
  call AddTranslation(lang, "ROCHippo", "Chevaucheurs d'hippogryphe.", "Je vais creer Chevaucheurs d'hippogryphe.")
  call AddTranslation(lang, "ROCBallista", "Baliste.", "I'm going glaive throwers and dryads")
  call AddTranslation(lang, "ROCTalon", "Druide Corbeau.", "Je vais creer des druides corbeau massivement.")
  call AddTranslation(lang, "ROCHippoChim", "Hippogryphe et Chimere.", "Je vais creer des Hippogryphes et des chimeres.")
  call AddTranslation(lang, "ROCDryadChim", "Dryades et Chimeres.", "Je vais creer des Dryades et des Chimeres.")
  call AddTranslation(lang, "ROCArcher", "Archers", "Je vais creer des archers en masse.")
  call AddTranslation(lang, "ROCDotC", "Druides Ours", "Je vais creer des Druides Ours massivement.")
  call AddTranslation(lang, "NormalElf", "Normal", "Je vais jouer normalement, je vais faire un peu de tout")
  call AddTranslation(lang, "MassHD", "Hunts and Dryads", "Je vais faire des chasseresses et des dryades")
  call AddTranslation(lang, "Druids", "Dryads and DotC", "Je vais faire des dryades et des druides ours")
  call AddTranslation(lang, "Hippo", "Hippo Riders", "Je vais faire beaucoups de chevaucheurs d'hippogryphe")
  call AddTranslation(lang, "Ballista", "Ballista", "Je vais construire des balistes et des dryades")
  call AddTranslation(lang, "Talon", "Talon", "Je vais construire des druides corbeaux en masse")
  call AddTranslation(lang, "HippoChim", "HippoChim", "Je vais aller pour des hippogryphes et des Chimres")
  call AddTranslation(lang, "DryadChim", "DryadChim", "Je m'occupe des dryades et des chimres")
  call AddTranslation(lang, "Archer", "Archers", "Je vaise faire beaucoup d'archers")
  call AddTranslation(lang, "DotC", "Bears", "Je vais m'occuper de faire des druides ours ")
  call AddTranslation(lang, "MassHuntress", "Mass Hunts", "Je vais faire beaucoup de chasseresses")
  call AddTranslation(lang, "MGDryads", "Dryads and MGs", "Je vais utiliser des dryades et des gants")
  call AddTranslation(lang, "AoWMix", "AoW Mix", "Je fais utiliser des units de l'ancient du vent")
  call AddTranslation(lang, "AolMix", "AoL Mix", "Je vais mlanger des units de l'ancient de Lore")
  call AddTranslation(lang, "NEAntiTower", "Anti Tower", "Je vais utiliser du sige")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "Je joue normalement et je construis quelque chose de tout.")
  call AddTranslation(lang, "ROCMassSp", "Casters", "Je vais creer des casters massivement.")
  call AddTranslation(lang, "ROCGryph", "Chevaucheur de griffon.", "Je vais creer des Chevaucheurs de griffon.")
  call AddTranslation(lang, "ROCKnight", "Chevaliers.", "Je vais creer des Fantassins et des Chevaliers en masse.")
  call AddTranslation(lang, "ROCRifle", "Fusilier.", "Je vais creer massivement des Fusiliers.")
  call AddTranslation(lang, "ROCMortars", "Mortiers", "Je vais creer massivement des Mortiers.")
  call AddTranslation(lang, "ROCCopters", "Gyrocopteres.", "Je vais creer des Gyrocopteres.")
  call AddTranslation(lang, "NormalHuman", "Normal", "Je vais jouer normalement, avec un peu de tout.")
  call AddTranslation(lang, "MassSp", "Casters", "Je vais masser des caster de sorts")
  call AddTranslation(lang, "Gryph", "Gryphon", "je vais faire des gryphons")
  call AddTranslation(lang, "Knight", "Knights", "Je vais faire des chevalier et des fantassins")
  call AddTranslation(lang, "Rifle", "Rifle", "Je vais faire des fusilier et des prtre")
  call AddTranslation(lang, "Mortars", "Mortars", "Je m'occupe des fusiliers et des mortiers")
  call AddTranslation(lang, "Copters", "Copters", "Je vais m'occuper des gyrocoptres")
  call AddTranslation(lang, "MassSB", "SpellBreakers", "Je vais masser des briseurs de sorts")
  call AddTranslation(lang, "Dragonhawk", "Dragon Hawks", "Je vais utiliser des chevaucheur de dragons ")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "Je vais mlanger des units des barraques et de l'atelier")
  call AddTranslation(lang, "SanctumMix", "Sanctum Mix", "J'ssai de mlanger des units du Sanctum")
  call AddTranslation(lang, "HAntiTower", "Anti Tower", "Je vais faire beaucoup de siges")
  call AddTranslation(lang, "VersusOrc", "Mass Sorceress", "Je m'occupe des sorcires")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "Je vais creer des grunts et des casters.")
  call AddTranslation(lang, "ROCFastSh", "Chamans et Taurens.", "Je vais creer des Chamans et des Taurens.")
  call AddTranslation(lang, "ROCKodo", "Bete Kodo.", "Je vais creer des Betes Kodo en masse.")
  call AddTranslation(lang, "ROCWyvSh", "Chamans and Wyvernes.", "Je vais creer des Chamans et des Wyvernes.")
  call AddTranslation(lang, "ROCHHunters", "Chasseurs de tetes.", "Je vais creer massivement des Chasseurs de tetes.")
  call AddTranslation(lang, "ROCRaiders", "Chevaucheurs de Loup.", "Je vais creer des Chevaucheurs de Loup en masse.")
  call AddTranslation(lang, "ROCCatapults", "Grunts and Catapultes.", "Je vais creer des grunts et des demolishers.")
  call AddTranslation(lang, "ROCHeadCatapults", "Chasseurs de tetes and Catapultes.", "Je vais creer des Chasseurs de tetes et des demolishers.")
  call AddTranslation(lang, "NormalOrc", "Normal", "Je vais faire des grunts et des casters")
  call AddTranslation(lang, "FastSh", "Shamans and Taurens", "Je m'occupe des casters et des taurens")
  call AddTranslation(lang, "WyvSh", "Shamans and Wyverns", "Je vais essayer des shamans et des wyverns")
  call AddTranslation(lang, "HHunters", "Head Hunters", "Je vais masser des trolls")
  call AddTranslation(lang, "Raiders", "Raiders", "Je mass des chevaucheurs de loups")
  call AddTranslation(lang, "GruntCatapults", "Grunts and Catapults", "Je vais faire du sige et des grunts")
  call AddTranslation(lang, "HeadCatapults", "Head hunters and Catapults", "j'ssai des trolls et des catapultes")
  call AddTranslation(lang, "Wyvern", "Mass Wyvern", "Je m'occupe des wyvernes")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "Je fais un mlanege des barraques")
  call AddTranslation(lang, "BestiaryMix", "Bestiary Mix", "je fais un mlange des units du bestiaire")
  call AddTranslation(lang, "AntiPierce", "Anti Pierce", "Je vais utiliser de mle")
  call AddTranslation(lang, "AntiAir", "Batriders", "Je vais utiliser des chevaucher de chauve-souris")
  call AddTranslation(lang, "OAntiTower", "Anti Tower", "Je m'occupe du sige")
  call AddTranslation(lang, "VersusHuman", "Raiders and Spirtwalkers", "Je vais faires des chevaucheurs de loups et des shamans taurens")
  call AddTranslation(lang, "VersusUndead", "Grunts and Beastiary", "Je vais faire des grunts et des unites du bestiaire")
  call AddTranslation(lang, "VersusElf", "Raiders and Demolishers", "je m'occupe des chevaucheurs de loup et des dmolisseurs")
  call AddTranslation(lang, "NormalUndead", "Normal", "je vais jouer normal et utiliser un peu de tout")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "Je joue normalement et je construis quelque chose de tout.")
  call AddTranslation(lang, "ROCWyrms", "Wyrms des glaces.", "Je vais creer massivement des Wyrms des glaces avec quelques Demons de cryptes.")
  call AddTranslation(lang, "ROCBanshee", "Banshees.", "Je vais creer principalement des Banshees.")
  call AddTranslation(lang, "ROCNecro", "Necromanciens.", "Je vais creer des Necromanciens.")
  call AddTranslation(lang, "ROCGhouls", "Goules.", "Je vais creer des Goules en masse.")
  call AddTranslation(lang, "ROCFiends", "Demons des cryptes.", "Je vais creer massivement des Demons des cryptes.")
  call AddTranslation(lang, "ROCGargWyrm", "Gargouilles and Wyrms des glaces.", "Je vais creer des gargouilles et des Wyrms des glaces.")
  call AddTranslation(lang, "ROCAboms", "Abominations.", "Je vais creer des Abominations en masse.")
  call AddTranslation(lang, "ROCMeatFiends", "Chariots a viande et Demons des cryptes.", "Je vais creer des Chariots a viande et des Demons des cryptes.")
  call AddTranslation(lang, "NormalUndead", "Normal", "je vais jouer normal et utiliser un peu de tout")
  call AddTranslation(lang, "Wyrms", "Wyrms", "Je vais faire des wyrms et des dmons des cryptes")
  call AddTranslation(lang, "Banshee", "Banshees", "Je m'occupe dse banshees")
  call AddTranslation(lang, "Necro", "Necros", "Je vais utiliser des ncros")
  call AddTranslation(lang, "Ghouls", "Ghouls", "Je vais masser des ghoules")
  call AddTranslation(lang, "Fiends", "Fiends", "Je vais masser des dmons des cryptes")
  call AddTranslation(lang, "GargWyrm", "Gargoyles and Wyrms", "Je m'occupe des wyrms et des gargouilles")
  call AddTranslation(lang, "Aboms", "Aboms", "Je vais masser des abominations")
  call AddTranslation(lang, "MeatFiends", "Meat wagons and Fiends", "Je vais essayer des dmons des cryptes et des catapultes")
  call AddTranslation(lang, "MassDestroyer", "Mass Destroyers", "Je vais faire des obsidian")
  call AddTranslation(lang, "CryptMix", "Crypt Mix", "Je vais mlanger des units de la crypte et slaughterhouse")
  call AddTranslation(lang, "TempleMix", "Temple Mix", "Je mlande le temple et la slaughterhouse")
  call AddTranslation(lang, "UAntiTower", "Anti Tower", "Je vais utiliser du sige")
  call AddTranslation(lang, "airair", "Air-Air", "Je construis des unites air-air.")
  call AddTranslation(lang, "airground", "Air-Sol", "Je construis des unites air-sol.")
  call AddTranslation(lang, "groundair", "Sol-Air", "Je construis des unites sol-air.")
  call AddTranslation(lang, "groundground", "Sol-Sol", "Je construis des unites sol-sol.")
  call AddTranslation(lang, "farm", "Fermes", "Je construis des fermes.")
  call AddTranslation(lang, "guard", "Tourelles", "Je construis des tourelles.")
  set lang = "Spanish"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "Voy a jugar normal y construir algo de cada cosa")
  call AddTranslation(lang, "ROCMassHD", "Cazadoras y Dryads", "Voy a construir Cazadoras en masa y algunas Dryads")
  call AddTranslation(lang, "ROCDruids", "Dryads y Druidas de la garra", "Voy a construir Dryads y Druidas de la garra")
  call AddTranslation(lang, "ROCHippo", "Montadoras de hipogrifos", "Voy a construir montadoras de hipogrifos")
  call AddTranslation(lang, "ROCBallista", "Ballista", "Voy a construir Ballistas y Dryads")
  call AddTranslation(lang, "ROCTalon", "Talon", "Voy a construir Druidas del Talon en masa")
  call AddTranslation(lang, "ROCHippoChim", "HipoQuim", "Voy a construir hipogrifos y quimera")
  call AddTranslation(lang, "ROCDryadChim", "DryadQuim", "Voy a construir dryads y quimeras")
  call AddTranslation(lang, "ROCArcher", "Arqueras", "Voy a construir arqueras en masa")
  call AddTranslation(lang, "ROCDotC", "Osos", "Voy a construir Druidas de la garra en masa")
  call AddTranslation(lang, "NormalElf", "Normal", "Yo jugar normal y construir de todo un poco")
  call AddTranslation(lang, "MassHD", "Cazadoras y Drades", "Voy a hacer cazadoras en masa con algunas drades")
  call AddTranslation(lang, "Druids", "Drades y DotC", "Har drades y Druidas de la Garra")
  call AddTranslation(lang, "Hippo", "Jinetes Hippo", "Har hippo raiders en masa")
  call AddTranslation(lang, "Ballista", "Ballesta", "Har lanzadores the sables y drades")
  call AddTranslation(lang, "Talon", "Talon", "Har Druidas del Taln en masa")
  call AddTranslation(lang, "HippoChim", "HippoQuim", "Har hippos y quimeras")
  call AddTranslation(lang, "DryadChim", "DradeQuim", "Har drades y quimeras")
  call AddTranslation(lang, "Archer", "Arqueras", "Estoy haciendo arqueras en masa")
  call AddTranslation(lang, "DotC", "Osos", "Intentando Druidas de la Garra en masa")
  call AddTranslation(lang, "MassHuntress", "Cazadoras en Masa", "Haciendo cazadoras en masa con algunas drades")
  call AddTranslation(lang, "MGDryads", "Drades y GigMontaas", "Haciendo drades y Gigantes de la Montaa")
  call AddTranslation(lang, "AoWMix", "Mezcla AoV", "Mezclando unidades del Ancestro de Viento")
  call AddTranslation(lang, "AolMix", "Mezcla AoS", "Mezclando unidades del Ancestro de Sabiduria")
  call AddTranslation(lang, "NEAntiTower", "Anti Torre", "Estoy reuniendo equipo de demolicin")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "Voy a jugar normal y construir algo de cada cosa")
  call AddTranslation(lang, "ROCMassSp", "Magicas", "Voy a construir unidades magicas en masa")
  call AddTranslation(lang, "ROCGryph", "Grifo", "Voy a construir montadores de grifos")
  call AddTranslation(lang, "ROCKnight", "Caballeros", "Voy a construir Soldados rasos y caballeros en masa")
  call AddTranslation(lang, "ROCRifle", "Rifle", "Voy a construir rifleros en masa")
  call AddTranslation(lang, "ROCMortars", "Morteros", "Voy a construir equipos morteros")
  call AddTranslation(lang, "ROCCopters", "Girocopteros", "Voy a construir maquinas voladoras")
  call AddTranslation(lang, "NormalHuman", "Normal", "Yo jugar normal y construir de todo un poco")
  call AddTranslation(lang, "MassSp", "Hechizeros", "Haciendo hechizeros en masa")
  call AddTranslation(lang, "Gryph", "Gryphon", "Har jinetes de grifos")
  call AddTranslation(lang, "Knight", "Caballeros", "Har soldados y caballeros en masa")
  call AddTranslation(lang, "Rifle", "Fusil", "Haciendo Fusileros y sacerdotes en masa")
  call AddTranslation(lang, "Mortars", "Mortero", "Haciendo Equipos mortero y Fusileros")
  call AddTranslation(lang, "Copters", "Helicopteros", "Haciendo mquinas voladoras")
  call AddTranslation(lang, "MassSB", "RompeHechizos", "Haciendo Rompehechizos en masa")
  call AddTranslation(lang, "Dragonhawk", "Hacones Dragon", "Haciendo Halcones Dragon")
  call AddTranslation(lang, "BarrackMix", "Mezcla Barracas", "Intentar mezclar unidades de las barracas y del taller")
  call AddTranslation(lang, "SanctumMix", "Mezcla Santuario", "Intentar mezclar unidades del santuario y el nido de grifos")
  call AddTranslation(lang, "HAntiTower", "Anti Torre", "Estoy reuniendo equipo de demolicin")
  call AddTranslation(lang, "VersusOrc", "Hechizeras en masa", "Haciendo hechizeras en masa")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "Voy a construir grunts y unidades magicas")
  call AddTranslation(lang, "ROCFastSh", "Shamanes y Taurens", "Voy a construir shamanes y taurens")
  call AddTranslation(lang, "ROCKodo", "Kodo", "Voy a construir bestias Kodo")
  call AddTranslation(lang, "ROCWyvSh", "Shamanes y Wyverns", "Voy a construir Shamanes y Wyverns")
  call AddTranslation(lang, "ROCHHunters", "trolls", "Voy a construir trolls arranca cabezas en masa")
  call AddTranslation(lang, "ROCRaiders", "Raiders", "Voy a construir raiders en masa")
  call AddTranslation(lang, "ROCCatapults", "Grunts y Catapultas", "Voy a construir grunts y demoledores")
  call AddTranslation(lang, "ROCHeadCatapults", "Trolls y Catapultas", "Voy a construir Trolls arranca cabezas y demoledors")
  call AddTranslation(lang, "NormalOrc", "Normal", "Haciendo grunts y hechizeros")
  call AddTranslation(lang, "FastSh", "Chamanes y Taurens", "Har hechizeros y Taurens")
  call AddTranslation(lang, "WyvSh", "Chamanes y Wyverns", "Haciendo Chamanes y Wyverns")
  call AddTranslation(lang, "HHunters", "Trolles Arrancacabezas", "Tratar Trolles arrancacabezas en masa")
  call AddTranslation(lang, "Raiders", "Incursores", "Hare Incursores en masa")
  call AddTranslation(lang, "GruntCatapults", "Grunts and Catapultas", "Har Grunts y demoledores")
  call AddTranslation(lang, "HeadCatapults", "Arrancacabezas y Catapultas", "Intentemos con Trolles arrancacabezas y demoledores")
  call AddTranslation(lang, "Wyvern", "Wyverns en masa", "Haciendo Wyverns en masa")
  call AddTranslation(lang, "BarrackMix", "Mezcla Barracas", "Estoy mezclando unidades de las barracas")
  call AddTranslation(lang, "BestiaryMix", "Mezcla Bestiario", "Estoy mezclando unidades del bestiario")
  call AddTranslation(lang, "AntiPierce", "Anti Lanzas", "Estoy haciendo unidades melee e incursores")
  call AddTranslation(lang, "AntiAir", "Jinetes Murcielago", "Estoy amasando Jinetes de murcilagos")
  call AddTranslation(lang, "OAntiTower", "Anti Torre", "Estoy reuniendo equipo de demolicin")
  call AddTranslation(lang, "VersusHuman", "Incursores y Spiritus", "Estoy haciendo Incursores y espritus caminantes")
  call AddTranslation(lang, "VersusUndead", "Grunts y Beastiario", "Haciendo grunts y una mezcla del bestiario")
  call AddTranslation(lang, "VersusElf", "Incursores y Catapultas", "Haciendo incursores y demoledores")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "Voy a jugar normal y voy a construir algo de cada cosa")
  call AddTranslation(lang, "ROCWyrms", "Wyrms", "Voy a construir Wyrms de hielo rapidamente con algunos demonios de la cripta")
  call AddTranslation(lang, "ROCBanshee", "Banshees", "Voy a construir banshees principalmente")
  call AddTranslation(lang, "ROCNecro", "Necros", "Voy a construir necromantes")
  call AddTranslation(lang, "ROCGhouls", "Necrosagos", "Voy a construir Necrosagos en masa")
  call AddTranslation(lang, "ROCFiends", "Demonios", "Voy a construir demonios de la cripta en masa")
  call AddTranslation(lang, "ROCGargWyrm", "Gargolas y Wyrms", "Voy a construir gargolas y wyrms")
  call AddTranslation(lang, "ROCAboms", "Aboms", "Voy a construir abominaciones en masa")
  call AddTranslation(lang, "ROCMeatFiends", "Vagones de carne y demonios", "Voy a construir demonios de la cripta y vagones de carne")
  call AddTranslation(lang, "NormalUndead", "Normal", "Yo jugar normal y construir de todo un poco")
  call AddTranslation(lang, "Wyrms", "Wyrms", "Haciendo Wyrms y unos cuantos demonios de la cripta")
  call AddTranslation(lang, "Banshee", "Banshees", "Har principalmente Banshees")
  call AddTranslation(lang, "Necro", "Nigromantes", "Tratando con Nigromantes")
  call AddTranslation(lang, "Ghouls", "Necrfagos", "Har Necrfagos en masa")
  call AddTranslation(lang, "Fiends", "Demonios Cripta", "Voy a hacer Demonios de la cripta en masa")
  call AddTranslation(lang, "GargWyrm", "Gargolas y Wyrms", "Har Grgolas y Wyrms")
  call AddTranslation(lang, "Aboms", "Abominaciones", "Har Abominaciones en masa")
  call AddTranslation(lang, "MeatFiends", "Carros y Demonios Cripta", "Tratar Demonios de la cripta y carros de despojos")
  call AddTranslation(lang, "MassDestroyer", "Destructores en masa", "Haciendo Destructores en masa")
  call AddTranslation(lang, "CryptMix", "Mezcla de la Cripta", "Intentando con unidades de la Cripta y la Casa de la Tortura")
  call AddTranslation(lang, "TempleMix", "Mezcla Templo", "Mezclando unidades del templo de los malditos y la Casa de la Tortura")
  call AddTranslation(lang, "AntiTower", "Anti Torre", "Estoy reuniendo equipo de demolicin")
  call AddTranslation(lang, "airair", "Aire-aire", "Voy a construir Unidades aire-aire")
  call AddTranslation(lang, "airground", "Aire-tierra", "Voy a construir unidades Aire-tierra")
  call AddTranslation(lang, "groundair", "Tierra-Aire", "Voy a construir unidades Tierra-aire")
  call AddTranslation(lang, "groundground", "Tierra-Tierra", "Voy a construir unidades Tierra-tierra")
  call AddTranslation(lang, "farm", "Granjas", "Voy a construir granjas")
  call AddTranslation(lang, "guard", "Torres", "Voy a construir torres")
  set lang = "Romanian"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "Voi juca normal si voi face cite ceva din toate")
  call AddTranslation(lang, "ROCMassHD", "Hunts si Dryads", "Voi face multe huntress cu ceva dryads")
  call AddTranslation(lang, "ROCDruids", "Dryads si DotC", "Voi face dryads si DotC")
  call AddTranslation(lang, "ROCHippo", "Hippo Riders", "Voi face hippo riders")
  call AddTranslation(lang, "ROCBallista", "Ballista", "Voi face glaive throwers si dryads")
  call AddTranslation(lang, "ROCTalon", "Talon", "Voi face multi DotT")
  call AddTranslation(lang, "ROCHippoChim", "HippoChim", "Voi face hippos si chimaera")
  call AddTranslation(lang, "ROCDryadChim", "DryadChim", "Voi face dryads si chimaeras")
  call AddTranslation(lang, "ROCArcher", "Archers", "Voi face multi archers")
  call AddTranslation(lang, "ROCDotC", "Bears", "Voi face multi DotC")
  call AddTranslation(lang, "NormalElf", "Normal", "Voi juca normal si voi face cite ceva din toate")
  call AddTranslation(lang, "MassH", "Hunts si Dryads", "Voi face multe huntress cu ceva dryads")
  call AddTranslation(lang, "Druids", "Dryads si DotC", "Voi face dryads si DotC")
  call AddTranslation(lang, "Hippo", "Hippo Riders", "Voi face hippo riders")
  call AddTranslation(lang, "Ballista", "Ballista", "Voi face glaive throwers si dryads")
  call AddTranslation(lang, "Talon", "Talon", "Voi face multi DotT")
  call AddTranslation(lang, "HippoChim", "HippoChim", "Voi face hippos si chimaera")
  call AddTranslation(lang, "DryadChim", "DryadChim", "Voi face dryads si chimaeras")
  call AddTranslation(lang, "Archer", "Archers", "Voi face multi archers")
  call AddTranslation(lang, "DotC", "Bears", "Voi face multi DotC")
  call AddTranslation(lang, "MassHuntress", "Mass Hunts", "I'm going massive Huntresses")
  call AddTranslation(lang, "MGDryads", "Dryads and MGs", "I'm going dryads and mountain giants")
  call AddTranslation(lang, "AoWMix", "AoW Mix", "I'm mixing units from the AoW")
  call AddTranslation(lang, "AolMix", "AoL Mix", "I'm mixing units from the Ancient of Lore")
  call AddTranslation(lang, "NEAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "Voi juca normal si voi face cite ceva din toate")
  call AddTranslation(lang, "ROCMassSp", "Casters", "Voi face multi spell casters")
  call AddTranslation(lang, "ROCGryph", "Gryphon", "Voi face gryphon riders")
  call AddTranslation(lang, "ROCKnight", "Knights", "Voi face multi footmen si knights")
  call AddTranslation(lang, "ROCRifle", "Rifle", "Voi face multi riflemen")
  call AddTranslation(lang, "ROCMortars", "Mortars", "Ma duc pe mortars")
  call AddTranslation(lang, "ROCCopters", "Copters", "Voi face flying machines")
  call AddTranslation(lang, "NormalHuman", "Normal", "Voi juca normal si voi face cite ceva din toate")
  call AddTranslation(lang, "MassSp", "Casters", "Voi face multi spell casters")
  call AddTranslation(lang, "Gryph", "Gryphon", "Voi face gryphon riders")
  call AddTranslation(lang, "Knight", "Knights", "Voi face multi footmen si knights")
  call AddTranslation(lang, "Rifle", "Rifle", "Voi face multi riflemen")
  call AddTranslation(lang, "Mortars", "Mortars", "Ma duc pe mortars")
  call AddTranslation(lang, "Copters", "Copters", "Voi face flying machines")
  call AddTranslation(lang, "MassSB", "SpellBreakers", "I'm going massive spell breakers")
  call AddTranslation(lang, "Dragonhawk", "Dragon Hawks", "I'm going dragon hawks")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "I'm trying to mix units from barrack and workshop")
  call AddTranslation(lang, "SanctumMix", "Sanctum Mix", "I'm trying to mix units from sanctum and aviary")
  call AddTranslation(lang, "HAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusOrc", "Mass Sorceress", "I'm massing Sorceress")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "Voi face grunts si casters")
  call AddTranslation(lang, "ROCFastSh", "Shamans and Taurens", "Voi face casters si taurens")
  call AddTranslation(lang, "ROCKodo", "Kodo", "Voi face multi kodo-beasts")
  call AddTranslation(lang, "ROCWyvSh", "Shamans and Wyverns", "Voi face Shamans si Wyverns")
  call AddTranslation(lang, "ROCHHunters", "Head Hunters", "Voi face multi head hunters")
  call AddTranslation(lang, "ROCRaiders", "Raiders", "Voi face multi raiders")
  call AddTranslation(lang, "ROCCatapults", "Grunts and Catapults", "Voi face grunts si demolisher")
  call AddTranslation(lang, "ROCHeadCatapults", "Head hunters and Catapults", "Voi face headhunters si demolishers")
  call AddTranslation(lang, "NormalOrc", "Normal", "Voi face grunts si casters")
  call AddTranslation(lang, "FastSh", "Shamans and Taurens", "Voi face casters si taurens")
  call AddTranslation(lang, "WyvSh", "Shamans and Wyverns", "Voi face Shamans si Wyverns")
  call AddTranslation(lang, "HHunters", "Head Hunters", "Voi face multi head hunters")
  call AddTranslation(lang, "Raiders", "Raiders", "Voi face multi raiders")
  call AddTranslation(lang, "GruntCatapults", "Grunts and Catapults", "Voi face grunts si demolisher")
  call AddTranslation(lang, "HeadCatapults", "Head hunters and Catapults", "Voi face headhunters si demolishers")
  call AddTranslation(lang, "Wyvern", "Mass Wyvern", "I'm going massive wyverns")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "I'm mixing units from barrack.")
  call AddTranslation(lang, "BestiaryMix", "Bestiary Mix", "I'm mixing units from bestiary")
  call AddTranslation(lang, "AntiPierce", "Anti Pierce", "I'm going melee units and raiders")
  call AddTranslation(lang, "AntiAir", "Batriders", "I'm a massing batriders")
  call AddTranslation(lang, "OAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusHuman", "Raiders and Spirtwalkers", "I'm going raiders and spirit walkers")
  call AddTranslation(lang, "VersusUndead", "Grunts and Beastiary", "I'm going Grunts and a mix from the beastiary")
  call AddTranslation(lang, "VersusElf", "Raiders and Demolishers", "I'm going raiders and Demolishers")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "Voi juca normal si voi face cite ceva din toate")
  call AddTranslation(lang, "ROCWyrms", "Wyrms", "Voi face wyrm rush cu citiva crypt fiends")
  call AddTranslation(lang, "ROCBanshee", "Banshees", "Voi face aproape numai banshees")
  call AddTranslation(lang, "ROCNecro", "Necros", "Voi face necromancers")
  call AddTranslation(lang, "ROCGhouls", "Ghouls", "Voi face multi ghouls")
  call AddTranslation(lang, "ROCFiends", "Fiends", "Voi face multi crypt fiends")
  call AddTranslation(lang, "ROCGargWyrm", "Gargoyles and Wyrms", "Voi face gargs si wyrms")
  call AddTranslation(lang, "ROCAboms", "Aboms", "Voi face multe abominations")
  call AddTranslation(lang, "ROCMeatFiends", "Meat wagons and Fiends", "Voi face fiends si meat wagons")
  call AddTranslation(lang, "NormalUndead", "Normal", "Voi juca normal si voi face cite ceva din toate")
  call AddTranslation(lang, "Wyrms", "Wyrms", "Voi face wyrm rush cu citiva crypt fiends")
  call AddTranslation(lang, "Banshee", "Banshees", "Voi face aproape numai banshees")
  call AddTranslation(lang, "Necro", "Necros", "Voi face necromancers")
  call AddTranslation(lang, "Ghouls", "Ghouls", "Voi face multi ghouls")
  call AddTranslation(lang, "Fiends", "Fiends", "Voi face multi crypt fiends")
  call AddTranslation(lang, "GargWyrm", "Gargoyles and Wyrms", "Voi face gargs si wyrms")
  call AddTranslation(lang, "Aboms", "Aboms", "Voi face multe abominations")
  call AddTranslation(lang, "MeatFiends", "Meat wagons and Fiends", "Voi face fiends si meat wagons")
  call AddTranslation(lang, "MassDestroyer", "Mass Destroyers", "I'm going massive destroyers")
  call AddTranslation(lang, "CryptMix", "Crypt Mix", "I'm trying to mix units from crypt and slaughterhouse")
  call AddTranslation(lang, "TempleMix", "Temple Mix", "I'm mixing units from temple of the damned and slaughterhouse")
  call AddTranslation(lang, "UAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "airair", "Air-Air", "Voi face unitati Aer-Aer")
  call AddTranslation(lang, "airground", "Air-Ground", "Voi face unitati Aer-Sol")
  call AddTranslation(lang, "groundair", "Ground-Air", "Voi face unitati Sol-Aer")
  call AddTranslation(lang, "groundground", "Ground-Ground", "Voi face unitati Sol-Sol")
  call AddTranslation(lang, "farm", "Farms", "Voi construi ferme")
  call AddTranslation(lang, "guard", "Towers", "Voi construi turnuri")
  set lang = "Russian"
  call AddTranslation(lang, "ROCNormalElf", " ", "       .")
  call AddTranslation(lang, "ROCMassHD", " + ", "      .")
  call AddTranslation(lang, "ROCDruids", " + ", "    .")
  call AddTranslation(lang, "ROCHippo", "", "    .")
  call AddTranslation(lang, "ROCBallista", " + ", "   .")
  call AddTranslation(lang, "ROCTalon", "", "   .")
  call AddTranslation(lang, "ROCHippoChim", "-", "   .")
  call AddTranslation(lang, "ROCDryadChim", " + ", "    .")
  call AddTranslation(lang, "ROCArcher", "", "   .")
  call AddTranslation(lang, "ROCDotC", "", "   .")
  call AddTranslation(lang, "NormalElf", " ", "       .")
  call AddTranslation(lang, "MassHD", " + ", "      .")
  call AddTranslation(lang, "Druids", " + ", "    .")
  call AddTranslation(lang, "Hippo", "", "    .")
  call AddTranslation(lang, "Ballista", " + ", "   .")
  call AddTranslation(lang, "Talon", "", "   .")
  call AddTranslation(lang, "HippoChim", "-", "   .")
  call AddTranslation(lang, "DryadChim", " + ", "    .")
  call AddTranslation(lang, "Archer", "", "   .")
  call AddTranslation(lang, "DotC", "", "   .")
  call AddTranslation(lang, "MassHuntress", " ", "   .")
  call AddTranslation(lang, "MGDryads", "  ", "   .")
  call AddTranslation(lang, "AoWMix", "AoW", "    .")
  call AddTranslation(lang, "AoLMix", "AoL", "    .")
  call AddTranslation(lang, "NEAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "ROCNormalHuman", " ", "       .")
  call AddTranslation(lang, "ROCMassSp", "", "   .")
  call AddTranslation(lang, "ROCGryph", "", " .")
  call AddTranslation(lang, "ROCKnight", " + ", "    .")
  call AddTranslation(lang, "ROCRifle", "", "  .")
  call AddTranslation(lang, "ROCMortars", "", "  .")
  call AddTranslation(lang, "ROCCopters", "", "  .")
  call AddTranslation(lang, "NormalHuman", " ", "       .")
  call AddTranslation(lang, "MassSp", "", "   .")
  call AddTranslation(lang, "Gryph", "", " .")
  call AddTranslation(lang, "Knight", " + ", "    .")
  call AddTranslation(lang, "Rifle", "", "  .")
  call AddTranslation(lang, "Mortars", "", "  .")
  call AddTranslation(lang, "MassSB", "", " .")
  call AddTranslation(lang, "Dragonhawks", "", "   .")
  call AddTranslation(lang, "BarrackMix", " ", "     .")
  call AddTranslation(lang, "SanctumMix", "  ", "      .")
  call AddTranslation(lang, "Copters", "", "  .")
  call AddTranslation(lang, "HAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusOrc", "Mass Sorceress", "I'm massing Sorceress")
  call AddTranslation(lang, "ROCNormalOrc", "+", "    .")
  call AddTranslation(lang, "ROCFastSh", " + ", "   .")
  call AddTranslation(lang, "ROCKodo", "", "   .")
  call AddTranslation(lang, "ROCWyvSh", " + ", "    .")
  call AddTranslation(lang, "ROCHHunters", "", "    .")
  call AddTranslation(lang, "ROCRaiders", "", "   .")
  call AddTranslation(lang, "ROCCatapults", " + ", "    .")
  call AddTranslation(lang, "ROCHeadCatapults", " + ", "     .")
  call AddTranslation(lang, "NormalOrc", "+", "    .")
  call AddTranslation(lang, "FastSh", " + ", "   .")
  call AddTranslation(lang, "WyvSh", " + ", "    .")
  call AddTranslation(lang, "HHunters", "", "    .")
  call AddTranslation(lang, "Raiders", "", "   .")
  call AddTranslation(lang, "GruntCatapults", " + ", "    .")
  call AddTranslation(lang, "HeadCatapults", " + ", "     .")
  call AddTranslation(lang, "Wyvern", "", "  .")
  call AddTranslation(lang, "BarrackMix", " ", "    .")
  call AddTranslation(lang, "BestiaryMix", "", "     .")
  call AddTranslation(lang, "AntiPierce", "Anti Pierce", "I'm going melee units and raiders")
  call AddTranslation(lang, "AntiAir", "Batriders", "I'm a massing batriders")
  call AddTranslation(lang, "OAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusHuman", "Raiders and Spirtwalkers", "I'm going raiders and spirit walkers")
  call AddTranslation(lang, "VersusUndead", "Grunts and Beastiary", "I'm going Grunts and a mix from the beastiary")
  call AddTranslation(lang, "VersusElf", "Raiders and Demolishers", "I'm going raiders and Demolishers")
  call AddTranslation(lang, "ROCNormalUndead", " ", "       .")
  call AddTranslation(lang, "ROCWyrms", " + ", "      .")
  call AddTranslation(lang, "ROCBanshee", "", "    .")
  call AddTranslation(lang, "ROCNecro", "", " .")
  call AddTranslation(lang, "ROCGhouls", "", "  .")
  call AddTranslation(lang, "ROCFiends", "", "    .")
  call AddTranslation(lang, "ROCGargWyrm", " + ", "    .")
  call AddTranslation(lang, "ROCAboms", "", "   .")
  call AddTranslation(lang, "ROCMeatFiends", " + ", "     .")
  call AddTranslation(lang, "NormalUndead", " ", "       .")
  call AddTranslation(lang, "Wyrms", " + ", "      .")
  call AddTranslation(lang, "Banshee", "", "    .")
  call AddTranslation(lang, "Necro", "", " .")
  call AddTranslation(lang, "Ghouls", "", "  .")
  call AddTranslation(lang, "Fiends", "", "    .")
  call AddTranslation(lang, "GargWyrm", " + ", "    .")
  call AddTranslation(lang, "Aboms", "", "   .")
  call AddTranslation(lang, "MeatFiends", " + ", "     .")
  call AddTranslation(lang, "MassDestroyer", "", " .")
  call AddTranslation(lang, "CryptMix", "", "    .")
  call AddTranslation(lang, "TempleMix", " ", "     .")
  call AddTranslation(lang, "UAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "airair", "-", "    .")
  call AddTranslation(lang, "airground", "-", "    .")
  call AddTranslation(lang, "groundair", "-", "    .")
  call AddTranslation(lang, "groundground", "-", "    .")
  call AddTranslation(lang, "farm", "", " .")
  call AddTranslation(lang, "guard", "", " .")
  set lang = "Portuguese"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "Eu jogarei normalmente construindo um pouco de tudo")
  call AddTranslation(lang, "ROCMassHD", "Hunts and Dryads", "Eu estou indo para huntress em massa e algumas dryads")
  call AddTranslation(lang, "ROCDruids", "Dryads e DotC", "Eu construirei dryads e DotC")
  call AddTranslation(lang, "ROCHippo", "Hippo Riders", "Eu construirei hippo riders em massa")
  call AddTranslation(lang, "ROCBallista", "Ballista", "Eu farei glaive throwers e dryads")
  call AddTranslation(lang, "ROCTalon", "Talon", "Eu farei toneladas de DotT")
  call AddTranslation(lang, "ROCHippoChim", "HippoChim", "Eu farei Hippgryfs e Chimaeras")
  call AddTranslation(lang, "ROCDryadChim", "DryadChim", "Indo pra dryads e chimaeras")
  call AddTranslation(lang, "ROCArcher", "Archers", "Vou fazer mass Archer")
  call AddTranslation(lang, "ROCDotC", "Ursos", "Tentarei DotC em massa")
  call AddTranslation(lang, "NormalElf", "Normal", "Eu jogarei normalmente construindo um pouco de tudo")
  call AddTranslation(lang, "MassH", "Hunts and Dryads", "Eu estou indo para huntress em massa e algumas dryads")
  call AddTranslation(lang, "Druids", "Dryads e DotC", "Eu construirei dryads e DotC")
  call AddTranslation(lang, "Hippo", "Hippo Riders", "Eu construirei hippo riders em massa")
  call AddTranslation(lang, "Ballista", "Ballista", "Eu farei glaive throwers e dryads")
  call AddTranslation(lang, "Talon", "Talon", "Eu farei toneladas de DotT")
  call AddTranslation(lang, "HippoChim", "HippoChim", "Eu farei Hippgryfs e Chimaeras")
  call AddTranslation(lang, "DryadChim", "DryadChim", "Indo pra dryads e chimaeras")
  call AddTranslation(lang, "Archer", "Archers", "Vou fazer mass Archer")
  call AddTranslation(lang, "DotC", "Ursos", "Tentarei DotC em massa")
  call AddTranslation(lang, "MassHuntress", "Mass Hunts", "I'm going massive Huntresses")
  call AddTranslation(lang, "MGDryads", "Dryads and MGs", "I'm going dryads and mountain giants")
  call AddTranslation(lang, "AoWMix", "AoW Mix", "I'm mixing units from the AoW")
  call AddTranslation(lang, "AolMix", "AoL Mix", "I'm mixing units from the Ancient of Lore")
  call AddTranslation(lang, "NEAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "Farei um pouco de tudo")
  call AddTranslation(lang, "ROCMassSp", "Casters", "Estou indo pra mass Casters")
  call AddTranslation(lang, "ROCGryph", "Gryphon", "Eu farei Gryphon riders")
  call AddTranslation(lang, "ROCKnight", "Knights", "Eu farei Footmen e Knights, muitos deles")
  call AddTranslation(lang, "ROCRifle", "Rifle", "Farei Riflemen")
  call AddTranslation(lang, "ROCMortars", "Mortars", "Farei Mortar Teams")
  call AddTranslation(lang, "ROCCopters", "Copters", "Vou fazer mass Flying machine")
  call AddTranslation(lang, "NormalHuman", "Normal", "Farei um pouco de tudo")
  call AddTranslation(lang, "MassSp", "Casters", "Estou indo pra mass Casters")
  call AddTranslation(lang, "Gryph", "Gryphon", "Eu farei Gryphon riders")
  call AddTranslation(lang, "Knight", "Knights", "Eu farei Footmen e Knights, muitos deles")
  call AddTranslation(lang, "Rifle", "Rifle", "Farei Riflemen")
  call AddTranslation(lang, "Mortars", "Mortars", "Farei Mortar Teams")
  call AddTranslation(lang, "Copters", "Copters", "Vou fazer mass Flying machine")
  call AddTranslation(lang, "MassSB", "SpellBreakers", "I'm going massive spell breakers")
  call AddTranslation(lang, "Dragonhawk", "Dragon Hawks", "I'm going dragon hawks")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "I'm trying to mix units from barrack and workshop")
  call AddTranslation(lang, "SanctumMix", "Sanctum Mix", "I'm trying to mix units from sanctum and aviary")
  call AddTranslation(lang, "HAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusOrc", "Mass Sorceress", "I'm massing Sorceress")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "Farei Grunts e casters")
  call AddTranslation(lang, "ROCFastSh", "Shamans and Taurens", "Farei Casters e Taureens")
  call AddTranslation(lang, "ROCKodo", "Kodo", "Vou fazer mass Kodo-Beast")
  call AddTranslation(lang, "ROCWyvSh", "Shamans and Wyverns", "Indo pra Shamans e Wyverns")
  call AddTranslation(lang, "ROCHHunters", "Head Hunters", "Vou tentar mass Troll HeadHunter")
  call AddTranslation(lang, "ROCRaiders", "Raiders", "Mass Raiders")
  call AddTranslation(lang, "ROCCatapults", "Grunts and Catapults", "Eu farei grunts e demolishers")
  call AddTranslation(lang, "ROCHeadCatapults", "Head hunters and Catapults", "Vamos tentar headhunters e demolishers")
  call AddTranslation(lang, "NormalOrc", "Normal", "Farei Grunts e casters")
  call AddTranslation(lang, "FastSh", "Shamans and Taurens", "Farei Casters e Taureens")
  call AddTranslation(lang, "WyvSh", "Shamans and Wyverns", "Indo pra Shamans e Wyverns")
  call AddTranslation(lang, "HHunters", "Head Hunters", "Vou tentar mass Troll HeadHunter")
  call AddTranslation(lang, "Raiders", "Raiders", "Mass Raiders")
  call AddTranslation(lang, "GruntCatapults", "Grunts and Catapults", "Eu farei grunts e demolishers")
  call AddTranslation(lang, "HeadCatapults", "Head hunters and Catapults", "Vamos tentar headhunters e demolishers")
  call AddTranslation(lang, "Wyvern", "Mass Wyvern", "I'm going massive wyverns")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "I'm mixing units from barrack.")
  call AddTranslation(lang, "BestiaryMix", "Bestiary Mix", "I'm mixing units from bestiary")
  call AddTranslation(lang, "AntiPierce", "Anti Pierce", "I'm going melee units and raiders")
  call AddTranslation(lang, "AntiAir", "Batriders", "I'm a massing batriders")
  call AddTranslation(lang, "OAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusHuman", "Raiders and Spirtwalkers", "I'm going raiders and spirit walkers")
  call AddTranslation(lang, "VersusUndead", "Grunts and Beastiary", "I'm going Grunts and a mix from the beastiary")
  call AddTranslation(lang, "VersusElf", "Raiders and Demolishers", "I'm going raiders and Demolishers")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "Eu vou fazer um pouco de tudo")
  call AddTranslation(lang, "ROCWyrms", "Wyrms", "Farei wyrms e algumas crypt fiends")
  call AddTranslation(lang, "ROCBanshee", "Banshees", "Farei muitas Banshees")
  call AddTranslation(lang, "ROCNecro", "Necros", "Tentarei Necromancers")
  call AddTranslation(lang, "ROCGhouls", "Ghouls", "Farei mass ghouls")
  call AddTranslation(lang, "ROCFiends", "Fiends", "Estou fazendo mass crypt fiends")
  call AddTranslation(lang, "ROCGargWyrm", "Gargoyles and Wyrms", "Farei gargs e wyrms")
  call AddTranslation(lang, "ROCAboms", "Aboms", "Vou fazer mass abominations")
  call AddTranslation(lang, "ROCMeatFiends", "Meat wagons and Fiends", "Eu tentarei fiends e meat wagons")
  call AddTranslation(lang, "NormalUndead", "Normal", "Eu vou fazer um pouco de tudo")
  call AddTranslation(lang, "Wyrms", "Wyrms", "Farei wyrms e algumas crypt fiends")
  call AddTranslation(lang, "Banshee", "Banshees", "Farei muitas Banshees")
  call AddTranslation(lang, "Necro", "Necros", "Tentarei Necromancers")
  call AddTranslation(lang, "Ghouls", "Ghouls", "Farei mass ghouls")
  call AddTranslation(lang, "Fiends", "Fiends", "Estou fazendo mass crypt fiends")
  call AddTranslation(lang, "GargWyrm", "Gargoyles and Wyrms", "Farei gargs e wyrms")
  call AddTranslation(lang, "Aboms", "Aboms", "Vou fazer mass abominations")
  call AddTranslation(lang, "MeatFiends", "Meat wagons and Fiends", "Eu tentarei fiends e meat wagons")
  call AddTranslation(lang, "MassDestroyer", "Mass Destroyers", "I'm going massive destroyers")
  call AddTranslation(lang, "CryptMix", "Crypt Mix", "I'm trying to mix units from crypt and slaughterhouse")
  call AddTranslation(lang, "TempleMix", "Temple Mix", "I'm mixing units from temple of the damned and slaughterhouse")
  call AddTranslation(lang, "UAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "airair", "Air-Air", "Eu farei unidades areas contra areas")
  call AddTranslation(lang, "airground", "Air-Ground", "Eu farei unidades areas contra terrestres")
  call AddTranslation(lang, "groundair", "Ground-Air", "Eu farei unidades terrestres contra terrestres")
  call AddTranslation(lang, "groundground", "Terra-Terra", "Eu construirei unidades de terra a unidades de terra")
  call AddTranslation(lang, "farm", "fazendas", "Eu construirei fazendas")
  call AddTranslation(lang, "guard", "Torres", "Eu construirei torres")
  set lang = "Norwegian"
  call AddTranslation(lang, "ROCNormalElf", "Normal", "Jeg spiller som vanlig og bygger litt av vert")
  call AddTranslation(lang, "ROCMassHD", "Hunts og Dryads", "Jeg bygger huntress og dryads")
  call AddTranslation(lang, "ROCDruids", "Dryads og DotC", "Jeg bygger dryads og DotC")
  call AddTranslation(lang, "ROCHippo", "Hippo Riders", "Jeg bygger hippo riders")
  call AddTranslation(lang, "ROCBallista", "Ballista", "Jeg bygger ballista og dryads")
  call AddTranslation(lang, "ROCTalon", "Talon", "Jeg bygger masse DotT")
  call AddTranslation(lang, "ROCHippoChim", "Hippogim", "Jeg bygger hippos og chimaeras")
  call AddTranslation(lang, "ROCDryadChim", "DryadChim", "Jeg bygger dryads og chimaeras")
  call AddTranslation(lang, "ROCArcher", "Archers", "Jeg spder med archers")
  call AddTranslation(lang, "ROCDotC", "DotC", "Jeg spder med DotC")
  call AddTranslation(lang, "NormalElf", "Normal", "Jeg spiller som vanlig og bygger litt av vert")
  call AddTranslation(lang, "MassH", "Hunts og Dryads", "Jeg bygger huntress og dryads")
  call AddTranslation(lang, "Druids", "Dryads og DotC", "Jeg bygger dryads og DotC")
  call AddTranslation(lang, "Hippo", "Hippo Riders", "Jeg bygger hippo riders")
  call AddTranslation(lang, "Ballista", "Ballista", "Jeg bygger ballista og dryads")
  call AddTranslation(lang, "Talon", "Talon", "Jeg bygger masse DotT")
  call AddTranslation(lang, "Hippogim", "Hippogim", "Jeg bygger hippos og chimaeras")
  call AddTranslation(lang, "DryadChim", "DryadChim", "Jeg bygger dryads og chimaeras")
  call AddTranslation(lang, "Archer", "Archers", "Jeg spder med archers")
  call AddTranslation(lang, "DotC", "DotC", "Jeg spder med DotC")
  call AddTranslation(lang, "MassHuntress", "Mass Hunts", "I'm going massive Huntresses")
  call AddTranslation(lang, "MGDryads", "Dryads and MGs", "I'm going dryads and mountain giants")
  call AddTranslation(lang, "AoWMix", "AoW Mix", "I'm mixing units from the AoW")
  call AddTranslation(lang, "AolMix", "AoL Mix", "I'm mixing units from the Ancient of Lore")
  call AddTranslation(lang, "NEAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "ROCNormalHuman", "Normal", "Jeg spiller som vanlig og bygger litt av vert")
  call AddTranslation(lang, "ROCMassSp", "Casters", "Jeg spder med casters")
  call AddTranslation(lang, "ROCGryph", "Gryphon", "Jeg bygger masse gryphoner")
  call AddTranslation(lang, "ROCKnight", "Knights", "Jeg skaffer footmen og knights")
  call AddTranslation(lang, "ROCRifle", "Rifle", "Jeg bygger masse riflemen")
  call AddTranslation(lang, "ROCMortars", "Mortars", "Jeg skaffer mortars og riflemen")
  call AddTranslation(lang, "ROCCopters", "Copters", "Jeg spder med flyvemaskiner")
  call AddTranslation(lang, "NormalHuman", "Normal", "Jeg spiller som vanlig og bygger litt av vert")
  call AddTranslation(lang, "MassSp", "Casters", "Jeg spder med casters")
  call AddTranslation(lang, "Gryph", "Gryphon", "Jeg bygger masse gryphoner")
  call AddTranslation(lang, "Knight", "Knights", "Jeg skaffer footmen og knights")
  call AddTranslation(lang, "Rifle", "Rifle", "Jeg bygger masse riflemen")
  call AddTranslation(lang, "Mortars", "Mortars", "Jeg skaffer mortars og riflemen")
  call AddTranslation(lang, "Copters", "Copters", "Jeg spder med flyvemaskiner")
  call AddTranslation(lang, "MassSB", "SpellBreakers", "I'm going massive spell breakers")
  call AddTranslation(lang, "Dragonhawk", "Dragon Hawks", "I'm going dragon hawks")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "I'm trying to mix units from barrack and workshop")
  call AddTranslation(lang, "SanctumMix", "Sanctum Mix", "I'm trying to mix units from sanctum and aviary")
  call AddTranslation(lang, "HAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusOrc", "Mass Sorceress", "I'm massing Sorceress")
  call AddTranslation(lang, "ROCNormalOrc", "Normal", "Jeg skaffer grunts og casters")
  call AddTranslation(lang, "ROCFastSh", "Shamans og Taurens", "Jeg skaffer casters og taurens")
  call AddTranslation(lang, "ROCKodo", "Kodo", "Jeg bygger masse kodo-beast")
  call AddTranslation(lang, "ROCWyvSh", "Shamans og Wyverns", "Jeg bygger Shamans og Wyverns")
  call AddTranslation(lang, "ROCHHunters", "Head Hunters", "Jeg bygger masse head hunters")
  call AddTranslation(lang, "ROCRaiders", "Raiders", "Jeg bygger masse raiders")
  call AddTranslation(lang, "ROCCatapults", "Grunts og Katapulter", "Jeg bygger grunts og katapulter")
  call AddTranslation(lang, "ROCHeadCatapults", "Head hunters og Katapulter", "Jeg skaffer headhunters og katapulter")
  call AddTranslation(lang, "NormalOrc", "Normal", "Jeg skaffer grunts og casters")
  call AddTranslation(lang, "FastSh", "Shamans og Taurens", "Jeg skaffer casters og taurens")
  call AddTranslation(lang, "WyvSh", "Shamans og Wyverns", "Jeg bygger Shamans og Wyverns")
  call AddTranslation(lang, "HHunters", "Head Hunters", "Jeg bygger masse head hunters")
  call AddTranslation(lang, "Raiders", "Raiders", "Jeg bygger masse raiders")
  call AddTranslation(lang, "GruntCatapults", "Grunts og Katapulter", "Jeg bygger grunts og katapulter")
  call AddTranslation(lang, "HeadCatapults", "Head hunters og Katapulter", "Jeg skaffer headhunters og katapulter")
  call AddTranslation(lang, "Wyvern", "Mass Wyvern", "I'm going massive wyverns")
  call AddTranslation(lang, "BarrackMix", "Barrack Mix", "I'm mixing units from barrack.")
  call AddTranslation(lang, "BestiaryMix", "Bestiary Mix", "I'm mixing units from bestiary")
  call AddTranslation(lang, "AntiPierce", "Anti Pierce", "I'm going melee units and raiders")
  call AddTranslation(lang, "AntiAir", "Batriders", "I'm a massing batriders")
  call AddTranslation(lang, "OAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "VersusHuman", "Raiders and Spirtwalkers", "I'm going raiders and spirit walkers")
  call AddTranslation(lang, "VersusUndead", "Grunts and Beastiary", "I'm going Grunts and a mix from the beastiary")
  call AddTranslation(lang, "VersusElf", "Raiders and Demolishers", "I'm going raiders and Demolishers")
  call AddTranslation(lang, "ROCNormalUndead", "Normal", "Jeg spiller som vanlig og bygger litt av vert")
  call AddTranslation(lang, "ROCWyrms", "Wyrms", "Jeg bygger wyrms og crypt fiends")
  call AddTranslation(lang, "ROCBanshee", "Banshees", "Jeg skaffer bashees")
  call AddTranslation(lang, "ROCNecro", "Necros", "Jeg bygger necromancers")
  call AddTranslation(lang, "ROCGhouls", "Ghouls", "Jeg skaffer masse ghouls")
  call AddTranslation(lang, "ROCFiends", "Fiends", "Jeg bygger masse crypt fiends")
  call AddTranslation(lang, "ROCGargWyrm", "Gargoyles og Wyrms", "Jeg bygger gargs og wyrms")
  call AddTranslation(lang, "ROCAboms", "Aboms", "Jeg skaffer masse abominations")
  call AddTranslation(lang, "ROCMeatFiends", "Meat wagons og Fiends", "Jeg bygger fiends og meat wagons")
  call AddTranslation(lang, "NormalUndead", "Normal", "Jeg spiller som vanlig og bygger litt av vert")
  call AddTranslation(lang, "Wyrms", "Wyrms", "Jeg bygger wyrms og crypt fiends")
  call AddTranslation(lang, "Banshee", "Banshees", "Jeg skaffer bashees")
  call AddTranslation(lang, "Necro", "Necros", "Jeg bygger necromancers")
  call AddTranslation(lang, "Ghouls", "Ghouls", "Jeg skaffer masse ghouls")
  call AddTranslation(lang, "Fiends", "Fiends", "Jeg bygger masse crypt fiends")
  call AddTranslation(lang, "GargWyrm", "Gargoyles og Wyrms", "Jeg bygger gargs og wyrms")
  call AddTranslation(lang, "Aboms", "Aboms", "Jeg skaffer masse abominations")
  call AddTranslation(lang, "MeatFiends", "Meat wagons og Fiends", "Jeg bygger fiends og meat wagons")
  call AddTranslation(lang, "MassDestroyer", "Mass Destroyers", "I'm going massive destroyers")
  call AddTranslation(lang, "CryptMix", "Crypt Mix", "I'm trying to mix units from crypt and slaughterhouse")
  call AddTranslation(lang, "TempleMix", "Temple Mix", "I'm mixing units from temple of the damned and slaughterhouse")
  call AddTranslation(lang, "UAntiTower", "Anti Tower", "I'm massing seige equipment")
  call AddTranslation(lang, "airair", "Luft-Luft", "Jeg bygger luft- mot luftenheter")
  call AddTranslation(lang, "airground", "Luft-Mark", "Jeg bygger luft- mot bakkeenheter")
  call AddTranslation(lang, "groundair", "Mark-Luft", "Jeg bygger bakke- mot luftenheter")
  call AddTranslation(lang, "groundground", "Mark-Mark", "Jeg bygger bakke- mot bakkeenheter")
  call AddTranslation(lang, "farm", "Farms", "Jeg bygger farms")
  call AddTranslation(lang, "guard", "Torn", "Jeg bygger trn")
  set lang = "Chinese"
  call AddTranslation(lang, "NormalElf", "", "?")
  call AddTranslation(lang, "MassH", "?", "?")
  call AddTranslation(lang, "Druids", "", "?")
  call AddTranslation(lang, "Hippo", "", "?")
  call AddTranslation(lang, "Ballista", "", "?")
  call AddTranslation(lang, "Talon", "?", "?")
  call AddTranslation(lang, "HippoChim", "?", "")
  call AddTranslation(lang, "DryadChim", "", "?")
  call AddTranslation(lang, "Archer", "?", "")
  call AddTranslation(lang, "DotC", "", "?")
  call AddTranslation(lang, "NormalHuman", "", "?")
  call AddTranslation(lang, "MassSp", "?", "")
  call AddTranslation(lang, "Gryph", "", "")
  call AddTranslation(lang, "Knight", "", "")
  call AddTranslation(lang, "Rifle", "", "?")
  call AddTranslation(lang, "Mortars", "?", "")
  call AddTranslation(lang, "Copters", "?", "")
  call AddTranslation(lang, "NormalOrc", "", "?")
  call AddTranslation(lang, "FastSh", "", "?")
  call AddTranslation(lang, "Kodo", "?", "?")
  call AddTranslation(lang, "WyvSh", "", "?")
  call AddTranslation(lang, "HHunters", "?", "?")
  call AddTranslation(lang, "Raiders", "", "?")
  call AddTranslation(lang, "Catapults", "?", "?")
  call AddTranslation(lang, "HeadCatapults", "?", "?")
  call AddTranslation(lang, "NormalUndead", "", "")
  call AddTranslation(lang, "Wyrms", "", "?")
  call AddTranslation(lang, "Banshee", "", "")
  call AddTranslation(lang, "Necro", "", "")
  call AddTranslation(lang, "Ghouls", "", "")
  call AddTranslation(lang, "Fiends", "", "")
  call AddTranslation(lang, "GargWyrm", "?", "")
  call AddTranslation(lang, "Aboms", "", "")
  call AddTranslation(lang, "MeatFiends", "?", "")
  call AddTranslation(lang, "airair", "?", "?")
  call AddTranslation(lang, "airground", "?", "?")
  call AddTranslation(lang, "groundair", "?", "?")
  call AddTranslation(lang, "groundground", "?", "?")
  call AddTranslation(lang, "farm", "", "")
  call AddTranslation(lang, "guard", "", "")
endfunction

function GetStrategyName takes integer stratnum returns string
  if HaveStoredInteger(translation_map, language, "Name"+strategy_name[stratnum]) then
    return translation[GetStoredInteger(translation_map, language, "Name"+strategy_name[stratnum])]
  else
    return strategy_default_name[stratnum]
  endif
endfunction

function GetStrategyReport takes integer stratnum returns string
  if HaveStoredInteger(translation_map, language, "Report"+strategy_name[stratnum]) then
    return translation[GetStoredInteger(translation_map, language, "Report"+strategy_name[stratnum])]
  else
    return strategy_default_report[stratnum]
  endif
endfunction

function GetCurrentStrategyName takes nothing returns string
  return GetStrategyName(strategy)
endfunction

function GetCurrentStrategyReport takes nothing returns string
  return GetStrategyReport(strategy)
endfunction

function DisplayChat takes boolean ally, boolean enemy, boolean obs, boolean important returns nothing
  local integer i = 0
  local integer std_rand = 0
  local integer rand = 0
  local player p = null
  call ApplyChatConditions()
  if chat_list_length == 0 then
    return
  endif
  set std_rand = GetRandomInt(0, chat_list_length - 1)
  loop
    exitwhen i >= 12
    set p = Player(i)
    if (GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(p) != MAP_CONTROL_COMPUTER and ((ally and IsPlayerAlly(p, ai_player)) or (enemy and IsPlayerEnemy(p, ai_player) and not IsPlayerObserver(p)))) or (obs and IsPlayerObserver(p)) then
      set rand = std_rand
      loop
        exitwhen (chat_list_eq[rand] == COMPARE_TRUE) or (chat_list_eq[rand] == COMPARE_EQ and chat_list_race[rand] == race_name[player_race[i]]) or (chat_list_eq[rand] == COMPARE_UNEQ and chat_list_race[rand] != race_name[player_race[i]])
        set rand = GetRandomInt(0, chat_list_length - 1)
      endloop
      call SetChatVarsPlayer(p)
      call DisplayToPlayer(ApplyChatVars(chat_list[rand]), p, important)
    endif
    set i = i + 1
  endloop
endfunction

function Chat takes integer c returns nothing
  local real chance = 0
  if campaign_ai or not (chat_important[c]) then
    return
  endif

  if c == C_STRATEGY then
    call DisplayToAlliesImportant( GetCurrentStrategyReport() )
    call DisplayToObserversImportant( GetCurrentStrategyReport() )
  else
    if not chatting then
		return
	endif
    if false then
    elseif c == C_AGG then
      set chance = 100
      call CopyChatAGG()
    elseif c == C_Ally then
      set chance = 100
      call CopyChatAlly()
    elseif c == C_Attack then
      set chance = 100
      call CopyChatAttack()
    elseif c == C_Creep then
      set chance = 100
      call CopyChatCreep()
    elseif c == C_Done then
      set chance = 100
      call CopyChatDone()
    elseif c == C_EGG then
      set chance = 100
      call CopyChatEGG()
    elseif c == C_Expansion then
      set chance = 100
      call CopyChatExpansion()
    elseif c == C_Goldproblem then
      set chance = 100
      call CopyChatGoldproblem()
    elseif c == C_Greet then
      set chance = 100
      call CopyChatGreet()
    elseif c == C_Mega then
      set chance = 100
      call CopyChatMega()
    elseif c == C_Megatarget then
      set chance = 100
      call CopyChatMegatarget()
    elseif c == C_Taunt then
      set chance = taunt_rate
      call CopyChatTaunt()
    elseif c == C_Thanks then
      set chance = 100
      call CopyChatThanks()
    else
      return
    endif
    if chance >= GetRandomReal(0.00,100.00) then
      call DisplayChat(chat_target_ally[c], chat_target_enemy[c], chat_target_obs[c], chat_important[c])
    endif
  endif
endfunction

function GetPlayerStartLocationLoc takes player whichPlayer returns location
    return GetStartLocationLoc(GetPlayerStartLocation(whichPlayer))
endfunction

function DisplayStratNames takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= rp_strat_length
    call DisplayToAllies(Int2Str(i) + ". " + GetStrategyName(i))
    set i = i + 1
  endloop
endfunction


function InitNeutralSkills takes nothing returns nothing
  set allskills[1] = FROSTARROWS
  set allskills[2] = FORKLIGHTNING
  set allskills[3] = FORKLIGHTNING
  set allskills[4] = FROSTARROWS
  set allskills[5] = FORKLIGHTNING
  set allskills[6] = TORNADO
  set allskills[7] = FROSTARROWS
  set allskills[8] = MANASHIELD
  set allskills[9] = MANASHIELD
  set allskills[10] = MANASHIELD

  set allskills[11] = FORKLIGHTNING
  set allskills[12] = FROSTARROWS
  set allskills[13] = FORKLIGHTNING
  set allskills[14] = FROSTARROWS
  set allskills[15] = FORKLIGHTNING
  set allskills[16] = TORNADO
  set allskills[17] = FROSTARROWS
  set allskills[18] = MANASHIELD
  set allskills[19] = MANASHIELD
  set allskills[20] = MANASHIELD

  set allskills[21] = FROSTARROWS
  set allskills[22] = FORKLIGHTNING
  set allskills[23] = FROSTARROWS
  set allskills[24] = FORKLIGHTNING
  set allskills[25] = FROSTARROWS
  set allskills[26] = TORNADO
  set allskills[27] = FORKLIGHTNING
  set allskills[28] = MANASHIELD
  set allskills[29] = MANASHIELD
  set allskills[30] = MANASHIELD

  set allskills[31] = FROSTARROWS
  set allskills[32] = FORKLIGHTNING
  set allskills[33] = FORKLIGHTNING
  set allskills[34] = FROSTARROWS
  set allskills[35] = FORKLIGHTNING
  set allskills[36] = TORNADO
  set allskills[37] = FROSTARROWS
  set allskills[38] = MANASHIELD
  set allskills[39] = MANASHIELD
  set allskills[40] = MANASHIELD

  set allskills[41] = FORKLIGHTNING
  set allskills[42] = FROSTARROWS
  set allskills[43] = FORKLIGHTNING
  set allskills[44] = FROSTARROWS
  set allskills[45] = FORKLIGHTNING
  set allskills[46] = TORNADO
  set allskills[47] = FROSTARROWS
  set allskills[48] = MANASHIELD
  set allskills[49] = MANASHIELD
  set allskills[50] = MANASHIELD

  set allskills[51] = FROSTARROWS
  set allskills[52] = FORKLIGHTNING
  set allskills[53] = FROSTARROWS
  set allskills[54] = FORKLIGHTNING
  set allskills[55] = FROSTARROWS
  set allskills[56] = TORNADO
  set allskills[57] = FORKLIGHTNING
  set allskills[58] = MANASHIELD
  set allskills[59] = MANASHIELD
  set allskills[60] = MANASHIELD

  set allskills[61] = FORKLIGHTNING
  set allskills[62] = FROSTARROWS
  set allskills[63] = FORKLIGHTNING
  set allskills[64] = FROSTARROWS
  set allskills[65] = FORKLIGHTNING
  set allskills[66] = TORNADO
  set allskills[67] = FROSTARROWS
  set allskills[68] = MANASHIELD
  set allskills[69] = MANASHIELD
  set allskills[70] = MANASHIELD

  set allskills[71] = FROSTARROWS
  set allskills[72] = FORKLIGHTNING
  set allskills[73] = FORKLIGHTNING
  set allskills[74] = FROSTARROWS
  set allskills[75] = FORKLIGHTNING
  set allskills[76] = TORNADO
  set allskills[77] = FROSTARROWS
  set allskills[78] = MANASHIELD
  set allskills[79] = MANASHIELD
  set allskills[80] = MANASHIELD

  set allskills[81] = FROSTARROWS
  set allskills[82] = FORKLIGHTNING
  set allskills[83] = FROSTARROWS
  set allskills[84] = FORKLIGHTNING
  set allskills[85] = FROSTARROWS
  set allskills[86] = TORNADO
  set allskills[87] = FORKLIGHTNING
  set allskills[88] = MANASHIELD
  set allskills[89] = MANASHIELD
  set allskills[90] = MANASHIELD

  set allskills[91] = QUILBEAST
  set allskills[92] = HAWK
  set allskills[93] = QUILBEAST
  set allskills[94] = HAWK
  set allskills[95] = QUILBEAST
  set allskills[96] = STAMPEDE
  set allskills[97] = HAWK
  set allskills[98] = BEAR
  set allskills[99] = BEAR
  set allskills[100] = BEAR

  set allskills[101] = QUILBEAST
  set allskills[102] = HAWK
  set allskills[103] = HAWK
  set allskills[104] = QUILBEAST
  set allskills[105] = HAWK
  set allskills[106] = STAMPEDE
  set allskills[107] = QUILBEAST
  set allskills[108] = BEAR
  set allskills[109] = BEAR
  set allskills[110] = BEAR

  set allskills[111] = BEAR
  set allskills[112] = QUILBEAST
  set allskills[113] = BEAR
  set allskills[114] = QUILBEAST
  set allskills[115] = BEAR
  set allskills[116] = STAMPEDE
  set allskills[117] = QUILBEAST
  set allskills[118] = HAWK
  set allskills[119] = HAWK
  set allskills[120] = HAWK

  set allskills[121] = QUILBEAST
  set allskills[122] = HAWK
  set allskills[123] = QUILBEAST
  set allskills[124] = HAWK
  set allskills[125] = QUILBEAST
  set allskills[126] = STAMPEDE
  set allskills[127] = HAWK
  set allskills[128] = BEAR
  set allskills[129] = BEAR
  set allskills[130] = BEAR

  set allskills[131] = QUILBEAST
  set allskills[132] = HAWK
  set allskills[133] = HAWK
  set allskills[134] = QUILBEAST
  set allskills[135] = HAWK
  set allskills[136] = STAMPEDE
  set allskills[137] = QUILBEAST
  set allskills[138] = BEAR
  set allskills[139] = BEAR
  set allskills[140] = BEAR

  set allskills[141] = BEAR
  set allskills[142] = QUILBEAST
  set allskills[143] = BEAR
  set allskills[144] = QUILBEAST
  set allskills[145] = BEAR
  set allskills[146] = STAMPEDE
  set allskills[147] = QUILBEAST
  set allskills[148] = HAWK
  set allskills[149] = HAWK
  set allskills[150] = HAWK

  set allskills[151] = BEAR
  set allskills[152] = QUILBEAST
  set allskills[153] = BEAR
  set allskills[154] = QUILBEAST
  set allskills[155] = BEAR
  set allskills[156] = STAMPEDE
  set allskills[157] = QUILBEAST
  set allskills[158] = HAWK
  set allskills[159] = HAWK
  set allskills[160] = HAWK

  set allskills[161] = QUILBEAST
  set allskills[162] = HAWK
  set allskills[163] = HAWK
  set allskills[164] = QUILBEAST
  set allskills[165] = HAWK
  set allskills[166] = STAMPEDE
  set allskills[167] = QUILBEAST
  set allskills[168] = BEAR
  set allskills[169] = BEAR
  set allskills[170] = BEAR

  set allskills[171] = QUILBEAST
  set allskills[172] = HAWK
  set allskills[173] = HAWK
  set allskills[174] = QUILBEAST
  set allskills[175] = HAWK
  set allskills[176] = STAMPEDE
  set allskills[177] = QUILBEAST
  set allskills[178] = BEAR
  set allskills[179] = BEAR
  set allskills[180] = BEAR

  set allskills[181] = BLACKARROW
  set allskills[182] = SILENCE
  set allskills[183] = BLACKARROW
  set allskills[184] = SILENCE
  set allskills[185] = BLACKARROW
  set allskills[186] = CHARM
  set allskills[187] = SILENCE
  set allskills[188] = DRAIN
  set allskills[189] = DRAIN
  set allskills[190] = DRAIN

  set allskills[191] = BLACKARROW
  set allskills[192] = SILENCE
  set allskills[193] = BLACKARROW
  set allskills[194] = SILENCE
  set allskills[195] = BLACKARROW
  set allskills[196] = CHARM
  set allskills[197] = SILENCE
  set allskills[198] = DRAIN
  set allskills[199] = DRAIN
  set allskills[200] = DRAIN

  set allskills[201] = BLACKARROW
  set allskills[202] = DRAIN
  set allskills[203] = BLACKARROW
  set allskills[204] = DRAIN
  set allskills[205] = BLACKARROW
  set allskills[206] = CHARM
  set allskills[207] = DRAIN
  set allskills[208] = SILENCE
  set allskills[209] = SILENCE
  set allskills[210] = SILENCE

  set allskills[211] = SILENCE
  set allskills[212] = DRAIN
  set allskills[213] = SILENCE
  set allskills[214] = DRAIN
  set allskills[215] = SILENCE
  set allskills[216] = CHARM
  set allskills[217] = DRAIN
  set allskills[218] = BLACKARROW
  set allskills[219] = BLACKARROW
  set allskills[220] = BLACKARROW

  set allskills[221] = BLACKARROW
  set allskills[222] = SILENCE
  set allskills[223] = BLACKARROW
  set allskills[224] = SILENCE
  set allskills[225] = SILENCE
  set allskills[226] = CHARM
  set allskills[227] = BLACKARROW
  set allskills[228] = DRAIN
  set allskills[229] = DRAIN
  set allskills[230] = DRAIN

  set allskills[231] = BLACKARROW
  set allskills[232] = DRAIN
  set allskills[233] = BLACKARROW
  set allskills[234] = DRAIN
  set allskills[235] = BLACKARROW
  set allskills[236] = CHARM
  set allskills[237] = DRAIN
  set allskills[238] = SILENCE
  set allskills[239] = SILENCE
  set allskills[240] = SILENCE

  set allskills[241] = SILENCE
  set allskills[242] = DRAIN
  set allskills[243] = SILENCE
  set allskills[244] = DRAIN
  set allskills[245] = SILENCE
  set allskills[246] = CHARM
  set allskills[247] = DRAIN
  set allskills[248] = BLACKARROW
  set allskills[249] = BLACKARROW
  set allskills[250] = BLACKARROW

  set allskills[251] = SILENCE
  set allskills[252] = DRAIN
  set allskills[253] = SILENCE
  set allskills[254] = DRAIN
  set allskills[255] = SILENCE
  set allskills[256] = CHARM
  set allskills[257] = DRAIN
  set allskills[258] = BLACKARROW
  set allskills[259] = BLACKARROW
  set allskills[260] = BLACKARROW

  set allskills[261] = DRAIN
  set allskills[262] = SILENCE
  set allskills[263] = DRAIN
  set allskills[264] = SILENCE
  set allskills[265] = SILENCE
  set allskills[266] = CHARM
  set allskills[267] = DRAIN
  set allskills[268] = BLACKARROW
  set allskills[269] = BLACKARROW
  set allskills[270] = BLACKARROW

  set allskills[271] = HOWL
  set allskills[272] = RAINOFFIRE
  set allskills[273] = RAINOFFIRE
  set allskills[274] = CLEAVING
  set allskills[275] = RAINOFFIRE
  set allskills[276] = DOOM
  set allskills[277] = HOWL
  set allskills[278] = CLEAVING
  set allskills[279] = CLEAVING
  set allskills[280] = HOWL

  set allskills[281] = RAINOFFIRE
  set allskills[282] = HOWL
  set allskills[283] = RAINOFFIRE
  set allskills[284] = CLEAVING
  set allskills[285] = RAINOFFIRE
  set allskills[286] = DOOM
  set allskills[287] = CLEAVING
  set allskills[288] = HOWL
  set allskills[289] = CLEAVING
  set allskills[290] = HOWL

  set allskills[291] = RAINOFFIRE
  set allskills[292] = CLEAVING
  set allskills[293] = RAINOFFIRE
  set allskills[294] = CLEAVING
  set allskills[295] = RAINOFFIRE
  set allskills[296] = DOOM
  set allskills[297] = CLEAVING
  set allskills[298] = HOWL
  set allskills[299] = HOWL
  set allskills[300] = HOWL

  set allskills[301] = HOWL
  set allskills[302] = RAINOFFIRE
  set allskills[303] = RAINOFFIRE
  set allskills[304] = CLEAVING
  set allskills[305] = RAINOFFIRE
  set allskills[306] = DOOM
  set allskills[307] = CLEAVING
  set allskills[308] = CLEAVING
  set allskills[309] = HOWL
  set allskills[310] = HOWL

  set allskills[311] = RAINOFFIRE
  set allskills[312] = HOWL
  set allskills[313] = RAINOFFIRE
  set allskills[314] = CLEAVING
  set allskills[315] = RAINOFFIRE
  set allskills[316] = DOOM
  set allskills[317] = CLEAVING
  set allskills[318] = CLEAVING
  set allskills[319] = HOWL
  set allskills[320] = HOWL

  set allskills[321] = RAINOFFIRE
  set allskills[322] = CLEAVING
  set allskills[323] = RAINOFFIRE
  set allskills[324] = HOWL
  set allskills[325] = RAINOFFIRE
  set allskills[326] = DOOM
  set allskills[327] = CLEAVING
  set allskills[328] = CLEAVING
  set allskills[329] = HOWL
  set allskills[330] = HOWL

  set allskills[331] = RAINOFFIRE
  set allskills[332] = HOWL
  set allskills[333] = RAINOFFIRE
  set allskills[334] = CLEAVING
  set allskills[335] = RAINOFFIRE
  set allskills[336] = DOOM
  set allskills[337] = CLEAVING
  set allskills[338] = HOWL
  set allskills[339] = CLEAVING
  set allskills[340] = HOWL

  set allskills[341] = HOWL
  set allskills[342] = RAINOFFIRE
  set allskills[343] = RAINOFFIRE
  set allskills[344] = CLEAVING
  set allskills[345] = RAINOFFIRE
  set allskills[346] = DOOM
  set allskills[347] = CLEAVING
  set allskills[348] = CLEAVING
  set allskills[349] = HOWL
  set allskills[350] = HOWL

  set allskills[351] = RAINOFFIRE
  set allskills[352] = CLEAVING
  set allskills[353] = RAINOFFIRE
  set allskills[354] = CLEAVING
  set allskills[355] = RAINOFFIRE
  set allskills[356] = DOOM
  set allskills[357] = CLEAVING
  set allskills[358] = HOWL
  set allskills[359] = HOWL
  set allskills[360] = HOWL

  set allskills[361] = BOF
  set allskills[362] = HAZE
  set allskills[363] = BOF
  set allskills[364] = HAZE
  set allskills[365] = BOF
  set allskills[366] = SEF
  set allskills[367] = HAZE
  set allskills[368] = BRAWLER
  set allskills[369] = BRAWLER
  set allskills[370] = BRAWLER

  set allskills[371] = BOF
  set allskills[372] = HAZE
  set allskills[373] = BOF
  set allskills[374] = HAZE
  set allskills[375] = BOF
  set allskills[376] = SEF
  set allskills[377] = HAZE
  set allskills[378] = BRAWLER
  set allskills[379] = BRAWLER
  set allskills[380] = BRAWLER

  set allskills[381] = BOF
  set allskills[382] = HAZE
  set allskills[383] = BRAWLER
  set allskills[384] = BRAWLER
  set allskills[385] = BRAWLER
  set allskills[386] = SEF
  set allskills[387] = BOF
  set allskills[388] = HAZE
  set allskills[389] = BOF
  set allskills[390] = HAZE

  set allskills[391] = BOF
  set allskills[392] = HAZE
  set allskills[393] = BOF
  set allskills[394] = HAZE
  set allskills[395] = BOF
  set allskills[396] = SEF
  set allskills[397] = HAZE
  set allskills[398] = BRAWLER
  set allskills[399] = BRAWLER
  set allskills[400] = BRAWLER

  set allskills[401] = BOF
  set allskills[402] = HAZE
  set allskills[403] = BOF
  set allskills[404] = HAZE
  set allskills[405] = BOF
  set allskills[406] = SEF
  set allskills[407] = HAZE
  set allskills[408] = BRAWLER
  set allskills[409] = BRAWLER
  set allskills[410] = BRAWLER

  set allskills[411] = BOF
  set allskills[412] = HAZE
  set allskills[413] = BRAWLER
  set allskills[414] = BRAWLER
  set allskills[415] = BRAWLER
  set allskills[416] = SEF
  set allskills[417] = BOF
  set allskills[418] = HAZE
  set allskills[419] = BOF
  set allskills[420] = HAZE

  set allskills[421] = BOF
  set allskills[422] = HAZE
  set allskills[423] = BOF
  set allskills[424] = HAZE
  set allskills[425] = BOF
  set allskills[426] = SEF
  set allskills[427] = HAZE
  set allskills[428] = BRAWLER
  set allskills[429] = BRAWLER
  set allskills[430] = BRAWLER

  set allskills[431] = BOF
  set allskills[432] = HAZE
  set allskills[433] = BOF
  set allskills[434] = HAZE
  set allskills[435] = BOF
  set allskills[436] = SEF
  set allskills[437] = HAZE
  set allskills[438] = BRAWLER
  set allskills[439] = BRAWLER
  set allskills[440] = BRAWLER

  set allskills[441] = BOF
  set allskills[442] = HAZE
  set allskills[443] = BRAWLER
  set allskills[444] = BRAWLER
  set allskills[445] = BRAWLER
  set allskills[446] = SEF
  set allskills[447] = BOF
  set allskills[448] = HAZE
  set allskills[449] = BOF
  set allskills[450] = HAZE

  set allskills[451] = POCKETFACTORY
  set allskills[452] = UPGRADE
  set allskills[453] = POCKETFACTORY
  set allskills[454] = UPGRADE
  set allskills[455] = POCKETFACTORY
  set allskills[456] = ROBOGOBLIN
  set allskills[457] = UPGRADE
  set allskills[458] = ROCKETS
  set allskills[459] = ROCKETS
  set allskills[460] = ROCKETS

  set allskills[461] = ROCKETS
  set allskills[462] = UPGRADE
  set allskills[463] = ROCKETS
  set allskills[464] = UPGRADE
  set allskills[465] = ROCKETS
  set allskills[466] = ROBOGOBLIN
  set allskills[467] = UPGRADE
  set allskills[468] = POCKETFACTORY
  set allskills[469] = POCKETFACTORY
  set allskills[470] = POCKETFACTORY

  set allskills[471] = ROCKETS
  set allskills[472] = POCKETFACTORY
  set allskills[473] = ROCKETS
  set allskills[474] = POCKETFACTORY
  set allskills[475] = ROCKETS
  set allskills[476] = ROBOGOBLIN
  set allskills[477] = POCKETFACTORY
  set allskills[478] = UPGRADE
  set allskills[479] = UPGRADE
  set allskills[480] = UPGRADE

  set allskills[481] = ROCKETS
  set allskills[482] = UPGRADE
  set allskills[483] = ROCKETS
  set allskills[484] = UPGRADE
  set allskills[485] = ROCKETS
  set allskills[486] = ROBOGOBLIN
  set allskills[487] = UPGRADE
  set allskills[488] = POCKETFACTORY
  set allskills[489] = POCKETFACTORY
  set allskills[490] = POCKETFACTORY

  set allskills[491] = ROCKETS
  set allskills[492] = POCKETFACTORY
  set allskills[493] = ROCKETS
  set allskills[494] = POCKETFACTORY
  set allskills[495] = ROCKETS
  set allskills[496] = ROBOGOBLIN
  set allskills[497] = POCKETFACTORY
  set allskills[498] = UPGRADE
  set allskills[499] = UPGRADE
  set allskills[500] = UPGRADE

  set allskills[501] = ROCKETS
  set allskills[502] = POCKETFACTORY
  set allskills[503] = ROCKETS
  set allskills[504] = UPGRADE
  set allskills[505] = ROCKETS
  set allskills[506] = ROBOGOBLIN
  set allskills[507] = UPGRADE
  set allskills[508] = UPGRADE
  set allskills[509] = POCKETFACTORY
  set allskills[510] = POCKETFACTORY

  set allskills[511] = ROCKETS
  set allskills[512] = UPGRADE
  set allskills[513] = ROCKETS
  set allskills[514] = UPGRADE
  set allskills[515] = ROCKETS
  set allskills[516] = ROBOGOBLIN
  set allskills[517] = UPGRADE
  set allskills[518] = POCKETFACTORY
  set allskills[519] = POCKETFACTORY
  set allskills[520] = POCKETFACTORY

  set allskills[521] = ROCKETS
  set allskills[522] = POCKETFACTORY
  set allskills[523] = ROCKETS
  set allskills[524] = POCKETFACTORY
  set allskills[525] = ROCKETS
  set allskills[526] = ROBOGOBLIN
  set allskills[527] = POCKETFACTORY
  set allskills[528] = UPGRADE
  set allskills[529] = UPGRADE
  set allskills[530] = UPGRADE

  set allskills[531] = ROCKETS
  set allskills[532] = POCKETFACTORY
  set allskills[533] = ROCKETS
  set allskills[534] = UPGRADE
  set allskills[535] = ROCKETS
  set allskills[536] = ROBOGOBLIN
  set allskills[537] = UPGRADE
  set allskills[538] = UPGRADE
  set allskills[539] = POCKETFACTORY
  set allskills[540] = POCKETFACTORY

  set allskills[541] = SUMMON_LAVASPAWN
  set allskills[542] = INCINERATE
  set allskills[543] = SUMMON_LAVASPAWN
  set allskills[544] = INCINERATE
  set allskills[545] = SUMMON_LAVASPAWN
  set allskills[546] = VOLCANO
  set allskills[547] = INCINERATE
  set allskills[548] = SOUL_BURN
  set allskills[549] = SOUL_BURN
  set allskills[550] = SOUL_BURN

  set allskills[551] = SUMMON_LAVASPAWN
  set allskills[552] = SOUL_BURN
  set allskills[553] = SUMMON_LAVASPAWN
  set allskills[554] = INCINERATE
  set allskills[555] = SUMMON_LAVASPAWN
  set allskills[556] = VOLCANO
  set allskills[557] = INCINERATE
  set allskills[558] = INCINERATE
  set allskills[559] = SOUL_BURN
  set allskills[560] = SOUL_BURN

  set allskills[561] = SOUL_BURN
  set allskills[562] = INCINERATE
  set allskills[563] = SOUL_BURN
  set allskills[564] = INCINERATE
  set allskills[565] = SOUL_BURN
  set allskills[566] = VOLCANO
  set allskills[567] = INCINERATE
  set allskills[568] = SUMMON_LAVASPAWN
  set allskills[569] = SUMMON_LAVASPAWN
  set allskills[570] = SUMMON_LAVASPAWN

  set allskills[571] = SUMMON_LAVASPAWN
  set allskills[572] = INCINERATE
  set allskills[573] = SUMMON_LAVASPAWN
  set allskills[574] = INCINERATE
  set allskills[575] = SUMMON_LAVASPAWN
  set allskills[576] = VOLCANO
  set allskills[577] = INCINERATE
  set allskills[578] = SOUL_BURN
  set allskills[579] = SOUL_BURN
  set allskills[580] = SOUL_BURN

  set allskills[581] = SUMMON_LAVASPAWN
  set allskills[582] = SOUL_BURN
  set allskills[583] = SUMMON_LAVASPAWN
  set allskills[584] = SOUL_BURN
  set allskills[585] = SUMMON_LAVASPAWN
  set allskills[586] = VOLCANO
  set allskills[587] = SOUL_BURN
  set allskills[588] = INCINERATE
  set allskills[589] = INCINERATE
  set allskills[590] = INCINERATE

  set allskills[591] = SOUL_BURN
  set allskills[592] = INCINERATE
  set allskills[593] = SOUL_BURN
  set allskills[594] = INCINERATE
  set allskills[595] = SOUL_BURN
  set allskills[596] = VOLCANO
  set allskills[597] = INCINERATE
  set allskills[598] = SUMMON_LAVASPAWN
  set allskills[599] = SUMMON_LAVASPAWN
  set allskills[600] = SUMMON_LAVASPAWN

  set allskills[601] = SOUL_BURN
  set allskills[602] = INCINERATE
  set allskills[603] = SOUL_BURN
  set allskills[604] = INCINERATE
  set allskills[605] = SOUL_BURN
  set allskills[606] = VOLCANO
  set allskills[607] = INCINERATE
  set allskills[608] = SUMMON_LAVASPAWN
  set allskills[609] = SUMMON_LAVASPAWN
  set allskills[610] = SUMMON_LAVASPAWN

  set allskills[611] = SOUL_BURN
  set allskills[612] = INCINERATE
  set allskills[613] = SOUL_BURN
  set allskills[614] = INCINERATE
  set allskills[615] = SOUL_BURN
  set allskills[616] = VOLCANO
  set allskills[617] = INCINERATE
  set allskills[618] = SUMMON_LAVASPAWN
  set allskills[619] = SUMMON_LAVASPAWN
  set allskills[620] = SUMMON_LAVASPAWN

  set allskills[621] = INCINERATE
  set allskills[622] = SOUL_BURN
  set allskills[623] = INCINERATE
  set allskills[624] = SOUL_BURN
  set allskills[625] = INCINERATE
  set allskills[626] = VOLCANO
  set allskills[627] = SOUL_BURN
  set allskills[628] = SUMMON_LAVASPAWN
  set allskills[629] = SUMMON_LAVASPAWN
  set allskills[630] = SUMMON_LAVASPAWN

  set allskills[631] = CHEMICAL_RAGE
  set allskills[632] = HEALING_SPRAY
  set allskills[633] = CHEMICAL_RAGE
  set allskills[634] = HEALING_SPRAY
  set allskills[635] = CHEMICAL_RAGE
  set allskills[636] = TRANSMUTE
  set allskills[637] = HEALING_SPRAY
  set allskills[638] = ACID_BOMB
  set allskills[639] = ACID_BOMB
  set allskills[640] = ACID_BOMB

  set allskills[641] = ACID_BOMB
  set allskills[642] = CHEMICAL_RAGE
  set allskills[643] = ACID_BOMB
  set allskills[644] = CHEMICAL_RAGE
  set allskills[645] = ACID_BOMB
  set allskills[646] = TRANSMUTE
  set allskills[647] = CHEMICAL_RAGE
  set allskills[648] = HEALING_SPRAY
  set allskills[649] = HEALING_SPRAY
  set allskills[650] = HEALING_SPRAY

  set allskills[651] = CHEMICAL_RAGE
  set allskills[652] = ACID_BOMB
  set allskills[653] = CHEMICAL_RAGE
  set allskills[654] = ACID_BOMB
  set allskills[655] = CHEMICAL_RAGE
  set allskills[656] = TRANSMUTE
  set allskills[657] = ACID_BOMB
  set allskills[658] = HEALING_SPRAY
  set allskills[659] = HEALING_SPRAY
  set allskills[660] = HEALING_SPRAY

  set allskills[661] = ACID_BOMB
  set allskills[662] = CHEMICAL_RAGE
  set allskills[663] = ACID_BOMB
  set allskills[664] = CHEMICAL_RAGE
  set allskills[665] = ACID_BOMB
  set allskills[666] = TRANSMUTE
  set allskills[667] = CHEMICAL_RAGE
  set allskills[668] = HEALING_SPRAY
  set allskills[669] = HEALING_SPRAY
  set allskills[670] = HEALING_SPRAY

  set allskills[671] = CHEMICAL_RAGE
  set allskills[672] = ACID_BOMB
  set allskills[673] = CHEMICAL_RAGE
  set allskills[674] = ACID_BOMB
  set allskills[675] = CHEMICAL_RAGE
  set allskills[676] = TRANSMUTE
  set allskills[677] = ACID_BOMB
  set allskills[678] = HEALING_SPRAY
  set allskills[679] = HEALING_SPRAY
  set allskills[680] = HEALING_SPRAY

  set allskills[681] = CHEMICAL_RAGE
  set allskills[682] = ACID_BOMB
  set allskills[683] = CHEMICAL_RAGE
  set allskills[684] = ACID_BOMB
  set allskills[685] = CHEMICAL_RAGE
  set allskills[686] = TRANSMUTE
  set allskills[687] = ACID_BOMB
  set allskills[688] = HEALING_SPRAY
  set allskills[689] = HEALING_SPRAY
  set allskills[690] = HEALING_SPRAY

  set allskills[691] = ACID_BOMB
  set allskills[692] = CHEMICAL_RAGE
  set allskills[693] = ACID_BOMB
  set allskills[694] = CHEMICAL_RAGE
  set allskills[695] = ACID_BOMB
  set allskills[696] = TRANSMUTE
  set allskills[697] = CHEMICAL_RAGE
  set allskills[698] = HEALING_SPRAY
  set allskills[699] = HEALING_SPRAY
  set allskills[700] = HEALING_SPRAY

  set allskills[701] = ACID_BOMB
  set allskills[702] = CHEMICAL_RAGE
  set allskills[703] = ACID_BOMB
  set allskills[704] = CHEMICAL_RAGE
  set allskills[705] = ACID_BOMB
  set allskills[706] = TRANSMUTE
  set allskills[707] = CHEMICAL_RAGE
  set allskills[708] = HEALING_SPRAY
  set allskills[709] = HEALING_SPRAY
  set allskills[710] = HEALING_SPRAY

  set allskills[711] = CHEMICAL_RAGE
  set allskills[712] = ACID_BOMB
  set allskills[713] = CHEMICAL_RAGE
  set allskills[714] = ACID_BOMB
  set allskills[715] = CHEMICAL_RAGE
  set allskills[716] = TRANSMUTE
  set allskills[717] = ACID_BOMB
  set allskills[718] = HEALING_SPRAY
  set allskills[719] = HEALING_SPRAY
  set allskills[720] = HEALING_SPRAY

endfunction


function TownCountExForUpgrade takes integer unitid, integer unitid_upgr, boolean only_done, integer townid returns integer
  local integer count = 0
  if tc_add1[unitid] != unitid_upgr then
    set count = count + GetUnitCountEx(tc_add1[unitid],false,townid)
  endif
  if tc_add2[unitid] != unitid_upgr then
    set count = count + GetUnitCountEx(tc_add2[unitid],false,townid)
  endif
  if unitid == WATCH_TOWER and unitid_upgr != WATCH_TOWER then
    set count = count + GetUnitCountEx(ARCANE_TOWER, false, townid)
  endif
  return count

endfunction

function DistanceBetweenPoints takes location locA, location locB returns real
	local real distance = GetLengthOfLoc_d(GetSubtractionLoc(locB, locA))
    return distance
endfunction
function DistanceBetweenPoints_kd takes location locA, location locB returns real
	local real distance = GetLengthOfLoc_d(GetSubtractionLoc_dk(locB, locA))
    return distance
endfunction
function DistanceBetweenPoints_dk takes location locA, location locB returns real
	local real distance = GetLengthOfLoc_d(GetSubtractionLoc_kd(locB, locA))	
    return distance
endfunction
function DistanceBetweenPoints_dd takes location locA, location locB returns real
	local real distance = GetLengthOfLoc_d(GetSubtractionLoc_dd(locB, locA))
    return distance
endfunction

function DistanceBetweenUnits takes unit unitA, unit unitB returns real
    local real r = DistanceBetweenPoints_dd(GetUnitLoc(unitA), GetUnitLoc(unitB))
    return r
endfunction

function GetTimeToReachUnit takes unit u, unit target returns real
	local real distance = 0
	local real movespeed = 0
	local real time = 0

	set movespeed = GetUnitMoveSpeed(u)
	set distance = DistanceBetweenUnits(target, u)
	if movespeed != 0 then
		set time = distance / movespeed
	else
		set time = 15
	endif

	return time

endfunction

function GetTimeToReachLoc takes unit u, location target returns real
	local real distance = 0
	local real movespeed = 0
	local real time = 0
    local location l = GetUnitLoc(u)

	set movespeed = GetUnitMoveSpeed(u)
	set distance = DistanceBetweenPoints_kd(target, l)
	//call DisplayToAllJobDebug("gettime: before")
	if movespeed != 0 then
		set time = distance / movespeed
	else
		set time = 15
	endif
	//call DisplayToAllJobDebug("gettime: after")
	
      set l = null

	return time
endfunction

function EstimatedTimeToReachUnit_d takes location locA, unit target, real movespeed returns real

	local real distance = 0
	local real time = 0
      local location l = GetUnitLoc(target)

	set distance = DistanceBetweenPoints_dd(locA, l)
	if movespeed != 0 then
		set time = distance / movespeed
	else
		set time = 15
	endif
      set l = null

	return time

endfunction

function GetLocationBetweenLoc takes location locA, location locB, real d returns location
  local location locC = GetSubtractionLoc(locA, locB)
  local location locD = GetMultipleLoc(locC, d)
  return GetSumLoc(locA, locD)
endfunction

function GetLocationBetweenUnits takes unit u1, unit u2, real d returns location
  local location loc1 = GetUnitLoc(u1)
  local location loc2 = GetUnitLoc(u2)
  local location returnloc = GetLocationBetweenLoc(loc1, loc2, d)
  call RemoveLocation(loc1)
  call RemoveLocation(loc2)
  set loc1 = null
  set loc2 = null
  return returnloc
endfunction

function GetNearestEnemyToLoc_k takes location l returns player
  local integer i = 0
  local real nr = 0
  local real min_nr = 1000000
  local player min_p = null
  
  loop
    exitwhen i >= 12
    if IsPlayerEnemy(Player(i), ai_player) and GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING and not IsPlayerObserver(Player(i)) then
      set nr = DistanceBetweenPoints_dk(GetPlayerStartLocationLoc(Player(i)), l)
      if nr < min_nr then
        set min_nr = nr
        set min_p = Player(i)
      endif
    endif
    set i = i + 1
  endloop
  return min_p
endfunction

function GetNearestEnemyToLoc_d takes location l returns player
  local integer i = 0
  local real nr = 0
  local real min_nr = 1000000
  local player min_p = null
  
  loop
    exitwhen i >= 12
    if IsPlayerEnemy(Player(i), ai_player) and GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING and not IsPlayerObserver(Player(i)) then
      set nr = DistanceBetweenPoints_dk(GetPlayerStartLocationLoc(Player(i)), l)
      if nr < min_nr then
        set min_nr = nr
        set min_p = Player(i)
      endif
    endif
    set i = i + 1
  endloop
  call RemoveLocation(l)
  return min_p
endfunction

function SetNearestEnemy takes nothing returns nothing
  local integer i = 0
  local real nr = 0
  
  loop
    exitwhen i >= 12
    if IsPlayerEnemy(Player(i), ai_player) and GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING and not IsPlayerObserver(Player(i)) then
      set nr = DistanceBetweenPoints_dk(GetPlayerStartLocationLoc(Player(i)), home_location)
      if nr < nearest_enemy_range then
        set nearest_enemy_range = nr
        set nearest_enemy = Player(i)
      endif
    endif
    set i = i + 1
  endloop
endfunction

function countAllyEnemy takes nothing returns nothing
  local integer i = 0
  local boolean self_came = false
  local boolean next_came = false

  loop
    exitwhen i > RACE_NUMBER
    set c_ally[i] = 0
    set c_enemy[i] = 0
    set i = i + 1
  endloop
  
  set i = 0
  loop
    exitwhen i >= 12
    if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then
      if GetPlayerController(Player(i)) == MAP_CONTROL_COMPUTER then
        set c_ai_total = c_ai_total + 1
      endif
      if IsPlayerAlly(ai_player,Player(i)) then
        if i == GetAiPlayer() then
          set self_came = true
          set next_came = true
          set own_force[force_number] = Player(i)
          set force_number = force_number + 1
        else
          if GetPlayerController(Player(i)) == MAP_CONTROL_COMPUTER then
          	set own_force[force_number] = Player(i)
          	set force_number = force_number + 1
          	if not self_came then
          	  set first_ai = false
          	elseif next_came then
          	  set next_ai = i
          	  set next_came = false
          	endif
          else
          	set no_ally_ctrl = false
          endif
          set c_ally[player_race[i]] = c_ally[player_race[i]] + 1
          set c_ally_total = c_ally_total + 1
        endif
      elseif IsPlayerEnemy(ai_player,Player(i)) and not IsPlayerObserver(Player(i)) then
        set c_enemy[player_race_pref[i]] = c_enemy[player_race_pref[i]] + 1
        set c_enemy_total = c_enemy_total + 1
      endif
    endif
    set i = i + 1
  endloop
  set no_ai_ally = first_ai and next_ai == 0
endfunction

function CopyGroup takes group g returns group
  local group gnew = CreateGroup()
  local group gtemp = CreateGroup()
  local unit u = null
  if FirstOfGroup(g) == null then
	return gnew
  endif
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call GroupAddUnit(gnew,u)
    call GroupAddUnit(gtemp,u)
    call GroupRemoveUnit(g,u)
  endloop
  loop
    set u = FirstOfGroup(gtemp)
    exitwhen u == null
    call GroupAddUnit(g,u)
    call GroupRemoveUnit(gtemp,u)
  endloop
  call DestroyGroup(gtemp)
  set gtemp = null
  set u = null
  return gnew
endfunction

function AreUnitsOfType takes group g, integer id returns boolean
  local group cg = CopyGroup(g)
  local unit u = null
  loop
    set u = FirstOfGroup(cg)
    exitwhen u == null
    if GetUnitTypeId(u) != id then
      call DestroyGroup(cg)
      set cg = null
      return false
    endif
    call GroupRemoveUnit(cg, u)
  endloop
  call DestroyGroup(cg)
  set cg = null
  return true
endfunction

function AddAbilityToGroup takes group g, integer abil returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitAbilityLevel(u, abil) <= 0 then
      call UnitAddAbility(u, abil)
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
endfunction

function SelectNumberOfId takes group g, integer n, integer id returns group
     local integer c = 0
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       exitwhen c == n
       if GetUnitTypeId(u) == id then
          set c = c + 1
          call GroupAddUnit(rg, u ) 
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectById takes group g, integer id, boolean is_id returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if (GetUnitTypeId(u) == id) == is_id then
          call GroupAddUnit(rg, u ) 
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectByIdOr takes group g, integer id1, integer id2, boolean is_id returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if (GetUnitTypeId(u) == id1 or GetUnitTypeId(u) == id2) == is_id then
          call GroupAddUnit(rg, u ) 
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectUnittype takes group g, unittype typ, boolean is_of_type returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if IsUnitType(u, typ) == is_of_type then
          call GroupAddUnit(rg, u ) 
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectByIllusion takes group g, boolean is_illusion returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if IsUnitIllusion(u) == is_illusion then
          call GroupAddUnit(rg, u ) 
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectByLoaded takes group g, boolean is_loaded returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if IsUnitLoaded(u) == is_loaded then
          call GroupAddUnit(rg, u ) 
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectByHidden takes group g, boolean is_visible returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if IsUnitHidden(u) == is_visible then
          call GroupAddUnit(rg, u ) 
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectByAlive takes group g, boolean is_alive returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if UnitAlive(u) == is_alive then
	   //if not IsUnitType(u, UNIT_TYPE_DEAD) == is_alive then
          call GroupAddUnit(rg, u ) 
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectByAlive2 takes group g, boolean is_alive returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if GetUnitState(u, UNIT_STATE_LIFE) > 0 == is_alive then
	   //if not IsUnitType(u, UNIT_TYPE_DEAD) == is_alive then
          call GroupAddUnit(rg, u ) 
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectByFullHealth takes group g, boolean is_healed returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if GetUnitState(u, UNIT_STATE_LIFE) >= GetUnitState(u, UNIT_STATE_MAX_LIFE) == is_healed or IsUnitType(u, UNIT_TYPE_HERO) then
	   //if not IsUnitType(u, UNIT_TYPE_DEAD) == is_alive then
          call GroupAddUnit(rg, u ) 
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectByPlayer takes group g, player p, boolean is_owner returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if (GetOwningPlayer(u) == p) == is_owner then
          call GroupAddUnit(rg, u )
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectByInvisible takes group g, player enemy, boolean is_visible returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if IsUnitInvisible(u, enemy) == is_visible then
          call GroupAddUnit(rg, u ) 
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectByVisible takes group g, player  enemy, boolean is_visible returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if IsUnitVisible(u, enemy) == is_visible then
          call GroupAddUnit(rg, u ) 
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectByDetected takes group g, player enemy, boolean is_detected returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if IsUnitDetected(u, enemy) == is_detected then
          call GroupAddUnit(rg, u ) 
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction 

function SelectByEnemy takes group g, player p, boolean is_enemy returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if IsPlayerEnemy(p, GetOwningPlayer(u)) == is_enemy then
          call GroupAddUnit(rg, u )
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function IsStandardUnit takes unit u returns boolean
	return (not IsUnitInGroup(u, unit_healing) and not IsUnitInGroup(u, unit_rescueing ) and not IsUnitInGroup(u, unit_harassing ) and not IsUnitInGroup(u, unit_zepplin_move ))
endfunction

function IsUnitBuying takes unit u returns boolean
	return IsUnitInGroup(u, unit_buying_tavern) or IsUnitInGroup(u, unit_buying_merc) or IsUnitInGroup(u, unit_buying_item)
endfunction

function SelectByUnitStandard takes group g, boolean has_data returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if IsStandardUnit(u) == has_data then
          call GroupAddUnit(rg, u )
	   endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectByUnitFree takes group g, boolean has_data returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if not IsUnitBuying(u) == has_data then
          call GroupAddUnit(rg, u )
	   endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectByOrder takes group g, integer my_order, boolean has_order returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if (GetUnitCurrentOrder(u) == my_order) == has_order then
          call GroupAddUnit(rg, u )
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectByOrderOr takes group g, integer my_order1, integer my_order2, boolean has_order returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if ((GetUnitCurrentOrder(u) == my_order1) or (GetUnitCurrentOrder(u) == my_order2)) == has_order then
          call GroupAddUnit(rg, u )
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function SelectByOrderOr2 takes group g, integer my_order1, integer my_order2, integer my_order3, boolean has_order returns group
     local unit u = null
     local group rg = CreateGroup()
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if ((GetUnitCurrentOrder(u) == my_order1) or (GetUnitCurrentOrder(u) == my_order2) or (GetUnitCurrentOrder(u) == my_order3)) == has_order then
          call GroupAddUnit(rg, u )
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction
	
function SelectByLocation takes group g, location l, real dist, boolean is_near returns group
     local unit u = null
     local group rg = CreateGroup()
	 local location unitloc = null
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
	   set unitloc = GetUnitLoc(u)
       if (DistanceBetweenPoints(unitloc, l) <= dist) == is_near then
          call GroupAddUnit(rg, u )
       endif
       call GroupRemoveUnit(g, u )
	   call RemoveLocation(unitloc)
	   set unitloc = null
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function GroupAddGroup takes group g, group to_add returns group
     local unit u = null
     loop
       set u = FirstOfGroup(to_add)
       exitwhen u == null
       call GroupAddUnit(g, u )
       call GroupRemoveUnit(to_add, u )
     endloop
     return g
endfunction


function GroupAddType takes group g, integer id, player p returns nothing
  local group ag = CreateGroup()
  call GroupEnumUnitsOfPlayer(ag, p, null)
  set ag = SelectNumberOfId(ag, 100, id)
  call GroupAddGroup(g, ag)
  call DestroyGroup(ag)
  set ag = null
endfunction

function GroupAddTypeAndRemoveGuard takes group g, integer id, player p returns nothing
  local unit u = null
  local group ag = CreateGroup()
  call GroupEnumUnitsOfPlayer(ag, p, null)
  loop
    set u = FirstOfGroup(ag)
    exitwhen u == null
    if GetUnitTypeId(u) == id then
      call RemoveGuardPosition(u)
      call GroupAddUnit(g,u)
    endif
    call GroupRemoveUnit(ag, u)
  endloop
  call DestroyGroup(ag)
  set ag = null
endfunction

function GroupRemoveGuardPositionInstant takes group g returns nothing
  local unit u = null
  local group ug = CopyGroup(g)
  
  loop
    set u = FirstOfGroup(ug)
    exitwhen u == null
    call RemoveGuardPosition(u)
    call GroupRemoveUnit(ug,u)
  endloop
  call DestroyGroup(ug)
  set ug = null
endfunction

function GroupRecycleGuardPositionInstant takes group g returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call RecycleGuardPosition(u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
endfunction

function GroupRecycleHarrassPositionInstant takes group g returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call RecycleGuardPosition(u)
	call AddAssault(1, GetUnitTypeId(u))
	call GroupRemoveUnit(unit_harassing, u)	
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
endfunction

function GroupRecycleGuardPositionByStandard takes group g returns nothing
     local unit u = null
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       if not IsUnitInGroup(u, unit_healing) and not IsUnitInGroup(u, unit_rescueing ) and not IsUnitInGroup(u, unit_harassing ) and not IsUnitInGroup(u, unit_zepplin_move ) then
          call RecycleGuardPosition( u )
	   endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
endfunction

function RemoveSentUnits takes group g returns group
  local integer i = 0
  loop
   exitwhen i > 3
   call GroupRemoveUnit(g, neutral_sent[i] )
   set i = i + 1
  endloop
  return SelectById(g, 'nzep', false)
endfunction

function GetOneOfId takes player p, integer id returns unit
   local unit u = null
   local group g = CreateGroup()     
   call GroupEnumUnitsOfPlayer(g, p, null)
   set g = SelectByAlive(g, true)
   loop
     set u = FirstOfGroup(g)
     exitwhen u == null
     if GetUnitTypeId(u) == id then
       call DestroyGroup(g)
       set g = null
       return u
     endif
     call GroupRemoveUnit(g, u )
   endloop
   call DestroyGroup(g)
   set g = null
   return null
endfunction

function GetOneOfIdNearLoc takes player p, integer id, location l, real dist returns unit
   local unit u = null
   local group g = CreateGroup()     
   call GroupEnumUnitsInRangeOfLoc(g, l, dist, null)
   set g = SelectByPlayer(g, p, true)
   set g = SelectByAlive(g, true)
   loop
     set u = FirstOfGroup(g)
     exitwhen u == null
     if GetUnitTypeId(u) == id then
       call DestroyGroup(g)
       set g = null
       return u
     endif
     call GroupRemoveUnit(g, u )
   endloop
   call DestroyGroup(g)
   set g = null
   return null
endfunction

function GetMineNearLoc takes location l, real dist returns unit
  local unit u = null
  local group g = CreateGroup()
  local integer i = 0
  call GroupEnumUnitsInRangeOfLoc(g, l, dist, null)
  //set g = SelectByAlive(g, true)
  loop
		if minearray == 0 then
			call DisplayToAll("Warning - No standard gold mine set in standardunits.slk")
			call Sleep(3)
		endif
    set u = FirstOfGroup(g)
    exitwhen u == null
	set i = 0
	loop
	exitwhen i >= minearray
	if GetUnitTypeId(u) == racial_goldmine[i] then
    //if SetHasEntry(ver_gold_mines, GetUnitTypeId(u)) then
	//if GetUnitTypeId(u) =='ngol' or GetUnitTypeId(u) =='egol' or GetUnitTypeId(u) == 'ugol' then
	  call Trace("GetMineNearLOC: A Mine match found")
      call DestroyGroup(g)
      set g = null
      return u
    endif
	set i = i + 1
	endloop
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return null
endfunction

function CanPathToLoc takes location locA, location target, pathingtype path returns real 


    local integer groundid = 'ewsp'
    local integer seaid = 'hdes'
    local integer amphibiousid = 'nsnp'
    local integer flyid = 'hgyr'
    local unit u = null
    local real distance = 0
    local location l = null
    local real checktime = 0
    local real totaltime = 0
	local location prev_loc = null
	local integer checks = 0	// Number of times unit has stayed at same position
    
    if path == PATHING_TYPE_WALKABILITY then
        set u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), groundid, GetLocationX(locA), GetLocationY(locA), 270.00)
    elseif path == PATHING_TYPE_FLOATABILITY then
        set u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), seaid, GetLocationX(locA), GetLocationY(locA), 270.00)
    elseif path == PATHING_TYPE_AMPHIBIOUSPATHING then
        set u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), amphibiousid, GetLocationX(locA), GetLocationY(locA), 270.00)
    elseif path == PATHING_TYPE_FLYABILITY then
        set u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), flyid, GetLocationX(locA), GetLocationY(locA), 270.00)
    else
        return false
    endif

	    call SetUnitInvulnerable(u, true)
        call ShowUnit(u, false)
        call SetUnitUseFood(u, false)
        call SetUnitMoveSpeed(u, 520)
        call RemoveGuardPosition(u)
        call IssuePointOrder(u, "move", GetLocationX(target), GetLocationY(target))

    set checktime =  GetTimeToReachLoc(u, target)
    set totaltime = checktime
    //call UnitApplyTimedLife(u, 'BTLF', checktime * 5)
    //call Sleep(checktime)
    set checktime = 2.00
    
    loop
		//	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "pathing loop")
        set l = Location(GetUnitX(u), GetUnitY(u))
        set distance = DistanceBetweenPoints(l,target)
        if distance <= buy_distance then
		//	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Tavern is pathable")
			call CreateDebugTag("Target Destination is pathable", 10, u, 3.00, 1.50)
			call RemoveUnit(u)
			set u = null
            return totaltime
		//elseif GetUnitCurrentOrder(u) == OrderId("stop") then
            //return (totaltime * -1)
        elseif GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
			call RemoveUnit(u)
			set u = null		
            return (totaltime * -1)
        elseif GetUnitCurrentOrder(u) == OrderId("stop") or GetUnitCurrentOrder(u) != OrderId("move") then
			set checks = checks + 1
			call CreateDebugTag("Invisible Path unit has stopped", 10, u, 3.00, 1.50)
			if checks > 1 then
				call CreateDebugTag("Target Destination was not reached", 10, u, 3.00, 1.50)
				call RemoveUnit(u)
				set u = null				
				return (totaltime * -1)
			endif
		else
			set checks = 0	// means unit is moving and not standing still
			call CreateDebugTag("Invisible Path Unit Here", 10, u, 3.00, 1.50)	
        endif
		call RemoveLocation(l)
		set l = null
        set totaltime = totaltime + checktime	
        call Sleep(checktime)
        
    endloop
    
    return (totaltime * -1)
    
endfunction

function GetNearestNeutralQuick takes integer id returns unit
	local group g = CreateGroup()
	local unit u = null
	local unit unit_nearest = null
	local real distance = 10000000
    local real newdistance = 0	
    local location l = null

	call GroupEnumUnitsOfPlayer(g, Player(PLAYER_NEUTRAL_PASSIVE), null)	
    loop
		set u = FirstOfGroup(g)
		exitwhen u == null 
		set l = GetUnitLoc(u)
		if GetUnitTypeId(u) == id then
			set newdistance = DistanceBetweenPoints(home_location, l )
			if newdistance < distance then
			 set distance = newdistance
			 set unit_nearest = u
		    endif
	      endif
        
        call GroupRemoveUnit(g, u)
		call RemoveLocation(l)
		set l = null	
	endloop
	
	call DestroyGroup(g)
	set g = null
	return unit_nearest 
endfunction

function GetNearestNeutral takes integer id returns unit
	local group g = CreateGroup()
	local unit u = null
    local unit unit_nearest = null
	local real distance = 0
	local group tempg = null
	local unit array pather
	local integer i = 0
	local integer checks = 0
  local boolean pathingdone = true
  local real totaltime = 0
  local integer groundid = 'ewsp'  
  local integer totalneutrals = 0
	



		// ----- initial loop to get the nearest neutral

		// ----- check if it really is passable
		//set l = GetUnitLoc(unit_nearest)
		//set newdistance = CanPathToLoc(start_loc, l, PATHING_TYPE_WALKABILITY)
		//call RemoveLocation(l)
		//set l = null
	
	//----- closest not passable so try others
	//call GroupClear(g)
	call GroupEnumUnitsOfPlayer(g, Player(PLAYER_NEUTRAL_PASSIVE), null)
	//call GroupRemoveUnit(g, unit_nearest)
	
	  set tempg = CopyGroup(g)
	  loop
	    set u = FirstOfGroup(tempg)
		exitwhen u == null
		if GetUnitTypeId(u) == id then
			set pather[i] = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), groundid, GetLocationX(home_location), GetLocationY(home_location), 270.00)	
			if pather[i] == null then
				set pather[i] = CreateUnitAtLoc(Player(PLAYER_NEUTRAL_PASSIVE), groundid, home_location, 270)
			endif
			if pather[i] == null then
				call Trace("Pather unit not made")
			endif
			call SetUnitInvulnerable(pather[i], true)
			call ShowUnit(pather[i], false)
			call SetUnitUseFood(pather[i], false)
			call SetUnitMoveSpeed(pather[i], 520)
			call RemoveGuardPosition(pather[i])
			call IssuePointOrder(pather[i], "move", GetUnitX(u), GetUnitY(u))	
			set i = i + 1
			set totalneutrals = i
		else
			call GroupRemoveUnit(g, u)
		endif
		call GroupRemoveUnit(tempg, u)
	  endloop
	  call DestroyGroup(tempg)
	  set tempg = null
	
	set unit_nearest = null
	//set distance = 10000000
	
	loop
	set totaltime = totaltime + 3	  
	set pathingdone = true
	set tempg = CopyGroup(g)
	set i = 0
	loop
	    set u = FirstOfGroup(tempg)
		exitwhen u == null
		if pather[i] != null and unit_nearest == null then		
			set distance = DistanceBetweenUnits(pather[i],u)	
			if distance <= buy_distance then
			//	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Tavern is pathable")
				call CreateDebugTag("Target Destination is pathable", 10, pather[i], 3.00, 1.50)
				call RemoveUnit(pather[i])
				set pather[i] = null
				if unit_nearest == null then
					set unit_nearest = u
				endif
			//elseif GetUnitCurrentOrder(u) == OrderId("stop") then
	            //return (totaltime * -1)
			elseif GetUnitState(pather[i], UNIT_STATE_LIFE) <= 0 then
			    //call Trace("DIED")
				call RemoveUnit(pather[i])
				set pather[i] = null				
			elseif GetUnitCurrentOrder(pather[i]) == OrderId("stop") or GetUnitCurrentOrder(pather[i]) != OrderId("move") then
				set checks = checks + 1
				call CreateDebugTag("Invisible Path unit has stopped", 10, pather[i], 3.00, 1.50)
				if checks > 1 then
					call CreateDebugTag("Target Destination was not reached", 10, pather[i], 3.00, 1.50)
					//call Trace("GOT STUCK")
					call RemoveUnit(pather[i])
					set pather[i] = null						
				endif
			else
				set checks = 0	// means unit is moving and not standing still
				call CreateDebugTag("Invisible Path Unit Here", 10, pather[i], 3.00, 1.50)	
			endif	
			set pathingdone = false
		endif
		call GroupRemoveUnit(tempg, u)
		set i = i + 1
	endloop
	call DestroyGroup(tempg)
    set tempg = null
	exitwhen pathingdone
	call Sleep(3)
  endloop
  
  call DestroyGroup(g)
  set g = null
	
  return unit_nearest 
	
	//loop
	//	set u = FirstOfGroup(g)
	//	exitwhen u == null 
	//	set l = GetUnitLoc(u)
	//	if GetUnitTypeId(u) == id then
	//	//set newdistance = DistanceBetweenPoints(start_loc, l )
	//	  	set newdistance = CanPathToLoc(start_loc, l, PATHING_TYPE_WALKABILITY)
	//		if newdistance > 0 and newdistance < distance then
	//		 set distance = newdistance
	//		 set unit_nearest = u
	//	     endif
	 //     endif
	        
    //    call GroupRemoveUnit(g, u)
	//	call RemoveLocation(l)
	//	set l = null
	//endloop
	
	//	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "neutral out loop")
	//call DestroyGroup(g)
	//set g = null
	//call RemoveLocation(start_loc)
	//set start_loc = null	

endfunction

function GetNearestOfGroup takes group g, location l returns unit
   local real d = 0
   local unit u = null
   local unit nu = null
   local real sd = 1000000
   local location unitloc = null
   loop
     set u = FirstOfGroup(g)
     exitwhen u == null
	 set unitloc = GetUnitLoc(u)
     set d = DistanceBetweenPoints(unitloc, l)
     if d < sd then
        set sd = d
        set nu = u
     endif
     call GroupRemoveUnit(g, u )
	 call RemoveLocation(unitloc)
     set unitloc = null
   endloop
   return nu
endfunction

function GetNearestSubGroupOfGroup takes group g, location l, integer n returns group
  local unit array ua
  local real array da
  local integer size = 0
  local integer i = 0
  local unit u = null
  local real d = 0
  local group ng = CreateGroup()
  local location unitloc =null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
	set unitloc = GetUnitLoc(u)
    set d = DistanceBetweenPoints(unitloc, l)
    set i = size - 1
    loop
      exitwhen i < 0 or da[i] >= d
      set ua[i+1] = ua[i]
      set da[i+1] = da[i]
      set i = i - 1
    endloop
    set i = i + 1
    set ua[i] = u
    set da[i] = d
    set size = size + 1
    call GroupRemoveUnit(g,u)
	call RemoveLocation(unitloc)
	set unitloc = null
  endloop
  set i = size - Min(n, size)
  loop
    exitwhen i >= size
    call GroupAddUnit(ng, ua[i])
    set i = i + 1
  endloop
  return ng
endfunction

function GetFarestOfGroup takes group g, location l returns unit
     local real d = 0
     local unit u = null
     local unit nu = null
     local real sd = 0
	 local location unitloc = null
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
	   set unitloc = GetUnitLoc(u)
       set d = DistanceBetweenPoints(unitloc, l)
       if d > sd then
          set sd = d
          set nu = u
       endif
       call GroupRemoveUnit(g, u )
	   call RemoveLocation(unitloc)
	   set unitloc = null
     endloop
     return nu
endfunction

function GetFastestToPointOfGroup takes group g, location l returns unit
     local real d = 0
     local unit u = null
     local unit nu = null
     local real sd = 1000000
     local real ms = 0
	 local location unitloc = null
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       set ms = GetUnitMoveSpeed(u)
       if ms == 0 then
         set ms = 0.01
       endif
	   set unitloc = GetUnitLoc(u)
       set d = DistanceBetweenPoints(unitloc, l) / ms
       if d < sd then
          set sd = d
          set nu = u
       endif
       call GroupRemoveUnit(g, u )
	   call RemoveLocation(unitloc)
	   set unitloc = null
     endloop
     return nu
endfunction

function GetLeastHPUnitOfGroup takes group g returns unit
     local real hp = 0
     local unit u = null
     local unit lhpu = null
     local real lhp = 1000000
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
       set hp = GetUnitState(u, UNIT_STATE_LIFE)
       if hp < lhp then
          set lhp = hp
          set lhpu = u
       endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return lhpu
endfunction

function UnitAliveInGroup takes group g returns boolean
  local unit u = null

  loop
    set u = FirstOfGroup(g)
    if u == null then
      call DestroyGroup(g)
      return false
    endif
    if UnitAlive(u) then
      return true
    endif
    call GroupRemoveUnit(g,u)
  endloop
  return true // never reached
endfunction

function GetUnitToBuy takes unit buy_place returns unit
  local group g = CreateGroup()
  local unit u = null
  local unit buyingunit = null
  local real distance = 10000
  local real newdistance = 0

  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectByUnitStandard(g, true)
  loop
	set u = FirstOfGroup(g)
	exitwhen u == null
	if IsUnitType(u, UNIT_TYPE_STRUCTURE) == false and IsUnitType(u, UNIT_TYPE_PEON) == false and IsUnitType(u, UNIT_TYPE_SUMMONED) == false and not IsUnitIllusion(u) and GetUnitState(u, UNIT_STATE_LIFE) > 0 and not IsUnitInGroup(u, unit_buying_item) and not IsUnitInGroup(u, unit_buying_merc) then
		set newdistance = DistanceBetweenUnits(buy_place, u)
  		if newdistance < distance then
			set distance = newdistance
			set buyingunit = u

		endif
	endif
      call GroupRemoveUnit(g, u)
  endloop

  if buyingunit == null then
    set buyingunit = GetExpansionPeon()
  endif

  return buyingunit
endfunction

function GetUnitOfTypeNearUnit takes integer ut, unit nu returns unit
  local group g = CreateGroup()
  local unit u = null
  local location unitloc = GetUnitLoc(nu)
  
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectById(g, ut, true)
  set u = GetNearestOfGroup(g, unitloc)
  call DestroyGroup(g)
  call RemoveLocation(unitloc)
  set g = null
  set unitloc = null
  return u
endfunction

function GetUnusedZeppelinNearUnit takes unit nu returns unit
  local group g = CreateGroup()
  local unit u = null
  local location unitloc = GetUnitLoc(nu)
  
  call GroupEnumUnitsOfType(g, "goblinzeppelin", null)
  set g = SelectByPlayer(g, ai_player, true)
  set g = SelectByOrderOr(g, 0, order_cancel, true)
  set g = SelectByUnitStandard(g, true)
  set u = GetNearestOfGroup(g, unitloc)
  call RemoveLocation(unitloc)
  call DestroyGroup(g)
  set g = null
  set unitloc = null
  return u
endfunction

function RemoveUnitsOfType takes string ut returns nothing
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsOfType(g, ut, null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call RemoveUnit(u)
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
endfunction

function GetHeroNumber takes integer id returns integer
  local integer i = 1
  loop
    exitwhen i > 3
    if id == old_id[hero[i]] then
      return i
    endif
    set i = i + 1
  endloop
  return 1
endfunction

function GetHeroNumberOfUnit takes unit u returns integer
  local integer i = 1
  loop
    exitwhen i > 3
    if u == hero_unit[i] then
      return i
    endif
    set i = i + 1
  endloop
  return 1
endfunction


function GetUnitHero takes nothing returns unit
 local group g = CreateGroup()
 local unit u = null

 call GroupEnumUnitsOfPlayer(g,ai_player,null) 
 set g = SelectByAlive(g, true)
 set g = SelectByUnitStandard(g, true)
 loop
	set u = FirstOfGroup(g)
	exitwhen u == null 
	if IsUnitType(u, UNIT_TYPE_STRUCTURE) == false and IsUnitType(u, UNIT_TYPE_PEON) == false then
	    call DestroyGroup(g)
		set g = null
		return u
	endif
	call GroupRemoveUnit(g,u)
 endloop
 call DestroyGroup(g)
 set g = null
 return null
endfunction

function GetUnitHeroReplacement takes location l returns unit
 local group g = CreateGroup()
 local unit u = null

 call GroupEnumUnitsOfPlayer(g,ai_player,null) 
 set g = SelectByAlive(g, true)
 set g = SelectByUnitStandard(g, true)
 loop
	set u = FirstOfGroup(g)
	exitwhen u == null 
	if IsUnitType(u, UNIT_TYPE_STRUCTURE) == false and IsUnitType(u, UNIT_TYPE_PEON) == false and IsUnitInRangeLoc(u, l, battle_radius) then
	    call DestroyGroup(g)
		set g = null
		return u
	endif
	call GroupRemoveUnit(g,u)
 endloop
 call DestroyGroup(g)
 set g = null
 return null
endfunction

function GetMajorHero takes nothing returns unit
  local integer i = 1
	  loop
	    exitwhen i > 3
	    if hero_built[i] and UnitAlive(hero_unit[i]) and not IsUnitInGroup(hero_unit[i], unit_healing) then
	      return hero_unit[i]
	    endif
	    set i = i + 1
	  endloop
	return GetUnitHero()	  
  return null
endfunction

function GetMajorHeroReplacement_d takes location l returns unit
  local integer i = 1
  local unit u = null

	  loop
	    exitwhen i > 3
	    if hero_built[i] and UnitAlive(hero_unit[i]) and IsUnitInRangeLoc(hero_unit[i], l, battle_radius) and not IsUnitInGroup(hero_unit[i], unit_healing) then
	      return hero_unit[i]
	    endif
	    set i = i + 1
	  endloop
	  call RemoveLocation(l)
     set u = GetUnitHeroReplacement(l)
	 call RemoveLocation(l)
     return u	  
  return null
endfunction

function GetMajorHeroReplacement_k takes location l returns unit
  local integer i = 1

	  loop
	    exitwhen i > 3
	    if hero_built[i] and UnitAlive(hero_unit[i]) and IsUnitInRangeLoc(hero_unit[i], l, battle_radius) and not IsUnitInGroup(hero_unit[i], unit_healing) then
	      return hero_unit[i]
	    endif
	    set i = i + 1
	  endloop
	return GetUnitHeroReplacement(l)	  
  return null
endfunction

function GetNeutralNumber takes integer id returns integer
  if buy_type[id] == BT_NEUTRAL_HERO then
    return NEUTRAL_TAVERN
  elseif buy_type[id] == BT_GOBLIN_MERC then
    return NEUTRAL_OBSERVATORY
  elseif buy_type[id] == BT_MERC then
    return NEUTRAL_MERC_CAMP
  else
    return NEUTRAL_DRAGON_ROOST
  endif
endfunction

function GetDensities takes location l, player p, real r returns nothing
  local group g = CreateGroup()
  local unit u = null
  local real ur = 0
  local location ul = null
  
  set enemy_density = 0
  set ally_density = 0
  if ally_density_loc == null then
	set ally_density_loc = Location(0,0)
  else
  	call MoveLocation(ally_density_loc, 0,0)
  endif
  if enemy_density_loc == null then
	set enemy_density_loc = Location(0,0)
  else
  	call MoveLocation(enemy_density_loc, 0,0)
  endif
  call GroupEnumUnitsInRangeOfLoc(g, l, r, null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) then
      set ul = GetUnitLoc(u)
      set ur = 1 - (DistanceBetweenPoints(ul, l) / r)
      //if ur == 1 then
      if IsPlayerEnemy(p, GetOwningPlayer(u)) then
        set enemy_density = enemy_density + ur
        set enemy_density_loc = GetSumLoc_dd(enemy_density_loc, GetMultipleLoc(ul, ur))
      elseif IsPlayerAlly(p, GetOwningPlayer(u)) then
        set ally_density = ally_density + ur
        set ally_density_loc = GetSumLoc_dd(ally_density_loc, GetMultipleLoc(ul, ur))
      endif
      call RemoveLocation(ul)
    endif
    call GroupRemoveUnit(g, u)
  endloop
  if ally_density > 0 then
    set ally_density_loc = GetDivisionLoc_d(ally_density_loc, ally_density)
  endif
  if enemy_density > 0 then
    set enemy_density_loc = GetDivisionLoc_d(enemy_density_loc, enemy_density)
  endif
  
  call DestroyGroup(g)
  set g = null  
  set ul = null
  set u = null
endfunction

function ActionListInit takes integer an returns nothing
  local integer i = 0
  set action_numbers = an
  loop
    exitwhen i >= an
    set action_points[i] = 0.0
    set i = i + 1
  endloop
endfunction

function ActionRule takes boolean b, integer chn, real cha returns nothing
  if b then
    set action_points[chn] = action_points[chn] + cha
  endif
endfunction

function ActionRule2 takes boolean b, integer chn, real cha, integer chn2, real cha2 returns nothing
  if b then
    set action_points[chn] = action_points[chn] + cha
    set action_points[chn2] = action_points[chn2] + cha2
  endif
endfunction

function ActionRule3 takes boolean b, integer chn, real cha, integer chn2, real cha2, integer chn3, real cha3 returns nothing
  if b then
    set action_points[chn] = action_points[chn] + cha
    set action_points[chn2] = action_points[chn2] + cha2
    set action_points[chn3] = action_points[chn3] + cha3
  endif
endfunction

function ActionListEval takes nothing returns integer
  local integer i = 0
  local integer max_i = -1
  local real max_val = -10000000.0
  loop
    exitwhen i >= action_numbers
    if action_points[i] > max_val then
      set max_i = i
      set max_val = action_points[i]
    endif
    set i = i + 1
  endloop
  return max_i
endfunction

function GetPlayerStrengthHandicap takes player p returns real
    return SquareRoot(GetPlayerHandicap(p))
endfunction

function GetPlayerHeroBonusStrength takes player p returns integer
  local integer strength = 0
  return strength
endfunction
function GetHeroStrength takes unit u returns integer
  local integer lvl = GetHeroLevel(u)
  if not IsUnitInGroup(u, unit_healing) then
	if lvl >= ver_hero_ultimate_level then
		return R2I((ver_hero_base_value + lvl + ver_hero_ultimate_value)/2 + 0.5)
	else
		return R2I((ver_hero_base_value + lvl)/2 + 0.5)
	endif
  else
	return 0
  endif
endfunction

function GetPlayerHeroStrengthMod takes player p returns integer
  local group g = CreateGroup()
  local unit u = null
  local integer sum = 0
  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectUnittype(g, UNIT_TYPE_HERO, true)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set sum = sum + R2I(GetHeroStrength(u) * GetPlayerStrengthHandicap(GetOwningPlayer(u)) * (GetUnitState(u, UNIT_STATE_LIFE) / GetUnitState(u, UNIT_STATE_MAX_LIFE)))
    call GroupRemoveUnit(g,u)
  endloop
  set sum = sum + GetPlayerHeroBonusStrength(ai_player)
  call DestroyGroup(g)
  set g = null
  return sum 
endfunction

function GetUnitStrengthEx takes unit u returns integer
  local integer f = GetUnitLevel(u)
  if GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_AGGRESSIVE) then
    if IsUnitType(u, UNIT_TYPE_HERO) then
      return GetHeroStrength(u)
    else
      return R2I((GetUnitFoodUsed(u) + f) / 2 + 0.5)
    endif
  else
  if f >= ver_hero_ultimate_level then
    return R2I((GetUnitFoodUsed(u)+ f + ver_hero_ultimate_value) / 2 + 0.5)
  else
    return R2I((GetUnitFoodUsed(u) + f)/2 + 0.5)
  endif
  endif
    return 0
endfunction

function GetUnitStrength takes unit u returns real
  if GetUnitState(u, UNIT_STATE_MAX_LIFE) == 0 then
	call DisplayToAll("ERROR: Major error has occured and caused amai system to crash at function GetUnitStrength")
	call DisplayToAll("Please contact the creator and provide this replay to them")
  endif
  return RMax(GetUnitStrengthEx(u) * GetPlayerStrengthHandicap(GetOwningPlayer(u)) * (GetUnitState(u, UNIT_STATE_LIFE) / GetUnitState(u, UNIT_STATE_MAX_LIFE)), 1.00)
endfunction

function GetPlayerStrength takes player p returns real

  local group g = CreateGroup()
  local unit u = null
  local real sum = 0
  
  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectByAlive(g, true)
    loop
        set u = FirstOfGroup(g)
        exitwhen u == null
        if not IsUnitType(u, UNIT_TYPE_HERO) and not IsUnitType(u, UNIT_TYPE_PEON) and not IsUnitType(u, UNIT_TYPE_STRUCTURE) and not IsUnitHidden(u) then
		    //call Trace("A Unit strength added: " + Int2Str(R2I(GetUnitStrength(u))))
        	set sum = sum + GetUnitStrength(u)
	  endif
        call GroupRemoveUnit(g,u)
    endloop
    call DestroyGroup(g)
    set g = null
    //call Trace("A HERO strength added: " + Int2Str(GetPlayerHeroStrengthMod(p)))	
    return sum + I2R(GetPlayerHeroStrengthMod(p))


endfunction

function GetUnexactPlayerStrength takes player p returns integer
  local integer pid = GetPlayerId(p)
  if p_str_cache_timeout[pid] < ai_time then
    set p_str_cache[pid] = Max(0, R2I(GetPlayerStrength(p) * GetRandomReal(1 - I2R(uncertainty)/50, 1 + I2R(uncertainty)/50)) + GetRandomDiff(uncertainty/5))
    set p_str_cache_timeout[pid] = ai_time + p_str_cache_valid_time
  endif
  return p_str_cache[pid]
endfunction

function GetMaximumEnemyStrength takes nothing returns integer
  local integer i = 0
  local integer max = 0
  local player p = null
  loop
    exitwhen i >= 12
    set p = Player(i)
    if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING then
      set max = Max(max, R2I(GetPlayerStrength(p)))
    endif
    set i = i + 1
  endloop
  return max
endfunction

function GetPlayerairStrength takes player p returns real
  local real strength = 0
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oCOPTER )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oGRYPHON )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oHUMAN_DRAGON_HAWK )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oWYVERN )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oBATRIDER )
  set strength = strength + 7 * GetPlayerUnitTypeCount(p, oFROST_WYRM )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGARGOYLE )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGARGOYLE_MORPH )
  set strength = strength + 5 * GetPlayerUnitTypeCount(p, oBLK_SPHINX )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oDRUID_TALON_M )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oHIPPO )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oHIPPO_RIDER )
  set strength = strength + 5 * GetPlayerUnitTypeCount(p, oCHIMAERA )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oFAERIE_DRAGON )
  if ai_time >= 20 and ai_time <= 40 and GetPlayerUnitTypeCount(p, oSTRONGHOLD) >= 1 and GetPlayerUnitTypeCount(p, oBESTIARY) >= 1 then
    set strength = strength + 10
  endif
  if ai_time >= 20 and ai_time <= 50 and GetPlayerUnitTypeCount(p, oANCIENT_WIND) >= 1 and GetPlayerUnitTypeCount(p, oTREE_ETERNITY) >= 1 then
    set strength = strength + 10
  endif
  if ai_time >= 20 and ai_time <= 40 and GetPlayerUnitTypeCount(p, oAVIARY) >= 1 then
    set strength = strength + 10
  endif
  return strength
endfunction
function GetPlayercastersStrength takes player p returns real
  local real strength = 0
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oELEMENTAL )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oELEMENTAL2 )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oELEMENTAL3 )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oPRIEST )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oSORCERESS )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oWITCH_DOCTOR )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oSHAMAN )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oSPIRIT_WALKER )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oSPIRIT_WALKER_M )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oBANSHEE )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oNECRO )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oSKEL_WARRIOR )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oOBSIDIAN_STATUE )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oCARRION_BEETLE )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oCARRION_BEETLE2 )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oCARRION_BEETLE3 )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oSKEL_MAGE )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oDRUID_TALON )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oDRUID_TALON_M )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oDRUID_CLAW )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oDRUID_CLAW_M )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oLAVASPAWN )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oLAVASPAWN2 )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oLAVASPAWN3 )
  return strength
endfunction
function GetPlayertowersStrength takes player p returns real
  local real strength = 0
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oSTEAM_TANK )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oROCKET_TANK )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oCANNON_TOWER )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oGUARD_TOWER )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oARCANE_TOWER )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oORC_WATCH_TOWER )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oNECROPOLIS_2 )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oNECROPOLIS_3 )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oZIGGURAT_2 )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oZIGGURAT_FROST )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oANCIENT_PROTECT )
  return strength
endfunction
function GetPlayerpiercingStrength takes player p returns real
  local real strength = 0
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oCOPTER )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oRIFLEMAN )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oHUMAN_DRAGON_HAWK )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oHEAD_HUNTER )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oBERSERKER )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oKODO_BEAST )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oWYVERN )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oCRYPT_FIEND )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oBURROWED_FIEND )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGARGOYLE )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGARGOYLE_MORPH )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oARCHER )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oDRYAD )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oHIPPO_RIDER )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oFAERIE_DRAGON )
  if ai_time >= 0 and ai_time <= 20 and GetPlayerUnitTypeCount(p, oBLACKSMITH) >= 1 then
    set strength = strength + 5
  endif
  if ai_time >= 0 and ai_time <= 20 and GetPlayerUnitTypeCount(p, oGRAVEYARD) >= 1 then
    set strength = strength + 5
  endif
  if ai_time >= 0 and ai_time <= 20 and GetPlayerUnitTypeCount(p, oFORGE) >= 1 then
    set strength = strength + 5
  endif
  return strength
endfunction
function GetPlayernormalStrength takes player p returns real
  local real strength = 0
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oFOOTMAN )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oKNIGHT )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oMILITIA )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oSPELL_BREAKER )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oGRUNT )
  set strength = strength + 5 * GetPlayerUnitTypeCount(p, oTAUREN )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oABOMINATION )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGHOUL )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oDRUID_CLAW )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oDRUID_CLAW_M )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oHIPPO )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oHUNTRESS )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oENT )
  set strength = strength + 7 * GetPlayerUnitTypeCount(p, oMOUNTAIN_GIANT )
  if ai_time >= 0 and ai_time <= 30 and true then
    set strength = strength + 8
  endif
  return strength
endfunction
function GetPlayersiegeStrength takes player p returns real
  local real strength = 0
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oCOPTER )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oMORTAR )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oSTEAM_TANK )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oROCKET_TANK )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oCATAPULT )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oRAIDER )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oBATRIDER )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oMEAT_WAGON )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oBALLISTA )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oMOUNTAIN_GIANT )
  if ai_time >= 20 and ai_time <= 40 and GetPlayerUnitTypeCount(p, oSTRONGHOLD) >= 1 and GetPlayerUnitTypeCount(p, oBESTIARY) >= 1 then
    set strength = strength + 5
  endif
  return strength
endfunction
function GetPlayermagicStrength takes player p returns real
  local real strength = 0
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oGRYPHON )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oPRIEST )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oSORCERESS )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oWITCH_DOCTOR )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oSHAMAN )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oSPIRIT_WALKER )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oSPIRIT_WALKER_M )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oBANSHEE )
  set strength = strength + 7 * GetPlayerUnitTypeCount(p, oFROST_WYRM )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oNECRO )
  set strength = strength + 5 * GetPlayerUnitTypeCount(p, oBLK_SPHINX )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oDRUID_TALON )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oDRUID_TALON_M )
  set strength = strength + 5 * GetPlayerUnitTypeCount(p, oCHIMAERA )
  if ai_time >= 20 and ai_time <= 40 and GetPlayerUnitTypeCount(p, oSANCTUM) >= 1 then
    set strength = strength + 10
  endif
  if ai_time >= 20 and ai_time <= 40 and GetPlayerUnitTypeCount(p, oDAMNED_TEMPLE) >= 1 then
    set strength = strength + 10
  endif
  if ai_time >= 20 and ai_time <= 40 and GetPlayerUnitTypeCount(p, oLODGE) >= 1 then
    set strength = strength + 10
  endif
  if ai_time >= 20 and ai_time <= 40 and GetPlayerUnitTypeCount(p, oANCIENT_WIND) >= 1 then
    set strength = strength + 5
  endif
  return strength
endfunction
function GetPlayerunarmoredStrength takes player p returns real
  local real strength = 0
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oPRIEST )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oSORCERESS )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oWITCH_DOCTOR )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oKODO_BEAST )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oSHAMAN )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oSPIRIT_WALKER )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oSPIRIT_WALKER_M )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oBANSHEE )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGARGOYLE )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGARGOYLE_MORPH )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oNECRO )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oDRUID_TALON )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oDRUID_TALON_M )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oDRYAD )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oHIPPO )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oHUNTRESS )
  return strength
endfunction
function GetPlayerlightarmorStrength takes player p returns real
  local real strength = 0
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oGRYPHON )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oHUMAN_DRAGON_HAWK )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oWYVERN )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oBATRIDER )
  set strength = strength + 7 * GetPlayerUnitTypeCount(p, oFROST_WYRM )
  set strength = strength + 5 * GetPlayerUnitTypeCount(p, oBLK_SPHINX )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oHIPPO_RIDER )
  set strength = strength + 5 * GetPlayerUnitTypeCount(p, oCHIMAERA )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oFAERIE_DRAGON )
  return strength
endfunction
function GetPlayermediumarmorStrength takes player p returns real
  local real strength = 0
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oRIFLEMAN )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oSPELL_BREAKER )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oHEAD_HUNTER )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oBERSERKER )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oRAIDER )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oCRYPT_FIEND )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oBURROWED_FIEND )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oARCHER )
  set strength = strength + 7 * GetPlayerUnitTypeCount(p, oMOUNTAIN_GIANT )
  return strength
endfunction
function GetPlayerheavyarmorStrength takes player p returns real
  local real strength = 0
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oCOPTER )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oFOOTMAN )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oKNIGHT )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oMORTAR )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oMILITIA )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oCATAPULT )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oGRUNT )
  set strength = strength + 5 * GetPlayerUnitTypeCount(p, oTAUREN )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oABOMINATION )
  set strength = strength + 2 * GetPlayerUnitTypeCount(p, oGHOUL )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oMEAT_WAGON )
  set strength = strength + 3 * GetPlayerUnitTypeCount(p, oBALLISTA )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oDRUID_CLAW )
  set strength = strength + 4 * GetPlayerUnitTypeCount(p, oDRUID_CLAW_M )
  set strength = strength + 1 * GetPlayerUnitTypeCount(p, oENT )
  return strength
endfunction

function GetPlayerAntiAirStrength takes player p returns real
  local group g = CreateGroup()
  local unit u = null
  local real sum = 0
  
  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectByAlive(g, true)
    loop
        set u = FirstOfGroup(g)
        exitwhen u == null
        if IsUnitType(u, UNIT_TYPE_ATTACKS_FLYING) and not IsUnitType(u, UNIT_TYPE_STRUCTURE) and not IsUnitHidden(u) then
            set sum = sum + GetUnitStrength(u)
        endif
        call GroupRemoveUnit(g,u)
    endloop
    call DestroyGroup(g)
    set g = null
    return sum
    
endfunction

function IsCreepsAwake takes real x, real y, real radius returns boolean
  local group g = CreateGroup()
  local unit u = null
  local boolean awake_creeps = false

  call GroupEnumUnitsInRange(g,x,y,radius,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null or awake_creeps 
    if UnitAlive(u) and GetOwningPlayer(u) == Player(PLAYER_NEUTRAL_AGGRESSIVE) then
		set awake_creeps = not IsUnitType(u, UNIT_TYPE_SLEEPING)
    endif
    call GroupRemoveUnit(g,u)
   endloop

  call DestroyGroup(g)
  set g = null
  return awake_creeps
endfunction

function GetLocationCreepStrength takes real x, real y, real radius returns integer
  local group g = CreateGroup()
  local real sum = 0
  local unit u = null
  local real airsum = 0
  set no_sleep = false
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and GetOwningPlayer(u) == Player(PLAYER_NEUTRAL_AGGRESSIVE) and not IsUnitHidden(u) then
	  //call Trace("Getting unit strength begin")
      set sum = sum + GetUnitStrength(u)
      if IsUnitType(u, UNIT_TYPE_FLYING) then
        set airsum= airsum + GetUnitStrength(u)
      endif
      if not UnitCanSleep(u) then
        set no_sleep = true
      endif
	  //call Trace("Getting unit strength end")
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  set air_strength = R2I(airsum + 0.5)
  return R2I(sum + 0.5)
endfunction

function GetLocationCreepAirStrength takes real x, real y, real radius returns integer
  local group g = CreateGroup()
  local unit u = null
  local real airsum = 0
  set no_sleep = false
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and GetOwningPlayer(u) == Player(PLAYER_NEUTRAL_AGGRESSIVE) and not IsUnitHidden(u) then
      if IsUnitType(u, UNIT_TYPE_FLYING) then
        set airsum= airsum + GetUnitStrength(u)
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return R2I(airsum + 0.5)
endfunction

function GetLocationNonCreepStrength takes real x, real y, real radius returns integer
  local group g = CreateGroup()
  local real sum = 0
  local unit u = null
  local real airsum = 0
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_AGGRESSIVE) and GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_PASSIVE) and IsPlayerEnemy(ai_player, GetOwningPlayer(u)) and not IsUnitHidden(u) and IsUnitType(u,UNIT_TYPE_STRUCTURE) == false and IsUnitType(u,UNIT_TYPE_PEON) == false and not (UnitInvis(u) and not IsUnitDetected(u, ai_player)) then
      set sum = sum + GetUnitStrength(u)
      if IsUnitType(u, UNIT_TYPE_FLYING) then
        set airsum= airsum + GetUnitStrength(u)
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  set air_strength = R2I(airsum + 0.5)
  return R2I(sum + 0.5)
endfunction

function GetLocationEnemyStructures takes real x, real y, real radius returns integer
  local group g = CreateGroup()
  local integer sum = 0
  local unit u = null
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitType(u,UNIT_TYPE_STRUCTURE) == true and GetUnitState(u, UNIT_STATE_LIFE) > 0 and GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_AGGRESSIVE) and GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_PASSIVE) and IsPlayerEnemy(ai_player, GetOwningPlayer(u)) and not IsUnitHidden(u) then
      set sum = sum + 1
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return sum
endfunction

function IsUnitTower takes unit u returns boolean
  return IsUnitType(u, UNIT_TYPE_STRUCTURE) == true and IsUnitType(u, UNIT_TYPE_RANGED_ATTACKER) == true and not IsUnitHidden(u)
endfunction

function GetLocationTowerStrength takes real x, real y, real radius returns integer
  local group g = CreateGroup()
  local unit u = null
  local integer sum = 0
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and IsPlayerEnemy(ai_player, GetOwningPlayer(u)) and IsUnitTower(u) then
      set sum = sum + 1
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return sum
endfunction

function GetLocationStrength takes real x, real y, real radius returns real
  local group g = CreateGroup()
  local real sum = 0
  local unit u = null
  local real airsum = 0
  call GroupEnumUnitsInRange(g,x,y,radius,null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and not IsUnitHidden(u) and IsUnitType(u,UNIT_TYPE_PEON) == false and not (UnitInvis(u) and not IsUnitDetected(u, ai_player)) then
      set sum = sum + GetUnitStrength(u)
      if IsUnitType(u, UNIT_TYPE_FLYING) then
        set airsum= airsum + GetUnitStrength(u)
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  set air_strength = R2I(airsum + 0.5)
  return sum
endfunction

function GetCreepBonus takes unit u, real radius returns integer
  local integer i = GetLocationCreepStrength(GetUnitX(u), GetUnitY(u), radius)
	//call Trace("Got bonus")
 if i >= 20 then
  return i + red_creep_camp_strength_bonus
 elseif i >= 10 then
  return i + orange_creep_camp_strength_bonus
 else
  return i + green_creep_camp_strength_bonus
 endif
endfunction

function GetExpansionStrength takes nothing returns integer
	//call Trace("Getting expansion strength")
	return GetCreepBonus(current_expansion, expansion_radius)
endfunction

function GetCreepCampStrength takes unit u returns integer
	return GetCreepBonus(u, creep_camp_radius)
endfunction

function GetOwnStrength takes nothing returns integer
  local real sum = 0
  local group g = CreateGroup()
  local unit u = null
  local integer max_ghouls = attacking_ghouls
  local integer ghoul_num = 0
  local real airsum = 0
  
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and not IsUnitType(u, UNIT_TYPE_PEON) and not IsUnitType(u, UNIT_TYPE_HERO) and not IsUnitType(u, UNIT_TYPE_STRUCTURE) and not IsUnitInGroup(u, unit_healing) and not IsUnitHidden(u) then
      if GetUnitTypeId(u) == old_id[racial_ghoul] then
        if ghoul_num < max_ghouls then
          set sum = sum + GetUnitStrength(u)
          set ghoul_num = ghoul_num + 1
        endif
      else
        set sum = sum + GetUnitStrength(u)
      endif
      if IsUnitType(u, UNIT_TYPE_ATTACKS_FLYING) then
        set airsum = airsum + GetUnitStrength(u)
      endif
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  set air_strength = R2I(airsum + 0.5)
  return R2I(sum) + GetPlayerHeroStrengthMod(ai_player)
endfunction

function GetTQLock takes nothing returns nothing
  loop
    exitwhen tq_lock
    call Sleep(0.5)
  endloop
  set tq_lock = false
endfunction

function ReleaseTQLock takes nothing returns nothing
  set tq_lock = true
endfunction

function TQDisplay takes nothing returns nothing
  local integer i = 1
  call DisplayToAll("Displaying heap")
  loop
    exitwhen i > tq_length
    call DisplayToAll(Int2Str(R2I(tq_time[i])) + " " + Int2Str(tq_jid[i]))
    set i = i + 1
  endloop
endfunction

function TQCopy takes integer spos, integer tpos returns nothing
  set tq_time[tpos] = tq_time[spos]
  set tq_jid[tpos] = tq_jid[spos]
  set tq_par[tpos] = tq_par[spos]
  set tq_unit_par[tpos] = tq_unit_par[spos]
  set tq_group_par[tpos] = tq_group_par[spos]
endfunction

function TQExchange takes integer pos1, integer pos2 returns nothing
  call TQCopy(pos2, tq_length+1)
  call TQCopy(pos1, pos2)
  call TQCopy(tq_length+1, pos1)
endfunction

function TQUpHeap takes integer pos returns nothing
  if tq_time[pos] < tq_time[pos/2] then
    call TQExchange(pos, pos/2)
    call TQUpHeap(pos/2)
  endif
endfunction

function TQFillPos takes integer pos returns integer
  local integer lpos = 2*pos
  local integer rpos = 2*pos + 1
  if lpos > tq_length then
    return pos
  elseif rpos > tq_length then
    call TQCopy(lpos, pos)
    return lpos
  elseif tq_time[lpos] <= tq_time[rpos] then
    call TQCopy(lpos, pos)
    return TQFillPos(lpos)
  else
    call TQCopy(rpos, pos)
    return TQFillPos(rpos)
  endif
endfunction

function TQRemoveRoot takes nothing returns nothing
  local integer pos = 0
  call GetTQLock()
  set pos = TQFillPos(1)
  set tq_length = tq_length - 1
  if pos <= tq_length then
    call TQCopy(tq_length + 1, pos)
    call TQUpHeap(pos)
  endif
  call ReleaseTQLock()
endfunction

function TQAddJobEx takes real time, integer jid, integer par, unit unit_par, group group_par returns nothing
  call GetTQLock()
  set tq_length = tq_length + 1
  set tq_time[tq_length] = time
  set tq_jid[tq_length] = jid
  set tq_par[tq_length] = par
  set tq_unit_par[tq_length] = unit_par
  set tq_group_par[tq_length] = group_par
  call TQUpHeap(tq_length)
  call ReleaseTQLock()
endfunction

function TQAddJob takes real time, integer jid, integer par returns nothing
  call TQAddJobEx(TimerGetElapsed(tq_timer) + time, jid, par, null, null)
endfunction

function TQAddUnitJob takes real time, integer jid, integer par, unit unit_par returns nothing
  call TQAddJobEx(TimerGetElapsed(tq_timer) + time, jid, par, unit_par, null)
endfunction

function TQAddGroupJob takes real time, integer jid, integer par, unit unit_par, group group_par returns nothing
  call TQAddJobEx(TimerGetElapsed(tq_timer) + time, jid, par, unit_par, group_par)
endfunction





function GetLocationInDistanceFromLoc takes location loc, real dist returns location
    local integer groundid = 'ewsp'
    local real distance = 0
    local unit u = null
    local location l = null
    local real checktime = 0

    set u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), groundid, GetLocationX(loc),GetLocationY(loc), 270.00)
    call ShowUnit(u, false)
    call SetUnitUseFood(u, false)
    call SetUnitMoveSpeed(u, 522)
    call RemoveGuardPosition(u)
    call IssuePointOrder(u, "move", GetLocationX(home_location), GetLocationY(home_location))
    set checktime =  GetTimeToReachLoc(u, home_location)
    call UnitApplyTimedLife(u, 'BTLF', checktime)
    call Sleep(0.3)

    loop
	   set l = GetUnitLoc(u)
	   set distance = DistanceBetweenPoints(l, loc)
	   if distance >= dist then
 //          call DisplayToAll("loc found")
	        return l
	   elseif GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
            call RemoveLocation(l)
            set l = null
	      return null
	   else
            call RemoveLocation(l)
            set l = null		
	   endif
	   call Sleep(0.3)
    endloop
    return null
endfunction


function GetLocationInDistanceFromBaseToLoc takes location loc, real d returns location
    local integer groundid = 'ewsp'
    local real distance = 0
    local unit u = null
    local location l = null
    local real checktime = 0

 // call DisplayToAll("Checking")
 //   call PingMinimap(GetLocationX(start_loc), GetLocationY(start_loc), 20)
    set u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), groundid, GetLocationX(home_location), GetLocationY(home_location), 270.00)
    call ShowUnit(u, false)
    call SetUnitUseFood(u, false)
    call SetUnitMoveSpeed(u, 500)
    call RemoveGuardPosition(u)
    call IssuePointOrderLoc(u, "move", loc)
    set checktime =  GetTimeToReachLoc(u, loc)
    call UnitApplyTimedLife(u, 'BTLF', checktime / 2)
    call Sleep(0.3)
    
    loop
	   set l = GetUnitLoc(u)
	   set distance = DistanceBetweenPoints(l, home_location)
	   if distance >= d then
 //     	call DisplayToAll("loc found")
	        return l
	   elseif GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
            call RemoveLocation(l)
            set l = null
	      return null
	   endif
	   call Sleep(0.3)
    endloop
    return null
    

endfunction

function GetBuildLocationInDistanceFromLoc_d takes integer id, location loc, real distance returns location
	local location build_loc = GetLocationInDistanceFromLoc(loc, distance)
 	local unit u = null

	if build_loc != null then
		set u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), id, GetLocationX(build_loc), GetLocationY(build_loc), 270.0)
		call RemoveLocation(build_loc)
		set build_loc = GetUnitLoc(u)
		call RemoveUnit(u)
		set u = null
		call RemoveLocation(loc)
		set loc = null
		return build_loc
	else
		call RemoveLocation(loc)
		set loc = null
		return null
	endif
	
endfunction

function GetLumberLocationAtBase takes nothing returns location
    local integer groundid = 0	//human peasant
    local real distance = 0
    local unit u = null
    local location l = null

	if race_has_ghouls then
		set groundid = old_id[racial_ghoul]
	else
		set groundid = old_id[racial_peon]
	endif
    set u = CreateUnitAtLoc(Player(PLAYER_NEUTRAL_PASSIVE), groundid, home_location, 270.00)
    call ShowUnit(u, false)
    call SetUnitUseFood(u, false)
    call SetUnitMoveSpeed(u, 500)
    call RemoveGuardPosition(u)
	call IssueImmediateOrder(u, "autoharvestlumber")
	call Sleep(5.00)
	set l = GetUnitLoc(u)
	call RemoveUnit(u)
	set u = null
	return l
endfunction

function BuildLumberMillAtBase takes nothing returns boolean
	local location build_loc = GetLumberLocationAtBase()
	local unit u = null
	local unit peon = GetExpansionPeon()
	if build_loc != null then
		set u = CreateUnitAtLoc(Player(PLAYER_NEUTRAL_PASSIVE), old_id[racial_lumber], build_loc, 270.0)
		call RemoveLocation(build_loc)
		set build_loc = GetUnitLoc(u)
		call RemoveUnit(u)
		set u = null
		return IssuePointOrderByIdLoc(peon, old_id[racial_lumber], build_loc)
	endif
	return false
endfunction

function GetExpFoeGroup takes unit mine returns group
  local group g = CreateGroup()
  
  call GroupEnumUnitsInRange(g, GetUnitX(mine), GetUnitY(mine), expansion_radius, null)
  set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_AGGRESSIVE), true)
  set g = SelectByAlive(g, true)
  return g
endfunction

function GetCreepGuardGroup takes integer nn returns group
  local group g = CreateGroup()

  if nearest_neutral[nn] == null then
    return null
  endif
  
  call GroupEnumUnitsInRange(g, GetUnitX(nearest_neutral[nn]), GetUnitY(nearest_neutral[nn]), 750, null)
  set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_AGGRESSIVE), true)
  set g = SelectByAlive(g, true)
  return g
endfunction

function AddExpansion takes unit u, real d returns nothing
	local location exp_loc = null

  set expansion_list[expansion_list_length] = u
  set expansion_dist[expansion_list_length] = d
  if race_ancient_expansion_available then
    set exp_loc = GetUnitLoc(u)
	set expansion_ancient[expansion_list_length] = GetBuildLocationInDistanceFromLoc_d(old_id[racial_expansion], exp_loc, ver_creeps_attack_buildings_dist + 500)
  else
	set expansion_ancient[expansion_list_length] = null
  endif
  set expansion_creeps[expansion_list_length] = GetExpFoeGroup(u)  // group of the the creeps that guard this mine
  set expansion_list_length = expansion_list_length + 1
endfunction

function AddWaterExpansion takes unit u returns nothing
  set water_expansion_list[water_expansion_list_length] = u
  set water_expansion_list_length = water_expansion_list_length + 1
endfunction

function CheckExpansionTaken takes unit expa returns boolean
  local group g = CreateGroup()
  local unit u = null
  if expa == not_taken_expansion then
    return false
  endif
  call GroupEnumUnitsInRange(g, GetUnitX(expa), GetUnitY(expa), expansion_taken_radius, null)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_PASSIVE), false)
  set g = SelectByAlive(g, true)
  call GroupRemoveUnit(g, expa)
  if FirstOfGroup(g) == null then
    call DestroyGroup(g)
    set g = null
    return false
  else
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null 
      if GetUnitTypeId(u) == old_id[racial_expansion] or IsUnitType(u,UNIT_TYPE_TOWNHALL) then
        call DestroyGroup(g)
        set g = null
        return true
	elseif GetOwningPlayer(u) != ai_player and GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_AGGRESSIVE) then		// Creeps dosn't mean expansion is taken
        call DestroyGroup(g)
        set g = null
        return true
      endif
      call GroupRemoveUnit(g, u)
    endloop
    call DestroyGroup(g)
    set g = null
    return false
  endif
endfunction

function GetExpNearestMin takes nothing returns unit
    // Return the nearest mine, uses old system so computer has a mine as new system can take a while to calculate
	
	local real distance = 0
	local real seconddistance = 0
	local unit u = null
	local real mindistance = 10000  // max distance away the first mine can be
	local real secMaxDistance = 6000  // max distance range second mine must be in
	local unit nearmine = null
	local unit secondmine = null
	local location l = null
    local group g = CreateGroup()
	local integer rand = GetRandomInt(1,4)


 call GroupEnumUnitsOfType(g, "goldmine", null)
loop
	set u = FirstOfGroup(g)
	exitwhen u == null
	set l = GetUnitLoc(u)
	set distance = DistanceBetweenPoints(l, home_location)
	if distance < mindistance and not CheckExpansionTaken(u) and GetLocationCreepStrength(GetUnitX(u), GetUnitY(u), expansion_radius) < 40 then
		if mindistance < secMaxDistance then
			set secondmine = nearmine	
			set seconddistance = mindistance
		endif
		set mindistance = distance
		set nearmine = u		
	elseif distance < seconddistance and distance <= secMaxDistance and not CheckExpansionTaken(u) and GetLocationCreepStrength(GetUnitX(u), GetUnitY(u), expansion_radius) < 40 then
		set seconddistance = distance
		set secondmine = u
	endif
	call GroupRemoveUnit(g, u)
	call RemoveLocation(l)
	set l = null
endloop

call DestroyGroup(g)
set g = null

if secondmine != null then
	if rand <= 3 then
		set secondmine = null	
		return nearmine
	else
		set nearmine = null
		return secondmine
	endif
else
	set secondmine = null
	return nearmine
endif

endfunction

function MakeExpansionList takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  //local location l = null
  local unit array pather
  local integer array traveltime
  local boolean array patherdone
  local integer i = 0
  local integer totalpathers = 0
  local group tempg = null
  local integer checks = 0	// Number of times unit has stayed at same position  
  local boolean pathingdone = true
  local real totaltime = 0
  local integer groundid = 'ewsp'
  local real distance = 0  
  
  call GroupEnumUnitsOfType(g, "goldmine", null)
  
  set tempg = CopyGroup(g)
  loop
    set u = FirstOfGroup(tempg)
	exitwhen u == null
	set pather[i] = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), groundid, GetLocationX(home_location), GetLocationY(home_location), 270.00)	
	call SetUnitInvulnerable(pather[i], true)
    call ShowUnit(pather[i], false)
    call SetUnitUseFood(pather[i], false)
    call SetUnitMoveSpeed(pather[i], 520)
    call RemoveGuardPosition(pather[i])
    call IssuePointOrder(pather[i], "move", GetUnitX(u), GetUnitY(u))	
	call GroupRemoveUnit(tempg, u)
	set i = i + 1
	set totalpathers = i
  endloop
  call DestroyGroup(tempg)
  set tempg = null

  loop
	set totaltime = totaltime + 3	  
	set pathingdone = true
	set tempg = CopyGroup(g)
	set i = 0
	loop
	    set u = FirstOfGroup(tempg)
		exitwhen u == null
		//set l = Location(GetUnitX(pather[i]), GetUnitY([pather[i]))
		if pather[i] != null then		
			set distance = DistanceBetweenUnits(pather[i],u)	
			if distance <= buy_distance then
			//	call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Tavern is pathable")
				call CreateDebugTag("Target Destination is pathable", 10, pather[i], 3.00, 1.50)
				call RemoveUnit(pather[i])
				set pather[i] = null
				set patherdone[i] = true
	            call AddExpansion(u, totaltime)
			//elseif GetUnitCurrentOrder(u) == OrderId("stop") then
	            //return (totaltime * -1)
			elseif GetUnitState(pather[i], UNIT_STATE_LIFE) <= 0 then
				call RemoveUnit(pather[i])
				set pather[i] = null	
				set patherdone[i] = true				
			elseif GetUnitCurrentOrder(pather[i]) == OrderId("stop") or GetUnitCurrentOrder(pather[i]) != OrderId("move") then
				set checks = checks + 1
				call CreateDebugTag("Invisible Path unit has stopped", 10, pather[i], 3.00, 1.50)
				if checks > 1 then
					call CreateDebugTag("Target Destination was not reached", 10, pather[i], 3.00, 1.50)
					call RemoveUnit(pather[i])
					set pather[i] = null		
				    set patherdone[i] = true					
					//      call AddWaterExpansion(u)
				endif
			else
				set checks = 0	// means unit is moving and not standing still
				call CreateDebugTag("Invisible Path Unit Here", 10, pather[i], 3.00, 1.50)	
			endif	
			set pathingdone = false
		endif
		call GroupRemoveUnit(tempg, u)
		set i = i + 1
		//call RemoveLocation(l)
		//set l = null
	endloop
	call DestroyGroup(tempg)
    set tempg = null
	exitwhen pathingdone
	call Sleep(3)
  endloop
  
  call DestroyGroup(g)
  set g = null
  
  call Trace("Expansion number: " + Int2Str(expansion_list_length))  
  

endfunction

function make_exp_rp_positive takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= exp_number
    if exp_rp[i] < 0 then
      set exp_rp[i] = 0
    endif
    set i = i + 1
  endloop
endfunction

function sum_exp_rp takes nothing returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i >= exp_number
    set sum = sum + exp_rp[i]
    set i = i + 1
  endloop
  return sum
endfunction

function ChooseExp takes nothing returns integer

  local integer i = 1
  local integer sum = 0
  local integer exp_roll = GetRandomInt(1,100)
  local integer first = 0
  local integer second = 0
  local integer third = 0
  local integer riskyexp = GetRandomInt(1, exp_number - 1)
  loop
    exitwhen i >= exp_number
    if exp_rp[i] < exp_rp[first] then
	set third = second
      set second = first
      set first = i
    else
	if exp_rp[i] < exp_rp[second] then
		set third = second
		set second = i
	else
		if exp_rp[i] < exp_rp[third] then
			set third = i
		endif
	endif
    endif
    set i = i + 1
  endloop
	if (exp_roll <= 80) then 
		return first  // The closest expansion choice
	elseif (exp_roll <= 100) then 
		return second // The second closest expansion choice
	else
		return riskyexp  // Complete Random choice (effectively disabled at the moment)
	endif
  return 0
endfunction

function remove_exp takes integer h returns nothing
  local integer i = h
  set exp_number = exp_number - 1
  loop
    exitwhen i  >= exp_number
    set exp_rp[i] = exp_rp[i + 1]
    set exp_unit[i] = exp_unit[i + 1]
    set exp_dist[i] = exp_dist[i + 1]
    set i = i + 1
  endloop
endfunction

function add_exp takes unit u, real dist, location ancient, group creeps returns nothing
  set exp_unit[exp_number] = u
  set exp_dist[exp_number] = dist
  set exp_ancient[exp_number] = ancient
  set exp_creeps[exp_number] = creeps
  set exp_number = exp_number + 1
endfunction

function GetNearestEnemyDistance takes nothing returns real
local integer i = 0
local real dist = 0
local real mindistance = 1000000
local player nearplayer = null

loop
    exitwhen i >= 12
    if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING and IsPlayerEnemy(Player(i), ai_player) then
		set dist = DistanceBetweenPoints_kd(home_location, GetPlayerStartLocationLoc(Player(i)))
		if dist < mindistance then
			set mindistance = dist
			set nearplayer = Player(i)
		endif
    endif
    set i = i + 1
endloop

set rushedplayer = nearplayer
return mindistance
endfunction

function MinRangeToEnemy takes location l returns real
  local integer i = 0
  local real d = 0
  local real min_d = 1000000
  
  loop
    exitwhen i >= 12
    if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING and IsPlayerEnemy(Player(i), ai_player) then
      set d = DistanceBetweenPoints_kd(l, GetPlayerStartLocationLoc(Player(i)))
      if d < min_d then
        set min_d = d
      endif
    endif
    set i = i + 1
  endloop
  return min_d
endfunction


function GetRushFactor takes nothing returns integer
  return R2I(MinRangeToEnemy(home_location)) + (1000*(GetPlayers() - (c_enemy_total + c_ally_total + 1)))
endfunction

function CheckExpansionRebuild takes nothing returns boolean
  local group g = CreateGroup()
  local unit u = null

  call GroupEnumUnitsInRange(g, GetUnitX(current_expansion), GetUnitY(current_expansion), expansion_taken_radius, null)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_PASSIVE), false)
  set g = SelectByPlayer(g, ai_player, true)
  set g = SelectByAlive(g, true)
  
  if FirstOfGroup(g) != null then
	  loop
		set u = FirstOfGroup(g)
		exitwhen u == null
		if GetUnitTypeId(u) == old_id[racial_expansion] or IsUnitType(u,UNIT_TYPE_TOWNHALL) == true then
	  		call DestroyGroup(g)
	 		set g = null
			return false
		endif
	      call GroupRemoveUnit(g, u)
	  endloop
	  call DestroyGroup(g)
	  set g = null
	  if GetResourceAmount(current_expansion) > 2 * GetUnitGoldCost2(racial_expansion) and GetLocationNonCreepStrength(GetUnitX(current_expansion),GetUnitY(current_expansion),expansion_taken_radius) <= 0 then
			return true
	  endif
  endif
  
  return false

endfunction

function ExpansionFormula takes integer exp_d, unit exp_u returns integer
  local group g = CreateGroup()
  local unit u = null


  call GroupEnumUnitsInRange(g, GetUnitX(exp_u), GetUnitY(exp_u), expansion_taken_radius, null)
  //set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_PASSIVE), false)
  set g = SelectByAlive(g, true)

  loop
	set u = FirstOfGroup(g)
	exitwhen u == null
	if GetOwningPlayer(u) == ai_player and (IsUnitType(u, UNIT_TYPE_STRUCTURE) == true or IsUnitType(u, UNIT_TYPE_PEON)) then
  		call DestroyGroup(g)
 		set g = null
		return R2I(exp_d*0.5)      // Increased likelyhood to build if was once owned by player
	endif
      call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null


 //return exp_d + R2I(I2R(GetLocationCreepStrength(GetUnitX(exp_u), GetUnitY(exp_u), expansion_radius)) / 2)
   return exp_d
 
endfunction

function add_exp_rp takes nothing returns nothing
  local integer i = 0
  local real way_dist = 0.0
  local integer max = 0
  local integer min = 1000000
  local real sv = 0.7
  local integer red = 0
  loop
    exitwhen i >= exp_number
    set exp_rp[i] = ExpansionFormula(R2I(exp_dist[i]), exp_unit[i])
    if exp_rp[i] > max then
      set max = exp_rp[i]
    endif
    if exp_rp[i] < min then
      set min = exp_rp[i]
    endif
    set i = i + 1
  endloop
endfunction

function IsRacialHall takes unit u, integer min_tier returns boolean
  local integer i = Max(min_tier, 1)
  loop
    exitwhen i > tiernum
    if GetUnitTypeId(u) == old_id[racial_hall[i]] then
      return true
    endif
    set i = i + 1
  endloop
  return false
endfunction

function IsRacialHallId takes integer id, integer min_tier returns boolean
  local integer i = Max(min_tier, 1)
  loop
    exitwhen i > tiernum
    if id == racial_hall[i] then
      return true
    endif
    set i = i + 1
  endloop
  return false
endfunction

function ChooseExpansion takes nothing returns nothing
  local integer i = 0
  local integer exp_chosen = 0
  
  set exp_number = 0
  set first_expansion_chosen = true
  loop
    exitwhen i >= expansion_list_length
    if GetResourceAmount(expansion_list[i]) > 2 * GetUnitGoldCost2(racial_expansion) and not CheckExpansionTaken(expansion_list[i]) then
      call add_exp(expansion_list[i], expansion_dist[i], expansion_ancient[i], expansion_creeps[i])
    endif
    set i = i + 1
  endloop
  if TownCountDone(neutral_zeppelin) > 0 then
    set i = 0
    loop
      exitwhen i >= water_expansion_list_length
      if not CheckExpansionTaken(water_expansion_list[i]) then
        call add_exp(water_expansion_list[i], 60, expansion_ancient[i], expansion_creeps[i])
      endif
      set i = i + 1
    endloop
  endif
  call add_exp_rp()
  if exp_number == 0 then
    set current_expansion = null
    call Trace("No valid expansions")
  else
    set exp_chosen = ChooseExp()
    set current_expansion = exp_unit[exp_chosen]
	set ancient_exp_loc = exp_ancient[exp_chosen]
	set current_expansion_creeps = exp_creeps[exp_chosen]
  endif
endfunction

function GetExpFoe takes nothing returns unit
  local group g = null
  local group t = null
  local unit u = null
  local location l = GetUnitLoc(current_expansion)
  //call Trace("Copy group")
  
  set g = CopyGroup(current_expansion_creeps)
  set g = SelectByAlive(g, true)
  set u = GetNearestOfGroup(g, l)
  if l != null then
	call RemoveLocation(l)
	set l = null
  endif
  if u == null then
	set t = CreateGroup()
    call GroupEnumUnitsInRange(t, GetUnitX(current_expansion), GetUnitY(current_expansion), expansion_radius, null)
    set t = SelectByPlayer(t, Player(PLAYER_NEUTRAL_AGGRESSIVE), true)
    set t = SelectByAlive(t, true) 	
	set u = FirstOfGroup(t)
	call DestroyGroup(t)
    set t = null
  endif
  call DestroyGroup(g)
  set g = null
  //call Trace("Have a foe")
  return u

endfunction

function GetNeutralGuard takes integer nn returns unit
  local group g = null
  local group t = null
  local unit u = null
  local location l = null
  
  if nearest_neutral[nn] == null then
    return null
  endif
  set g = CopyGroup(neutral_guards[nn])
  set g = SelectByAlive(g, true)
  set l = GetUnitLoc(nearest_neutral[nn])
  set u = GetNearestOfGroup(g, l)  
  call RemoveLocation(l)
  set l = null
  if u == null then
	set t = CreateGroup()
    call GroupEnumUnitsInRange(t, GetUnitX(nearest_neutral[nn]), GetUnitY(nearest_neutral[nn]), expansion_radius, null)
    set t = SelectByPlayer(t, Player(PLAYER_NEUTRAL_AGGRESSIVE), true)
    set t = SelectByAlive(t, true) 	
	set u = FirstOfGroup(t)
	call DestroyGroup(t)
    set t = null
  endif  
  call DestroyGroup(g)
  set g = null
  return u
endfunction

function CanCreepGuardsSleep takes integer nn returns boolean
  local group g = null
  local group t = null
  local unit u = null
  
  if nearest_neutral[nn] == null then
    return false
  endif
  set g = CopyGroup(neutral_guards[nn])
  loop
	set u = FirstOfGroup(g)
	exitwhen u == null
	exitwhen not UnitCanSleep(u)
	call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  if u == null then
  	set t = CreateGroup()
    call GroupEnumUnitsInRange(t, GetUnitX(nearest_neutral[nn]), GetUnitY(nearest_neutral[nn]), 750, null)
    set t = SelectByPlayer(t, Player(PLAYER_NEUTRAL_AGGRESSIVE), true)
    set t = SelectByAlive(t, true) 	
    loop
		set u = FirstOfGroup(t)
		exitwhen u == null
	    exitwhen not UnitCanSleep(u)
        call GroupRemoveUnit(t, u)
	endloop
	call DestroyGroup(t)
    set t = null
  endif  
  if u == null then 
    return true
  endif  
  return false
endfunction

function SetAIArray takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= 12
    if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(Player(i)) == MAP_CONTROL_COMPUTER and GetStoredBoolean(com, "IsAMAI", Int2Str(i)) then
      set ai_force[ai_force_length] = i
      set ai_force_length = ai_force_length + 1
    endif
    set i = i + 1
  endloop
endfunction

function CheckFastExpansion takes nothing returns nothing
  local integer es = 0
  local location expanloc = null
  local real timeaway = 0
  //local location l = null
  local unit firstexp = null


  set firstexp = null
  
  if current_expansion != null then
	set es = GetExpansionStrength()
  //MinRangeToEnemy(l) > 7000
	if GetRandomInt(1,2) == 1 and GetPlayers() > 2 and MinRangeToEnemy(home_location) > 7000 and es <= 0 then
		set exp_time_count = -exp_first_time
	endif
  //call RemoveLocation(l)
  //set l = null
  endif
endfunction

function AddFrontPoint takes location l returns nothing
  set front_loc[front_loc_num] = l
  set front_loc_num = front_loc_num + 1
endfunction

function ComputeFrontPointPlayer takes player p returns nothing
  local location loc = GetPlayerStartLocationLoc(p)
  local location front = GetLocationInDistanceFromBaseToLoc(loc, front_base_distance)
  call AddFrontPoint(front)
  set front = null
  call RemoveLocation(loc)
  set loc = null
endfunction

function ComputeFrontPoints takes nothing returns nothing
  local integer i = 0
  local integer n = 0
  local player p = null
  local unit array u
  local integer totalplayers = 0
  local location loc = null
  local integer groundid = 'ewsp'  
  local player mainplayer = Player(GetAiPlayer()) 
  local boolean pathingdone = true
  local boolean array patherdone
  local location l = null
  local real distance = 0
  
  loop
    exitwhen i >= 12
    set p = Player(i)
    if IsPlayerEnemy(mainplayer, p) and GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING then
		set loc = GetPlayerStartLocationLoc(p)
		set u[n] = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), groundid, GetLocationX(home_location), GetLocationY(home_location), 270.00)
		call ShowUnit(u[n], false)
		call SetUnitUseFood(u[n], false)
		call SetUnitMoveSpeed(u[n], 500)
		call RemoveGuardPosition(u[n])
		call IssuePointOrder(u[n], "move", GetLocationX(loc), GetLocationY(loc))
		call RemoveLocation(loc)
		set n = n + 1
		set totalplayers = n
    endif
	set i = i + 1
	set loc = null

  endloop

	loop
		set pathingdone = true
		set i = 0
		loop
			exitwhen i >= totalplayers
			if patherdone[i] == false then
				set l = GetUnitLoc(u[i])
				set distance = DistanceBetweenPoints(l, home_location)
				if distance >= front_base_distance then
					call CreateDebugTag("Front Point Found", 10, u[i], 3.00, 1.50)
					call RemoveUnit(u[i])
					set u[i] = null
					set patherdone[i] = true
			        call AddFrontPoint(l)
				elseif GetUnitState(u[i], UNIT_STATE_LIFE) <= 0 then
					set patherdone[i] = true
					call RemoveUnit(u[i])
					set u[i] = null
		            call RemoveLocation(l)
				else
					call RemoveLocation(l)
				endif
				set pathingdone = false
			endif
			set i = i + 1
		endloop
		exitwhen pathingdone
		call Sleep(0.3)
	endloop
	
  set front_locs_computed = true
  set l = null
  set p = null
  set mainplayer = null
	

endfunction

function PingFrontPoints takes nothing returns nothing
  local integer i = 0
  local location l = null
  loop
    exitwhen i >= front_loc_num
    set l = front_loc[i]
    call PingMinimap(GetLocationX(l), GetLocationY(l), 20)
    set i = i + 1
  endloop
endfunction

function GetPlayerGold takes player p returns integer
    return GetPlayerState(p,PLAYER_STATE_RESOURCE_GOLD)
endfunction

function GetPlayerWood takes player p returns integer
    return GetPlayerState(p,PLAYER_STATE_RESOURCE_LUMBER)
endfunction

function set_aggression takes nothing returns nothing
  local integer f = FoodUsed()
  if false then
  elseif f >= 99 then
    set added_aggression = 25
  elseif f >= 88 then
    set added_aggression = 20
  elseif f >= 80 then
    set added_aggression = 12
  elseif f >= 70 then
    set added_aggression = 10
  elseif f >= 60 then
    set added_aggression = 8
  elseif f >= 50 then
    set added_aggression = 7
  elseif f >= 40 then
    set added_aggression = 6
  elseif f >= 30 then
    set added_aggression = 5
  elseif f >= 20 then
    set added_aggression = 2
  else
    set added_aggression = 0
  endif

  if GetUnitCountDone(old_id[hero[1]]) == 0 then
    set added_aggression = added_aggression - 10
  endif
endfunction

function GetExpansionDistance takes nothing returns real
  return DistanceBetweenPoints_kd(home_location,GetUnitLoc(current_expansion))
endfunction

function GetItemNumberOnUnit takes integer id, unit u returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i > 5
    if GetItemTypeId(UnitItemInSlot(u, i)) == old_id[id] then
      set sum = sum + 1
    endif
    set i = i + 1
  endloop
  return sum
endfunction

function GetItemNumber takes integer id returns integer
  local integer sum = 0
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] then
      set sum = sum + GetItemNumberOnUnit(id, hero_unit[i])
    endif
    set i = i + 1
  endloop
  return sum
endfunction

function GetItemOfTypeOnUnit takes integer id, unit u returns item
  local integer i = 0
  loop
    exitwhen i > 5
    if GetItemTypeId(UnitItemInSlot(u, i)) == old_id[id] then
      set item_unit = u
      return UnitItemInSlot(u, i)
    endif
    set i = i + 1
  endloop
  return null
endfunction

function GetItemOfType takes integer id returns item
  local item it = null
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] then
      set it = GetItemOfTypeOnUnit(id, hero_unit[i])
      if it != null then
        return it
      endif
    endif
    set i = i + 1
  endloop
  return null
endfunction

function GetSlotsFreeOnUnit takes unit u returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i > 5
    if UnitItemInSlot(u, i) == null then
      set sum = sum + 1
    endif
    set i = i + 1
  endloop
  return sum
endfunction

function GetSlotsFree takes nothing returns integer
  local integer sum = 0
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] then
      set sum = sum + GetSlotsFreeOnUnit(hero_unit[i])
    endif
    set i = i + 1
  endloop
  return sum
endfunction

function GetHeroToBuyItem takes unit shop, real limit, boolean is_healing_included returns unit
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] and UnitAlive(hero_unit[i]) then
      if GetSlotsFreeOnUnit(hero_unit[i]) > 0 and DistanceBetweenUnits(hero_unit[i], shop) < limit and not IsUnitInGroup(hero_unit[i], unit_buying_tavern) and not IsUnitInGroup(hero_unit[i], unit_buying_merc) and not IsUnitInGroup(hero_unit[i], unit_harassing) then
	   if IsUnitInGroup(hero_unit[i], unit_healing) and is_healing_included then
	   elseif not is_healing_included or (is_healing_included and not IsUnitInGroup(hero_unit[i], unit_healing)) then
        return hero_unit[i]
	   endif
      endif
    endif
    set i = i + 1
  endloop
  set i = 1
  loop
    exitwhen i > 3
    if hero_built[i] and UnitAlive(hero_unit[i]) then
      if DistanceBetweenUnits(hero_unit[i], shop) < limit and not IsUnitInGroup(hero_unit[i], unit_buying_tavern) and not IsUnitInGroup(hero_unit[i], unit_buying_merc) and not IsUnitInGroup(hero_unit[i], unit_harassing) then
	   if IsUnitInGroup(hero_unit[i], unit_healing) and is_healing_included then
	   elseif not is_healing_included or (is_healing_included and not IsUnitInGroup(hero_unit[i], unit_healing)) then
        return hero_unit[i]
	   endif
      endif
    endif
    set i = i + 1
  endloop  
  return null
endfunction

function GetItemHero takes item it returns unit
  local integer i = 1
  loop
    exitwhen i > 3
    if hero_built[i] and UnitAlive(hero_unit[i]) then
      if UnitHasItem(hero_unit[i], it) then
        return hero_unit[i]
      endif
    endif
    set i = i + 1
  endloop
  return null
endfunction

function AddHealer takes integer id, integer spell, integer mana_cost,integer t, integer upg_id, integer upg_level returns nothing
  set healer_id[healer_length] = id
  set healer_spell[healer_length] = spell
  set healer_mana_cost[healer_length] = mana_cost
  set healer_type[healer_length] = t
  set healer_upg_id[healer_length] = upg_id
  set healer_upg_level[healer_length] = upg_level
  set healer_length = healer_length + 1
endfunction

function InitHealers takes nothing returns nothing
  if own_race == R_ELF then
    call AddHealer(oDRUID_CLAW, 852160, 125, HEALER_TYPE_SUDDEN, oUPG_DRUID_CLAW, 1)
  endif
  if own_race == R_HUMAN then
    call AddHealer(oPRIEST, 852063, 5, HEALER_TYPE_CONTINUOUS, o0, 0)
  endif
  if own_race == R_ORC then
    call AddHealer(oWITCH_DOCTOR, 852109, 200, HEALER_TYPE_WARD, oUPG_ORC_DOCS, 2)
  endif
  if own_race == R_UNDEAD then
    call AddHealer(oOBSIDIAN_STATUE, 852545, 10, HEALER_TYPE_NO_TARGET, o0, 0)
  endif
  if false then
  elseif merc_healer == RAZORMANE_MEDICINE_MAN then
    call AddHealer(oRAZORMANE_MEDICINE_MAN, 852109, 200, HEALER_TYPE_WARD, o0, 0)
  elseif merc_healer == FURBOLG_SHAMAN then
    call AddHealer(oFURBOLG_SHAMAN, 852160, 125, HEALER_TYPE_SUDDEN, o0, 0)
  elseif merc_healer == FOREST_TROLL_HIGH_PRIEST then
    call AddHealer(oFOREST_TROLL_HIGH_PRIEST, 852248, 5, HEALER_TYPE_CONTINUOUS, o0, 0)
  elseif merc_healer == FOREST_TROLL_SHADOW_PRIEST then
    call AddHealer(oFOREST_TROLL_SHADOW_PRIEST, 852248, 5, HEALER_TYPE_CONTINUOUS, o0, 0)
  elseif merc_healer == DRAENEI_DISCIPLE then
    call AddHealer(oDRAENEI_DISCIPLE, 852248, 5, HEALER_TYPE_CONTINUOUS, o0, 0)
  endif
endfunction

function GetHealerId takes integer id returns integer
  local integer i = 0
  loop
    exitwhen i >= healer_length
    if healer_id[i] == id then
      return i
    endif
    set i = i + 1
  endloop
  return -1
endfunction

function IsUnitHealer takes unit u returns boolean
  if GetUnitState(u, UNIT_STATE_MAX_MANA) <= 0 then
    return false
  else
    if GetHealerId(GetUnitTypeId(u)) >= 0 then
      return true
    endif
  endif
  return false
endfunction

function HealUnit takes unit healer, unit to_heal, boolean hero_heal returns nothing
  local integer id = GetHealerId(GetUnitTypeId(healer))
  if id == -1 then
    return
  endif
  if healer_type[id] != HEALER_TYPE_NO_TARGET then
    if healer_type[id] == HEALER_TYPE_WARD then
      if not ward_cast then
        call IssuePointOrderById(healer, healer_spell[id], GetUnitX(healer), GetUnitY(healer))
        set ward_cast = true
      endif
    else
      if healer_type[id] != HEALER_TYPE_HERO or hero_heal then
        call IssueTargetOrderById(healer, healer_spell[id], to_heal)
      endif
    endif
  endif
endfunction

function GetHealer takes nothing returns unit
  local unit u = FirstOfGroup(healer_group)
  local integer id = 0
  loop
    exitwhen u == null
    set id = GetHealerId(GetUnitTypeId(u))
    exitwhen (GetUnitState(u, UNIT_STATE_MANA) >= healer_mana_cost[id]) and ((healer_upg_id[id] == 0) or (GetUpgradeLevel(healer_upg_id[id]) >= healer_upg_level[id]))
    call GroupRemoveUnit(healer_group, u)
    set u = FirstOfGroup(healer_group)
  endloop
  return u
endfunction

function GetArmyOfUnit takes unit u returns integer
  local integer i = 0
  loop
    exitwhen i >= army_num
    if IsUnitInGroup(u, army_group[i]) then
      return i
    endif
    set i = i + 1
  endloop
  return -1
endfunction

function GroupRecycleGuardPosition takes group g returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call TQAddUnitJob(30, RESET_GUARD_POSITION, 0, u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set u = null
endfunction

function GroupRecycleGuardPositionDelay takes group g, real delay returns nothing
  local unit u = null
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call TQAddUnitJob(delay, RESET_GUARD_POSITION, 0, u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set u = null
endfunction

function GetHealingItem takes nothing returns integer
	if false then
	elseif own_race == R_ORC and available_time[HEALING_SALVE] <= ai_time then
		return HEALING_SALVE
	endif
	return 0	
endfunction

function GetMassHealingItem takes nothing returns integer
  if false then
  elseif own_race == R_HUMAN and available_time[SCROLL_OF_REGENERATION] <= ai_time then
    return SCROLL_OF_REGENERATION
  elseif own_race == R_UNDEAD and tier >= 3 and available_time[SCROLL_OF_HEALING] <= ai_time then
    return SCROLL_OF_HEALING
  endif
  return 0
endfunction

function GetMerchantMassHealingItem takes nothing returns integer
	if false then
	elseif true and available_time[M_SCROLL_OF_HEALING] <= ai_time then
		return M_SCROLL_OF_HEALING
	endif
	return 0	
endfunction

function GetGlobalHealingItem takes nothing returns integer
	if false then
	elseif own_race == R_ELF and GetFloatGameState(GAME_STATE_TIME_OF_DAY) < 18 and available_time[MOONSTONE] <= ai_time then
		return MOONSTONE
	endif
	return 0
endfunction

function GetHeroManaItem takes nothing returns integer
	if false then
	elseif own_race != R_UNDEAD and available_time[LESSER_CLARITY_POTION] <= ai_time then
		return LESSER_CLARITY_POTION
	elseif tier >= 2 and available_time[MANA_POTION] <= ai_time then
		return MANA_POTION
	endif
	return 0
endfunction

function GetItemHealingTime takes integer id returns integer
  if false then
	elseif SCROLL_OF_REGENERATION == id then
		return 9
	elseif MOONSTONE == id then
		return 6
	elseif HEALING_SALVE == id then
		return 9
	elseif LESSER_CLARITY_POTION == id then
		return 6
  endif
  return 0
endfunction

function GetItemInstantType takes integer id returns integer
  if false then
	elseif SCROLL_OF_HEALING == id then
		return ITEMTYPE_SUDDEN
	elseif M_SCROLL_OF_HEALING == id then
		return ITEMTYPE_SUDDEN
	elseif HEALING_POTION == id then
		return ITEMTYPE_SUDDEN
	elseif MANA_POTION == id then
		return ITEMTYPE_SUDDEN
	elseif SCROLL_OF_REGENERATION == id then
		return ITEMTYPE_CONTINUOUS
	elseif HEALING_SALVE == id then
		return ITEMTYPE_CONTINUOUS
	elseif LESSER_CLARITY_POTION == id then
		return ITEMTYPE_CONTINUOUS
  endif
  return 0
endfunction 

function GetHeroHealingItem takes nothing returns integer
	if false then
	elseif tier >= 2 and available_time[HEALING_POTION] <= ai_time then
		return HEALING_POTION
	elseif GetHealingItem() != 0 then
		return GetHealingItem()
	elseif GetGlobalHealingItem() != 0 then
		return GetGlobalHealingItem()
	elseif GetMassHealingItem() != 0 then
		return GetMassHealingItem()
	elseif GetMerchantMassHealingItem() != 0 then
		return GetMerchantMassHealingItem()
	endif
	return 0
endfunction


function BuyNeutral takes integer id returns nothing
  local real timetotravel = 0
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  local real current_time = TimerGetElapsed(tq_timer)
  local real time_next_try = 0
  local real dist = 0
  local integer nn = GetNeutralNumber(id)
  local unit buy_place = nearest_neutral[nn]
  local boolean place_guarded = neutral_guarded[nn]
local integer detectedenemies = GetLocationNonCreepStrength(GetUnitX(neutral_sent[nn]), GetUnitY(neutral_sent[nn]), 1000) 
  local location l = null
  local boolean retreat_home = false

  call DisplayToAllJobDebug("BUY_NEUTRAL JOB START")

  // moved this check here to prevent a job crash if placed lower down
    if neutral_sent[nn] == null or not UnitAlive(neutral_sent[nn]) then
	  if retreat_home then
	    set retreat_home = false
		return
	  endif
      set neutral_sent[nn] = GetUnitToBuy(buy_place)
      if neutral_sent[nn] == null then
        call TQAddJob(sleep_multiplier, BUY_NEUTRAL, id)
        return
	  endif
	  call GroupAddUnit(unit_buying_merc, neutral_sent[nn])
    endif  

  if retreat_home then
	set l = GetUnitLoc(neutral_sent[nn])
	if DistanceBetweenPoints(l, home_location) >= 1100 then
		call CreateDebugTag("BUY_ITEM: Retreat to Home", 10, neutral_sent[nn], 3.00, 1.50)	
		call RemoveGuardPosition(neutral_sent[nn])
		call IssuePointOrder(neutral_sent[nn], "move", GetLocationX(home_location), GetLocationY(home_location))
		call TQAddJob(5, BUY_NEUTRAL, id)
	else
		call GroupRemoveUnit(unit_buying_merc, neutral_sent[nn])
		call RecycleGuardPosition(neutral_sent[nn])
		set retreat_home = false
		set neutral_sent[nn] = null
		set neutral_ordered[nn] = false
		set buy_time_large[nn] = -1
		set buy_time_small[nn] = -1
	endif
	call RemoveLocation(l)
	set l = null	
	return
  endif
	
 if DistanceBetweenUnits(neutral_sent[nn], buy_place) <= 800 and detectedenemies >= GetUnitStrength(neutral_sent[nn]) then
    call IssuePointOrder(neutral_sent[nn], "move", GetLocationX(home_location), GetLocationY(home_location))
    //call TQAddUnitJob(GetTimeToReachLoc(neutral_sent[nn], home_location), RESET_GUARD_POSITION, 1, neutral_sent[nn])
	set retreat_home = true
    call TQAddJob(1, BUY_NEUTRAL, id)
 endif

  if (buy_time_large[nn] >= 0 and buy_time_large[nn] + buy_timeout_large < current_time) or (buy_time_small[nn] >= 0 and buy_time_small[nn] + buy_timeout_small < current_time) then
    set available_time[id] = ai_time + regenerate_time[id] / 2
    call RecycleGuardPosition(neutral_sent[nn])
	call GroupRemoveUnit(unit_buying_merc, neutral_sent[nn])
    set neutral_sent[nn] = null
    set neutral_ordered[nn] = false
    set buy_time_large[nn] = -1
    set buy_time_small[nn] = -1
    return
  endif

  if TownCountDone(id) >= neutral_wanted[nn] then
    call RecycleGuardPosition(neutral_sent[nn])
	call GroupRemoveUnit(unit_buying_merc, neutral_sent[nn])
    set neutral_sent[nn] = null
    set neutral_ordered[nn] = false
    set buy_time_large[nn] = -1
    set buy_time_small[nn] = -1
    return
  endif

  if place_guarded and daytime >= 5 and daytime < 18 then
    set time_next_try = (18 - daytime)*20
  else
    call RemoveGuardPosition(neutral_sent[nn])
    //call SetUnitUserData(neutral_sent[nn], UNIT_BUYING)
    if buy_time_large[nn] < 0 then
      set buy_time_large[nn] = current_time
    endif

	set timetotravel = GetTimeToReachUnit(neutral_sent[nn], buy_place)
	
    set dist = DistanceBetweenUnits(neutral_sent[nn], buy_place)
    if dist < buy_distance then
		call CreateDebugTag("buy unit", 10, neutral_sent[nn], 3.00, 1.50) 
      call IssueImmediateOrder(neutral_sent[nn], "stop")
      call IssueNeutralImmediateOrderById(ai_player, buy_place, old_id[id])
      if buy_time_small[nn] < 0 then
        set buy_time_small[nn] = current_time
      endif
      set time_next_try = 0.5
    else
	  call CreateDebugTag("move to merc camp", 10, neutral_sent[nn], 3.00, 1.50) 
      call IssuePointOrder(neutral_sent[nn], "move", GetUnitX(buy_place), GetUnitY(buy_place))
      
      set time_next_try = 4
    endif
  endif
  call TQAddJob(time_next_try, BUY_NEUTRAL, id)
endfunction
function BuyNeutralHero takes integer id returns nothing
  local real timetotravel = 0
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  local real current_time = TimerGetElapsed(tq_timer)
  local real time_next_try = 0
  local real distance = 0
  local integer nn = GetNeutralNumber(id)
  local unit buying_unit = neutral_sent[nn]
  local unit tavern = nearest_neutral[nn]
  local boolean place_guarded = neutral_guarded[nn]

  call DisplayToAllJobDebug("BUY_NEUTRAL_HERO JOB START")
  
    //call Trace("Get Tavern Hero Job")

    if TownCountDone(id) >= neutral_wanted[nn] then
      call RecycleGuardPosition(neutral_sent[nn])
	  call GroupRemoveUnit(unit_buying_merc, neutral_sent[nn])
      set neutral_sent[nn] = null
      set neutral_ordered[nn] = false
      set buy_time_large[nn] = -1
      set buy_time_small[nn] = -1
      return
    endif

    if place_guarded and daytime >= 5 and daytime < 18 then
      set time_next_try = (18 - daytime)*20
    else    

    if buying_unit == null or GetUnitState(buying_unit, UNIT_STATE_LIFE) <= 0 then
		set neutral_sent[nn] = GetUnitToBuy(tavern)
		set buying_unit = neutral_sent[nn]
    	if neutral_sent[nn] == null then
        	call TQAddJob(sleep_multiplier, BUY_NEUTRAL, id)
			call Trace("No unit to get neutral hero")
        	return
		else
			call RemoveGuardPosition(buying_unit)
			call Trace("unit for neutral hero obtained")
		endif
    endif
	call GroupAddUnit(unit_buying_merc, buying_unit)

     set timetotravel = GetTimeToReachUnit(buying_unit, tavern)

    if current_time < (neutral_hero_time*5) - timetotravel then
		set time_next_try = RMax((neutral_hero_time*5) - timetotravel - current_time, 0.5 )
    else
    	set distance = DistanceBetweenUnits(buying_unit, tavern)
    	if distance >= buy_distance then
	   	call CreateDebugTag("Move to Tavern", 10, buying_unit, 3.00, 1.50)
    		call IssuePointOrder(buying_unit, "move", GetUnitX(tavern), GetUnitY(tavern))
      	set time_next_try = 4
    	else
		call CreateDebugTag("buy tavern hero", 10, buying_unit, 3.00, 1.50) 
		call IssueImmediateOrder(buying_unit, "stop")
      	call IssueNeutralImmediateOrderById(ai_player, tavern, old_id[id])
      	set time_next_try = 0.5
    	endif
    endif
    endif

    call TQAddJob(time_next_try, BUY_NEUTRAL_HERO, id)
endfunction

function SetPlayerGold takes player p, integer i returns nothing
    call SetPlayerState(p,PLAYER_STATE_RESOURCE_GOLD,i)
endfunction

function SetPlayerWood takes player p, integer i returns nothing
    call SetPlayerState(p,PLAYER_STATE_RESOURCE_LUMBER,i)
endfunction

function IncreasePlayerGold takes player p, integer i returns nothing
    call SetPlayerGold(p, GetPlayerState(p,PLAYER_STATE_RESOURCE_GOLD) + i)
endfunction

function IncreasePlayerWood takes player p, integer i returns nothing
    call SetPlayerWood(p, GetPlayerState(p,PLAYER_STATE_RESOURCE_LUMBER) + i)
endfunction

function DistributeGold takes integer value returns nothing
    local integer amount = value
    local integer p_amount = value / force_number
    local integer i = 0
    loop
      exitwhen i == force_number
      call IncreasePlayerGold(own_force[i], p_amount)
      set amount = amount - p_amount
      set i = i + 1
    endloop
    call IncreasePlayerGold(ai_player,amount)    
endfunction

function DistributeWood takes integer value returns nothing
    local integer amount = value
    local integer p_amount = value / force_number
    local integer i = 0
    loop
      exitwhen i == force_number
      call IncreasePlayerWood(own_force[i], p_amount)
      set amount = amount - p_amount
      set i = i + 1
    endloop
    call IncreasePlayerWood(ai_player,amount)    
endfunction

function ExchangeOnce takes nothing returns nothing
    local integer amount = 0
    if force_number == 0 then
      return
    endif
    set amount = GetPlayerGold(ai_player)
    if  amount > gold_exchange_level then
      call IncreasePlayerGold(ai_player, - (amount - gold_exchange_level))
      call DistributeGold(amount - gold_exchange_level)
    endif
    set amount = GetPlayerWood(ai_player)
    if  amount > wood_exchange_level then
      call IncreasePlayerWood(ai_player, - (amount - wood_exchange_level))
      call DistributeWood(amount - wood_exchange_level)
    endif
endfunction

function ExchangeJob takes nothing returns nothing
  call DisplayToAllJobDebug("EXCHANGE JOB Start")
  call ExchangeOnce()
  call TQAddJob(30 * sleep_multiplier, EXCHANGE, 0)
endfunction
function UpdateStrength takes nothing returns nothing
local integer i = 0
local integer enemy_num = 0
local integer ally_num = 0
local real air = 0
local real aair = 0
local real casters = 0
local real acasters = 0
local real towers = 0
local real atowers = 0
local real piercing = 0
local real apiercing = 0
local real normal = 0
local real anormal = 0
local real siege = 0
local real asiege = 0
local real magic = 0
local real amagic = 0
local real unarmored = 0
local real aunarmored = 0
local real lightarmor = 0
local real alightarmor = 0
local real mediumarmor = 0
local real amediumarmor = 0
local real heavyarmor = 0
local real aheavyarmor = 0

loop
  exitwhen i >= 12
  if IsPlayerEnemy(ai_player, Player(i)) and GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then
    set enemy_num = enemy_num + 1
    set air = air + ((GetPlayerairStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set casters = casters + ((GetPlayercastersStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set towers = towers + ((GetPlayertowersStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set piercing = piercing + ((GetPlayerpiercingStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set normal = normal + ((GetPlayernormalStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set siege = siege + ((GetPlayersiegeStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set magic = magic + ((GetPlayermagicStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set unarmored = unarmored + ((GetPlayerunarmoredStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set lightarmor = lightarmor + ((GetPlayerlightarmorStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set mediumarmor = mediumarmor + ((GetPlayermediumarmorStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set heavyarmor = heavyarmor + ((GetPlayerheavyarmorStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
  elseif IsPlayerAlly(ai_player, Player(i)) and GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then
	set ally_num = ally_num + 1
    set aair = aair + ((GetPlayerairStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set acasters = acasters + ((GetPlayercastersStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set atowers = atowers + ((GetPlayertowersStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set apiercing = apiercing + ((GetPlayerpiercingStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set anormal = anormal + ((GetPlayernormalStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set asiege = asiege + ((GetPlayersiegeStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set amagic = amagic + ((GetPlayermagicStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set aunarmored = aunarmored + ((GetPlayerunarmoredStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set alightarmor = alightarmor + ((GetPlayerlightarmorStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set amediumarmor = amediumarmor + ((GetPlayermediumarmorStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
    set aheavyarmor = aheavyarmor + ((GetPlayerheavyarmorStrength(Player(i))) * GetPlayerStrengthHandicap(Player(i)))
  endif
  set i = i + 1
endloop

set enemy_air = RMax(air + GetRandomDiff(area_uncertainty), 0 ) / Max(enemy_num, 1)
set ally_air = aair/ Max(ally_num, 1)
set enemy_casters = RMax(casters + GetRandomDiff(area_uncertainty), 0 ) / Max(enemy_num, 1)
set ally_casters = acasters/ Max(ally_num, 1)
set enemy_towers = RMax(towers + GetRandomDiff(area_uncertainty), 0 ) / Max(enemy_num, 1)
set ally_towers = atowers/ Max(ally_num, 1)
set enemy_piercing = RMax(piercing + GetRandomDiff(area_uncertainty), 0 ) / Max(enemy_num, 1)
set ally_piercing = apiercing/ Max(ally_num, 1)
set enemy_normal = RMax(normal + GetRandomDiff(area_uncertainty), 0 ) / Max(enemy_num, 1)
set ally_normal = anormal/ Max(ally_num, 1)
set enemy_siege = RMax(siege + GetRandomDiff(area_uncertainty), 0 ) / Max(enemy_num, 1)
set ally_siege = asiege/ Max(ally_num, 1)
set enemy_magic = RMax(magic + GetRandomDiff(area_uncertainty), 0 ) / Max(enemy_num, 1)
set ally_magic = amagic/ Max(ally_num, 1)
set enemy_unarmored = RMax(unarmored + GetRandomDiff(area_uncertainty), 0 ) / Max(enemy_num, 1)
set ally_unarmored = aunarmored/ Max(ally_num, 1)
set enemy_lightarmor = RMax(lightarmor + GetRandomDiff(area_uncertainty), 0 ) / Max(enemy_num, 1)
set ally_lightarmor = alightarmor/ Max(ally_num, 1)
set enemy_mediumarmor = RMax(mediumarmor + GetRandomDiff(area_uncertainty), 0 ) / Max(enemy_num, 1)
set ally_mediumarmor = amediumarmor/ Max(ally_num, 1)
set enemy_heavyarmor = RMax(heavyarmor + GetRandomDiff(area_uncertainty), 0 ) / Max(enemy_num, 1)
set ally_heavyarmor = aheavyarmor/ Max(ally_num, 1)

endfunction

function UpdateStrengthJob takes nothing returns nothing
  call DisplayToAllJobDebug("UPDATE_STRENGTH Start")
  if player_defeated then
    return
  endif
  call UpdateStrength()
  call TQAddJob(15 * sleep_multiplier, UPDATE_STRENGTH, 0)
endfunction
function countEnemyReal takes nothing returns nothing
  local integer i = 0

  loop
    exitwhen i > RACE_NUMBER
    set c_enemy[i] = 0
    set i = i + 1
  endloop

  set i = 0
  loop
    exitwhen i >= 12
    if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then
    	if IsPlayerEnemy(ai_player,Player(i)) and not IsPlayerObserver(Player(i)) then
	      set c_enemy[player_race[i]] = c_enemy[player_race[i]] + 1
	    endif
    endif
    set i = i + 1
  endloop

endfunction

function RevealEnemy takes nothing returns nothing
  call DisplayToAllJobDebug("REVEAL_ENEMY JOB START")
  call countEnemyReal()
endfunction
function RemoveFromOwnForce takes player p returns nothing
  local integer i = 0
  loop
    if i >= force_number then
      return
    endif
    exitwhen own_force[i] == p
    set i = i + 1
  endloop
  set force_number = force_number - 1
  loop
    exitwhen i >= force_number
    set own_force[i] = own_force[i+1]
    set i = i + 1
  endloop
endfunction

function KillYourself takes boolean end_ai returns nothing
    local group g = null
    local unit u = null
    local integer i = 0
    if not player_defeated then
      call Chat(C_AGG)
      call Chat(C_EGG)
      call Sleep(3)
      set g = CreateGroup()
      call GroupEnumUnitsOfPlayer(g, ai_player, null)
      loop
        set u = FirstOfGroup(g)
        exitwhen u == null
        if destroy_buildings_on_defeat then
          call KillUnit(u)
        else
          call SetUnitOwner(u, Player(13), true)
        endif
        call GroupRemoveUnit(g, u )
      endloop
      call DestroyGroup(g)
      set g = null
      if not no_ai_ally then
        set wood_exchange_level = 0
        set gold_exchange_level = 0
        call RemoveFromOwnForce(ai_player)
        call ExchangeOnce()
      endif
      if not destroy_buildings_on_defeat then
        call SetPlayerAlliance(ai_player, Player(PLAYER_NEUTRAL_AGGRESSIVE), ALLIANCE_PASSIVE, true)  // trigger the victory/defeat recognition triggers
        call SetPlayerAlliance(ai_player, Player(PLAYER_NEUTRAL_AGGRESSIVE), ALLIANCE_PASSIVE, false)
      endif
      set player_defeated = true
    endif
endfunction

function Defeated takes nothing returns nothing
    if c_ally_total > 1 then
      call Chat(C_Goldproblem)
      call Sleep(10)
      if GetGold() >= gold_problem_level then
          call Chat(C_Thanks)
          return
      endif
    endif
    call KillYourself(no_ai_ally)
endfunction

function CheckDefeated takes nothing returns nothing
  local integer hall_count = TownCount(racial_hall[1])
  local integer hall_cost = GetUnitGoldCost2(racial_hall[1])
  local integer expa_cost = GetUnitGoldCost2(racial_expansion)
  local integer expa_count = TownCount(racial_expansion)
  local integer expa_done_count = TownCountDone(racial_expansion)
  local integer worker_cost = GetUnitGoldCost2(racial_peon)
  local integer worker_count = TownCountDone(racial_peon)
  local integer farm_food = GetFoodMade(old_id[racial_farm])
  local integer farm_count = TownCountDone(racial_farm)
  local integer farm_cost = GetUnitGoldCost2(racial_farm)
  local integer mines = GetMinesOwned()
  local integer agg = p_surrender[profile]
  local group g = CreateGroup()
  local unit u = null
  local real enemy_sum = 0
  local real player_sum = GetPlayerStrength(ai_player)
  local real ally_sum = 0
  local integer i = 0

  if disable_surrender then
	set agg = 0
  endif
  
  if town_threatened then
	  set enemy_sum = army_strength[town_threat_army[most_threatened_town]]
  else
	  call GroupEnumUnitsInRange(g,GetLocationX(home_location),GetLocationY(home_location),front_base_distance,null)
	  loop
	      set u = FirstOfGroup(g)
	      exitwhen u == null
		if UnitAlive(u) and GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_AGGRESSIVE) and GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_PASSIVE) and IsPlayerEnemy(ai_player, GetOwningPlayer(u)) then
	      	set enemy_sum = enemy_sum + GetUnitStrength(u)
		endif
		call GroupRemoveUnit(g,u)
	  endloop
  endif
  call DestroyGroup(g)
  set g = null

  if c_ally_total > 1 then
  loop
 	exitwhen i >= 12
	if IsPlayerAlly(ai_player,Player(i)) then
		set ally_sum = ally_sum + GetPlayerStrength(Player(i))
	endif
      set i = i + 1
  endloop
  endif

  if GetPlayerUnitCount(ai_player, true) == 0 and GetPlayerStructureCount(ai_player, true) == 0 then
	call KillYourself(no_ai_ally)	
	return
  endif
  
  if agg <= 0 then
	return
  endif

  if agg >= 1 then
  	if FoodUsed() == 0 and hall_count == 0 then
    		call KillYourself(no_ai_ally)
			return
 	endif
  endif

  if agg >= 2 then
	if FoodUsed() < 6 and hall_count == 0 and worker_count == 0 then
		call KillYourself(no_ai_ally)
		return
	endif 
	if enemy_sum > ((player_sum + ally_sum + 5) * 5) and hall_count <= 1 then
	 	call KillYourself(no_ai_ally)
		return
  	endif
  	if worker_count == 0 and GetGold() < worker_cost and hall_count >= 1 and FoodUsed() < 6 and worker_count == 0 then
      	set gold_problem_level = worker_cost
		call Defeated()
		return
  	endif
  	if GetPlayerStrength(ai_player) == 0 and hall_count == 0 and GetGold() < hall_cost then
    		set gold_problem_level = hall_cost
    		call Defeated()
			return
  	endif
  	if GetPlayerStrength(ai_player) == 0 and mines == 0 and GetGold() < expa_cost and (expa_count - expa_done_count) == 0 then
    		set gold_problem_level = expa_cost
    		call Defeated()
			return
  	endif
  endif

  if agg >= 3 then
	if FoodUsed() < 6 and hall_count == 0 then
		call KillYourself(no_ai_ally)
		return
	endif
	if enemy_sum > ((player_sum + ally_sum + 5) * 4) and hall_count <= 1 then
	 	call KillYourself(no_ai_ally)
		return
  	endif
	if (farm_count * farm_food) < FoodUsed() and mines == 0 and GetGold() < farm_cost and (FoodUsed()) < 10 and worker_count == 0 then
		set gold_problem_level = farm_cost
		call Defeated()
		return
  	endif
	if worker_count == 0 and GetGold() < worker_cost and hall_count >= 1 and FoodUsed() < 15 then
      	set gold_problem_level = worker_cost
		call Defeated()
		return
  	endif
  	if GetPlayerStrength(ai_player) <= 7 and mines == 0 and GetGold() < expa_cost and (expa_count - expa_done_count) == 0 then
    		set gold_problem_level = expa_cost
    		call Defeated()
			return
  	endif
  endif

  if agg >= 4 then
	if enemy_sum > ((player_sum + ally_sum + 5) * 3) and hall_count <= 2 then
	 	call KillYourself(no_ai_ally)
		return
  	endif
  endif
endfunction

function SumForceState takes playerstate ps returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i >= force_number
    set sum = sum + GetPlayerState(own_force[i],ps)
    set i = i + 1
  endloop
  return sum
endfunction

function SumForceFood takes nothing returns integer
  return SumForceState(PLAYER_STATE_RESOURCE_FOOD_USED)
endfunction

function SumForceGold takes nothing returns integer
  return SumForceState(PLAYER_STATE_RESOURCE_GOLD)
endfunction

function CheckDefeatedForce takes nothing returns nothing
  if SumForceFood() == 0 and SumForceGold() <= 100 then
    call KillYourself(true)
  endif
endfunction

function DetectDefeatJob takes nothing returns nothing
  call DisplayToAllJobDebug("DETECT_DEFEAT Job Start")
  call CheckDefeated()
  call CheckDefeatedForce()
  if not player_defeated then
    call TQAddJob(13 * sleep_multiplier, DETECT_DEFEAT, 0)
  endif
endfunction
function GetOtherExpansionNearby takes real tx, real ty returns unit
  local group g = CreateGroup()
  local unit u = null
  local integer id = 0
  call GroupEnumUnitsInRange(g, tx, ty, expansion_taken_radius, null)
  set g = SelectByPlayer(g, ai_player, false)
  set g = SelectByAlive(g, true)
  set g = SelectByAlive2(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set id = GetUnitTypeId(u)
      if IsUnitType(u, UNIT_TYPE_TOWNHALL) == true then //or id == oUNDEAD_MINE then//id == oTOWN_HALL or id == oKEEP or id == oCASTLE or id == oUNDEAD_MINE or id == oGREAT_HALL or id == oSTRONGHOLD or id == oFORTRESS or id == oTREE_LIFE or id == oTREE_AGES or id == oTREE_ETERNITY then
        call DestroyGroup(g)
        set g = null
        return u
      elseif IsPlayerEnemy(GetOwningPlayer(u), ai_player) and IsUnitType(u, UNIT_TYPE_STRUCTURE) == true then
        set nearby_enemy_building = u
      endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return nearby_enemy_building
endfunction

function CheckDoubleExpansion takes nothing returns nothing
  local group g = CreateGroup()
  local unit v = null
  local unit u = null
  local player p = null
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectNumberOfId(g, 100, old_id[racial_expansion])
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set v = GetOtherExpansionNearby(GetUnitX(u), GetUnitY(u))
    if v != null then
      set p = GetOwningPlayer(v)
      if IsPlayerEnemy(ai_player, p) then
        call Trace("Enemy double expansion detected")
        set double_expansion_target = v
      else
        call Trace("Ally double expansion detected")
        call IssueImmediateOrderById(u, order_cancel)
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
endfunction

function DetectDoubleExpJob takes nothing returns nothing
  call DisplayToAllJobDebug("DETECT_DOUBLE JOB START")
  call CheckDoubleExpansion()
  call TQAddJob(10 * sleep_multiplier, DETECT_DOUBLE_EXP, 0)
endfunction
function ZeppelinFollowJob takes nothing returns nothing
  local real dist = 0
  local location l = null
  local group g = CreateGroup()
  local location heroloc = null

  call DisplayToAllJobDebug("ZEPPELIN_FOLLOW Start")
  //call GroupEnumUnitsOfType(g, "goblinzeppelin", null)
  // ---------- NO CUSTOMIZEABLE SECTION DETECTED
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  //set g = SelectByPlayer(g, ai_player, true)
  set g = SelectById(g, old_id[neutral_zeppelin], true)
  //-----------------------------------------------
  //set g = SelectByOrderOr(g, 0, order_attack, true)
  set g = SelectByUnitStandard(g, true)
  call GroupRemoveGuardPositionInstant(g)
  call GroupPointOrderLoc(g, "attack", home_location)
  if major_hero != null and UnitAlive(major_hero) then
    set heroloc = GetUnitLoc(major_hero)
    set follow_zeppelin = GetNearestOfGroup(g, heroloc)
	call RemoveLocation(heroloc)
	set heroloc = null	
  else
	set follow_zeppelin = null
  endif	
  call DestroyGroup(g)
  set g = null

  if follow_zeppelin == null then
    call TQAddJob(10, ZEPPELIN_FOLLOW, 0)
    set zeppelin_following = false
    return
  endif
  set zeppelin_following = true
  set dist = DistanceBetweenUnits(major_hero, follow_zeppelin)
  if dist > max_follow_dist then
	call CreateDebugTag("Zepplin follow hero", 10, follow_zeppelin, 3.00, 1.50)
    set l = GetLocationBetweenUnits(follow_zeppelin, major_hero, (dist - 0.5 * max_follow_dist)/dist)
	//set l = GetLocationBetweenUnits(follow_zeppelin, major_hero, (dist - 0.33 * max_follow_dist))
    //call IssuePointOrderLoc(follow_zeppelin, "attack", l)
	call IssuePointOrder(follow_zeppelin, "unloadall", GetLocationX(l), GetLocationY(l))  // Extra aid to help prevent units getting stuck in zepplin
	call IssueTargetOrder(follow_zeppelin, "move", major_hero)
    call RemoveLocation(l)
    set l = null
    call TQAddJob(RMax((dist - max_follow_dist) / RMax(GetUnitMoveSpeed(follow_zeppelin) + GetUnitMoveSpeed(major_hero), 50), 1) * sleep_multiplier,ZEPPELIN_FOLLOW,0)
  else
    call IssueImmediateOrder(follow_zeppelin, "stop")
	call IssuePointOrder(follow_zeppelin, "unloadall", GetUnitX(follow_zeppelin), GetUnitY(follow_zeppelin))
    call TQAddJob(10 * sleep_multiplier,ZEPPELIN_FOLLOW,0)
  endif
endfunction
function NeutralGuardedJob takes integer nn returns nothing
  call DisplayToAllJobDebug("NEUTRAL_GUARDED JOB START")
  set neutral_guarded[nn] = GetNeutralGuard(nn) != null
  if neutral_guarded[nn] then
    call TQAddJob(30 * sleep_multiplier, NEUTRAL_GUARDED, nn)
  endif
endfunction
function RepairControlJob takes nothing returns nothing
  local integer peons = TownCountDone(racial_peon)
  call DisplayToAllJobDebug("REPAIR_CONTROL JOB START")
  if towerrush then
    call SetPeonsRepair(false)
  elseif peons <= repair_threshold or (peons <= repair_threshold_threatened and town_threatened) then
    call SetPeonsRepair(false)
  else
    call SetPeonsRepair(true)
  endif
  call TQAddJob(15, REPAIR_CONTROL, 0)
endfunction
function ElfMineCheck takes unit mine returns boolean
  local group g = CreateGroup()
  local group tempg = null
  local location unitloc = GetUnitLoc(mine)
  local unit u = null
  local unit v = null
  local integer i = 0
  local integer delaywisps = 0
  
    call DisplayToAllJobDebug("WISP_CHECK Job Start")
  
  if TownCountDone(race_manual_loading_wisp) > 6 then
	set delaywisps = ver_optimal_gold
  else
    set delaywisps = ver_optimal_gold - 1
  endif
  
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitInTransport(u, mine) then
      set i = i + 1
	  //call RecycleGuardPosition(u)
    endif
    call GroupRemoveUnit(g, u)
  endloop
  if i < delaywisps then
    call GroupEnumUnitsOfPlayer(g, ai_player, null)
    set g = SelectByLoaded(g, false)
    set g = SelectNumberOfId(g, 100, old_id[race_manual_loading_wisp])
	set tempg = CopyGroup(g)
	call DestroyGroup(g)
    set g = GetNearestSubGroupOfGroup(tempg, unitloc, delaywisps - i)
	//call GroupRemoveGuardPositionInstant(g) // this gets wisps to come off the trees.
    call GroupTargetOrder(g, "harvest", mine)
	call DestroyGroup(tempg)
	set tempg = null
  endif
  call RemoveLocation(unitloc)
  set unitloc = null
  call DestroyGroup(g)
  set g = null
  return i < delaywisps
endfunction

function WispCheckJob takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  local boolean mines_not_full = true
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectNumberOfId(g, 100, old_id[race_manual_loading_mine])
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) then
      set mines_not_full = ElfMineCheck(u) and mines_not_full
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  if mines_not_full then
    call TQAddJob(90, WISP_CHECK, 0)
  else
    call TQAddJob(20, WISP_CHECK, 0)
  endif
endfunction

function RetreatControlJob takes nothing returns nothing
  local group g = CreateGroup()
  local real ally_sum = 0
  local real enemy_sum = 0
  local real creep_sum = 0
  local unit u = null
  local real unit_strength = 0
  local real unit_life = 0
  local real unit_mana = 0
  //local group g_battle = CreateGroup()
  local real enemy_ranged_strength = 0
  local real ally_ranged_strength = 0
  local integer num_units = 0
  local real ally_strength = 0
  local real enemy_strength = 0
  local location l = null
  
  // local variables used to calculate roughly where the current enemy army is located at
  local integer ally_count = 0
  local integer enemy_count = 0  

  call DisplayToAllJobDebug("RETREAT_CONTROL JOB Start")

  if major_hero == null or not UnitAlive(major_hero) then
    set major_hero = GetMajorHeroReplacement_k(last_major_hero_loc)
  endif

   //   call GroupEnumUnitsInRange(g_battle,GetUnitX(major_hero),GetUnitY(major_hero),battle_radius,null)
	//loop
    //  	set u = FirstOfGroup(g_battle)
	//	exitwhen u == null
	//	if UnitAlive(u) and IsPlayerAlly(GetOwningPlayer(u), ai_player) and IsUnitType(u, UNIT_TYPE_RANGED_ATTACKER) then
	//		set ally_ranged_strength = ally_ranged_strength + GetUnitStrength(u)
	//	else
	//		if UnitAlive(u) and IsPlayerEnemy(GetOwningPlayer(u),ai_player) and IsUnitType(u, UNIT_TYPE_RANGED_ATTACKER) then
	//			set enemy_ranged_strength = enemy_ranged_strength + GetUnitStrength(u)
	//			set num_units = num_units + 1
	//		endif
	//	endif
	//	if UnitAlive(u) and IsPlayerAlly(GetOwningPlayer(u), ai_player) then
	//		set ally_strength = ally_strength + GetUnitStrength(u)
	//	else
	//		if UnitAlive(u) and IsPlayerEnemy(GetOwningPlayer(u),ai_player) then
	//			set enemy_strength = enemy_strength + GetUnitStrength(u)
	//		endif
	//	endif
	//	call GroupRemoveUnit(g_battle,u)
	//endloop
	//call DestroyGroup(g_battle)
	//set g = null




if (CaptainRetreating() and isfleeing) or town_threatened then     //((major_hero == null or not UnitAlive(major_hero)) and ver_heroes) or  then  //attack_running and
    call Trace("===Retreat control ended===")
    set break_attack = attack_running
    set retreat_controlled = false
    call SetGroupsFlee(true)
	set l = GetUnitLoc(major_hero)
	if DistanceBetweenPoints(home_location, l) < 1250 then
		set isfleeing = false     // home so no need to be retreating. Also prevents bug in the captainretreating condition
	endif
	call RemoveLocation(l)
	set l = null
    return
endif

  if main_army == -1 or army_loc[main_army] == null or (GetLocationX(army_loc[main_army]) == 0 and GetLocationY(army_loc[main_army]) == 0 )then
    if major_hero == null then
		call Trace("No major hero in retreat control")
	endif
	call GroupEnumUnitsInRange(g,GetUnitX(major_hero),GetUnitY(major_hero),battle_radius,null)
  else
	call GroupEnumUnitsInRange(g, GetLocationX(army_loc[main_army]), GetLocationY(army_loc[main_army]), battle_radius, null)
  endif

  set g = SelectByAlive(g, true)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, false)

  call MoveLocation(last_enemy_loc, GetLocationX(enemy_loc), GetLocationY(enemy_loc))
  call MoveLocation(last_ally_loc, GetLocationX(ally_loc), GetLocationY(ally_loc))
  call MoveLocation(enemy_loc, 0,0)
  call MoveLocation(ally_loc, 0,0)  
  
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null  
		if GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_AGGRESSIVE) and not IsUnitHidden(u) then
		  //call Trace("RETREAT_CONTROL: At least 1 unit detected")
		  set unit_strength = GetUnitStrength(u)
		  set unit_life = GetUnitState(u, UNIT_STATE_LIFE)
		  set unit_mana = GetUnitState(u, UNIT_STATE_MANA)
		  if IsPlayerAlly(GetOwningPlayer(u), ai_player) then
			//if GetUnitUserData(u) != UNIT_GOING_HOME then 
			  if not IsUnitInGroup(u, unit_healing) then //and unit_life > RMax(flee_health_percentage * GetUnitState(u, UNIT_STATE_MAX_LIFE), flee_minimum_health) then
				set ally_sum = ally_sum + unit_strength
			  endif
			set ally_loc = GetSumLoc_dd(ally_loc, GetUnitLoc(u))
			set ally_count = ally_count + 1
		  elseif not (UnitInvis(u) and not IsUnitDetected(u, ai_player)) then
			set enemy_sum = enemy_sum + unit_strength
			set enemy_loc = GetSumLoc_dd(enemy_loc, GetUnitLoc(u))
			set enemy_count = enemy_count + 1
		  endif
		elseif GetOwningPlayer(u) == Player(PLAYER_NEUTRAL_AGGRESSIVE) and not IsUnitHidden(u)and not (UnitInvis(u) and not IsUnitDetected(u, ai_player)) then
			set unit_strength = GetUnitStrength(u)
			set unit_life = GetUnitState(u, UNIT_STATE_LIFE)
			set unit_mana = GetUnitState(u, UNIT_STATE_MANA)
			set creep_sum = creep_sum + unit_strength
		endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null

  set enemy_loc = GetDivisionLoc_d(enemy_loc, I2R(Max(enemy_count, 1)))
  set ally_loc = GetDivisionLoc_d(ally_loc, I2R(Max(ally_count, 1)))  
  
  set enemy_strength_sum = enemy_sum
  set ally_strength_sum = ally_sum
  //call Trace("RETREAT_CONTROL: Our strength: " + Int2Str(R2I(ally_strength_sum))) 
  //call Trace("RETREAT_CONTROL: Enemy strength: " + Int2Str(R2I(enemy_strength_sum)))
  
  if enemy_sum > LinearInterpolation(ver_low_aggression,ver_high_aggression,ver_flee_multiple2,ver_flee_multiple3,attacking_aggression + added_aggression + added_target_aggression + added_racial_aggression)*ally_sum or (town_threatened and attack_running) then
    call Trace("RETREAT_CONTROL: Flee!!!!")
    set break_attack = attack_running
    set retreat_controlled = false  
    call ClearCaptainTargets()	
	call CaptainGoHome()
	set isfleeing = true
	return
  elseif enemy_sum > LinearInterpolation(ver_low_aggression,ver_high_aggression,ver_flee_multiple1,ver_flee_multiple2,attacking_aggression + added_aggression + added_target_aggression + added_racial_aggression)*ally_sum or (battle_radius == creep_battle_radius and creep_sum - 2 > ally_sum ) then
    call Trace("RETREAT_CONTROL: Allowed to Flee")
    call SetGroupsFlee(true)
	set isfleeing = true
    //call ClearCaptainTargets()	
	//call CaptainGoHome()
  else
	  //if town_threatened and town_threat[most_threatened_town] >= teleport_high_threat then
		
	 // else
		call SetGroupsFlee(false)
		set isfleeing = false
	 // endif
  endif

  call TQAddJob(2 * sleep_multiplier, RETREAT_CONTROL, 0)
endfunction
function CleanupBlock takes nothing returns nothing
  local integer i = 0
  local integer ff = 0

  loop
    exitwhen i >= bl_length
    if bl_expire_time[i] >= ai_time then
      set bl_req_qty[ff] = bl_req_qty[i]
      set bl_req_type[ff] = bl_req_type[i]
      set bl_allow_qty[ff] = bl_allow_qty[i]
      set bl_allow_type[ff] = bl_allow_type[i]
      set bl_expire_time[ff] = bl_expire_time[i]
      set bl_only_done[ff] = bl_only_done[i]
      set ff = ff + 1
    endif
    set i = i + 1
  endloop
  set bl_length = ff
endfunction

function CleanupRBlock takes nothing returns nothing
  local integer i = 0
  local integer ff = 0
  loop
    exitwhen i >= rbl_length
    if rbl_expire_time[i] >= ai_time then
      set rbl_req_gold[ff] = rbl_req_gold[i]
      set rbl_req_wood[ff] = rbl_req_wood[i]
      set rbl_allow_qty[ff] = rbl_allow_qty[i]
      set rbl_allow_type[ff] = rbl_allow_type[i]
      set rbl_expire_time[ff] = rbl_expire_time[i]
      set ff = ff + 1
    endif
    set i = i + 1
  endloop
  set rbl_length = ff
endfunction

function CleanupBlocksJob takes nothing returns nothing
  call DisplayToAllJobDebug("CLEANUP_BLOCKS JOB START")
  call CleanupBlock()
  call CleanupRBlock()
  call TQAddJob(60, CLEANUP_BLOCKS, 0)
endfunction
function ResetGuardPositionJob takes unit u returns nothing
  call DisplayToAllJobDebug("RESET_GUARD_POSITION JOB START")
  call RecycleGuardPosition(u)
  call GroupRemoveUnit(unit_healing, u)
  call GroupRemoveUnit(unit_rescueing, u)
  call GroupRemoveUnit(unit_harassing, u)
  call GroupRemoveUnit(unit_zepplin_move, u)
 // call SetUnitUserData(u, UNIT_STANDARD)
endfunction
function ResetByHealthJob takes unit u, integer p returns nothing
  call DisplayToAllJobDebug("RESET_HEALTH JOB START")
  if GetUnitState(u, UNIT_STATE_LIFE) >= GetUnitState(u, UNIT_STATE_MAX_LIFE) * (I2R(p)/100) then
    call RecycleGuardPosition(u)
  else
    call TQAddUnitJob(8, RESET_HEALTH, p, u)
  endif
endfunction
function IsHealingItem takes integer id returns boolean
	if false then	//basically check that item to build is healing item and drop item to make room for this
	elseif oSCROLL_OF_REGENERATION == id then
		return true	
	elseif oSCROLL_OF_HEALING == id then
		return true	
	elseif oMOONSTONE == id then
		return true	
	elseif oHEALING_SALVE == id then
		return true	
	elseif oM_SCROLL_OF_HEALING == id then
		return true	
	elseif oHEALING_POTION == id then
		return true	
	elseif oLESSER_CLARITY_POTION == id then
		return true	
	elseif oMANA_POTION == id then
		return true	
	elseif oTOWN_PORTAL == id then
		return true
	endif
	return false
endfunction

function DropNonHealingItem takes unit u returns nothing
	local integer i = 0
	local item t = null
	
	loop
		exitwhen i >= 6
		set t = UnitItemInSlot(u, i)
		if t != null and not IsHealingItem(GetItemTypeId(t)) then
			call UnitDropItemPoint(u, t, GetUnitX(u), GetUnitY(u))
			return
		endif
		set i = i + 1
	endloop
endfunction

function BuyItemJob takes integer id returns nothing
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  local real current_time = TimerGetElapsed(tq_timer)
  local real time_next_try = 0
  local real dist = 0
  local location l = null
  local boolean healing = false

local integer detectedenemies = GetLocationNonCreepStrength(GetUnitX(shop_sent), GetUnitY(shop_sent), 1000) 

 call DisplayToAllJobDebug("BUY_ITEM JOB START")

   if shop_ordered == false then
    call Trace("Order to get item is off so end job")
	return	// Shouldn't be buying an item anyway
   endif

  // moved here to prevent a job crash 
   if shop_sent == null or not UnitAlive(shop_sent) then
    set ismoving = false
    if retreat_home then
	    call Trace("Running Home end but item job")
	    set shop_ordered = false
		set shop_buy_time_large = -1
		set shop_buy_time_small = -1
		set retreat_home = false
		return
	endif
	if buy_type[id] == BT_RACIAL_ITEM then
		set shop_sent = GetHeroToBuyItem(shop_unit, shop_distance_limit,false)
	else
		set shop_sent = GetHeroToBuyItem(shop_unit, shop_distance_limit,true)
	endif
    if shop_sent == null then
	  call Trace("No unit to buy item so end job")
      set shop_ordered = false
      set shop_buy_time_large = -1
      set shop_buy_time_small = -1
      return
    endif
	call GroupAddUnit(unit_buying_item, shop_sent)
  endif
 
   //call CreateDebugTag("In BUT ITEM JOB, 10, shop_sent, 3.00, 1.50) 

  if GetUnitTypeId(shop_unit) == old_id[racial_shop] and DistanceBetweenUnits(shop_sent, shop_unit) < 1000 then
  else
    if town_threatened or attack_running then
		call CreateDebugTag("BUY_ITEM:in attack so dont get item", 10, shop_sent, 3.00, 1.50) 
    	call RecycleGuardPosition(shop_sent)
		call GroupRemoveUnit(unit_buying_item, shop_sent)
		call AddAssault(1, GetUnitTypeId(shop_sent))
    	set shop_sent = null
    	set shop_ordered = false
    	set shop_buy_time_large = -1
    	set shop_buy_time_small = -1
    	return
    endif
  endif
   
  if retreat_home then
	set l = GetUnitLoc(shop_sent)
	if DistanceBetweenPoints(l, home_location) >= 1100 then
		call CreateDebugTag("BUY_ITEM: Retreat to Home", 10, shop_sent, 3.00, 1.50)	
		call RemoveGuardPosition(shop_sent)
		if not IsUnitInGroup(shop_sent, going_home_group) then
			call IssuePointOrder(shop_sent, "move", GetLocationX(home_location), GetLocationY(home_location))
			call GroupAddUnit(going_home_group, shop_sent)
		elseif GetUnitCurrentOrder(shop_sent) == OrderId("stop") or GetUnitCurrentOrder(shop_sent) != OrderId("move") then
			call IssuePointOrder(shop_sent, "move", GetLocationX(home_location), GetLocationY(home_location))
		endif
		call TQAddJob(5, BUY_ITEM, id)
	else
		call GroupRemoveUnit(unit_buying_item, shop_sent)
		if IsUnitInGroup(shop_sent, going_home_group) then
			call GroupRemoveUnit(going_home_group, shop_sent)
		endif
		call RecycleGuardPosition(shop_sent)
		call CreateDebugTag("BUY_ITEM: Retreated", 10, shop_sent, 3.00, 1.50)
	    set shop_sent = null
		set retreat_home = false
		set shop_ordered = false
		set shop_buy_time_large = -1
		set shop_buy_time_small = -1
	endif
	call RemoveLocation(l)
	set l = null
	return
  endif
 
   if detectedenemies >= GetUnitStrength(shop_sent) and GetUnitTypeId(shop_unit) != old_id[racial_shop] then
	 call IssuePointOrder(shop_sent, "move", GetLocationX(home_location), GetLocationY(home_location))
    //call TQAddUnitJob(GetTimeToReachLoc(shop_sent, home_location), RESET_GUARD_POSITION, 1, shop_sent)
	set retreat_home = true
	call CreateDebugTag("BUY_ITEM: Enemies present so dont get item this time", 10, shop_sent, 3.00, 1.50) 
    call TQAddJob(0, BUY_ITEM, id)
	return
   endif

  if (shop_buy_time_large >= 0 and shop_buy_time_large + buy_timeout_large < current_time) or (shop_buy_time_small >= 0 and shop_buy_time_small + buy_timeout_small < current_time) then
    set available_time[id] = ai_time + regenerate_time[id] / 2
	call CreateDebugTag("Buy item timeout reached", 10, shop_sent, 3.00, 1.50) 	
    call RecycleGuardPosition(shop_sent)
	call GroupRemoveUnit(unit_buying_item, shop_sent)
    set shop_sent = null
    set shop_ordered = false
    set shop_buy_time_large = -1
    set shop_buy_time_small = -1
    return
  endif

	set healing = IsHealingItem(old_id[id])	

  
  if GetItemNumber(id) >= shop_wanted or shop_unit == null or (not UnitAlive(shop_unit)) or (shop_sent != null and GetSlotsFreeOnUnit(shop_sent) <= 0 and not healing) then
    call RecycleGuardPosition(shop_sent)
	call GroupRemoveUnit(unit_buying_item, shop_sent)
	call CreateDebugTag("BUT_ITEM: Items have been brought", 10, shop_sent, 3.00, 1.50) 
	call AddAssault(1, GetUnitTypeId(shop_sent))
    set shop_sent = null
    set shop_ordered = false
    set shop_buy_time_large = -1
    set shop_buy_time_small = -1
    return
  endif

  
  if shop_buy_time_large < 0 then
    set shop_buy_time_large = current_time
  endif
  call RemoveGuardPosition(shop_sent)
  set dist = DistanceBetweenUnits(shop_sent, shop_unit)
  if dist < buy_distance then
  		call CreateDebugTag("buy item", 10, shop_sent, 3.00, 1.50) 
		if GetSlotsFreeOnUnit(shop_sent) <= 0 and healing then
			call DropNonHealingItem(shop_sent)
		else
		    call IssueImmediateOrder(shop_sent, "stop")
		endif
		set ismoving = false
	if GetUnitTypeId(shop_unit) == old_id[racial_shop] then
		call IssueTargetOrderById(shop_unit, 'Aall', shop_sent)  // Change shop target to this hero
	endif
    call IssueNeutralImmediateOrderById(ai_player, shop_unit, old_id[id])
    if shop_buy_time_small < 0 then
      set shop_buy_time_small = current_time
    endif
    set time_next_try = 0.5
  else
  	call CreateDebugTag("move to item shop", 10, shop_sent, 3.00, 1.50) 
	if ismoving == false then
		set ismoving = true
		call IssuePointOrder(shop_sent, "move", GetUnitX(shop_unit), GetUnitY(shop_unit))
	elseif GetUnitCurrentOrder(shop_sent) == OrderId("stop") or GetUnitCurrentOrder(shop_sent) != OrderId("move") then
		call IssuePointOrder(shop_sent, "move", GetUnitX(shop_unit), GetUnitY(shop_unit))
	endif
    set time_next_try = 4
  endif

  call TQAddJob(time_next_try, BUY_ITEM, id)
endfunction
function HealthFountainJob takes unit u, integer p returns nothing

local real distance = 0
local integer nn = NEUTRAL_HEALING_FOUNTAIN
local unit fountain = nearest_neutral[nn]
local integer detectedenemies = GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 1000) 
local integer enemiesatfountain = GetLocationNonCreepStrength(GetUnitX(fountain), GetUnitY(fountain), 1000)
local boolean creepsawake = IsCreepsAwake(GetUnitX(fountain), GetUnitY(fountain), 1000)


  call DisplayToAllJobDebug("HEALTH_FOUNTAIN Start")

  call RemoveGuardPosition(u)
  if GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
    call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)
	return
  elseif fountain == null then
    call TQAddUnitJob(2, SEND_HOME, p, u)
	return
  elseif (DistanceBetweenUnits(u, fountain) <= 600 and (detectedenemies >= GetUnitStrength(u) or creepsawake)) or (MeleeDifficulty() == MELEE_INSANE and (enemiesatfountain >= GetUnitStrength(u) or creepsawake)) then
    call IssuePointOrder(u, "move", GetLocationX(home_location), GetLocationY(home_location))
	call GroupRemoveUnit(unit_healing, u)	
    call TQAddUnitJob(8, RESET_GUARD_POSITION, p, u)
  elseif GetUnitState(u, UNIT_STATE_LIFE) >= GetUnitState(u, UNIT_STATE_MAX_LIFE) * (I2R(p)/100) then
    call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)
	return
  else
     set distance = DistanceBetweenUnits(u, fountain)
    if distance >= buy_distance then
	if GetUnitAbilityLevel(u, 'Ashm') > 0 and GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 800) > 0 and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) <= 6) then
		call IssueImmediateOrder(u, "ambush")
    else
		if GetUnitCurrentOrder(u) != OrderId("move") then
			call IssuePointOrder(u, "move", GetUnitX(fountain), GetUnitY(fountain))
		endif
	endif
    elseif GetUnitAbilityLevel(u, 'Ashm') > 0 then
      call IssueImmediateOrder(u, "ambush")
    endif
    call TQAddUnitJob(8, HEALTH_FOUNTAIN, p, u)
  endif


endfunction
function ManaFountainJob takes unit u, integer p returns nothing

local real distance = 0
local integer nn = NEUTRAL_MANA_FOUNTAIN
local unit fountain = nearest_neutral[nn]
local integer detectedenemies = GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 1000) 
local integer enemiesatfountain = GetLocationNonCreepStrength(GetUnitX(fountain), GetUnitY(fountain), 1000)
local boolean creepsawake = IsCreepsAwake(GetUnitX(fountain), GetUnitY(fountain), 1000)

  call DisplayToAllJobDebug("MANA_FOUNTAIN Start")
  call RemoveGuardPosition(u)
  if GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
    call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)
	return
  elseif (DistanceBetweenUnits(u, fountain) <= 600 and (detectedenemies >= GetUnitStrength(u) or creepsawake)) or (MeleeDifficulty() == MELEE_INSANE and (enemiesatfountain >= GetUnitStrength(u) or creepsawake)) then
    call IssuePointOrder(u, "move", GetLocationX(home_location), GetLocationY(home_location))
    call TQAddUnitJob(8, RESET_GUARD_POSITION, p, u)
  elseif GetUnitState(u, UNIT_STATE_MANA) >= GetUnitState(u, UNIT_STATE_MAX_MANA) * (I2R(p)/100) then
    call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)
	return
  else
     set distance = DistanceBetweenUnits(u, fountain)
    if distance >= buy_distance then
	if GetUnitAbilityLevel(u, 'Ashm') > 0 and GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 800) > 0 and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) <= 6) then
		call IssueImmediateOrder(u, "ambush")
	else	
		if GetUnitCurrentOrder(u) != OrderId("move") then
			call IssuePointOrder(u, "move", GetUnitX(fountain), GetUnitY(fountain))
		endif
	endif
    elseif GetUnitAbilityLevel(u, 'Ashm') > 0 then
      call IssueImmediateOrder(u, "ambush")
    endif
    call TQAddUnitJob(8, MANA_FOUNTAIN, p, u)
  endif

endfunction

function TeleportHome takes unit u returns nothing
  local integer i = 0
  local player p = null
  local real distance = 9999999
  local location teleport_loc = null
  local real dx = 0
  local real dy = 0
  local real actual_diff = 0 
  local location start_loc = null
  local location hero_loc = null

  set hero_loc = GetUnitLoc(u)
  set break_attack = attack_running
  set attack_running = false
  call ClearCaptainTargets()	
  call CaptainGoHome()
  set teleporting = true
  if c_ally_total > 1 and UnitAlive(major_hero) and major_hero != null then
	  loop
		exitwhen i >= 12
	      set p = Player(i)
	      set start_loc =GetPlayerStartLocationLoc(p)
	      //set dx = GetLocationX(start_loc) - GetLocationX(hero_loc)
	      //set dy = GetLocationY(start_loc) - GetLocationY(hero_loc)
	      //set actual_diff = SquareRoot(dx * dx + dy * dy)
		  set actual_diff = DistanceBetweenPoints(start_loc, hero_loc)
	      if IsPlayerAlly(ai_player, p) and actual_diff < distance and GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING then
			set distance = actual_diff
			if teleport_loc != null then
				call RemoveLocation(teleport_loc)
			endif
	 	    set teleport_loc = Location(GetLocationX(start_loc), GetLocationY(start_loc))
	      endif
	      set i = i + 1
		if start_loc != null then
			call RemoveLocation( start_loc )
		endif
	  endloop 
	  call UnitUseItemPoint(u, GetItemOfTypeOnUnit(tp_item, u), GetLocationX(teleport_loc), GetLocationY(teleport_loc))
  	  call RemoveLocation(teleport_loc)
  	  set teleport_loc = null
  else
		call UnitUseItemPoint(u, GetItemOfTypeOnUnit(tp_item, u), GetLocationX(home_location), GetLocationY(home_location))
  endif
  set start_loc = null
  if hero_loc != null then
	call RemoveLocation( hero_loc )
	set hero_loc = null
  endif
  set p = null
  call TQAddUnitJob(0.5, TELEPORT, 0, u)
endfunction

function TeleportToLoc takes unit u, location l returns nothing
  set break_attack = attack_running
  set attack_running = false
  set teleporting = true
  call ClearCaptainTargets()	
  call CaptainGoHome()
  call UnitUseItemPoint(u, GetItemOfTypeOnUnit(tp_item, u), GetLocationX(l), GetLocationY(l))
  call TQAddUnitJob(0.5, TELEPORT, 0, u)
endfunction

function ExecuteSaveHero takes integer hn, integer a, unit healer returns nothing
  local location l = null
  local group g = null
  local location unitloc = null
  local location loc = null
  
  if a != ACTION_DO_NOTHING and a != ACTION_TP then
    call RemoveGuardPosition(hero_unit[hn])
	if not IsUnitInvisible(hero_unit[hn], Player(PLAYER_NEUTRAL_AGGRESSIVE)) then
		call IssueImmediateOrder(hero_unit[hn], "windwalk")
	endif
    if a != ACTION_HEALER and hero_unit[hn] == major_hero then
      set major_hero = null
    endif
  endif
  if a == ACTION_HEALER then
    call GroupAddUnit(unit_healing, hero_unit[hn])
	call CreateDebugTag("HERO: Going to Healer", 10, hero_unit[hn], 4.00, 2.00)
	set unitloc = GetUnitLoc(healer)
	if GetLocationX(last_enemy_loc) != 0 and GetLocationY(last_enemy_loc) != 0 then
		set l = GetProjectedLoc(unitloc, GetSubtractionLoc(unitloc, last_enemy_loc), 350)
		call TQAddUnitJob(GetTimeToReachLoc(hero_unit[hn], l) + 1, RESET_GUARD_POSITION, 0, hero_unit[hn])	
		call IssuePointOrderLoc(hero_unit[hn], "move", l)		
		call RemoveLocation(l)	
		set l = null		
	else
		call TQAddUnitJob(GetTimeToReachLoc(hero_unit[hn], unitloc) + 1, RESET_GUARD_POSITION, 0, hero_unit[hn])	
		call IssuePointOrderLoc(hero_unit[hn], "move", unitloc)
	endif	
	call RemoveLocation(unitloc)
	set unitloc = null
    call HealUnit(healer, hero_unit[hn], false)
  elseif a == ACTION_FOUNTAIN then
	call CreateDebugTag("HERO: Going to Fountain", 10, hero_unit[hn], 4.00, 2.00)  
	call GroupAddUnit(unit_healing, hero_unit[hn])
	call TQAddUnitJob(0, HEALTH_FOUNTAIN, 80, hero_unit[hn])
    call IssuePointOrder(hero_unit[hn], "move", GetUnitX(nearest_neutral[NEUTRAL_HEALING_FOUNTAIN]), GetUnitY(nearest_neutral[NEUTRAL_HEALING_FOUNTAIN]))
  elseif a == ACTION_MANA_FOUNTAIN then
	call CreateDebugTag("HERO: Going to Mana Fountain", 10, hero_unit[hn], 4.00, 2.00)  
    call GroupAddUnit(unit_healing, hero_unit[hn])
	call TQAddUnitJob(0, MANA_FOUNTAIN, 80, hero_unit[hn])    
    call IssuePointOrder(hero_unit[hn], "move", GetUnitX(nearest_neutral[NEUTRAL_MANA_FOUNTAIN]), GetUnitY(nearest_neutral[NEUTRAL_MANA_FOUNTAIN]))
  elseif a == ACTION_GO_HOME then
    //call UnitGoHome(hero_unit[hn])
	call CreateDebugTag("HERO: Going Home", 10, hero_unit[hn], 4.00, 2.00)
    call GroupAddUnit(unit_healing, hero_unit[hn])
    call TQAddUnitJob(0, SEND_HOME, 50, hero_unit[hn])
  elseif a == ACTION_ZEPPELIN_HOME then
	call CreateDebugTag("HERO: Zeppelin Home", 10, hero_unit[hn], 4.00, 2.00)	
    call GroupAddUnit(unit_rescueing, follow_zeppelin)
    set g = CreateGroup()
    call GroupAddUnit(g, follow_zeppelin)
    call GroupAddUnit(unit_healing, hero_unit[hn])	
    call TQAddGroupJob(0, ZEPPELIN_MOVE, ZTARGET_HOME, hero_unit[hn], g)
  elseif a == ACTION_ZEPPELIN_FOUNTAIN then
	call CreateDebugTag("HERO: Zepplin to fountain", 10, hero_unit[hn], 4.00, 2.00)  
    call GroupAddUnit(unit_rescueing, follow_zeppelin)
    set g = CreateGroup()
    call GroupAddUnit(g, follow_zeppelin)
    call GroupAddUnit(unit_healing, hero_unit[hn])	
    call TQAddGroupJob(0, ZEPPELIN_MOVE, ZTARGET_FOUNTAIN, hero_unit[hn], g)
  elseif a == ACTION_TP then
	call CreateDebugTag("Hero: Town Portalling", 10, hero_unit[hn], 4.00, 2.00)  
    call TeleportHome(hero_unit[hn])
  elseif a == ACTION_MOONWELLS then
 	call CreateDebugTag("HERO: Going to Moonwells", 10, hero_unit[hn], 4.00, 2.00) 
	call GroupAddUnit(unit_healing,hero_unit[hn])
  	call TQAddUnitJob(0, MOON_WELL_CONTROL, 80, hero_unit[hn])  
  endif
endfunction

function SaveHero takes integer hn returns nothing
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  local unit healer = GetHealer()
  call ActionListInit(9)
  // Initial Proirity Rules
  call ActionRule3(true, ACTION_FOUNTAIN, 40, ACTION_ZEPPELIN_FOUNTAIN, 45, ACTION_DO_NOTHING, -10)
  call ActionRule2(true, ACTION_MANA_FOUNTAIN, 5, ACTION_MOONWELLS, 30)
  call ActionRule2(true, ACTION_GO_HOME, 25, ACTION_ZEPPELIN_HOME, 35)
  call ActionRule2(true, ACTION_TP, 50, ACTION_HEALER, 8)
 
  //call ActionRule2(true, ACTION_GO_HOME, (1 - hero_hp[hn])*20, ACTION_ZEPPELIN_HOME, (1 - hero_hp[hn])*30)
  //call ActionRule2(true, ACTION_TP, (1 - hero_hp[hn])*15, ACTION_ZEPPELIN_FOUNTAIN, (1 - hero_hp[hn])*25)
  
  call ActionRule2(hero_hp_loss[hn] > 0.5, ACTION_TP, 40, ACTION_ZEPPELIN_HOME, 15)
  call ActionRule2((hero_enemy_density[hn] > 5) and (hero_hp_loss[hn] > 0.4), ACTION_TP, 200, ACTION_ZEPPELIN_HOME, 150)  
  //call ActionRule(true, ACTION_TP, DistanceBetweenPoints_kd(home_location, GetUnitLoc(hero_unit[hn]))*0.006)
  
  // Only here as a backup as getdensities may not totally be working correctly
  call ActionRule(GetLocationNonCreepStrength(GetUnitX(hero_unit[hn]), GetUnitY(hero_unit[hn]), 1500) * 2 < army_strength[GetArmyOfUnit(hero_unit[hn])] , ACTION_TP, -100000)
  
  call ActionRule(DistanceBetweenPoints_kd(home_location, GetUnitLoc(hero_unit[hn])) < 2000 and (hero_enemy_density[hn] > 1), ACTION_TP, -100)
  call ActionRule(DistanceBetweenPoints_kd(home_location, GetUnitLoc(hero_unit[hn])) < 2000 and (hero_enemy_density[hn] < 1), ACTION_TP, -1000000)
  call ActionRule(town_threatened, ACTION_TP, -100000)
  
  //call ActionRule(DistanceBetweenPoints_kd(home_location, GetUnitLoc(hero_unit[hn])) < 2500, ACTION_TP, -1000000)
  call ActionRule( army_strength[GetArmyOfUnit(hero_unit[hn])] < teleport_army_min_strength  ,ACTION_TP, -100)  
  //call ActionRule( army_strength[GetArmyOfUnit(hero_unit[hn])] < enemy_strength_sum, ACTION_TP, -1000000) 
  //call ActionRule3(true, ACTION_TP, (I2R(GetHeroLevel(hero_unit[hn]))*14)-20, ACTION_ZEPPELIN_HOME, I2R(GetHeroLevel(hero_unit[hn]))*8, ACTION_ZEPPELIN_FOUNTAIN, I2R(GetHeroLevel(hero_unit[hn]))*6)

  // Rules of action failure
  call ActionRule(not race_has_moonwells or TownCountDone(racial_farm) <= 0, ACTION_MOONWELLS,-1000000)
  if nearest_neutral[NEUTRAL_HEALING_FOUNTAIN] != null then
  	call ActionRule(DistanceBetweenPoints_dd(GetUnitLoc(nearest_neutral[NEUTRAL_HEALING_FOUNTAIN]),GetUnitLoc(hero_unit[hn])) > DistanceBetweenPoints_kd(home_location,GetUnitLoc(hero_unit[hn])), ACTION_MOONWELLS, 18) // Use moonwells if they closer than the fountain
  else
	call ActionRule(true,ACTION_MOONWELLS, 18)
  endif
  call ActionRule2(follow_zeppelin == null or IsUnitInGroup(follow_zeppelin, unit_rescueing),  ACTION_ZEPPELIN_HOME, -1000000.0, ACTION_ZEPPELIN_FOUNTAIN, -1000000.0)
  call ActionRule3(not race_use_fountain, ACTION_FOUNTAIN, -100.0, ACTION_ZEPPELIN_FOUNTAIN, -100.0, ACTION_MANA_FOUNTAIN, -100.0)
  call ActionRule2(nearest_neutral[NEUTRAL_HEALING_FOUNTAIN] == null, ACTION_FOUNTAIN, -1000000, ACTION_ZEPPELIN_FOUNTAIN, -1000000)
  call ActionRule(nearest_neutral[NEUTRAL_MANA_FOUNTAIN] == null, ACTION_MANA_FOUNTAIN, -1000000)
  call ActionRule2(not neutral_available[NEUTRAL_HEALING_FOUNTAIN] or (neutral_guarded[NEUTRAL_HEALING_FOUNTAIN] and (not neutral_night_buy[NEUTRAL_HEALING_FOUNTAIN] or daytime < 18)) or GetLocationNonCreepStrength(GetUnitX(nearest_neutral[NEUTRAL_HEALING_FOUNTAIN]), GetUnitY(nearest_neutral[NEUTRAL_HEALING_FOUNTAIN]), 1500) > 0 , ACTION_FOUNTAIN, -1000000.0, ACTION_ZEPPELIN_FOUNTAIN, -1000000.0)
  call ActionRule(not neutral_available[NEUTRAL_MANA_FOUNTAIN] or (neutral_guarded[NEUTRAL_MANA_FOUNTAIN] and (not neutral_night_buy[NEUTRAL_MANA_FOUNTAIN] or daytime < 18)) or GetLocationNonCreepStrength(GetUnitX(nearest_neutral[NEUTRAL_MANA_FOUNTAIN]), GetUnitY(nearest_neutral[NEUTRAL_MANA_FOUNTAIN]), 1500) > 0 , ACTION_MANA_FOUNTAIN, -1000000.0)
  call ActionRule(GetItemNumberOnUnit(tp_item, hero_unit[hn]) <= 0, ACTION_TP, -1000000)
  call ActionRule(healer == null, ACTION_HEALER, -1000000)

  
    call ExecuteSaveHero(hn, ActionListEval(), healer)
endfunction

function MicroHeroJob takes integer hn returns nothing
  local real new_hp = 0.0
  local real teleportdistance = 0.0
  local integer current_order = 0 

  call DisplayToAllJobDebug("MICRO_HERO Job start")
  
  // A Temporary Bug fix
      if GetUnitState(hero_unit[hn], UNIT_STATE_LIFE) == GetUnitState(hero_unit[hn], UNIT_STATE_MAX_LIFE) and IsUnitInGroup(hero_unit[hn], unit_healing) then
		call CreateDebugTag("HERO: Healing Bug Fix", 10, hero_unit[hn], 4.00, 2.00)
		call RecycleGuardPosition(hero_unit[hn])
		call GroupRemoveUnit(unit_healing, hero_unit[hn])
      endif
  //
  
  set new_hp = GetUnitState(hero_unit[hn], UNIT_STATE_LIFE) / GetUnitState(hero_unit[hn], UNIT_STATE_MAX_LIFE)
  set current_order = GetUnitCurrentOrder(hero_unit[hn])
  
  if UnitAlive(hero_unit[hn]) then
	//  call DisplayToAll("MicroH Start")
      if hero_dir[hn] != null then
	  	call RemoveLocation(hero_dir[hn])
	  endif
	  //set hero_dir[hn] = GetSubtractionLoc_dd(GetUnitLoc(hero_unit[hn]), hero_loc[hn])
	  set hero_dir[hn] = hero_loc[hn]
	  set hero_loc[hn] = GetUnitLoc(hero_unit[hn])
	  set hero_hp_loss[hn] = hero_hp[hn] - new_hp
	  set hero_hp[hn] = new_hp
	  call GetDensities(hero_loc[hn], ai_player, hero_radius)
	  set hero_enemy_density[hn] = enemy_density
	  call MoveLocation(hero_enemy_loc[hn], GetLocationX(enemy_density_loc), GetLocationY(enemy_density_loc))
	  set hero_ally_density[hn] = ally_density
	  call MoveLocation(hero_ally_loc[hn], GetLocationX(ally_density_loc), GetLocationY(ally_density_loc))
	  
	  if not teleporting and current_order >= 852008 and current_order <= 852013 then
	    if GetItemTypeId(UnitItemInSlot(hero_unit[hn], current_order - 852008)) == old_id[tp_item] then
	      set teleporting = true
	      call TQAddUnitJob(0.5, TELEPORT, 0, hero_unit[hn])
	    endif
	  endif
	  
	//  call DisplayToAll("Hero Order: "+Int2Str(GetUnitCurrentOrder(hero_unit[hn])))

	//  call DisplayToAll(Int2Str(R2I(hero_enemy_density[hn] * 10)))
	//  call DisplayToAll(Int2Str(R2I(DistanceBetweenPoints(hero_enemy_loc[hn],GetUnitLoc(hero_unit[hn])))))

	  set teleportdistance =  DistanceBetweenPoints(hero_loc[hn], town_loc[most_threatened_town]) 
	  if not teleporting and GetUnitState(hero_unit[hn], UNIT_STATE_LIFE) < RMax(flee_health_percentage * GetUnitState(hero_unit[hn], UNIT_STATE_MAX_LIFE), flee_minimum_health) and not IsUnitInGroup(hero_unit[hn], unit_healing) then
	    call SaveHero(hn)
	  elseif not teleporting and town_threatened and town_threat[most_threatened_town] >= teleport_min_threat and teleportdistance > LinearInterpolation(teleport_low_threat, teleport_high_threat, teleport_low_threat_distance, teleport_high_threat_distance, town_threat[most_threatened_town]) and GetItemNumberOnUnit(tp_item, hero_unit[hn]) > 0 and town_can_tp[most_threatened_town] and army_strength[GetArmyOfUnit(hero_unit[hn])] >= teleport_army_min_strength then
	      if LinearInterpolation(ver_low_aggression,ver_high_aggression,ver_flee_multiple1,ver_flee_multiple2,attacking_aggression)*own_strength > army_strength[town_threat_army[most_threatened_town]] then
			//call PingMinimap(GetLocationX(hero_loc[hn]), GetLocationY(hero_loc[hn]), 10.00)
		    //call PingMinimap(GetLocationX(town_loc[most_threatened_town]), GetLocationY(town_loc[most_threatened_town]), 10.00)	
			//call DisplayToAll("Protection Town Portal: " + Int2Str(R2I(teleportdistance)))
			call CreateDebugTag("HERO: Teleporting to threatened town", 10, hero_unit[hn], 4.00, 2.00)		
			call TeleportToLoc(hero_unit[hn], town_loc[most_threatened_town])
		  elseif DistanceBetweenPoints(hero_loc[hn], home_location) > 2500 then
		  		call CreateDebugTag("HERO: Teleporting home town too threatened", 10, hero_unit[hn], 4.00, 2.00)	
		      call TeleportHome(hero_unit[hn])
		  endif
	 // Next statement detects when the main army is outmatched and so teleports back to home base
	 elseif not teleporting and attack_running and IsUnitInRangeXY(hero_unit[hn],GetLocationX(army_loc[main_army]), GetLocationY(army_loc[main_army]), battle_radius) and GetItemNumberOnUnit(tp_item, hero_unit[hn]) > 0 and army_strength[GetArmyOfUnit(hero_unit[hn])] >= teleport_army_min_strength and CaptainRetreating() and isfleeing and DistanceBetweenPoints(hero_loc[hn], home_location) > teleport_low_threat_distance then
		call CreateDebugTag("HERO: Army outmatched-teleporting home", 10, hero_unit[hn], 4.00, 2.00)
		call TeleportHome(hero_unit[hn])
	 elseif not teleporting and hero_enemy_density[hn] > 5 and IsUnitInGroup(hero_unit[hn], unit_healing) and DistanceBetweenPoints(hero_dir[hn],hero_loc[hn]) <= 225 then
		call CreateDebugTag("HERO: Surround Detection Teleportation", 10, hero_unit[hn], 4.00, 2.00)
		call TeleportHome(hero_unit[hn])		
	 endif
  endif
  call TQAddJob(1, MICRO_HERO, hn)
  //call DisplayToAll("MICRO_HERO END")
endfunction




  

function StatueControl takes unit u returns nothing
  local location statue_loc = GetProjectedLoc(last_ally_loc, GetSubtractionLoc(last_ally_loc, last_enemy_loc), statue_distance)
  local location unitloc = GetUnitLoc(u)
  if DistanceBetweenPoints(unitloc, statue_loc) > 200 then
    call IssuePointOrderLoc(u, "move", statue_loc)
  endif
  call RemoveLocation(statue_loc)
  set statue_loc = null
  call RemoveLocation(unitloc)
  set unitloc = null
endfunction

function SaveUnit takes unit u returns nothing
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  local unit healer = GetHealer()
  local location l = null
  local group g = null
  local location unitloc = null
  local location temploc = null
  
  if IsUnitType(u, UNIT_TYPE_HERO) then
    return
  endif
  
  if (GetUnitTypeId(u) == old_id[racial_militia]) then
	return
  endif
  
  call RemoveGuardPosition(u)
  if not IsUnitInvisible(u, Player(PLAYER_NEUTRAL_AGGRESSIVE)) then
	call IssueImmediateOrder(u, "windwalk")
  endif
  if healer != null and not IsUnitType(u, UNIT_TYPE_MECHANICAL) then
	call CreateDebugTag("Going to Healer", 10, u, 3.00, 1.50)	
	set unitloc = GetUnitLoc(healer)
	if GetLocationX(last_enemy_loc) != 0 and GetLocationY(last_enemy_loc) != 0 then
		set l = GetProjectedLoc(unitloc, GetSubtractionLoc(unitloc, last_enemy_loc), 350)
		call TQAddUnitJob(GetTimeToReachLoc(u, l) + 1, RESET_GUARD_POSITION, 0, u)
		call IssuePointOrderLoc(u, "move", l)	
		call RemoveLocation(l)
		set l = null		
	else
		call TQAddUnitJob(GetTimeToReachLoc(u, unitloc) + 1, RESET_GUARD_POSITION, 0, u)
		call IssuePointOrderLoc(u, "move", unitloc)				
	endif
    call GroupAddUnit(unit_healing, u)
	call RemoveLocation(unitloc)
	set unitloc = null
    call HealUnit(healer, u, false)
  elseif race_use_fountain and not IsUnitType(u, UNIT_TYPE_PEON) and not IsUnitType(u, UNIT_TYPE_MECHANICAL) and neutral_enemy[NEUTRAL_HEALING_FOUNTAIN] <= 0 and not (GetUnitTypeId(u) == old_id[racial_ghoul]) and not (GetUnitTypeId(u) == old_id[racial_militia]) and neutral_available[NEUTRAL_HEALING_FOUNTAIN] and nearest_neutral[NEUTRAL_HEALING_FOUNTAIN] != null and (not neutral_guarded[NEUTRAL_HEALING_FOUNTAIN] or (neutral_night_buy[NEUTRAL_HEALING_FOUNTAIN] and daytime >= 18 and nearest_neutral[NEUTRAL_HEALING_FOUNTAIN] != null))  then
    if follow_zeppelin != null and not IsUnitInGroup(follow_zeppelin, unit_rescueing) and not IsUnitType(u, UNIT_TYPE_FLYING) then
		call CreateDebugTag("Zepplin to fountain", 10, follow_zeppelin, 3.00, 1.50)
      call GroupAddUnit(unit_rescueing, follow_zeppelin)
      set g = CreateGroup()
      call GroupAddUnit(g, follow_zeppelin)
		call GroupAddUnit(unit_healing, u)	  
      call TQAddGroupJob(0, ZEPPELIN_MOVE, ZTARGET_FOUNTAIN, u, g)
    else
		call GroupAddUnit(unit_healing, u)
	  	call CreateDebugTag("Going to Fountain", 10, u, 3.00, 1.50)
		call TQAddUnitJob(0, HEALTH_FOUNTAIN, 80, u)
     	call IssuePointOrder(u, "move", GetUnitX(nearest_neutral[NEUTRAL_HEALING_FOUNTAIN]), GetUnitY(nearest_neutral[NEUTRAL_HEALING_FOUNTAIN]))  
    endif
  elseif race_has_moonwells and TownCountDone(racial_farm) > 0 then
    if follow_zeppelin != null and not IsUnitInGroup(follow_zeppelin, unit_rescueing) and not IsUnitType(u, UNIT_TYPE_FLYING) then
		call GroupAddUnit(unit_rescueing, follow_zeppelin)
		call CreateDebugTag("Zeppelin to Moonwells", 10, u, 3.00, 1.50)
		set g = CreateGroup()
		call GroupAddUnit(g, follow_zeppelin)
		call GroupAddUnit(unit_healing, u)	
		call TQAddGroupJob(0, ZEPPELIN_MOVE, ZTARGET_MOONWELLS, u, g)		
	else
		call CreateDebugTag("Going to Moonwells", 10, u, 3.00, 1.50)
		call GroupAddUnit(unit_healing, u)
		call TQAddUnitJob(0, MOON_WELL_CONTROL, 80, u)
	endif
  //elseif GetUnitCurrentOrder(u) != OrderId("move") then	
  elseif follow_zeppelin != null and not IsUnitInGroup(follow_zeppelin, unit_rescueing) and not IsUnitType(u, UNIT_TYPE_FLYING) then
	call CreateDebugTag("Zepplin Home", 10, u, 3.00, 1.50)
    call GroupAddUnit(unit_rescueing, follow_zeppelin)
    set g = CreateGroup()
    call GroupAddUnit(g, follow_zeppelin)
	call GroupAddUnit(unit_healing, u)	
    call TQAddGroupJob(0, ZEPPELIN_MOVE, ZTARGET_HOME, u, g)
  else
	call CreateDebugTag("Going Home", 10, u, 3.00, 1.50)
    call GroupAddUnit(unit_healing, u)
    call TQAddUnitJob(0, SEND_HOME, 50, u)
    //call TQAddUnitJob(GetTimeToReachLoc(u, home_location) + 1, RESET_GUARD_POSITION, 0, u)
    //call IssuePointOrderLoc(u, "move", home_location)			 
  
  endif
endfunction

function GetMana takes unit u returns nothing
	local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
	
	if race_use_fountain and GetUnitState(u, UNIT_STATE_MANA) < GetUnitState(u, UNIT_STATE_MAX_MANA) * 0.4 and not IsUnitType(u, UNIT_TYPE_PEON) and neutral_enemy[NEUTRAL_MANA_FOUNTAIN] <= 0 and not (GetUnitTypeId(u) == old_id[racial_ghoul]) and not (GetUnitTypeId(u) == old_id[racial_militia]) and neutral_available[NEUTRAL_MANA_FOUNTAIN] and nearest_neutral[NEUTRAL_MANA_FOUNTAIN] != null and (not neutral_guarded[NEUTRAL_MANA_FOUNTAIN] or (neutral_night_buy[NEUTRAL_MANA_FOUNTAIN] and daytime >= 18 and nearest_neutral[NEUTRAL_MANA_FOUNTAIN] != null)) then
		call CreateDebugTag("Going to mana fountain", 10, u, 3.00, 1.50)	  
		call GroupAddUnit(unit_healing, u)
		call TQAddUnitJob(8, MANA_FOUNTAIN, 80, u)    
		call IssuePointOrder(u, "move", GetUnitX(nearest_neutral[NEUTRAL_MANA_FOUNTAIN]), GetUnitY(nearest_neutral[NEUTRAL_MANA_FOUNTAIN]))
	endif
endfunction

function MicroUnitsJob takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  local real unit_life = 0
  local real unit_mana = 0
  local group new_healer_group = CreateGroup()
  local boolean ward_check = false
  local boolean prev_ward = ward_cast
  local location unitloc = null

  
  local real health_sum = 0.0
  local integer count = 0
  local real unit_health_ratio = 0.0

  if major_hero == null or not UnitAlive(major_hero) then
    set major_hero = GetMajorHero()
  endif

  //call DisplayToAllJobDebug("MICRO_UNITS Job Started") 

  //call GroupEnumUnitsInRange(g,GetUnitX(major_hero),GetUnitY(major_hero),battle_radius,null)
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectByAlive(g, true)  
  set g = SelectByUnitStandard(g, true)
  set g = SelectUnittype(g,UNIT_TYPE_PEON,false)
  set g = SelectUnittype(g,UNIT_TYPE_STRUCTURE,false)
  set g = SelectUnittype(g,UNIT_TYPE_SUMMONED,false)
  //call DisplayToAll("MICRO_UNITS: Group made") 
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
	//call DisplayToAllJobDebug("MICRO_UNITS: Main Loop")
    set unit_life = GetUnitState(u, UNIT_STATE_LIFE)
    set unit_mana = GetUnitState(u, UNIT_STATE_MANA)
    set unitloc = GetUnitLoc(u)	
    //if (attack_running or town_threatened) then //and DistanceBetweenUnits(major_hero, u) <= battle_radius then
	  //call Trace("MIRCO_UNITS: Attack healing section")
      //if IsPlayerAlly(GetOwningPlayer(u), ai_player) then
	    //call Trace("MICRO_UNITS: Friendly Unit")
        if GetUnitTypeId(u) == 'ohwd' then
	        if GetOwningPlayer(u) == ai_player then
	          set ward_check = true
	        endif
        endif
        if not (IsUnitType(u, UNIT_TYPE_MECHANICAL)) and not IsUnitIllusion(u) and GetUnitFoodUsed(u) > 0 and unit_life < RMax(flee_health_percentage * GetUnitState(u, UNIT_STATE_MAX_LIFE), flee_minimum_health) then
			call SaveUnit(u)
        else
            if GetUnitTypeId(u) == oOBSIDIAN_STATUE then
			    //call DisplayToAllJobDebug("MICRO_UNITS: Statue Control")
				if attack_running and GetLocationX(last_enemy_loc) != 0 and GetLocationY(last_enemy_loc) != 0 then
					call StatueControl(u)
				endif
				//call DisplayToAllJobDebug("MICRO_UNITS: Statue Control end")
            endif
            if IsUnitHealer(u) then
				call GroupAddUnit(new_healer_group, u)
            endif
              //if GetUnitFoodUsed(u) > 0 and unit_mana < RMax(0.35 * GetUnitState(u, UNIT_STATE_MAX_MANA), 50) then
            	//call GetMana(u)
		      //endif
		endif
      //else
      //endif
	//else
		// HEAL ARMY CODE
		//INCONSISTENCY  - NOT MODDABLE DETECTED HERE
		//if GetUnitTypeId(u) == 'ohwd' then
			//set ward_cast = true
		//endif
		// ///////////////////////////////////
		//if not (IsUnitType(u, UNIT_TYPE_MECHANICAL)) then
		//	set unit_health_ratio = unit_life / GetUnitState(u, UNIT_STATE_MAX_LIFE)
		//	set health_sum = health_sum + unit_health_ratio
		//	set count = count + 1


		//	if GetHealerId(GetUnitTypeId(u)) != -1 and GetUnitState(u, UNIT_STATE_MANA) >= (healer_mana_cost[GetHealerId(GetUnitTypeId(u))] * 2) / 3 and ((healer_upg_id[GetHealerId(GetUnitTypeId(u))] == 0) or (GetUpgradeLevel(healer_upg_id[GetHealerId(GetUnitTypeId(u))]) >= healer_upg_level[GetHealerId(GetUnitTypeId(u))])) then
		//		call GroupAddUnit(new_healer_group, u)
		//	endif	
		
		//	if not IsUnitInGroup(u, unit_healing) then
		//		if unit_life < RMax(flee_health_percentage * GetUnitState(u, UNIT_STATE_MAX_LIFE), flee_minimum_health) then
		//		    //call DisplayToAllJobDebug("MICRO_UNITS Special Extra Save")
		//			call SaveUnit(u)
		//		elseif unit_health_ratio <= 0.5 then
		//		    //call DisplayToAllJobDebug("MICRO_UNITS Make Unit Heal")
		//			call MakeUnitHeal(u) 
		//		endif
		//	endif
		//endif		
	//endif
		
    call GroupRemoveUnit(g,u)
	call RemoveLocation(unitloc)
	set unitloc = null
  endloop
  call DestroyGroup(g)
  set g = null
 
  //call DisplayToAll("MICRO_UNITS: Clear up code")
  if prev_ward or not ward_cast then
    set ward_cast = ward_check
  endif
  call DestroyGroup(healer_group)
  set healer_group = new_healer_group
  set new_healer_group = null


  call TQAddJob(1 * sleep_multiplier, MICRO_UNITS, 0)
  //call DisplayToAll("MICRO_UNITS END")

endfunction

function GetZTargetLocation takes integer target returns location
  if target == ZTARGET_HOME then
    return Location(GetLocationX(home_location), GetLocationY(home_location)) // Need to make new location otherwise home_location would be cleared
  elseif target == ZTARGET_MOONWELLS then
	return Location(GetLocationX(home_location), GetLocationY(home_location))
  else
    return GetUnitLoc(nearest_neutral[NEUTRAL_HEALING_FOUNTAIN])
  endif
endfunction

function AddZepFinishingJob takes integer target, integer wait, unit hu returns nothing
      if target == ZTARGET_FOUNTAIN then
		call TQAddUnitJob(wait, HEALTH_FOUNTAIN, 80, hu)
	  elseif target == ZTARGET_MOONWELLS then
		call TQAddUnitJob(wait, MOON_WELL_CONTROL, 80, hu)		
      else
		call TQAddUnitJob(wait, SEND_HOME, 50, hu)
      endif		
endfunction

function ZeppelinMoveJob takes integer target, unit hu, group z returns nothing
  local location tl = null
  local unit zep = FirstOfGroup(z)
  local location zeploc = null
  local location heroloc = null
  local integer clearvars = 0  //=1.. Zepplin system can now finish so return

  if GetUnitState(hu, UNIT_STATE_LIFE) <= 0 then
	call GroupRemoveUnit(unit_rescueing, zep)
	call DestroyGroup(z)
	return
  endif
  
  call DisplayToAllJobDebug("ZEPPELIN_MOVE Start")
  if not UnitAlive(zep) then
	call AddZepFinishingJob(target, 1,hu)
    call DestroyGroup(z)
    return
  endif
  
  set zeploc = GetUnitLoc(zep)
  set heroloc = GetUnitLoc(hu)
  set tl = GetZTargetLocation(target)
  if IsUnitInTransport(hu, zep) then
    if DistanceBetweenPoints(zeploc, tl) > 1000 and not zepdropping then  // and DistanceBetweenPoints(zeploc, ally_loc) < 1500 then
      call IssuePointOrderLoc(zep, "move", tl)
	  call CreateDebugTag("Move to safe location", 10, zep, 3.00, 1.50)
    else
	  if not zepdropping then
		call IssueImmediateOrder(zep, "stop")
	  endif
	  set zepdropping = true
      //call IssueTargetOrder(zep, "unload", hu)
	  call IssuePointOrder(zep, "unloadall", GetUnitX(zep), GetUnitY(zep))
	  call CreateDebugTag("unload unit", 10, zep, 3.00, 1.50)
	  call AddZepFinishingJob(target, 1,hu)
    endif
  elseif not IsUnitInTransport(hu,zep) and (zepdropping or GetUnitState(hu,UNIT_STATE_LIFE)>= GetUnitState(hu,UNIT_STATE_MAX_LIFE)) then
	set zepdropping = false
	call GroupRemoveUnit(unit_rescueing, zep)
	set clearvars = 1
 	call DestroyGroup(z)
  elseif not zepdropping then
    if DistanceBetweenPoints(heroloc, tl) < 1500 then //or DistanceBetweenPoints(zeploc, ally_loc) > 1300 then
	  call AddZepFinishingJob(target, 1,hu)
      call GroupRemoveUnit(unit_rescueing, zep)
      call DestroyGroup(z)
	  set clearvars = 1
    else
	  call CreateDebugTag("Pick up unit", 10, zep, 3.00, 1.50)
      call IssueTargetOrder(zep, "smart", hu)	
      call IssueTargetOrder(hu, "smart", zep)
    endif
  endif
  
  if tl != null then
  call RemoveLocation(tl)
  set tl = null
  endif
  if zeploc != null then
  call RemoveLocation(zeploc)
  set zeploc = null
  endif
  if heroloc != null then
  call RemoveLocation(heroloc)
  set heroloc = null
  endif
  if clearvars == 1 then 
	return
  endif
  call TQAddGroupJob(2, ZEPPELIN_MOVE, target, hu, z)
endfunction
function TeleportJob takes unit hu returns nothing
  local group g = CreateGroup()
  local unit u = null
  local integer current_order = GetUnitCurrentOrder(hu)

  call DisplayToAllJobDebug("TELEPORT JOB Start")
  if not UnitAlive(hu) or current_order < 852008 or current_order > 852013 then
    call TeleportCaptain(GetUnitX(hu), GetUnitY(hu))
    set teleporting = false
    call DestroyGroup(g)
    set g = null
    return
  endif
  call GroupEnumUnitsInRange(g, GetUnitX(hu), GetUnitY(hu), 2 * teleport_radius, null)
  set g = SelectByPlayer(g, ai_player, true)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, false)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if DistanceBetweenUnits(hu, u) > teleport_radius then
      call IssuePointOrder(u, "move", GetUnitX(hu), GetUnitY(hu))
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  call TQAddUnitJob(1, TELEPORT, 0, hu)
endfunction
function GetHarassPeonTarget takes unit u returns unit
  local group g = CreateGroup()
  local location unitloc = GetUnitLoc(u)
  local player p = GetNearestEnemyToLoc_k(unitloc)
  local unit tempu = null
  
  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectUnittype(g, UNIT_TYPE_PEON, true)
  set g = SelectByAlive(g, true)
  set g = SelectByLoaded(g, false)
  set g = SelectByHidden(g, false) // Hopefully to get peons not currently building
  set tempu = GetNearestOfGroup(g, unitloc)
  call RemoveLocation(unitloc)
  call DestroyGroup(g)
  set unitloc = null
  set g = null
  set p = null
  return tempu 
endfunction

function GetHarassExpansionTarget takes unit u returns unit
  local group g = CreateGroup()
  local location unitloc = GetUnitLoc(u)
  local player p = GetNearestEnemyToLoc_k(unitloc)  
  local location baseloc = GetPlayerStartLocationLoc(p)
  local unit tempu = null
  
  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectUnittype(g, UNIT_TYPE_TOWNHALL, true)
  set g = SelectByLocation(g, baseloc, 1000, false)
  set g = SelectByAlive(g, true)
  set tempu = GetNearestOfGroup(g, unitloc)
  call RemoveLocation(unitloc)
  call RemoveLocation(baseloc)
  call DestroyGroup(g)
  set unitloc = null
  set g = null
  set p = null
  set baseloc = null
  return tempu 
endfunction

function GetHarassLocationTarget takes real x, real y returns unit
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsInRange(g, x, y, 1000, null)
  set g = SelectByEnemy(g, ai_player, true)
  set g = SelectByAlive(g, true)
  set u = GetLeastHPUnitOfGroup(g)
  set g = null
  return u
endfunction

function GetHarassMainHallTarget takes unit u returns unit
  local group g = CreateGroup()
  local location unitloc = GetUnitLoc(u)
  local player p = GetNearestEnemyToLoc_k(unitloc)  
  local location baseloc = GetPlayerStartLocationLoc(p)
  local unit tempu = null
  
  call GroupEnumUnitsOfPlayer(g, p, null)
  set g = SelectUnittype(g, UNIT_TYPE_TOWNHALL, true)
  set g = SelectByLocation(g, baseloc, 1000, true)
  set g = SelectByAlive(g, true)
  set tempu = GetNearestOfGroup(g, unitloc)
  call RemoveLocation(unitloc)
  call RemoveLocation(baseloc)
  call DestroyGroup(g)
  set unitloc = null
  set g = null  
  set p = null
  set baseloc = null
  return tempu
endfunction

function GroupOrderWindWalkInstant_d takes group g returns nothing
	local unit u = null
	loop
		set u = FirstOfGroup(g)
		exitwhen u == null
		if not IsUnitInvisible(u, Player(PLAYER_NEUTRAL_AGGRESSIVE)) then
			//call CreateDebugTag("HARASS: WINDWALK COMMANDED", 10, u, 3.00, 1.50)
			call IssueImmediateOrder(u, "windwalk")
		endif
		call GroupRemoveUnit(g, u)
	endloop
	call DestroyGroup(g)
endfunction

function HarassJob takes integer ht, unit targ, group harasser returns nothing
  local unit target = targ
  local string key = Int2Str(H2I(harasser))
  local real strength_limit = GetStoredReal(additional_info, key, "Strength_Limit")
  local boolean state_attacking = GetStoredBoolean(additional_info, key, "State_Attacking")
  local real flee_percent = GetStoredReal(additional_info, key, "Flee_Percent")
  local boolean avoiding_towers = GetStoredBoolean(additional_info, key, "Avoid_Towers")
  local boolean state_retreat = GetStoredBoolean(additional_info, key, "State_Retreat")
  local real start_strength = GetStoredReal(additional_info, key, "Start_Strength")
  local group g = null
  local unit u = null
  local real strength_sum = 0
  local real player_sum = 0
  local integer harass_num = 0
  local boolean towersdetected = false
  local location l = null
  local boolean hero_harass = false
  local integer hiddencount = GetStoredInteger(additional_info, key, "Invisible_Count")
  local integer timedelay = GetStoredInteger(additional_info, key, "Windwalk_Count") // Delay count so windwalkers show themselves after a period of waiting

  call DisplayToAllJobDebug("HARASS JOB START")
  if not UnitAliveInGroup(harasser) then
    return
  endif

  if FirstOfGroup(harasser) == hero_unit[1] or FirstOfGroup(harasser) == hero_unit[2] then
	set hero_harass = true
  endif
  
  if (town_threatened and not state_attacking) or (town_threatened and hero_harass) then
    call TQAddGroupJob(5 * sleep_multiplier, HARASS, ht, target, harasser)
	return
  endif
  
  set l = GetUnitLoc(FirstOfGroup(harasser))
  if state_retreat and DistanceBetweenPoints(l, home_location) > 1000 then
	call GroupOrderWindWalkInstant_d(CopyGroup(harasser))
	call GroupPointOrder(harasser, "move", GetLocationX(home_location), GetLocationY(home_location))
	call TQAddGroupJob(3 * sleep_multiplier, HARASS, ht, target, harasser)
	//call GroupRemoveUnit(unit_harassing, FirstOfGroup(harasser))
	call RemoveLocation(l)
	set l = null
	return
  elseif state_retreat then
    call StoreBoolean(additional_info, key, "State_Retreat", false)
	//call GroupRecycleGuardPositionInstant(harasser)
	call GroupRecycleHarrassPositionInstant(harasser)
	call RemoveLocation(l)
	set l = null
	return
  endif
  	call RemoveLocation(l)
	set l = null
  
  if target != null and (IsUnitHidden(target) or IsUnitLoaded(target) or IsUnitInvisible(target, ai_player)) then	// Checks to see if unit is not targetable and after small period will change to target it can hit
	set hiddencount = hiddencount + 1
	call StoreInteger(additional_info, key, "Inisible_Count", hiddencount)
  else
	set hiddencount = 0
	call StoreInteger(additional_info, key, "Inisible_Count", hiddencount)
  endif
  
  if target == null or not UnitAlive(target) or hiddencount > 2 then
  	if target != null then
		call GroupOrderWindWalkInstant_d(CopyGroup(harasser))
	endif
    if ht == HARASS_TARGET_PEONS then
      set target = GetHarassPeonTarget(FirstOfGroup(harasser))
    elseif ht == HARASS_TARGET_EXPANSION then
      set target = GetHarassExpansionTarget(FirstOfGroup(harasser))
    elseif ht == HARASS_TARGET_LOCATION then
      set target = GetHarassLocationTarget(GetStoredReal(additional_info, key, "LocationX"), GetStoredReal(additional_info, key, "LocationY"))
    else
      set target = GetHarassMainHallTarget(FirstOfGroup(harasser))
    endif
  endif
  
  
	//if not state_attacking then	// first run
	    if avoiding_towers and GetLocationTowerStrength(GetUnitX(target), GetUnitY(target), ver_harass_tower_check_radius) > 0 then
			set target = null
	    else
			//call GroupRemoveGuardPositionInstant(harasser)
			
		endif
	//endif
  
  if target != null and UnitAlive(target) then
  
    set g = CreateGroup()
    //if state_attacking then
    //  call GroupEnumUnitsInRange(g,GetUnitX(FirstOfGroup(harasser)),GetUnitY(FirstOfGroup(harasser)),harass_radius_attack_melee,null)
    //else
    //  call GroupEnumUnitsInRange(g,GetUnitX(FirstOfGroup(harasser)),GetUnitY(FirstOfGroup(harasser)),harass_radius_flee_melee,null)
    //endif
	//set g = SelectByAlive(g, true)
    //loop
    //  set u = FirstOfGroup(g)
    //  exitwhen u == null
    //  if IsPlayerEnemy(ai_player, GetOwningPlayer(u)) and IsUnitType(u, UNIT_TYPE_MELEE_ATTACKER) and GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_AGGRESSIVE) and IsUnitType(u, UNIT_TYPE_PEON) == false then
    //    set strength_sum = strength_sum + GetUnitStrength(u)
    //  endif
    //  call GroupRemoveUnit(g, u)
    //endloop
    
    //call GroupClear(g)
    if state_attacking then
      call GroupEnumUnitsInRange(g,GetUnitX(FirstOfGroup(harasser)),GetUnitY(FirstOfGroup(harasser)),harass_radius_attack_ranged,null)
    else
      call GroupEnumUnitsInRange(g,GetUnitX(FirstOfGroup(harasser)),GetUnitY(FirstOfGroup(harasser)),harass_radius_flee_ranged,null)
    endif
	set g = SelectByAlive(g, true)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
	  if IsPlayerEnemy(ai_player, GetOwningPlayer(u)) and IsUnitTower(u) and avoiding_towers then
		set towersdetected = true
	  endif	  
      if IsPlayerEnemy(ai_player, GetOwningPlayer(u)) and IsUnitType(u, UNIT_TYPE_RANGED_ATTACKER) and GetOwningPlayer(u) != Player(PLAYER_NEUTRAL_AGGRESSIVE) and IsUnitType(u, UNIT_TYPE_PEON) == false then
        set strength_sum = strength_sum + GetUnitStrength(u)
      elseif IsUnitInGroup(u, harasser) then
	     if ht == HARASS_TARGET_LOCATION then
		 	call CreateDebugTag("Distraction: Harrasing Opponent Location", 10, u, 3.00, 1.50)
		 else
			call CreateDebugTag("Harassing Opponent", 10, u, 3.00, 1.50)
		 endif
		//if GetUnitState(u, UNIT_STATE_LIFE) <= GetUnitState(u, UNIT_STATE_MAX_LIFE) * flee_percent then
		  
		  if GetUnitState(u, UNIT_STATE_LIFE) <= RMax(flee_health_percentage * GetUnitState(u, UNIT_STATE_MAX_LIFE), flee_minimum_health) and not IsUnitInGroup(u, unit_healing) and IsUnitType(u, UNIT_TYPE_HERO) == false then // Not used on heroes as micro hero is in control of that
		    call GroupAddUnit(unit_healing, u)
			call IssuePointOrder(u, "move", GetLocationX(home_location), GetLocationY(home_location))
			call TQAddUnitJob(0.5, SEND_HOME, 50, u)
			call GroupRemoveUnit(harasser, u)
			call GroupRemoveUnit(unit_harassing, u)
		  elseif IsUnitInGroup(u, unit_healing) then // Another system moved unit to healing
			call GroupRemoveUnit(harasser, u)
			call GroupRemoveUnit(unit_harassing, u)
		  else
		  	//call IssuePointOrder(u, "move", GetLocationX(home_location), GetLocationY(home_location))
			//call TQAddUnitJob(0.5, SEND_HOME, R2I(flee_percent * GetUnitState(u, UNIT_STATE_MAX_LIFE)), u)
			set harass_num = harass_num + 1
			set player_sum = player_sum + GetUnitStrength(u)
		  endif
        //else

        //endif
      endif
      call GroupRemoveUnit(g, u)
    endloop

    call DestroyGroup(g)
    set g = null
    set u = null
    if harass_num <= GetStoredInteger(additional_info, key, "Flee_Number") or towersdetected or (player_sum <= start_strength * flee_percent and not hero_harass) then
	  call StoreBoolean(additional_info, key, "State_Retreat", true)
      call GroupPointOrder(harasser, "move", GetLocationX(home_location), GetLocationY(home_location))
      //call GroupRecycleGuardPosition(harasser)
      //return
    elseif strength_sum < strength_limit then
      call StoreBoolean(additional_info, key, "State_Attacking", true)
	  if IsUnitInvisible(FirstOfGroup(harasser), Player(PLAYER_NEUTRAL_AGGRESSIVE)) then
		set timedelay = timedelay + 1
		call StoreInteger(additional_info, key, "Windwalk_Count", timedelay)
	  else
		set timedelay = -1	// Not a windwalker harassing so attack immediatly
		call StoreInteger(additional_info, key, "Windwalk_Count", 0)		
	  endif
      if DistanceBetweenUnits(FirstOfGroup(harasser), target) > 650 then
	  	  	if DistanceBetweenUnits(FirstOfGroup(harasser), target) <= 5000 then
				call GroupOrderWindWalkInstant_d(CopyGroup(harasser))
			endif
	    call CreateDebugTag("HARASS: Move to Target unit", 10, target, 3.00, 1.50)
        call GroupPointOrder(harasser, "move", GetUnitX(target), GetUnitY(target))
      else
	  	if timedelay >= 5 or timedelay == -1 or IsUnitDetected(FirstOfGroup(harasser), GetOwningPlayer(target)) then
			call GroupTargetOrder(harasser, "attack", target)
			call IssueTargetOrder(FirstOfGroup(harasser), "attack", target)
		endif
		call CreateDebugTag("HARASS: Attack Target", 10, target, 3.00, 1.50)
	    //call CreateDebugTag("HARASS: Changing Target", 10, FirstOfGroup(harasser), 3.00, 1.50)
        //call HarassJob(ht, null, harasser)
        //return
      endif
    elseif strength_sum >= strength_limit*2 then
	  call StoreBoolean(additional_info, key, "State_Retreat", true)
      call GroupPointOrder(harasser, "move", GetLocationX(home_location), GetLocationY(home_location))
      call StoreBoolean(additional_info, key, "State_Attacking", false)	
      //call GroupRecycleGuardPosition(harasser)	  
	else
	  call StoreBoolean(additional_info, key, "State_Retreat", true)
      call GroupPointOrder(harasser, "move", GetLocationX(home_location), GetLocationY(home_location))
      call StoreBoolean(additional_info, key, "State_Attacking", false)
	  //call TQAddGroupJob(30, HARASS, ht, target, harasser)
    endif
  else
    call CreateDebugTag("HARASS: Target Dead", 10, target, 3.00, 1.50)
    call GroupPointOrder(harasser, "move", GetLocationX(home_location), GetLocationY(home_location))
	call StoreBoolean(additional_info, key, "State_Retreat", true)
	call StoreBoolean(additional_info, key, "State_Attacking", false)
    //call GroupRecycleGuardPositionDelay(harasser,GetTimeToReachLoc(u, home_location) + 1)
    //return
  endif
  call TQAddGroupJob(2, HARASS, ht, target, harasser)
endfunction
function RallypointJob takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  call DisplayToAllJobDebug("RALLY_POINT JOB START")
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  call GroupPointOrderLoc(g, "setrally", home_location)
  call DestroyGroup(g)
  set g = null
  call TQAddJob(60, RALLY_POINT, 0)
endfunction
function NeutralEnemyCheckJob takes integer nn returns nothing
  call DisplayToAllJobDebug("NEUTRAL_ENEMY_CHECK JOB START")
  set neutral_enemy[nn] = GetLocationNonCreepStrength(GetUnitX(nearest_neutral[nn]), GetUnitY(nearest_neutral[nn]), 1500)
  call TQAddJob(6 * sleep_multiplier, NEUTRAL_ENEMY_CHECK, nn)
endfunction

function CopyArmy takes integer from, integer to returns nothing
  set army_owner[to] = army_owner[from]
  set army_loc[to] = army_loc[from]
  set army_dir[to] = army_dir[from]
  set army_future[to] = army_future[from]
  set army_strength[to] = army_strength[from]
  set army_group[to] = army_group[from]
  set army_count[to] = army_count[from]
endfunction

function TrackArmy takes integer num returns boolean
  local group g = CreateGroup()
  local unit u = null
  local location l = Location(0,0)
  
  call GroupClear(army_group[num])
  set army_strength[num] = 0
  set army_count[num] = 0
  
  call GroupEnumUnitsInRangeOfLoc(g, army_loc[num], army_radius, null)
  set g = SelectByUnitStandard(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and GetOwningPlayer(u) == Player(army_owner[num]) and not (IsUnitType(u, UNIT_TYPE_STRUCTURE) or IsUnitType(u, UNIT_TYPE_PEON) or IsUnitInGroup(u, in_army_group)) then
      if GetOwningPlayer(u) != ai_player and IsUnitInvisible(u, ai_player) then 
			// Fix using invisible units to exploit amai to force defend its town
	  else
		  if u == major_hero then
	        set main_army = num
	      endif
	      call GroupAddUnit(army_group[num], u)
	      call GroupAddUnit(in_army_group, u)
	      set l = GetSumLoc_dd(l, GetUnitLoc(u))
	      set army_count[num] = army_count[num] + 1
	      set army_strength[num] = army_strength[num] + GetUnitStrength(u)
	  endif
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  set u = null
  
  if army_strength[num] == 0 then
    call DestroyGroup(army_group[num])
    call RemoveLocation(army_loc[num])
    call RemoveLocation(army_dir[num])
    call RemoveLocation(army_future[num])
    call RemoveLocation(l) 	
	set l = null	
    return false
  endif  
  
  call RemoveLocation(army_dir[num])
  set l = GetDivisionLoc_d(l, Max(army_count[num], 1))
  set army_dir[num] = GetSubtractionLoc_kd(l, army_loc[num])
  set army_loc[num] = Location(GetLocationX(l), GetLocationY(l))
  call RemoveLocation(army_future[num])
  set army_future[num] = GetSumLoc_kd(army_loc[num], GetMultipleLoc(army_dir[num], army_future_mult))
  
 // if army_strength[num] != 0 then
   // call PingMinimap(GetLocationX(l), GetLocationY(l), 4)
 // endif
  call RemoveLocation(l)   
  set l = null
  
  return true
endfunction

function TrackExistingArmies takes nothing returns nothing
  local integer i = 0
  local integer first_free = 0
  loop
    exitwhen i >= army_num
    if TrackArmy(i) then
      call CopyArmy(i, first_free)
      set first_free = first_free + 1
    endif
    set i = i + 1
  endloop
  set army_num = first_free
endfunction

function SeedNewArmyAtLoc takes location l, integer p returns nothing
  set army_owner[army_num] = p
  set army_loc[army_num] = l
  set army_dir[army_num] = Location(0,0)
  set army_future[army_num] = Location(0,0)
  set army_group[army_num] = CreateGroup()
  if TrackArmy(army_num) then
	set army_num = army_num + 1
  endif
endfunction

function SeedNewArmiesForPlayer takes integer p returns nothing
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsOfPlayer(g, Player(p), null)
  set g = SelectByUnitStandard(g, true)   // Hopefully fix issues of heroes doing other things not making false armies
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if UnitAlive(u) and not IsUnitInGroup(u, in_army_group) and (IsUnitType(u, UNIT_TYPE_HERO) or major_hero == u or (GetRandomInt(0, 30) == 1 and not (IsUnitType(u, UNIT_TYPE_STRUCTURE) or IsUnitType(u, UNIT_TYPE_PEON)))) then
      call SeedNewArmyAtLoc(GetUnitLoc(u), p)
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
endfunction

function SeedNewArmies takes nothing returns nothing
  local integer p = 0
  loop
    exitwhen p > 11
    if GetPlayerSlotState(Player(p)) == PLAYER_SLOT_STATE_PLAYING then
      call SeedNewArmiesForPlayer(p)
    endif
    set p = p + 1
  endloop
endfunction

function UpdateSpecificTownThreat takes integer num returns nothing
  local integer i = 0
  local real dist = 0
  local real threat = 0
  local real max_threat = 0
  local location loc = null
  
  set town_threat[num] = 0
  loop
    if i == main_army then
      set i = i + 1
    endif
    exitwhen i >= army_num
    set dist = RMax(DistanceBetweenPoints(army_future[i], town_loc[num]), full_threat_distance)
    if dist <= no_threat_distance then
	  set loc = GetSubtractionLoc(town_loc[num], army_loc[i]) 
      if DistanceBetweenPoints(army_loc[i], town_loc[num]) < GetLengthOfLoc(army_dir[i]) and RAbs(GetAngleBetweenLocs(army_dir[i], loc)) <= 0.4 then
        set dist = full_threat_distance
      endif
	  call RemoveLocation(loc)
	  set loc = null
      set threat = distance_threat_mult * army_strength[i] / Pow(dist, distance_threat_exponent)
      if IsPlayerAlly(Player(town_owner[num]), Player(army_owner[i])) then
        set town_threat[num] = town_threat[num] - threat
      else
        set town_threat[num] = town_threat[num] + threat
        if threat > max_threat then
          set max_threat = threat
          set town_threat_army[num] = i
        endif
      endif
    endif
    set i = i + 1
  endloop
  if IsPlayerAlly(Player(town_owner[num]), ai_player) then
    if (most_threatened_town == -1 or town_threat[most_threatened_town] < town_threat[num]) and town_count[num] > 0 then
      set most_threatened_town = num
    endif
   // call DisplayToAll("Town threatened "+Int2Str(num)+" Threat: "+Int2Str(R2I(town_threat[num])))
   // call PingMinimapEx(GetLocationX(town_loc[num]), GetLocationY(town_loc[num]), 4, 255, 0, 0, true)
  elseif IsPlayerEnemy(Player(town_owner[num]), ai_player) and town_count[num] > 0 then
    if most_threatened_enemy_town == -1 or town_threat[most_threatened_enemy_town] < town_threat[num] then
      set most_threatened_enemy_town = num
    endif
  endif
endfunction

function UpdateTownThreat takes nothing returns nothing
  local integer i = 0
  local real accepted_threat_level = LinearInterpolation(atl_time_start, atl_time_end, atl_time_start_val, atl_time_end_val, TimerGetElapsed(tq_timer)) * LinearInterpolation(atl_enemy_start, atl_enemy_end, atl_enemy_start_mult, atl_enemy_end_mult, c_enemy_total)
  set town_threatened = false
  //call Trace("ARMY_TRACK: Town threat update")
  set most_threatened_town = -1
  set most_threatened_enemy_town = -1
  loop
    exitwhen i >= town_num
    call UpdateSpecificTownThreat(i)
    set i = i + 1
  endloop
  if town_threat[most_threatened_town] > accepted_threat_level and town_threat[most_threatened_town] > (I2R(c_ally_total + 1) / c_enemy_total) * town_threat[most_threatened_enemy_town] then
    set town_threatened = true
  endif
  if town_threatened then
	call SetCaptainHome(DEFENSE_CAPTAIN, GetLocationX(town_loc[most_threatened_town]), GetLocationY(town_loc[most_threatened_town]))	
  endif
endfunction

function ArmyTrackJob takes nothing returns nothing
  call DisplayToAllJobDebug("ARMY_TRACK JOB START")
  call GroupClear(in_army_group)
  call TrackExistingArmies()
  call SeedNewArmies()
  call UpdateTownThreat()
  call TQAddJob(4, ARMY_TRACK, 0)
endfunction
function CopyTown takes integer from, integer to returns nothing
  set town_owner[to] = town_owner[from]
  set town_loc[to] = town_loc[from]
  set town_value[to] = town_value[from]
  set town_threat[to] = town_threat[from]
  set town_group[to] = town_group[from]
  set town_count[to] = town_count[from]
endfunction






function TrackTown takes integer num returns boolean
  local group g = CreateGroup()
  local unit u = null
  local location l = Location(0,0)
  local location unitloc = null
  local location temploc = null
  
  call GroupClear(town_group[num])
  set town_value[num] = 0
  set town_count[num] = 0
  set town_can_tp[num] = false
  call GroupEnumUnitsInRangeOfLoc(g, town_loc[num], town_radius, null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitState(u, UNIT_STATE_LIFE) > 0 and GetOwningPlayer(u) == Player(town_owner[num]) and IsUnitType(u, UNIT_TYPE_STRUCTURE) and not IsUnitInGroup(u, in_town_group) then
      call GroupAddUnit(town_group[num], u)
      call GroupAddUnit(in_town_group, u)
	  set temploc = l
      set unitloc = GetUnitLoc(u)
      set l = GetSumLoc(temploc, unitloc)
      set town_count[num] = town_count[num] + 1
      set town_value[num] = town_value[num] + 1
      if IsUnitType(u, UNIT_TYPE_TOWNHALL) and UnitAlive(u) then
        set town_can_tp[num] = true
      endif
	  call RemoveLocation(temploc)
	  call RemoveLocation(unitloc)
	  set temploc = null
	  set unitloc = null
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  set temploc = l
  set l = GetDivisionLoc(temploc, Max(town_count[num], 1))
  call RemoveLocation(temploc)
  set temploc = null
  call RemoveLocation(town_loc[num])
  set town_loc[num] = l
  set l = null
  if town_count[num] == 0 then
    call DestroyGroup(town_group[num])
	set town_group[num] = null
    call RemoveLocation(town_loc[num])
	set town_loc[num] = null
    return false
  endif
  return true
endfunction

function TrackExistingTowns takes nothing returns nothing
  local integer i = 0
  local integer first_free = 0
  loop
    exitwhen i >= town_num
    if TrackTown(i) then
      call CopyTown(i, first_free)
      set first_free = first_free + 1
    endif
    set i = i + 1
  endloop
  set town_num = first_free
endfunction

function SeedNewTownAtLoc takes location l, integer p returns nothing
  set town_owner[town_num] = p
  set town_loc[town_num] = l
  set town_threat[town_num] = 0
  set town_group[town_num] = CreateGroup()
  call TrackTown(town_num)
  set town_num = town_num + 1
endfunction

function SeedNewTownsForPlayer takes integer p returns nothing
  local group g = CreateGroup()
  local unit u = null
  local location l = null
  call GroupEnumUnitsOfPlayer(g, Player(p), null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if IsUnitType(u, UNIT_TYPE_STRUCTURE) and UnitAlive(u) and not IsUnitInGroup(u, in_town_group) then
      call SeedNewTownAtLoc(GetUnitLoc(u), p)
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null
  set l = null
endfunction

function SeedNewTowns takes nothing returns nothing
  local integer p = 0
  loop
    exitwhen p > 11
    if GetPlayerSlotState(Player(p)) == PLAYER_SLOT_STATE_PLAYING then
      call SeedNewTownsForPlayer(p)
    endif
    set p = p + 1
  endloop
endfunction

function TownTrackJob takes nothing returns nothing
  call DisplayToAllJobDebug("TOWN_TRACK Job Start")
  call GroupClear(in_town_group)
  call TrackExistingTowns()
  call SeedNewTowns()
  call TQAddJob(9, TOWN_TRACK, 0)
endfunction
function IsMilitiaAllowed takes nothing returns boolean
  if use_militia_only_on_bigger_threats then
    if militia_allowed then
      return town_threat[most_threatened_town] > 0
    else
      return town_threat[most_threatened_town] > 7
    endif
  endif
  return true
endfunction

function MilitiaCheckJob takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  local integer i = 0
  local boolean big_dist = false
  local location unitloc = null
  local integer militiarequired = 0

  call DisplayToAllJobDebug("MILITIA_CHECK JOB START")
  if militia_check_enabled and GetUnitState(militia_hall, UNIT_STATE_LIFE) > 0 then
    set militia_allowed = IsMilitiaAllowed()
    call GroupEnumUnitsOfType(g, race_militia_unitstring, null)
    set g = SelectByPlayer(g, ai_player, true)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
	  set unitloc = GetUnitLoc(u)
      if not militia_allowed or DistanceBetweenPoints(unitloc, home_location) > race_militia_max_distance then
        call IssueImmediateOrder(u, "militiaoff")
      endif
      call GroupRemoveUnit(g,u)
	  call RemoveLocation(unitloc)
	  set unitloc = null
    endloop
	set militiarequired = Max(1,GetLocationNonCreepStrength(GetUnitX(militia_hall), GetUnitY(militia_hall), 1500)/2) // Militia are 2 strength so divide total enemy strength by 2
    call GroupEnumUnitsOfType(g, race_militiaworker_unitstring, null)
    set g = SelectByPlayer(g, ai_player, true)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      set big_dist = DistanceBetweenUnits(u, militia_hall) > 1500
      if militia_allowed and i>= 2 and i < militiarequired + 2 and not big_dist then
        if GetUnitAbilityLevel(u, race_militia_ability) <= 0 then
          call UnitAddAbility(u, race_militia_ability)
        endif
      elseif GetUnitAbilityLevel(u, race_militia_ability) > 0 then
        call UnitRemoveAbility(u, race_militia_ability)
      endif
      if not big_dist then
        set i = i + 1
      endif
      call GroupRemoveUnit(g,u)
    endloop
  endif
  call DestroyGroup(g)
  set g = null
  if GetUnitAbilityLevel(militia_hall, race_militia_hall_ability) > 0 then
    call TQAddJob(5, MILITIA_CHECK, 0)
  endif
endfunction


function TowerRushBuilderControl takes unit u, location l returns nothing
    local real builder_x = 0
    local real builder_y = 0
    local integer buildrange = 1100
	local integer randomnum = GetRandomInt(1,4)
	local unit loccheck = null
	local location unitloc = null
	local location t = null
	
	if towers_built < 3 then
		set t = GetProjectedLoc(tower_target_loc, GetSubtractionLoc(tower_target_loc, toweringplayerloc), 600)	
	elseif towers_built < 6 then
		set t = GetProjectedLoc(tower_target_loc, GetSubtractionLoc(tower_target_loc, toweringplayerloc), 350)	
	elseif towers_built <= 9 then
		set t = Location(GetLocationX(tower_target_loc), GetLocationY(tower_target_loc))	
	endif
	
	if first_tower_point_x == 0 and first_tower_point_y == 0 then
		set first_tower_point_x = GetLocationX(t)
		set first_tower_point_y = GetLocationY(t)
		set enemy_point_x = GetLocationX(tower_target_loc)
		set enemy_point_y = GetLocationY(tower_target_loc)		
	endif
	
	if DistanceBetweenPoints(l, tower_target_loc) > buildrange and GetUnitCurrentOrder(u) != OrderId("move") then
		call CreateDebugTag("TRush: builder moving", 10, u, 4.00, 2.00)
		call IssuePointOrderLoc(u, "move", t)
	elseif towers_built == 0 and DistanceBetweenPoints(l, tower_target_loc) <= buildrange and GetUnitCurrentOrder(u) != OrderId("smart") and GetUnitCurrentOrder(u) != OrderId("repair") then
		if not IsTerrainPathable(GetLocationX(l), GetLocationY(l), PATHING_TYPE_BUILDABILITY) then
			call IssueImmediateOrder(u, "stop")
			call CreateDebugTag("TRush: First Building", 10, u, 4.00, 2.00)
			set loccheck = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), old_id[race_tower_id], first_tower_point_x, first_tower_point_y, 270.0)
			set unitloc = GetUnitLoc(loccheck)
			//set first_tower_point_x = GetLocationX(unitloc)
			//set first_tower_point_y = GetLocationY(unitloc)
			call RemoveUnit(loccheck)
			set loccheck = null
			call RemoveLocation(unitloc)
			set unitloc = null
			if GetGold() < GetUnitGoldCost2(race_tower_id) or GetWood() < GetUnitWoodCost2(race_tower_id) then
			//set gold_buffer = GetUnitGoldCost2(towerid)
			//set wood_buffer = GetUnitWoodCost2(towerid)
			else
			//set gold_buffer = 0
			//set wood_buffer = 0
				set towers_built = 1
				call IssueBuildOrderById(u, old_id[race_tower_id], first_tower_point_x, first_tower_point_y)
			endif
		else
			call CreateDebugTag("TRush: Not Buildable location", 10, u, 4.00, 2.00)
			call IssuePointOrderLoc(u, "move", t)
		endif
	elseif DistanceBetweenPoints(l, tower_target_loc) <= buildrange and GetUnitCurrentOrder(u) != OrderId("smart") and GetUnitCurrentOrder(u) != OrderId("repair") then
		if towers_built < 3 or (towers_built < 6 and GetGold() >= GetUnitGoldCost(race_tower_id) and GetWood() >= GetUnitWoodCost(race_tower_id)) or (towers_built <= 9 and GetGold() >= GetUnitGoldCost(race_tower_id)*2 and GetWood() >= GetUnitWoodCost(race_tower_id)*2) then
			set builder_x = GetLocationX(t)
			set builder_y = GetLocationY(t)				
			//set builder_x = ((enemy_point_x - first_tower_point_x) / 6) + first_tower_point_x
			//set builder_y = ((enemy_point_y - first_tower_point_y) / 6) + first_tower_point_y	
		//else
			//set builder_x = ((enemy_point_x - GetLocationX(loc1)) / 6) + GetLocationX(loc1) 
			//set builder_y = ((enemy_point_x - GetLocationX(loc1)) / 6) + GetLocationY(loc1)
			//set builder_x = GetLocationX(l) - GetRandomInt(100,300)
			//set builder_y = GetLocationY(l) - GetRandomInt(100,300)				
		//endif
			set loccheck = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), old_id[race_tower_id], builder_x, builder_y, 270.0)
			set unitloc = GetUnitLoc(loccheck)
			set builder_x = GetLocationX(unitloc)
			set builder_y = GetLocationY(unitloc)
			call RemoveUnit(loccheck)
			set loccheck = null
			call RemoveLocation(unitloc)
			set unitloc = null
			if not IsTerrainPathable(builder_x, builder_y, PATHING_TYPE_BUILDABILITY) then
				call CreateDebugTag("TRush: Building", 10, u, 4.00, 2.00)
				if GetGold() < GetUnitGoldCost2(race_tower_id) or GetWood() < GetUnitWoodCost2(race_tower_id) then
					//set gold_buffer = GetUnitGoldCost2(towerid)
					//set wood_buffer = GetUnitWoodCost2(towerid)
				else
					//set gold_buffer = 0
					//set wood_buffer = 0
					call IssueBuildOrderById(u, old_id[race_tower_id], builder_x, builder_y)
				endif
			else
				call CreateDebugTag("TRush: Not Buildable location", 10, u, 4.00, 2.00)
				call IssuePointOrderLoc(u, "move", t)
			endif
		endif
	else
	endif
	
			call RemoveLocation(t)
			set t = null	
endfunction

function TowerRushJob takes nothing returns nothing
    local group g = CreateGroup()
    local unit u = null
    local integer requirement = race_towerrush_requirement
    local integer towerid = race_tower_id
    local integer upgradeid = race_tower_upgrade
    local integer buildtries = 9
    local real time_next_try = 0
    local location loc1 = null
    local location loc2 = null
    local location loc3 = null
    local integer i = 0
    local integer v = 0
	local integer randomnum

	
	  call DisplayToAllJobDebug("TOWER_RUSH Job START")
	
if upgradeid != 0 then
	call GroupEnumUnitsInRange(g, first_tower_point_x, first_tower_point_y, 1000, null)
	loop
    		set u = FirstOfGroup(g)
    		exitwhen u == null
    		if GetOwningPlayer(u) == ai_player and GetUnitTypeId(u) == old_id[towerid] and GetUnitState(u, UNIT_STATE_LIFE) > 0 then
                   call TQAddJob(5, TOWER_RUSH, 0)	
				if GetGold() < GetUnitGoldCost2(upgradeid) or GetWood() < GetUnitWoodCost2(upgradeid) then
					set gold_buffer = GetUnitGoldCost2(upgradeid)
      				set wood_buffer = GetUnitWoodCost2(upgradeid)
				else
		      		call IssueImmediateOrderById(u, old_id[upgradeid])
				endif
			  return
		else

		endif 	
		call GroupRemoveUnit(g, u)
	endloop
	

endif

    if GetPlayerSlotState(rushedplayer) != PLAYER_SLOT_STATE_PLAYING or GetPlayerUnitCount(rushedplayer,true) <= 0 or (towers_built == 0 and not (first_tower_point_x == 0 and first_tower_point_y == 0) and GetLocationNonCreepStrength(first_tower_point_x, first_tower_point_y, 1500) > GetOwnStrength() * 4) then    //or (builder[1] != null and (GetUnitState(builder[1], UNIT_STATE_LIFE) <= 0  and GetUnitState(builder[3], UNIT_STATE_LIFE) <= 0 and GetUnitState(builder[2], UNIT_STATE_LIFE) <= 0)) then
        call Trace("I have finished the tower rush")
        call RecycleGuardPosition(builder[1])
        call RecycleGuardPosition(builder[2])
        call RecycleGuardPosition(builder[3])
        set builder[1] = null
        set builder[2] = null
        set builder[3] = null
		set towers_built = 0
        set first_tower_point_x = 0
        set first_tower_point_y = 0
		call RemoveLocation(toweringplayerloc)
        set enemy_point_x = 0
        set enemy_point_y = 0
        call RemoveLocation(tower_target_loc)
		set towerrush = false
	    set gold_buffer = 0
		set wood_buffer = 0
		call SetCaptainHome(BOTH_CAPTAINS, GetLocationX(home_location), GetLocationY(home_location))
	  return
    endif

	if towers_built < 3 then
		set gold_buffer = GetUnitGoldCost2(towerid) * 2
		set wood_buffer = GetUnitWoodCost2(towerid) * 2
	elseif towers_built < 6 then
		set gold_buffer = GetUnitGoldCost2(towerid)
		set wood_buffer = GetUnitWoodCost2(towerid) 
	elseif towers_built <= 9 then
		set gold_buffer = 0
		set wood_buffer = 0
	endif
		
	call GroupEnumUnitsOfPlayer(g, ai_player, null)
	set g = SelectByAlive(g,true)
	set g = SelectById(g, old_id[racial_peon], true)
	set g = GetNearestSubGroupOfGroup(g, tower_target_loc, 3)  //g not destroyed memory leak - need to modify the code

	if (builder[1] == null or GetUnitState(builder[1], UNIT_STATE_LIFE) <= 0) and GetUnitCountDone(old_id[racial_peon]) > 7 then
		set builder[1] = FirstOfGroup(g)
	endif
	call GroupRemoveUnit(g,builder[1])
	if (builder[2] == null or GetUnitState(builder[2], UNIT_STATE_LIFE) <= 0) and GetUnitCountDone(old_id[racial_peon]) > 7 then
		set builder[2] = FirstOfGroup(g)
	endif	
	call GroupRemoveUnit(g,builder[2])
	if (builder[3] == null or GetUnitState(builder[3], UNIT_STATE_LIFE) <= 0) and GetUnitCountDone(old_id[racial_peon]) > 7 then
		set builder[3] = FirstOfGroup(g)
	endif
	call GroupRemoveUnit(g,builder[3])
    
    if towers_built < buildtries then
	    if TownCountDone(requirement) <= 0 then 
			set time_next_try = 5
		else
	        call RemoveGuardPosition(builder[1])
	        call RemoveGuardPosition(builder[2])
	        call RemoveGuardPosition(builder[3])
	        set loc1 = GetUnitLoc(builder[1])
			set loc2 = GetUnitLoc(builder[2])
			set loc3 = GetUnitLoc(builder[3])

	        set time_next_try = 2

			call TowerRushBuilderControl(builder[1], loc1)
			call TowerRushBuilderControl(builder[2], loc2)
			call TowerRushBuilderControl(builder[3], loc3)
		endif
	endif

	set towers_built = 0
	call GroupEnumUnitsInRange(g, enemy_point_x, enemy_point_y, 3000, null)
	loop
    	set u = FirstOfGroup(g)
    	exitwhen u == null
		exitwhen towers_built == buildtries
    	if GetOwningPlayer(u) == ai_player and GetUnitTypeId(u) == old_id[towerid] then
    		set towers_built = towers_built + 1
			if GetUnitState(u, UNIT_STATE_LIFE) < GetUnitState(u, UNIT_STATE_MAX_LIFE) then
    			set randomnum = GetRandomInt(1,3)
				if GetUnitCurrentOrder(builder[randomnum]) != OrderId("repair") then
					call IssueTargetOrder(builder[randomnum], "repair", u)
				endif
			endif
		endif 	
		if upgradeid != 0 and GetUnitTypeId(u) == old_id[upgradeid] then
			set towers_built = towers_built + 1
		endif
		call GroupRemoveUnit(g, u)
	endloop
    
	call DestroyGroup(g)
	set g = null
	call RemoveLocation(loc1)
	call RemoveLocation(loc2)
	call RemoveLocation(loc3)
    set loc1 = null
    set loc2 = null
    set loc3 = null
    call TQAddJob(RMax(time_next_try,1), TOWER_RUSH, 0)
endfunction



function StartTowerRush takes integer delay returns nothing
  set toweringplayerloc = GetStartLocationLoc(GetPlayerStartLocation(rushedplayer))

  call Trace("Starting the tower rush")
  set towerrush = true
  call SetPeonsRepair(false)
  set towers_built = 0
  call DisplayToAllies(chat_towerrush)
  set tower_target_loc = GetLocationInDistanceFromLoc(toweringplayerloc,front_base_distance)

  call TQAddJob(delay , TOWER_RUSH, 0)

endfunction

function TowerRushCheck takes nothing returns nothing
local integer i = GetRandomInt(1,100)
  call DisplayToAllJobDebug("TOWER_RUSH_CHECK JOB START")

	if not towerrush then
	 if hero_rush_bonus[hero[1]] >= race_towerrush_hero_rush_level then
	//	if ai_time > 60 then     // 5 mins
	//		set towerrush = false
	//		//call Trace("Tower Rush - Out of Time")
	//	elseif GetNearestEnemyDistance() < 8000 then   // Total percentage to be choosen is 33%
	//		call StartTowerRush()
	//	elseif i <= 75 and GetNearestEnemyDistance() < 11000 then // Total percentage to be choosen is 25%
	//		call StartTowerRush()
	//	elseif i <= 50 and GetNearestEnemyDistance() < 14000 then // Total percentage to be choosen is 16%
	//		call StartTowerRush()
	//	elseif i <= 20 and GetNearestEnemyDistance() < 16000 then // Total percentage to be choosen is 7%
	//	endif
	  endif
	endif
endfunction


function AncientExpansionJob takes nothing returns nothing
  local unit u = null
  local location exp_loc = null
  local location wisp_loc = null
  local unit temp = null 
  local boolean isstrong = GetOwnStrength() > GetExpansionStrength()
  call DisplayToAllJobDebug("ANCIENT_EXPANSION JOB STARTED")

  set exp_time_count = ai_time
  if current_expansion == null then
      call ChooseExpansion()
  endif
  set not_taken_expansion = current_expansion

  set u = GetExpFoe()
  
if ancient_exp_unit != null and GetUnitState(ancient_exp_unit, UNIT_STATE_LIFE) <= 0 then
		// Found out so no point trying ancient expansion again
        set ancient_exp_state = 0
        set ancient_exp_unit = null
		call SetCaptainHome(BOTH_CAPTAINS,GetLocationX(home_location),GetLocationY(home_location))		
        call GroupRecycleGuardPositionInstant(ancient_exp_group)
		set gold_buffer = 0
		set wood_buffer = 0
		return
endif	

  if ancient_exp_state == 0 then
	 if current_expansion == null then
		call TQAddJob(5, ANCIENT_EXPANSION, 0)
		return
	 endif
	 call Trace("Expansion Distance: " + Int2Str(R2I(GetExpansionDistance())))
     call Trace("Expansion state 0: Get the Wisp and Location")
      set gold_buffer = GetUnitGoldCost2(racial_expansion)
      set wood_buffer = GetUnitWoodCost2(racial_expansion)
	  set ancient_exp_count = 0
	 
    if GetGold() < GetUnitGoldCost2(racial_expansion) or GetWood() < GetUnitWoodCost2(racial_expansion) then

    else
	  if ancient_exp_wisp == null or not UnitAlive(ancient_exp_wisp) then
		set ancient_exp_wisp = GetExpansionPeon()
		if ancient_exp_wisp == null then
			set ancient_exp_wisp = GetExpansionPeon2()
		endif
      endif
	  if u != null then
	    if ancient_exp_loc != null then
			call RemoveGuardPosition(ancient_exp_wisp)
			set exp_loc = GetUnitLoc(current_expansion)
			//call RemoveLocation(ancient_exp_loc)
			//set ancient_exp_loc = GetBuildLocationInDistanceFromLoc(old_id[racial_expansion], exp_loc, ver_creeps_attack_buildings_dist + 500)
			call IssuePointOrderByIdLoc(ancient_exp_wisp, old_id[racial_expansion], ancient_exp_loc)
			set ancient_exp_state = 1
			call RemoveLocation(exp_loc)
			set exp_loc = null
		endif
	  else
	  	call RemoveGuardPosition(ancient_exp_wisp)
		set exp_loc = GetUnitLoc(current_expansion)
      	//call RemoveLocation(ancient_exp_loc)
    	set temp = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), old_id[racial_expansion], GetUnitX(current_expansion), GetUnitY(current_expansion), 270.0)
 		set ancient_exp_loc = GetUnitLoc(temp)
    	call RemoveUnit(temp)
    	set temp = null
	    call IssuePointOrderByIdLoc(ancient_exp_wisp,old_id[racial_expansion], ancient_exp_loc)
		set ancient_exp_state = 5
		call RemoveLocation(exp_loc)
		set exp_loc = null
	  endif
    endif
    call TQAddJob(5, ANCIENT_EXPANSION, 0)

  elseif ancient_exp_state == 1 then
	 call CreateDebugTag("Expansion State 1 - Ordering wisp", 10, ancient_exp_wisp, 3.00, 1.50)
	 set wisp_loc = GetUnitLoc(ancient_exp_wisp)
	 if gold_buffer != 0 and DistanceBetweenPoints(wisp_loc, ancient_exp_loc) <= 400 then
		set gold_buffer = 0
		set wood_buffer = 0
	 endif
	 if wisp_loc != null then
		call RemoveLocation(wisp_loc)
		set wisp_loc = null
	 endif
    if GetUnitState(ancient_exp_wisp, UNIT_STATE_LIFE) > 0 then
      call IssuePointOrderByIdLoc(ancient_exp_wisp, old_id[racial_expansion], ancient_exp_loc)
      call TQAddJob(5, ANCIENT_EXPANSION, 0)
    else
      set ancient_exp_unit = GetOneOfIdNearLoc(ai_player, old_id[racial_expansion], ancient_exp_loc, 400)
      if ancient_exp_unit == null then
        set ancient_exp_state = 0
        call AncientExpansionJob()
      else
	    if GetLocationNonCreepStrength(GetUnitX(ancient_exp_unit), GetUnitY(ancient_exp_unit), 800) <= 0 then
        set ancient_exp_state = 2
        call RemoveGuardPosition(ancient_exp_unit)
		call IssueImmediateOrderById(ancient_exp_unit, OrderIdCancel)
        call IssueImmediateOrder(ancient_exp_unit, "unroot")
		endif
        //set no_attack_allowed = true
        call TQAddJob(1, ANCIENT_EXPANSION, 0)
      endif
    endif
  elseif ancient_exp_state == 2 then
	if GetUnitMoveSpeed(ancient_exp_unit) == 0 then
	    call CreateDebugTag("Expansion State 2: Uproot Tree", 10, ancient_exp_unit, 3.00, 1.50)
	    call IssueImmediateOrderById(ancient_exp_unit, OrderIdCancel)
		call IssueImmediateOrder(ancient_exp_unit, "unroot")	
	else

		if hero_built[1] then
			set ancient_exp_state = 3
		  //call RemoveGuardPosition(hero_unit[1])
		  //call IssuePointOrder(hero_unit[1], "move", GetUnitX(ancient_exp_unit), GetUnitY(ancient_exp_unit))	
			//call GroupClear(ancient_exp_group)
			//call GroupEnumUnitsOfPlayer(ancient_exp_group, ai_player, null)
			//set ancient_exp_group = SelectByAlive(ancient_exp_group, true)
			//set ancient_exp_group = SelectUnittype(ancient_exp_group, UNIT_TYPE_STRUCTURE, false)
			//set ancient_exp_group = SelectUnittype(ancient_exp_group, UNIT_TYPE_PEON, false)
			//set ancient_exp_group = SelectByUnitStandard(ancient_exp_group, true)
			//call GroupRemoveGuardPositionInstant(ancient_exp_group)
			//call GroupPointOrder(ancient_exp_group, "smart", GetUnitX(ancient_exp_unit), GetUnitY(ancient_exp_unit))		
		endif
	endif
    call TQAddJob(3, ANCIENT_EXPANSION, 0)
  elseif ancient_exp_state == 3 then
	call CreateDebugTag("Expansion State 3: Awaiting Hero", 10, ancient_exp_unit, 3.00, 1.50)
	call SetCaptainHome(BOTH_CAPTAINS,R2I(GetUnitX(ancient_exp_unit)),R2I(GetUnitY(ancient_exp_unit)))
    if DistanceBetweenUnits(ancient_exp_unit, hero_unit[1]) <= 750 or u == null or isstrong then
		if ancient_exp_count > 0 then
			call GroupEnumUnitsInRange(ancient_exp_group, GetUnitX(ancient_exp_unit), GetUnitY(ancient_exp_unit), 1000, null)
			set ancient_exp_group = SelectByPlayer(ancient_exp_group, ai_player, true)
			set ancient_exp_group = SelectByAlive(ancient_exp_group, true)
			set ancient_exp_group = SelectUnittype(ancient_exp_group, UNIT_TYPE_STRUCTURE, false)
			set ancient_exp_group = SelectUnittype(ancient_exp_group, UNIT_TYPE_PEON, false)
			set ancient_exp_group = SelectByUnitStandard(ancient_exp_group, true)
			if not isstrong then
				call GroupAddUnit(ancient_exp_group, ancient_exp_unit)
	        endif
			////call GroupAddTypeAndRemoveGuard(ancient_exp_group, race_ancient_expansion_help_id, ai_player)
	        //call GroupPointOrder(ancient_exp_group, "smart", GetUnitX(u), GetUnitY(u))
	        set ancient_exp_state = 4
		else
			set ancient_exp_count = ancient_exp_count + 1
		endif
    else
	    if ancient_exp_count > 0 then
			set ancient_exp_count = ancient_exp_count - 1
		endif
		//call GroupEnumUnitsOfPlayer(ancient_exp_group, ai_player, null)
		//set ancient_exp_group = SelectByAlive(ancient_exp_group, true)
		//set ancient_exp_group = SelectUnittype(ancient_exp_group, UNIT_TYPE_STRUCTURE, false)
		//set ancient_exp_group = SelectUnittype(ancient_exp_group, UNIT_TYPE_PEON, false)
		//set ancient_exp_group = SelectByUnitStandard(ancient_exp_group, true)
		//call GroupRemoveGuardPositionInstant(ancient_exp_group)
		//call GroupPointOrder(ancient_exp_group, "smart", GetUnitX(ancient_exp_unit), GetUnitY(ancient_exp_unit))		
    endif
    call TQAddJob(5, ANCIENT_EXPANSION, 0)
  elseif ancient_exp_state == 4 then
	call CreateDebugTag("Expansion State 4: Attacking and taking expansion", 10, ancient_exp_unit, 3.00, 1.50)
	call SetCaptainHome(BOTH_CAPTAINS,R2I(GetUnitX(ancient_exp_unit)),R2I(GetUnitY(ancient_exp_unit))) 
    if u == null then
		call GroupRemoveUnit(ancient_exp_group, ancient_exp_unit)
		call IssueTargetOrder(ancient_exp_unit, "entangle", current_expansion)
		call TQAddUnitJob(R2I(GetTimeToReachUnit(ancient_exp_unit, current_expansion)*2 + 5), RESET_GUARD_POSITION, 0, ancient_exp_unit)
		call GroupRecycleGuardPositionInstant(ancient_exp_group)
		//call RemoveLocation(ancient_exp_loc)
		set ancient_exp_state = 0
		//set no_attack_allowed = false
		set not_taken_expansion = null
		set ancient_expanding = false
		set ancient_attack_running = false
		call SetCaptainHome(BOTH_CAPTAINS,GetLocationX(home_location),GetLocationY(home_location))	  
		return
    else
		//call GroupAddTypeAndRemoveGuard(ancient_exp_group, race_ancient_expansion_help_id, ai_player)
		if GetUnitState(ancient_exp_unit, UNIT_STATE_LIFE) <= GetUnitState(ancient_exp_unit, UNIT_STATE_MAX_LIFE) * 0.40 then
			call IssueImmediateOrderById(ancient_exp_unit, OrderId("eattree"))
		elseif ancient_attack_running then
			if DistanceBetweenUnits(ancient_exp_unit, u) <= 750 then
				call GroupTargetOrder(ancient_exp_group, "attack", u)
			else
				call GroupPointOrder(ancient_exp_group, "attack", GetUnitX(u), GetUnitY(u))
			endif
		endif
		call TQAddJob(2, ANCIENT_EXPANSION, 0)
    endif
  elseif ancient_exp_state == 5 then
	call CreateDebugTag("Expansion State 5: Fast Expand as camp clear", 10, ancient_exp_wisp, 3.00, 1.50)
    if GetUnitState(ancient_exp_wisp, UNIT_STATE_LIFE) > 0 and CheckExpansionTaken(current_expansion) == false then
		if GetUnitCurrentOrder(ancient_exp_wisp) != old_id[racial_expansion] then
				call IssuePointOrderByIdLoc(ancient_exp_wisp, old_id[racial_expansion], ancient_exp_loc)
		endif
		call TQAddJob(5, ANCIENT_EXPANSION, 0)
    else
		set gold_buffer = 0
		set wood_buffer = 0
		//call RemoveLocation(ancient_exp_loc)
		set ancient_exp_state = 0
		//set no_attack_allowed = false
		set not_taken_expansion = null
		set ancient_expanding = false		
	endif
  endif
endfunction


function AncientExpansionCheck takes nothing returns nothing
    call DisplayToAllJobDebug("ANCIENT_EXPANSION_CHECK JOB START")
	if not ancient_expanding then
		if current_expansion != null then
			call Trace("expansion free")
			if GetExpansionStrength() < race_ancient_expansion_strength and GetExpFoe() != null and hero_rush_bonus[hero[1]] >= race_ancient_expansion_hero_rush_level then
				call Trace("Acient expansion - Begin Job")
				set ancient_expanding = true
	            call TQAddJob(1, ANCIENT_EXPANSION, 0)
				return
			elseif hero_rush_bonus[hero[1]] < race_ancient_expansion_hero_rush_level then
				call Trace("Ancient Expansion not possible with hero")
				return
			endif
		else
			call Trace("Ancient expansion - No expansion available")
		endif
	endif
    call TQAddJob(50, ANCIENT_EXPANSION_CHECK, 0)
endfunction

function ChatVarsJob takes nothing returns nothing
  call DisplayToAllJobDebug("CHAT_VARS JOB START")
  call SetChatVarR("Time", TimerGetElapsed(tq_timer))
  call SetChatVar("RandomRace", race_name[GetRandomInt(1,RACE_NUMBER)])
  call SetChatVar("OwnGold", Int2Str(GetGold()))
  call SetChatVarR("OwnGold", GetGold())
  call SetChatVar("OwnLumber", Int2Str(GetWood()))
  call SetChatVarR("OwnLumber", GetWood())
  call SetChatVarR("Strength", GetOwnStrength())
  call TQAddJob(6, CHAT_VARS, 0)
endfunction

function SelectByZiggurat takes group g, boolean is_id returns group
     local unit u = null
     local group rg = CreateGroup()
	 local integer i = 0
     loop
       set u = FirstOfGroup(g)
       exitwhen u == null
	   loop
	    if i > ziggarray and not is_id then
			call GroupAddUnit(rg, u)
		endif
		exitwhen i > ziggarray
       //if SetHasEntry(s, GetUnitTypeId(u)) == is_id then
        if is_id and GetUnitTypeId(u) == racial_zigg[i] then
			call GroupAddUnit(rg, u ) 
		endif
		set i = i + 1
		endloop
       //endif
       call GroupRemoveUnit(g, u )
     endloop
     call DestroyGroup(g)
     return rg
endfunction

function CheckSellZiggurat takes unit u returns nothing
  local group g = CreateGroup()
  call GroupEnumUnitsInRange(g, GetUnitX(u), GetUnitY(u), race_ziggurat_keep_distance, null)
  set g = SelectByPlayer(g, ai_player, true)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  set g = SelectByZiggurat(g, false)
  if FirstOfGroup(g) == null then
    call Unsummon(u)
  endif
  call DestroyGroup(g)
  set g = null
endfunction

function SellZigguratJob takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  local integer i = 0

  call DisplayToAllJobDebug("SELL_ZIGGURATS JOB START")
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectByZiggurat(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call CheckSellZiggurat(u)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  call TQAddJob(30, SELL_ZIGGURATS, 0)
endfunction

function GroupMicroSystem takes group g, group meleeg returns nothing
	local unit u = null
	local location unitloc = null
	local location l = null
	local unit melee = null
	local group copy = null
	
	loop
		set u = FirstOfGroup(g)
		set unitloc = GetUnitLoc(u)
		exitwhen u == null
		set copy = CopyGroup(meleeg)
		set melee = GetNearestOfGroup(copy, unitloc)
		if DistanceBetweenUnits(u, melee) < 400 then
			set l = GetProjectedLoc(unitloc, GetSubtractionLoc_kd(unitloc, GetUnitLoc(melee)), 400)
			call RemoveGuardPosition(u)
			call IssuePointOrderLoc(u, "move", l)
			call RecycleGuardPosition(u)
			call GroupRemoveUnit(focus_fire_group, u) // prevent focus fire controls interrupting
			call RemoveLocation(l)
		endif
		call DestroyGroup(copy)
		call RemoveLocation(unitloc)
		call GroupRemoveUnit(g, u)
	endloop
	set copy = null
	set l = null
endfunction

function GroupOrderFocusWindInstant_d takes group g returns nothing
	local unit u = null
	loop
		set u = FirstOfGroup(g)
		exitwhen u == null
		if (GetUnitAbilityLevel(u, 'AOwk') > 0 or GetUnitAbilityLevel(u, 'ANwk') > 0) then
			//call CreateDebugTag("HARASS: WINDWALK COMMANDED", 10, u, 3.00, 1.50)
			if not IsUnitInGroup(u, windwalk_group) then
				call GroupAddUnit(windwalk_group, u)
				call TQAddUnitJob(8, RESET_WINDWALKER, 0, u)
			endif
			if not UnitInvis(u) then
				call IssueImmediateOrder(u, "windwalk")
			endif
		endif
		call GroupRemoveUnit(g, u)
	endloop
	call DestroyGroup(g)
endfunction

function GroupOrderAttack_d takes group g, unit target returns nothing
	local unit u = null
	loop
		set u = FirstOfGroup(g)
		exitwhen u == null
		call RemoveGuardPosition(u)	
		if UnitInvis(u) then
			call IssueTargetOrder(u, "attack", target)
		endif
		call GroupRemoveUnit(g, u)
	endloop
	call DestroyGroup(g)		
endfunction

function FocusFire takes unit u returns nothing
  local group g = CreateGroup()
  local group t = CreateGroup()
  
  call GroupClear(focus_fire_group)
  call GroupEnumUnitsInRange(g, GetUnitX(u), GetUnitY(u), focus_fire_ranged_dist, null)
  set g = SelectUnittype(g, UNIT_TYPE_RANGED_ATTACKER, true)
  set focus_fire_group = GroupAddGroup(focus_fire_group, g)
  call DestroyGroup(g)
  set g = null
  call GroupEnumUnitsInRange(t, GetUnitX(u), GetUnitY(u), focus_fire_melee_dist, null)
  set t = SelectUnittype(t, UNIT_TYPE_MELEE_ATTACKER, true)
  set focus_fire_group = GroupAddGroup(focus_fire_group, t)
  call DestroyGroup(t)
  set t = CreateGroup()
  call GroupEnumUnitsInRange(t, GetUnitX(u), GetUnitY(u), normal_battle_radius, null)
  set t = SelectByInvisible(t, GetOwningPlayer(u), true)
  set focus_fire_group = GroupAddGroup(focus_fire_group, t)
  call DestroyGroup(t)
  set t = null
  set focus_fire_group = SelectByPlayer(focus_fire_group, ai_player, true)
  if IsUnitType(u, UNIT_TYPE_FLYING) == true then
    set focus_fire_group = SelectUnittype(focus_fire_group, UNIT_TYPE_ATTACKS_FLYING, true)
  endif
  set focus_fire_group = SelectUnittype(focus_fire_group, UNIT_TYPE_PEON, false)
  set focus_fire_group = SelectByUnitStandard(focus_fire_group, true)
  set focus_fire_group = SelectByAlive(focus_fire_group, true)
  //set focus_fire_group = SelectByOrderOr2(focus_fire_group,OrderId("move"),OrderId("attack"),OrderId("stop"), true)
	set focus_fire_group = SelectByOrder(focus_fire_group, OrderId("blizzard"), false)
	set focus_fire_group = SelectByOrder(focus_fire_group, OrderId("flamestrike"), false)
	set focus_fire_group = SelectByOrder(focus_fire_group, OrderId("massteleport"), false)
	set focus_fire_group = SelectByOrder(focus_fire_group, OrderId("earthquake"), false)
	set focus_fire_group = SelectByOrder(focus_fire_group, OrderId("voodoo"), false)	
	set focus_fire_group = SelectByOrder(focus_fire_group, OrderId("deathanddecay"), false)
	set focus_fire_group = SelectByOrder(focus_fire_group, OrderId("starfall"), false)
	set focus_fire_group = SelectByOrder(focus_fire_group, OrderId("tranquility"), false)
	set focus_fire_group = SelectByOrder(focus_fire_group, OrderId("clusterrockets"), false)
	set focus_fire_group = SelectByOrder(focus_fire_group, OrderId("tornado"), false)
	set focus_fire_group = SelectByOrder(focus_fire_group, OrderId("volcano"), false)
  
  //if FirstOfGroup(micro_enemymelee_group) != null then
 // endif
  
  if focus_fire_unit == null or focus_fire_unit != u then
    call CreateDebugTag("Focus fire directly", 10, u, 3.00, 1.50)  
	if IsUnitType(u,UNIT_TYPE_STRUCTURE) == false and not IsUnitOwnedByPlayer(u, Player(PLAYER_NEUTRAL_AGGRESSIVE)) then
		call GroupOrderFocusWindInstant_d(CopyGroup(focus_fire_group))  // Dont want it wasting mana
	endif
	set focus_fire_unit = u
	call GroupTargetOrder(focus_fire_group, "attack", u)
	call GroupOrderAttack_d(CopyGroup(windwalk_group), u) // Invisible units attack directly as normal group order is ignored
  else
    call CreateDebugTag("Focus our fire here", 10, u, 3.00, 1.50)  
	call GroupTargetOrder(focus_fire_group, "attack", u)
	call GroupOrderAttack_d(CopyGroup(windwalk_group), u)	 // Invisible units attack directly as normal group order is ignored
  endif

endfunction

function FocusFireJob takes nothing returns nothing
  local group g = CreateGroup()
  local unit u = null
  local real hero_min_health = 100000
  local unit hero_min_health_unit = null
  local real range_strength = 0
  local real min_health = 100000
  local unit min_health_unit = null
  local real building_min_health = 100000
  local unit building_min_health_unit = null
  local real disabled_min_health = 100000
  local unit disabled_min_health_unit = null
  local integer enemy_count = 0
  local real unit_life = 0

  call DisplayToAllJobDebug("FOCUSFIRE_CONTROL JOB START")
  

  call GroupClear(focus_fire_group)
  call GroupClear(micro_ranged_group)
  call GroupClear(micro_enemymelee_group)

  if major_hero == null or not UnitAlive(major_hero) then
    set major_hero = GetMajorHeroReplacement_k(last_major_hero_loc)
  endif

 //if retreat_controlled and (attack_running or town_threatened) then
 if not CaptainRetreating() and (attack_running or town_threatened) then


  if main_army == -1 or army_loc[main_army] == null or (GetLocationX(army_loc[main_army]) == 0 and GetLocationY(army_loc[main_army]) == 0 ) then
    if major_hero == null then
		call TQAddJob(2 * sleep_multiplier, FOCUSFIRE_CONTROL, 0)
		return
	else
		call GroupEnumUnitsInRange(g,GetUnitX(major_hero),GetUnitY(major_hero),battle_radius,null)
	endif
  else
	call GroupEnumUnitsInRange(g, GetLocationX(army_loc[main_army]), GetLocationY(army_loc[main_army]), battle_radius, null)
  endif
  
  call MoveLocation(enemy_melee_loc, 0,0)  
  
  if town_threatened then
	set g = SelectByPlayer(g, Player(PLAYER_NEUTRAL_AGGRESSIVE), false)
  endif
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    set unit_life = GetUnitState(u, UNIT_STATE_LIFE)
    if unit_life > 0 and not IsUnitHidden(u) then
	    if IsPlayerEnemy(GetOwningPlayer(u), ai_player) and not (UnitInvis(u) and not IsUnitDetected(u, ai_player)) and IsUnitVisible(u, ai_player) then
			if IsUnitType(u, UNIT_TYPE_MELEE_ATTACKER) == true then
				set enemy_melee_loc = GetSumLoc_dd(enemy_melee_loc, GetUnitLoc(u))
				set enemy_count = enemy_count + 1
				call GroupAddUnit(micro_enemymelee_group, u)
			endif
			if IsUnitType(u, UNIT_TYPE_HERO) then
	          if unit_life < hero_min_health then
	            set hero_min_health = unit_life
	            set hero_min_health_unit = u
	          endif
			else
	          if unit_life < min_health and (unit_life < GetUnitState(u, UNIT_STATE_MAX_LIFE) or IsUnitType(u, UNIT_TYPE_MELEE_ATTACKER) or IsUnitType(u, UNIT_TYPE_RANGED_ATTACKER) or IsUnitType(u, UNIT_TYPE_TOWNHALL)) then
	            set min_health = unit_life
	            set min_health_unit = u
	          endif
			  if unit_life < disabled_min_health and GetUnitMoveSpeed(u) == 0 and not IsUnitType(u, UNIT_TYPE_STRUCTURE) then
			  	  set disabled_min_health = unit_life
				  set disabled_min_health_unit = u
			  endif
			  if unit_life < building_min_health and IsUnitType(u, UNIT_TYPE_STRUCTURE) then
				set building_min_health = unit_life
				set building_min_health_unit = u
			  endif
	        endif
	    elseif IsPlayerAlly(GetOwningPlayer(u), ai_player) then
	            if IsUnitType(u, UNIT_TYPE_RANGED_ATTACKER) == true then
	              set range_strength = range_strength + GetUnitStrength(u)
				  call GroupAddUnit(micro_ranged_group, u)
	            endif
	    endif
	endif
    call GroupRemoveUnit(g,u)
  endloop

  call MoveLocation(last_major_hero_loc, GetUnitX(major_hero), GetUnitY(major_hero))
  set enemy_melee_loc = GetDivisionLoc_d(enemy_melee_loc, I2R(Max(enemy_count, 1)))  
  //if GetLocationX(enemy_melee_loc) != 0 and GetLocationY(enemy_melee_loc) != 0 then 


  //else


    if hero_min_health_unit != null and hero_min_health < focus_fire_limit * range_strength then
      call SetTargetHeroes(true)
      call FocusFire(hero_min_health_unit)
    else
      call SetTargetHeroes(false)
	  if disabled_min_health_unit != null then
		if min_health_unit != null then
		    if min_health * 3 < disabled_min_health then
				call FocusFire(min_health_unit)
			else
				call FocusFire(disabled_min_health_unit)
			endif
		else
			call FocusFire(disabled_min_health_unit)
		endif
	  elseif min_health_unit != null then
	  	call FocusFire(min_health_unit)
	  elseif building_min_health_unit != null then
	    call FocusFire(building_min_health_unit)
	  endif
    endif
 else
	//call GroupRecycleGuardPositionInstant(windwalk_group)
	//loop
	//	set u = FirstOfGroup(windwalk_group)
	//	exitwhen u == null
	//	call GroupRemoveUnit(windwalk_group, u)
	//	if not IsUnitInGroup(u, unit_healing) and not IsUnitInGroup(u, unit_harassing) then
	//		call RecycleGuardPosition(u)
	//	endif
	//endloop
 endif
call DestroyGroup(g)
set g = null 
call TQAddJob(2 * sleep_multiplier, FOCUSFIRE_CONTROL, 0)
endfunction


function GetMoonWell takes player p, integer id returns unit
   local unit u = null
   local group g = CreateGroup()     
   call GroupEnumUnitsOfPlayer(g, p, null)
   set g = SelectByAlive(g, true)
   loop
     set u = FirstOfGroup(g)
     exitwhen u == null
     if GetUnitTypeId(u) == id and GetUnitState(u, UNIT_STATE_MANA) >= 30 then
       call DestroyGroup(g)
       set g = null
       return u
     endif
     call GroupRemoveUnit(g, u )
   endloop
   call DestroyGroup(g)
   set g = null
   return null

endfunction

function MoonWellJob takes unit u, integer p returns nothing
	local location l = null
	local real dist = 0
	local real enemystrength = 0

  call DisplayToAllJobDebug("MOON_WELL_CONTROL JOB START")
  if GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
    call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)
	return
  elseif GetUnitState(u, UNIT_STATE_LIFE) >= GetUnitState(u, UNIT_STATE_MAX_LIFE) * (I2R(p)/100) then
  	call GroupRemoveUnit(unit_healing, u)
    call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)
	return
  elseif nearest_moon_well == null or GetUnitState(nearest_moon_well, UNIT_STATE_MANA) < 30 then
  	set nearest_moon_well = GetMoonWell(ai_player, old_id[racial_farm])
	if nearest_moon_well == null then	  
			set l = GetUnitLoc(u)
			set dist = DistanceBetweenPoints(l, home_location)
			set enemystrength = GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 800)
			if dist >= 1000 and enemystrength > 0 and ((GetUnitState(u, UNIT_STATE_MANA) > 50 and GetUnitAbilityLevel(u, 'AEbl') == 1) or (GetUnitState(u, UNIT_STATE_MANA) > 10 and GetUnitAbilityLevel(u, 'AEbl') > 1)) then
					call IssuePointOrder(u, "blink", GetLocationX(home_location), GetLocationY(home_location))
			elseif dist >= 1000 and enemystrength > 0 and GetUnitAbilityLevel(u, 'Ashm') > 0 and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) < 6) then
					call IssueImmediateOrder(u, "ambush")
					call TQAddUnitJob(4, MOON_WELL_CONTROL, p, u)				
			elseif dist >= 1000 then
					call IssuePointOrder(u, "move", GetLocationX(home_location), GetLocationY(home_location))
					call TQAddUnitJob(4, MOON_WELL_CONTROL, p, u)	
			elseif IsUnitType(u,UNIT_TYPE_HERO)==true then
				call TQAddUnitJob(2, SEND_HOME, p, u)
			else
				call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)
			endif
			call RemoveLocation(l)
			set l = null
	else
		set dist = DistanceBetweenUnits(u, nearest_moon_well)
		set enemystrength = GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 800)
		if dist >= 1000 and enemystrength > 0 and ((GetUnitState(u, UNIT_STATE_MANA) > 50 and GetUnitAbilityLevel(u, 'AEbl') >= 1) or (GetUnitState(u, UNIT_STATE_MANA) > 10 and GetUnitAbilityLevel(u, 'AEbl') > 1)) then
				call IssuePointOrder(u, "blink", GetUnitX(nearest_moon_well), GetUnitY(nearest_moon_well))		
		elseif dist >= 1000 and GetUnitAbilityLevel(u, 'Ashm') > 0 and enemystrength > 0 and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) < 6) then
				call IssueImmediateOrder(u, "ambush")
				call TQAddUnitJob(4, MOON_WELL_CONTROL, p, u)				
		else
			call IssuePointOrder(u, "smart", GetUnitX(nearest_moon_well), GetUnitY(nearest_moon_well))
			call TQAddUnitJob(4, MOON_WELL_CONTROL, p, u)
		endif
	endif
  else
		set dist = DistanceBetweenUnits(u, nearest_moon_well)
		set enemystrength = GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 800)
		if dist >= 1000 and enemystrength > 0 and ((GetUnitState(u, UNIT_STATE_MANA) > 50 and GetUnitAbilityLevel(u, 'AEbl') >= 1) or (GetUnitState(u, UNIT_STATE_MANA) > 10 and GetUnitAbilityLevel(u, 'AEbl') > 1)) then
				call IssuePointOrder(u, "blink", GetUnitX(nearest_moon_well), GetUnitY(nearest_moon_well))		
		elseif dist >= 1000 and GetUnitAbilityLevel(u, 'Ashm') > 0 and enemystrength > 0 and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) < 6) then
				call IssueImmediateOrder(u, "ambush")
				call TQAddUnitJob(4, MOON_WELL_CONTROL, p, u)				
		else 
		call IssuePointOrder(u, "smart", GetUnitX(nearest_moon_well), GetUnitY(nearest_moon_well))
		call TQAddUnitJob(4, MOON_WELL_CONTROL, p, u)
	endif
  endif

endfunction

function GetFastBuildPeasantNumber takes nothing returns integer
  local integer minres = Min(GetGold(),GetWood())
  if minres < 40 or GetMinesOwned() == 0 then
	//call Trace("0 fast build peasants")
    return 0
  elseif minres < 100 then
  	//call Trace("1 fast build peasant")
    return 1
  elseif minres < 150 then
  	//call Trace("2 fast build peasants")
    return 2
  elseif minres < 200 then
  	//call Trace("3 fast build peasants")
    return 3
  else
  	//call Trace("4 fast build peasants")
    return 4
  endif
endfunction

function GetBuildingBuilt takes nothing returns unit
     local group g = CreateGroup()
	 if expansion_changed then
		call GroupEnumUnitsInRange(g, last_expansion_x, last_expansion_y, 1000, null)
     else
		call GroupEnumUnitsInRange(g, next_expansion_x, next_expansion_y, 1000, null)	 
	 endif
	 set g = SelectByPlayer(g, ai_player, true)
     set g = SelectNumberOfId(g, 1, old_id[racial_hall[1]])
     return FirstOfGroup(g)
endfunction

function FastBuildBuilding takes nothing returns nothing
  local unit u = GetBuildingBuilt()
  local group tempg = CreateGroup()
  local group g = null
  local location unitloc = GetUnitLoc(u)
  
  call Trace("Town hall is being built soon")
  if u == null then
    return
  endif
  call Trace("Town hall is being built")
	 call GroupEnumUnitsOfPlayer(tempg, ai_player,null)
	 set tempg = SelectNumberOfId(tempg, 50, old_id[racial_militia] )
	 set tempg = SelectByAlive(tempg, true)
	 if FirstOfGroup(tempg) == null then
		call DestroyGroup(tempg)
		set tempg = CreateGroup()
		call GroupEnumUnitsOfPlayer(tempg, ai_player, null)	 
		set tempg = SelectNumberOfId(tempg, 50, old_id[racial_peon] )
		set tempg = SelectByAlive(tempg, true)
	 endif
  call GroupClear(g)  
  set g = GetNearestSubGroupOfGroup(tempg, unitloc, GetFastBuildPeasantNumber())
  call GroupTargetOrder(g, "repair", u)
  call Trace("Fast Build Town Hall")
  set town_hall_built = true
  call RemoveLocation(unitloc)
  call DestroyGroup(tempg)
  call DestroyGroup(g)
  set unitloc = null
  set tempg = null
  set g = null
endfunction

function FastBuildCheck takes nothing returns nothing
  if GetUnitX(current_expansion) != next_expansion_x or GetUnitY(current_expansion) != next_expansion_y then
    set last_expansion_x = next_expansion_x
    set last_expansion_y = next_expansion_y
    set next_expansion_x = GetUnitX(current_expansion)
    set next_expansion_y = GetUnitY(current_expansion)
    set expansion_changed = true
  else
    set expansion_changed = false
  endif
  if TownCount(racial_hall[1]) - TownCountDone(racial_hall[1]) > 0 then
    //if expansion_changed and not town_hall_built then
    if not town_hall_built then  
	  call FastBuildBuilding()
    endif
  else
    set town_hall_built = false
  endif
endfunction

function FastBuild takes nothing returns nothing
	call FastBuildCheck()
	call TQAddJob(10, FAST_BUILD, 0)
endfunction

function GetMilitiaExpansionLoc takes integer unitid returns location
	local unit u = null
	local location l = null

	set u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), unitid, GetUnitX(militia_expansion), GetUnitY(militia_expansion), 270.0)
    if DistanceBetweenUnits(u, militia_expansion) > race_max_expa_mine_distance then
      call RemoveUnit(u)
      set u = null
      return null
    endif	
	set l = GetUnitLoc(u)
	call RemoveUnit(u)
	set u = null
	return l
	
endfunction

function BuildMilitiaExpansion takes unit peon , integer unitid returns boolean
  local unit u = null

    call Trace("did a check")

	if militia_loc == null then
		return false
	endif
	
  if IssuePointOrderByIdLoc(peon, unitid, militia_loc) then
	return true
  else
	return false
  endif
  
endfunction

function GetMilitiaExpansionStrength takes nothing returns integer
	return GetLocationCreepStrength(GetUnitX(militia_expansion), GetUnitY(militia_expansion), expansion_radius)
endfunction

function TryMilitiaExpansionFoot takes nothing returns nothing
local group g = null
local group tempg = null
local integer ownstrength = GetOwnStrength()
local integer expansionstrength = 0


  call DisplayToAllJobDebug("MILITIA_EXPAND JOB START")
  
  
	if militia_state == 0 then
		if not militia_expanding and not towerrush then
			if current_expansion != null then
		      set militia_time_count = militia_time_count + 1
			  call Trace("Expansion Distance: " + Int2Str(R2I(GetExpansionDistance())))
		      if GetExpansionDistance() <= 6600 and GetExpansionStrength() < 20 then //and militia_time_count < militia_time_out then //and GetExpansionStrength() < 36 then // and hero[1] == racial_militiahero then
		        if TownCount(hero[1]) > 0 then
		        endif
				set expansionstrength = GetExpansionStrength()
				call Trace("Our Strength:" + Int2Str(ownstrength) + " Expansion Strength:" + Int2Str(expansionstrength))
		        if TownCountDone(hero[1])>0 and not town_threatened and GetPlayerStrength(ai_player) >= minimum_attack_strength and TownCountDone(racial_peon) > 6 and ownstrength + 6 >= expansionstrength then
		    		set gold_buffer = GetUnitGoldCost2(racial_expansion)
					set wood_buffer = GetUnitWoodCost2(racial_expansion)	
					set militia_expansion = current_expansion 
					if GetGold() >= GetUnitGoldCost2(racial_expansion) and GetWood() >= GetUnitWoodCost2(racial_expansion) then
					if GetMilitiaExpansionStrength() <= 0 then
						set militia_expanding = false
						set militia_state = 2
					else
						set militia_expanding = true
						call Trace("Militia active")
						set militia_state = 1
					endif		
					endif
		        endif
		      else
		        set gold_buffer = 0
		        set wood_buffer = 0
		        call Trace("MILITIA_EXPAND: Militia expansion will not be done")
		        set militia = false
		      endif
			endif
		endif
		if militia then
			call TQAddJob(7, MILITIA_EXPAND, 0)
		endif
	elseif militia_state == 1 then
		set gold_buffer = GetUnitGoldCost2(racial_expansion)
		set wood_buffer = GetUnitWoodCost2(racial_expansion)	
		if ownstrength + 6 < GetExpansionStrength() then
		    set militia_expanding = false
			set militia_state = 0 // Lost units so stop trying to expand
		elseif GetMilitiaExpansionStrength() <= 0 and GetExpFoe() == null then
			set militia_expanding = false
			set militia_state = 2
			call Trace("Militia state 1 done")
		else
			set militia_expanding = true
		endif
		if militia then
			call TQAddJob(2, MILITIA_EXPAND, 0)
		endif	
	elseif militia_state == 2 then
	 call Trace("Militia state 2")
	 if GetMilitiaExpansionStrength() > 0 then
		set militia_state = 1
		set militia_expanding = true
	 endif
	 set gold_buffer = GetUnitGoldCost2(racial_expansion)
	 set wood_buffer = GetUnitWoodCost2(racial_expansion)	
	 set g = CreateGroup()
	 set tempg = CreateGroup()
	 call GroupEnumUnitsOfPlayer(tempg, ai_player,null)
	 set tempg = SelectNumberOfId(tempg, 50, old_id[racial_militia] )
	 set tempg = SelectByAlive(tempg, true)
	 if FirstOfGroup(tempg) == null then
		call GroupEnumUnitsOfPlayer(g, ai_player, null)	 
		set g = SelectNumberOfId(g, 50, old_id[racial_peon] )
		set tempg = GroupAddGroup(tempg, g)
		set tempg = SelectByAlive(tempg, true)
	 endif
	 //call GroupClear(g)
     set g = GetNearestSubGroupOfGroup(tempg, GetUnitLoc(current_expansion), 3)
     set militia_builder =FirstOfGroup(g)
	 call GroupRemoveUnit(g, militia_builder)
	 set militia_fastb1 = FirstOfGroup(g)
	 call GroupRemoveUnit(g, militia_fastb1)
	 set militia_fastb2 = FirstOfGroup(g)
	 call GroupRemoveUnit(g, militia_fastb2)
	 set militia_fastb3 = FirstOfGroup(g)
	 call RemoveGuardPosition(militia_builder)
	 call DestroyGroup(tempg)
	 call DestroyGroup(g)
	 set tempg = null
	 set g = null
	 if militia_builder != null then
		set militia_state = 3
		call Trace("Militia state 2 done")
	 endif
	 if militia then
		call TQAddJob(2, MILITIA_EXPAND, 0)
	 endif
	elseif militia_state == 3 then
		if GetMilitiaExpansionStrength() > 0 then
			set militia_state = 1
			set militia_expanding = true
		endif
		if militia_builder == null or GetUnitState(militia_builder, UNIT_STATE_LIFE) <=0 then
			set militia_state = 2
		else
			if CheckExpansionTaken(militia_expansion) then
				set militia = false
				set militia_state = 0
				set militia_expansion = null
				call RemoveLocation(militia_loc)
				set militia_loc = null
				set gold_buffer = 0
				set wood_buffer = 0
				call Trace("Militia Ended")
				call RecycleGuardPosition(militia_builder)
				return
			endif
			if militia_loc == null then
				set militia_loc = GetMilitiaExpansionLoc(old_id[racial_expansion])
			endif
			if GetGold() >= GetUnitGoldCost2(racial_hall[1]) and GetWood() >= GetUnitWoodCost2(racial_hall[1]) then
				//call IssueTargetOrder(militia_fastb1, "stop", current_expansion)
				//call IssueTargetOrder(militia_fastb2, "stop", current_expansion)
				call RecycleGuardPosition(militia_builder)  // has to be here or peasant comes off construction
				call BuildMilitiaExpansion(militia_builder, old_id[racial_expansion])		
				//set militia = false
				//set militia_state = 0
				//set militia_expansion = null
				call Trace("Militia Build commanded")			
			else 
				set gold_buffer = GetUnitGoldCost2(racial_expansion)
				set wood_buffer = GetUnitWoodCost2(racial_expansion)	
			    call Trace("Moving near")
				call RemoveGuardPosition(militia_builder)
				if militia_loc == null then
					call IssueTargetOrder(militia_builder, "move", current_expansion)
					//call IssueTargetOrder(militia_fastb1, "move", current_expansion)
					//call IssueTargetOrder(militia_fastb2, "move", current_expansion)
				else
					call IssuePointOrderLoc(militia_builder, "move", militia_loc)
				endif
			endif
		endif
		if militia then
			call TQAddJob(3, MILITIA_EXPAND, 0)
		endif
	endif

endfunction



function SendHomeMoveUnitToLoc takes unit u, integer p, location l returns nothing
local integer enemystrength = GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 800)
		if enemystrength > 0 and not UnitInvis(u) then
			call IssueImmediateOrder(u, "windwalk")
		endif
		if enemystrength > 0 and ((GetUnitState(u, UNIT_STATE_MANA) > 50 and GetUnitAbilityLevel(u, 'AEbl') == 1) or (GetUnitState(u, UNIT_STATE_MANA) > 10 and GetUnitAbilityLevel(u, 'AEbl') > 1)) then
			call IssuePointOrder(u, "blink", GetLocationX(l), GetLocationY(l))
		elseif GetUnitAbilityLevel(u, 'Ashm') > 0 and enemystrength > 0 and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) < 6) then
			call CreateDebugTag("SEND_HOME: Night Hide", 10, u, 3.00, 1.50)
			call IssueImmediateOrder(u, "ambush")
		else
			call CreateDebugTag("SEND_HOME: Moving to Location", 10, u, 3.00, 2.00)		
			call RemoveGuardPosition(u)			
			call IssuePointOrder(u, "move", GetLocationX(l), GetLocationY(l))
		endif
		call TQAddUnitJob(4, SEND_HOME, p, u)
endfunction
		
function SomeUnitHasHealingItem takes unit u, integer rhi returns unit
	local group g = CreateGroup()
	local unit aunit = null
	
	call GroupEnumUnitsInRange(g, GetUnitX(u), GetUnitY(u), 400, null)
	set g = SelectByPlayer(g,ai_player, true)
	set g = SelectByAlive(g,true)
	loop
		set aunit = FirstOfGroup(g)
		exitwhen aunit == null
		if rhi != 0 and GetItemNumberOnUnit(rhi, aunit) > 0 then
			call DestroyGroup(g)
			set g = null
			return aunit
		endif
		call GroupRemoveUnit(g, aunit)
	endloop
	call DestroyGroup(g)
	set g = null
	return null
endfunction		
		
function SendUnitHomeJob takes unit u, integer p returns nothing

local location l = null
local unit nearshopunit = null 
local group g = null
local unit corpse = null
local integer racial_healing_item = GetHeroHealingItem()
local integer racial_mana_item = GetHeroManaItem()
local integer enemystrength = 0
local unit otherhero =null 
local item it = null

  call DisplayToAllJobDebug("SEND_HOME Job")
  if racial_healing_item != null and IsUnitType(u, UNIT_TYPE_HERO) then
	set otherhero = SomeUnitHasHealingItem(u, racial_healing_item)
  endif
	
  if IsUnitType(u, UNIT_TYPE_HERO) then
  	//set shop_wanted = 1
  	if buy_type[racial_healing_item] == BT_RACIAL_ITEM then
    	//	set shop_unit = GetUnitOfTypeNearUnit(old_id[racial_shop], u)
    		set nearshopunit = GetUnitOfTypeNearUnit(old_id[racial_shop], u)
    	//	set shop_distance_limit = raceshop_distance_limit
  	else
    	//	set shop_unit = nearest_neutral[NEUTRAL_MERCHANT]
		    if not (neutral_guarded[NEUTRAL_MERCHANT] and ((GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 5 and GetFloatGameState(GAME_STATE_TIME_OF_DAY) < 18) or not neutral_night_buy[NEUTRAL_MERCHANT])) then
				set nearshopunit = nearest_neutral[NEUTRAL_MERCHANT]
			endif
    	//	set shop_distance_limit = merchant_distance_limit
  	endif
  	//set shop_sent = u
      //call TQAddJob(0, BUY_ITEM, racial_healing_item)
      //set nearshopunit = shop_unit
  endif

  call DisplayToAllJobDebug("SEND_HOME Starting check")

   
  // set enemystrength = GetLocationNonCreepStrength(GetUnitX(u), GetUnitY(u), 800)
  if GetUnitState(u, UNIT_STATE_LIFE) <= 0 then
	call CreateDebugTag("SEND_HOME unit dead", 10, u, 3.00, 1.50)
  	call GroupRemoveUnit(unit_healing, u)
    call TQAddUnitJob(2, RESET_GUARD_POSITION, p, u)  
  elseif GetUnitState(u, UNIT_STATE_LIFE) >= GetUnitState(u, UNIT_STATE_MAX_LIFE) * (I2R(p)/100) and GetUnitCurrentOrder(u) != OrderId("cannibalize") then
	call CreateDebugTag("SEND_HOME Healed", 10, u, 3.00, 1.50)	
	call GroupRemoveUnit(unit_healing, u)
    call TQAddUnitJob(2, RESET_GUARD_POSITION, 0, u)
  elseif racial_healing_item != 0 and GetItemNumberOnUnit(racial_healing_item, u) > 0 then
        set l = GetUnitLoc(u)
		if GetItemInstantType(racial_healing_item) == ITEMTYPE_CONTINUOUS and DistanceBetweenPoints(l, home_location) >= 1200 then
			call SendHomeMoveUnitToLoc(u,p,home_location)  // This should be required for all regenerative type healing items	
		else
		    set it = GetItemOfTypeOnUnit(racial_healing_item, u)
			call UnitUseItem(u, it )
			call UnitUseItemTarget(u, it, u)
			if racial_mana_item != 0 and GetUnitState(u, UNIT_STATE_MANA) < 100 and GetItemNumberOnUnit(racial_mana_item, u) > 0 then
				call UnitUseItem(u, GetItemOfTypeOnUnit(racial_mana_item, u))
			endif
			call CreateDebugTag("Hero: Use healing item", 10, u, 3.00, 2.00)	
			call TQAddUnitJob(Max(3,GetItemHealingTime(racial_healing_item)), SEND_HOME, p, u) // Have to add delay as continous healing items run out then
		endif
		call RemoveLocation(l)
		set l = null
  elseif otherhero != null then
		call UnitAddItem(u, GetItemOfTypeOnUnit(racial_healing_item, otherhero))
  elseif nearshopunit != null and GetSlotsFreeOnUnit(u) > 0 and GetItemNumberOnUnit(racial_healing_item, u) <= 0 then
    set l = GetUnitLoc(nearshopunit)
	if DistanceBetweenUnits(u, nearshopunit) >= buy_distance then
		call SendHomeMoveUnitToLoc(u,p, l)
  	else
		call CreateDebugTag("SEND_HOME Stop at Shop", 10, u, 3.00, 2.00)	
      	call IssueImmediateOrder(u, "stop")
      	call IssueNeutralImmediateOrderById(ai_player, nearshopunit, old_id[racial_healing_item])
		if GetUnitState(u, UNIT_STATE_MANA) < 100 and GetItemNumberOnUnit(racial_mana_item, u) <= 0 then
			call IssueNeutralImmediateOrderById(ai_player, nearshopunit, old_id[racial_mana_item])
		endif
		call RecycleGuardPosition(u)		
		call TQAddUnitJob(4, SEND_HOME, p, u)	
  	endif
	call RemoveLocation(l)
  	set l = null
  else
      set l = GetUnitLoc(u)
      if DistanceBetweenPoints(l, home_location) >= 1200 then
		call SendHomeMoveUnitToLoc(u,p,home_location)
	  else
		set g = CreateGroup()
		call GroupEnumUnitsInRangeOfLoc(g, home_location, 1000, null)
		set g = SelectByAlive(g, false)		
		set g = SelectUnittype(g,UNIT_TYPE_STRUCTURE,false)
		set g = SelectUnittype(g,UNIT_TYPE_DEAD,true)
		
		set corpse = FirstOfGroup(g)
		if town_threatened then
			call RecycleGuardPosition(u)   // Gives unit control for only a little bit but dosn't remove from healing group
		elseif GetUnitAbilityLevel(u, 'Ashm') > 0 and (GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18 or GetFloatGameState(GAME_STATE_TIME_OF_DAY) < 6) then
			call IssueImmediateOrder(u, "ambush")
			call CreateDebugTag("SEND_HOME hide", 10, u, 3.00, 1.50)	
		elseif GetUnitCurrentOrder(u) != OrderId("cannibalize") and (GetUnitAbilityLevel(u, 'Acn2') > 0 or GetUnitAbilityLevel(u, 'Acan') > 0 or GetUnitAbilityLevel(u, 'ACcn') > 0)  and corpse != null then
			call IssueTargetOrder(u, "move" , corpse)
			call IssueImmediateOrder(u, "cannibalize")
			call CreateDebugTag("SEND_HOME cannibalize", 10, u, 3.00, 1.50)	
		elseif GetUnitAbilityLevel(u, 'Ahrl') > 0 and GetUnitCurrentOrder(u) != OrderId("cannibalize") then   // 'Ahrl' Ghoul Harvest lumber ability
			call IssueImmediateOrder(u, "autoharvestlumber")
			call CreateDebugTag("SEND_HOME harvest lumber", 10, u, 3.00, 1.50)	
		endif
		call DestroyGroup(g)
		set g = null
		call TQAddUnitJob(4, SEND_HOME, p, u)
	  endif
      call RemoveLocation(l)
	  set l = null
	  //call DisplayToAllJobDebug("SEND_HOME: JOB Finished!!!! ")
  endif
endfunction
function ResetWindWalkerGuardPosition takes unit u returns nothing
  call DisplayToAllJobDebug("RESET_GUARD_POSITION JOB START")
  	if not IsUnitInGroup(u, unit_healing) and not IsUnitInGroup(u, unit_rescueing ) and not IsUnitInGroup(u, unit_harassing ) and not IsUnitInGroup(u, unit_zepplin_move ) then
	else
		call GroupRemoveUnit(windwalk_group, u)
		return
	endif
	if IsUnitInvisible(u, Player(PLAYER_NEUTRAL_AGGRESSIVE)) then
		//call IssueImmediateOrder(u, "windwalk")
		//call UnitRemoveAbility(u, 'BOwk')
		if CaptainRetreating() and isfleeing then
			call RecycleGuardPosition(u)
			call GroupRemoveUnit(windwalk_group, u)
			//call AddAssault(1, GetUnitTypeId(u))
			return
		else
			call RecycleGuardPosition(u)
			call AddAssault(1, GetUnitTypeId(u))
			//call IssuePointOrder(u, "move", GetLocationX(army_loc[main_army]), GetLocationY(army_loc[main_army]))
			call TQAddUnitJob(8, RESET_WINDWALKER, 0, u)		
		endif
	else
		call RecycleGuardPosition(u)
		call GroupRemoveUnit(windwalk_group, u)
		call AddAssault(1, GetUnitTypeId(u))	
		return
	endif

	//	return
	//endif
	//call TQAddUnitJob(3, RESET_WINDWALKER, 0, u)
endfunction

function TQDoJob takes integer jid, integer par, unit unit_par, group group_par returns nothing
if jid < 22 then
if jid < 13 then
if jid < 4 then
if jid < 2 then
if jid < 1 then
call ResetByHealthJob(unit_par, par)
 else
call ZeppelinMoveJob(par, unit_par, group_par)
 endif
 else
if jid < 3 then
call TeleportJob(unit_par)
 else
call TownTrackJob()
 endif
 endif
 else
if jid < 9 then
if jid < 5 then
call ChatVarsJob()
 else
if jid < 8 then
if jid < 7 then
if jid < 6 then
call RevealEnemy()
 else
call Chat(par)
 endif
 else
call CleanupBlocksJob()
 endif
 else
call NeutralGuardedJob(par)
 endif
 endif
 else
if jid < 12 then
if jid < 10 then
call ResetWindWalkerGuardPosition(unit_par)
 else
if jid < 11 then
call SellZigguratJob()
 else
call ExchangeJob()
 endif
 endif
 else
call ZeppelinFollowJob()
 endif
 endif
 endif
 else
if jid < 17 then
if jid < 15 then
if jid < 14 then
call ResetGuardPositionJob(unit_par)
 else
call BuyItemJob(par)
 endif
 else
if jid < 16 then
call HealthFountainJob(unit_par, par)
 else
call ManaFountainJob(unit_par, par)
 endif
 endif
 else
if jid < 19 then
if jid < 18 then
call NeutralEnemyCheckJob(par)
 else
call MoonWellJob(unit_par, par)
 endif
 else
if jid < 20 then
call SendUnitHomeJob(unit_par, par)
 else
if jid < 21 then
call BuyNeutral(par)
 else
call BuyNeutralHero(par)
 endif
 endif
 endif
 endif
 endif
 else
if jid < 34 then
if jid < 30 then
if jid < 26 then
if jid < 24 then
if jid < 23 then
call UpdateStrengthJob()
 else
call DetectDefeatJob()
 endif
 else
if jid < 25 then
call DetectDoubleExpJob()
 else
call WispCheckJob()
 endif
 endif
 else
if jid < 28 then
if jid < 27 then
call MicroUnitsJob()
 else
call MilitiaCheckJob()
 endif
 else
if jid < 29 then
call TowerRushJob()
 else
call FocusFireJob()
 endif
 endif
 endif
 else
if jid < 33 then
if jid < 32 then
if jid < 31 then
call FastBuild()
 else
call TryMilitiaExpansionFoot()
 endif
 else
call HarassJob(par, unit_par, group_par)
 endif
 else
call MicroHeroJob(par)
 endif
 endif
 else
if jid < 35 then
call RetreatControlJob()
 else
if jid < 39 then
if jid < 36 then
call ArmyTrackJob()
 else
if jid < 38 then
if jid < 37 then
call RallypointJob()
 else
call AncientExpansionJob()
 endif
 else
call RepairControlJob()
 endif
 endif
 else
if jid < 40 then
call TowerRushCheck()
 else
call AncientExpansionCheck()
 endif
 endif
 endif
 endif
 endif
endfunction

function TQHandleOnce takes nothing returns boolean
  local integer jid = tq_jid[1]
  local integer par = tq_par[1]
  local unit unit_par = tq_unit_par[1]
  local group group_par = tq_group_par[1]
  if TimerGetElapsed(tq_timer) >= tq_time[1] then
    call TQRemoveRoot()
    call TQDoJob(jid, par, unit_par, group_par)
    return true
  endif
  return false
endfunction

function TQInitJobs takes nothing returns nothing
  call TQAddJob(GetRandomReal(5, 30), TIMED_CHAT, C_Greet)
  call TQAddJob(GetRandomReal(5, 10), TIMED_CHAT, C_STRATEGY)
  
  call TQAddJob(GetRandomReal(50, 65), UPDATE_STRENGTH, 0)
  call TQAddJob(GetRandomReal(120, 135), REVEAL_ENEMY, 0)
  call TQAddJob(GetRandomReal(90, 110), DETECT_DEFEAT, 0)
  call TQAddJob(GetRandomReal(100, 120), DETECT_DOUBLE_EXP, 0)
  call TQAddJob(GetRandomReal(80, 100), ZEPPELIN_FOLLOW, 0)
  call TQAddJob(GetRandomReal(0, 10), REPAIR_CONTROL, 0)
  call TQAddJob(GetRandomReal(60, 70), CLEANUP_BLOCKS, 0)
  call TQAddJob(GetRandomReal(10, 20), MICRO_UNITS, 0)
  call TQAddJob(GetRandomReal(20, 30), RALLY_POINT, 0)
  call TQAddJob(GetRandomReal(50, 60), ARMY_TRACK, 0)
  call TQAddJob(GetRandomReal(50, 60), TOWN_TRACK, 0)
  call TQAddJob(GetRandomReal(1, 2), CHAT_VARS, 0)
  call TQAddJob(GetRandomReal(40, 60), FOCUSFIRE_CONTROL, 0)

  if force_number > 1 then
    call TQAddJob(GetRandomReal(75, 90), EXCHANGE, 0)
  endif
  if race_manual_loading then
    call TQAddJob(GetRandomReal(200, 220), WISP_CHECK, 0)
  endif
  if race_militia_available then
    call TQAddJob(GetRandomReal(80, 90), MILITIA_CHECK, 0)
  endif
  if race_towerrush_available then
    call TQAddJob(GetRandomReal(0, 10), TOWER_RUSH_CHECK, 0)
  endif
  if race_ancient_expansion_available then
    call TQAddJob(GetRandomReal(10, 20), ANCIENT_EXPANSION_CHECK, 0)
  endif
  if race_sell_ziggurats then
    call TQAddJob(GetRandomReal(300, 400), SELL_ZIGGURATS, 0)
  endif
  if race_has_power_build then
    call TQAddJob(GetRandomReal(10, 20), FAST_BUILD, 0)
  endif
  if militia then
    call TQAddJob(GetRandomReal(40, 50), MILITIA_EXPAND, 0)
  endif
endfunction

function TQLoop takes nothing returns nothing
  set tq_time[0] = 0
  call TimerStart(tq_timer, 1000000, false, null)
  //call Trace("Starting Job Loop Thread")
  call TQInitJobs()
  //call Trace("Job Initialisation done")
  loop
    exitwhen player_defeated
    if tq_length > 0 then
      if not TQHandleOnce() then
        call Sleep(RMin(tq_time[1] - TimerGetElapsed(tq_timer) + 0.05 ,1))
	  else
	    call Sleep(0.05)
      endif
    else
	  call Trace("TQLOOP: No job is ready to fire")
      call Sleep(sleep_multiplier)
    endif
  endloop
  call Trace("Shutting down Job Thread")
  loop
    call ExchangeOnce()
    call Sleep(30)
  endloop
endfunction

function CheckNeutral takes integer nn returns nothing
if neutral_available[nn] == true then
    set neutral_ordered[nn] = false
    set neutral_sent[nn] = null
    set buy_time_large[nn] = -1
    set buy_time_small[nn] = -1
    
    set nearest_neutral[nn] = GetNearestNeutral(neutral_id[nn])
    set neutral_guards[nn] = GetCreepGuardGroup(nn)
    set neutral_guarded[nn] = GetNeutralGuard(nn) != null
    set neutral_night_buy[nn] = CanCreepGuardsSleep(nn)
    // set neutral_night_buy[nn] = not no_sleep
    if neutral_guarded[nn] then
      call TQAddJob(30 * sleep_multiplier, NEUTRAL_GUARDED, nn)
    endif
	
	if nearest_neutral[nn] != null then
	  call Trace("Neutral Pathing ID done: " + Int2Str(nn)) 
	else
	  call Trace("Neutral Pathing ID done (no pathable neutral): " + Int2Str(nn))
	endif
endif

endfunction

function InitNeutralBuildings takes nothing returns nothing
  local group g = CreateGroup()
  local integer i = 0
  local integer j = 0
  local integer k = 0
  local integer m = 0
  local integer array camp
  local integer array roost
  local integer array merc_types
  local boolean mercfound = false
  local boolean roostfound = false
  local boolean tavernfound = false
  local unit u = null

    set neutral_id[NEUTRAL_TAVERN] = 'ntav'
    set neutral_id[NEUTRAL_MERCHANT] = 'ngme'
    set neutral_id[NEUTRAL_HEALING_FOUNTAIN] = 'nfoh'
    set neutral_id[NEUTRAL_MANA_FOUNTAIN] = 'nmoo'
    set neutral_id[NEUTRAL_OBSERVATORY] = 'ngad'
    set neutral_id[NEUTRAL_SHIPYARD] = 'nshp'
    set neutral_id[NEUTRAL_MARKETPLACE] = 'nmrk'


  set camp[1] = 'nmr5'
  set camp[2] = 'nmr4'
  set camp[3] = 'nmrf'
  set camp[4] = 'nmr8'
  set camp[5] = 'nmr9'
  set camp[6] = 'nmrb'
  set camp[7] = 'nmr6'
  set camp[8] = 'nmrd'
  set camp[9] = 'nmr2'
  set camp[10] = 'nmer'
  set camp[11] = 'nmr3'
  set camp[12] = 'nmr7'
  set camp[13] = 'nmre'
  set camp[14] = 'nmrc'
  set camp[15] = 'nmra'
  set camp[16] = 'nmr0'
  set j = 16


  set roost[1] = 'ndrk'
  set roost[2] = 'ndru'
  set roost[3] = 'ndrz'
  set roost[4] = 'ndrg'
  set roost[5] = 'ndro'
  set roost[6] = 'ndrr'
  set m = 6

    call GroupEnumUnitsOfPlayer(g, Player(PLAYER_NEUTRAL_PASSIVE), null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == neutral_id[NEUTRAL_TAVERN] then
      set neutral_available[NEUTRAL_TAVERN] = true
    elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_MERCHANT] then
    	set neutral_available[NEUTRAL_MERCHANT] = true
    elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_OBSERVATORY] then
    	set neutral_available[NEUTRAL_OBSERVATORY] = true
    elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_HEALING_FOUNTAIN] then
    	set neutral_available[NEUTRAL_HEALING_FOUNTAIN] = true
    elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_MANA_FOUNTAIN] then
    	set neutral_available[NEUTRAL_MANA_FOUNTAIN] = true
    elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_SHIPYARD] then
    	set neutral_available[NEUTRAL_SHIPYARD] = true
    elseif GetUnitTypeId(u) == neutral_id[NEUTRAL_MARKETPLACE] then
    	set neutral_available[NEUTRAL_MARKETPLACE] = true
    elseif not mercfound then
	loop
		set i = i + 1
      	if GetUnitTypeId(u) == camp[i] then
			set mercfound = true
		endif
	      exitwhen mercfound or i >= j
	endloop
    elseif not roostfound then
      loop
      	set k = k + 1
		if GetUnitTypeId(u) == roost[k] then
			set roostfound = true
    		endif
	      exitwhen roostfound or k >= m
	endloop
    else
    endif
    call GroupRemoveUnit(g, u)
  endloop
  call DestroyGroup(g)
  set g = null

if mercfound then

  if not mercfound then
  elseif i == 1 then
    set merc_unit[0] = SATYR_SHADOWDANCER
    set merc_unit[1] = FURBOLG_SHAMAN
    set merc_unit[2] = THUNDER_LIZARD
    set merc_unit[3] = 0
    set merc_types[1] = FURBOLG_SHAMAN
    set merc_types[2] = SATYR_SHADOWDANCER
    set merc_types[3] = 0
    set merc_types[4] = THUNDER_LIZARD
    set merc_types[5] = THUNDER_LIZARD
    set merc_types[6] = 0
  elseif i == 2 then
    set merc_unit[0] = CENTAUR_OUTRUNNER
    set merc_unit[1] = HARPY_ROGUE
    set merc_unit[2] = RAZORMANE_MEDICINE_MAN
    set merc_unit[3] = HARPY_WINDWITCH
    set merc_types[1] = RAZORMANE_MEDICINE_MAN
    set merc_types[2] = HARPY_WINDWITCH
    set merc_types[3] = CENTAUR_OUTRUNNER
    set merc_types[4] = HARPY_ROGUE
    set merc_types[5] = 0
    set merc_types[6] = CENTAUR_OUTRUNNER
  elseif i == 3 then
    set merc_unit[0] = FEL_BEAST
    set merc_unit[1] = DRAENEI_DISCIPLE
    set merc_unit[2] = VOIDWALKER
    set merc_unit[3] = DRAENEI_DARKSLAYER
    set merc_types[1] = DRAENEI_DISCIPLE
    set merc_types[2] = VOIDWALKER
    set merc_types[3] = DRAENEI_DARKSLAYER
    set merc_types[4] = VOIDWALKER
    set merc_types[5] = 0
    set merc_types[6] = FEL_BEAST
  elseif i == 4 then
    set merc_unit[0] = ROGUE
    set merc_unit[1] = ASSASSIN
    set merc_unit[2] = KOBOLD_GEOMANCER
    set merc_unit[3] = FOREST_TROLL_HIGH_PRIEST
    set merc_types[1] = FOREST_TROLL_HIGH_PRIEST
    set merc_types[2] = KOBOLD_GEOMANCER
    set merc_types[3] = ROGUE
    set merc_types[4] = ASSASSIN
    set merc_types[5] = 0
    set merc_types[6] = 0
  elseif i == 5 then
    set merc_unit[0] = ROGUE
    set merc_unit[1] = ASSASSIN
    set merc_unit[2] = KOBOLD_GEOMANCER
    set merc_unit[3] = FOREST_TROLL_HIGH_PRIEST
    set merc_types[1] = FOREST_TROLL_HIGH_PRIEST
    set merc_types[2] = KOBOLD_GEOMANCER
    set merc_types[3] = ROGUE
    set merc_types[4] = ASSASSIN
    set merc_types[5] = 0
    set merc_types[6] = 0
  elseif i == 6 then
    set merc_unit[0] = BURNING_ARCHER
    set merc_unit[1] = KOBOLD_GEOMANCER
    set merc_unit[2] = WILDKIN
    set merc_unit[3] = 0
    set merc_types[1] = 0
    set merc_types[2] = KOBOLD_GEOMANCER
    set merc_types[3] = WILDKIN
    set merc_types[4] = BURNING_ARCHER
    set merc_types[5] = 0
    set merc_types[6] = BURNING_ARCHER
  elseif i == 7 then
    set merc_unit[0] = MURLOC_FLESHEATER
    set merc_unit[1] = SLUDGE_FLINGER
    set merc_unit[2] = SATYR_SOULSTEALER
    set merc_unit[3] = 0
    set merc_types[1] = 0
    set merc_types[2] = SATYR_SOULSTEALER
    set merc_types[3] = MURLOC_FLESHEATER
    set merc_types[4] = SLUDGE_FLINGER
    set merc_types[5] = 0
    set merc_types[6] = MURLOC_FLESHEATER
  elseif i == 8 then
    set merc_unit[0] = BARBED_ARACHNATHID
    set merc_unit[1] = BLUE_DRAGONSPAWN_MEDDLER
    set merc_unit[2] = MAGNATAUR_WARRIOR
    set merc_unit[3] = POLAR_FURBOLG_SHAMAN
    set merc_types[1] = 0
    set merc_types[2] = POLAR_FURBOLG_SHAMAN
    set merc_types[3] = MAGNATAUR_WARRIOR
    set merc_types[4] = 0
    set merc_types[5] = 0
    set merc_types[6] = BARBED_ARACHNATHID
  elseif i == 9 then
    set merc_unit[0] = GNOLL_BRUTE
    set merc_unit[1] = GNOLL_WARDEN
    set merc_unit[2] = OGRE_MAGI
    set merc_unit[3] = MUD_GOLEM
    set merc_types[1] = 0
    set merc_types[2] = OGRE_MAGI
    set merc_types[3] = GNOLL_BRUTE
    set merc_types[4] = GNOLL_WARDEN
    set merc_types[5] = 0
    set merc_types[6] = GNOLL_BRUTE
  elseif i == 10 then
    set merc_unit[0] = FOREST_TROLL_BERSERKER
    set merc_unit[1] = FOREST_TROLL_SHADOW_PRIEST
    set merc_unit[2] = OGRE_MAULER
    set merc_unit[3] = MUD_GOLEM
    set merc_types[1] = FOREST_TROLL_SHADOW_PRIEST
    set merc_types[2] = MUD_GOLEM
    set merc_types[3] = OGRE_MAULER
    set merc_types[4] = FOREST_TROLL_BERSERKER
    set merc_types[5] = 0
    set merc_types[6] = 0
  elseif i == 11 then
    set merc_unit[0] = GNOLL_OVERSEER
    set merc_unit[1] = ICE_TROLL_BERSERKER
    set merc_unit[2] = ICE_TROLL_TRAPPER
    set merc_unit[3] = MUD_GOLEM
    set merc_types[1] = 0
    set merc_types[2] = MUD_GOLEM
    set merc_types[3] = GNOLL_OVERSEER
    set merc_types[4] = ICE_TROLL_BERSERKER
    set merc_types[5] = ICE_TROLL_TRAPPER
    set merc_types[6] = 0
  elseif i == 12 then
    set merc_unit[0] = NERUBIAN_WARRIOR
    set merc_unit[1] = ICE_TROLL_BERSERKER
    set merc_unit[2] = FROST_REVENANT
    set merc_unit[3] = NERUBIAN_WEBSPINNER
    set merc_types[1] = 0
    set merc_types[2] = FROST_REVENANT
    set merc_types[3] = NERUBIAN_WARRIOR
    set merc_types[4] = ICE_TROLL_BERSERKER
    set merc_types[5] = NERUBIAN_WEBSPINNER
    set merc_types[6] = NERUBIAN_WARRIOR
  elseif i == 13 then
    set merc_unit[0] = FEL_BEAST
    set merc_unit[1] = DRAENEI_DISCIPLE
    set merc_unit[2] = VOIDWALKER
    set merc_unit[3] = DRAENEI_DARKSLAYER
    set merc_types[1] = DRAENEI_DISCIPLE
    set merc_types[2] = VOIDWALKER
    set merc_types[3] = DRAENEI_DARKSLAYER
    set merc_types[4] = VOIDWALKER
    set merc_types[5] = 0
    set merc_types[6] = FEL_BEAST
  elseif i == 14 then
    set merc_unit[0] = MURGUL_SNARECASTER
    set merc_unit[1] = MAKRURA_SNAPPER
    set merc_unit[2] = MAKRURA_DEEPSEER
    set merc_unit[3] = GIANT_SEA_TURTLE
    set merc_types[1] = 0
    set merc_types[2] = MAKRURA_DEEPSEER
    set merc_types[3] = MAKRURA_SNAPPER
    set merc_types[4] = GIANT_SEA_TURTLE
    set merc_types[5] = 0
    set merc_types[6] = GIANT_SEA_TURTLE
  elseif i == 15 then
    set merc_unit[0] = BURNING_ARCHER
    set merc_unit[1] = KOBOLD_GEOMANCER
    set merc_unit[2] = WILDKIN
    set merc_unit[3] = 0
    set merc_types[1] = 0
    set merc_types[2] = KOBOLD_GEOMANCER
    set merc_types[3] = WILDKIN
    set merc_types[4] = BURNING_ARCHER
    set merc_types[5] = 0
    set merc_types[6] = BURNING_ARCHER
  elseif i == 16 then
    set merc_unit[0] = KOBOLD
    set merc_unit[1] = MURLOC_HUNTSMAN
    set merc_unit[2] = ASSASSIN
    set merc_unit[3] = KOBOLD_GEOMANCER
    set merc_types[1] = 0
    set merc_types[2] = KOBOLD_GEOMANCER
    set merc_types[3] = KOBOLD
    set merc_types[4] = ASSASSIN
    set merc_types[5] = MURLOC_HUNTSMAN
    set merc_types[6] = KOBOLD
  endif
  
  set merc_healer = merc_types[1]
  set merc_caster = merc_types[2]
  set merc_melee = merc_types[3]
  set merc_range = merc_types[4]
  set merc_stopper = merc_types[5]
  set merc_rush = merc_types[6]

  set merc_number = 0
  set j = 0
  loop
    exitwhen j >= 4
    if merc_unit[j] != 0 then
      set merc_number = merc_number + 1
    endif
    set j = j + 1
  endloop
  
  set neutral_id[NEUTRAL_MERC_CAMP] = camp[i]
  set neutral_available[NEUTRAL_MERC_CAMP] = true
endif

if roostfound then
  if not roostfound then
  elseif k == 1 then
    set dragons[1] = BLACK_DRAGON_1
    set dragons[2] = BLACK_DRAGON_2
    set dragons[3] = BLACK_DRAGON_3
  elseif k == 2 then
    set dragons[1] = BLUE_DRAGON_1
    set dragons[2] = BLUE_DRAGON_2
    set dragons[3] = BLUE_DRAGON_3
  elseif k == 3 then
    set dragons[1] = BRONZE_DRAGON_1
    set dragons[2] = BRONZE_DRAGON_2
    set dragons[3] = BRONZE_DRAGON_3
  elseif k == 4 then
    set dragons[1] = GREEN_DRAGON_1
    set dragons[2] = GREEN_DRAGON_2
    set dragons[3] = GREEN_DRAGON_3
  elseif k == 5 then
    set dragons[1] = NETHER_DRAGON_1
    set dragons[2] = NETHER_DRAGON_2
    set dragons[3] = NETHER_DRAGON_3
  elseif k == 6 then
    set dragons[1] = RED_DRAGON_1
    set dragons[2] = RED_DRAGON_2
    set dragons[3] = RED_DRAGON_3
  endif
	set dragon_number = 3

  
  set neutral_id[NEUTRAL_DRAGON_ROOST] = roost[i]
  set neutral_available[NEUTRAL_DRAGON_ROOST] = true
endif

endfunction

function CheckAllNeutrals takes nothing returns nothing
    local integer i = 0

  call Sleep(5)
  loop
	exitwhen i > 8
      call CheckNeutral(i)
	set i = i + 1
  endloop

  if nearest_neutral[NEUTRAL_HEALING_FOUNTAIN] != null then
    call TQAddJob(10, NEUTRAL_ENEMY_CHECK, NEUTRAL_HEALING_FOUNTAIN)
  endif

  if nearest_neutral[NEUTRAL_MANA_FOUNTAIN] != null then
    call TQAddJob(10, NEUTRAL_ENEMY_CHECK, NEUTRAL_MANA_FOUNTAIN)
  endif
endfunction

function CheckNeutralQuick takes integer nn returns nothing
if neutral_available[nn] == true then
    set neutral_ordered[nn] = false
    set neutral_sent[nn] = null
    set buy_time_large[nn] = -1
    set buy_time_small[nn] = -1

    set nearest_neutral[nn] = GetNearestNeutralQuick(neutral_id[nn])
    set neutral_guards[nn] = GetCreepGuardGroup(nn)
    set neutral_guarded[nn] = GetNeutralGuard(nn) != null
    set neutral_night_buy[nn] = CanCreepGuardsSleep(nn)
    if neutral_guarded[nn] then
      call TQAddJob(30 * sleep_multiplier, NEUTRAL_GUARDED, nn)
    endif
endif
endfunction

function CheckAllNeutralsQuick takes nothing returns nothing
	local integer i = 0
	
  loop
	exitwhen i > 8
      call CheckNeutralQuick(i)
	set i = i + 1
  endloop

 // if nearest_neutral[NEUTRAL_HEALING_FOUNTAIN] != null then
 //   call TQAddJob(10, NEUTRAL_ENEMY_CHECK, NEUTRAL_HEALING_FOUNTAIN)
 // endif

 // if nearest_neutral[NEUTRAL_MANA_FOUNTAIN] != null then
 //   call TQAddJob(10, NEUTRAL_ENEMY_CHECK, NEUTRAL_MANA_FOUNTAIN)
 // endif
 endfunction
function PathingThread takes nothing returns nothing

  call SetAIArray()
  call ComputeFrontPoints()
  call Sleep(3)
  //set current_expansion = GetExpNearestMin()  // Rough guide to what first expansion should be
  call CheckAllNeutralsQuick() // Old system check
  call MakeExpansionList()
  set water_map = water_expansion_list_length >= expansion_list_length
  call ChooseExpansion()
  call CheckFastExpansion()  
  call CheckAllNeutrals() // The more advanced new system check

endfunction

function QueueReset takes nothing returns nothing
    set queue_length 	= 0
    set queue_pointer	= 0
endfunction

function QueueRestart takes nothing returns nothing
    set queue_pointer	= 0
endfunction

function QueueGetNextUnit takes nothing returns unit
    return target_queue_u[queue_pointer]
endfunction

function QueueGetNextX takes nothing returns integer
    return target_queue_x[queue_pointer]
endfunction

function QueueGetNextY takes nothing returns integer
    return target_queue_y[queue_pointer]
endfunction

function QueuePopCommand takes nothing returns nothing
    set queue_pointer = queue_pointer + 1
endfunction

function QueueFinished takes nothing returns boolean
    return queue_pointer >= queue_length
endfunction

function QueueGetNextCommand takes nothing returns boolean
  if QueueFinished() then
    set queue_running = false
    call QueueReset()
    return false
  else
    set queue_t_u = QueueGetNextUnit()
    if queue_t_u == null then
	set queue_t_x = QueueGetNextX()
	set queue_t_y = QueueGetNextY()
	set queue_attack_p = true
	set queue_attack_u = false
    else
	set queue_attack_u = true
	set queue_attack_p = false
    endif
    call QueuePopCommand()
    return true
  endif
endfunction

function QueueSetCommand takes integer x, integer y, unit u returns nothing
  set target_queue_x[queue_length] = x
  set target_queue_y[queue_length] = y
  set target_queue_u[queue_length] = u
  set queue_length = queue_length + 1
endfunction

function QueueRemoveCommand takes nothing returns nothing
  set queue_length = queue_length - 1
endfunction

function cmd_cancel takes integer cmd, integer data returns nothing
  if cmd == 0 then		// Cancel all orders
    set break_attack 	= false
    set go_home		= false
    set strategy	= chosen_strategy
    set attack_player	= false
    set attack_point	= false
    set no_attack	= false
    set no_creep_attack	= false
    set no_player_attack = false
    set queue_running	= false
    call Trace("Cancel All command" )

  elseif cmd == 1 then	// Cancel build orders
    set strategy = chosen_strategy
    call Trace("Cancel Build Command" )

  elseif cmd == 2 then	// Cancel attacking orders
    set attack_player	= false
    set attack_point	= false
    set no_attack	= false
    set no_creep_attack	= false
    set no_player_attack = false
    set queue_running	= false
    call Trace("Cancel Attack Command" )

  endif
endfunction

function cmd_attack takes integer cmd, integer data returns nothing
  local group gr = null
  if cmd == 10 then	// Stop the current attack
    set break_attack	= true
    set go_home		= true
    set queue_running	= false
    set attack_player	= false
    set attack_point	= false
    call Trace("Stop Attack Command" )

  elseif cmd == 11 then	// Start no attacks
    set break_attack	= true
    set no_attack		= true
    call Trace("No Attacks Command" )
  elseif cmd == 12 then	// Attack specific player
    set break_attack	= true
    set go_home		= false
    set attack_target_p = data
    set attack_player	= true
    set attack_point	= false
    call Trace("Attack Player Command" )

  elseif cmd == 13 then	// Attack specific point
    call Trace("Attack Point Command" )
    loop
      exitwhen CommandsWaiting()!=0
      call Sleep(0.5)
    endloop
    set attack_target_x	= GetLastCommand()
    set attack_target_y	= GetLastData()
    set break_attack	= true
    set go_home		= false
    set attack_point	= true
    set attack_player	= false
    call PopLastCommand()
    call Trace("Attack Coordinates received" )

  elseif cmd == 14 then	// No attacks on creeps
    set no_creep_attack	= true
    call Trace("Attack No Creeps" )

  elseif cmd == 15 then	// No attack on players
    set no_player_attack = true
    call Trace("Attack No Player" )

  elseif cmd == 16 then	// Attack selected unit
    set gr = CreateGroup()
    call GroupEnumUnitsSelected(gr, Player(data), null)
    set target_unit	= FirstOfGroup(gr)
    call DestroyGroup(gr)
    set gr = null
    if target_unit == null then
      call DisplayToAllies(chat_no_unit_selected)
    endif
    set attack_point	= false
    set attack_player	= false
    set attack_unit	= true
    set break_attack	= true
    set go_home		= false
    call DisplayToAllies(chat_confirm_attack_unit)

  elseif cmd == 17 then // Towerrush
    if race_towerrush_available then
      call StartTowerRush(1)
      call DisplayToAllies(chat_towerrush)
    else
      call DisplayToAllies(chat_no_orc)
    endif

  endif
endfunction

function cmd_build takes integer cmd, integer data returns nothing
  if false then
  elseif cmd == 20 then
    set strategy = 50
    set bn_airair = data
  elseif cmd == 21 then
    set strategy = 51
    set bn_airground = data
  elseif cmd == 22 then
    set strategy = 52
    set bn_groundair = data
  elseif cmd == 23 then
    set strategy = 53
    set bn_groundground = data
  elseif cmd == 24 then
    set strategy = 54
    set bn_farm = data
  elseif cmd == 25 then
    set strategy = 55
    set bn_guard = data
  endif
endfunction

function cmd_queue takes integer cmd, integer data returns nothing
  local group gr = null
  if cmd == 30 then	// Cancel queue
    call QueueReset()
    set queue_running 	= false
    call Trace("Cancel Queue Command" )

  elseif cmd == 31 then	// Queue Attack specific point
    call Trace("Queue Attack Point Command" )
    loop
      exitwhen CommandsWaiting()!=0
      call Sleep(0.5)
    endloop
    call QueueSetCommand(GetLastCommand(), GetLastData(), null)
    call PopLastCommand()
    call Trace("Attack Coordinates received" )

  elseif cmd == 32 then	// Queue Attack selected unit
    set gr = CreateGroup()
    call GroupEnumUnitsSelected(gr, Player(data), null)
    if FirstOfGroup(gr) == null then
      call DisplayToAllies(chat_no_unit_selected)
    else
      call QueueSetCommand(0,0, FirstOfGroup(gr))
      call DisplayToAllies(chat_confirm_attack_unit)
    endif
    call DestroyGroup(gr)
    set gr = null

  elseif cmd == 33 then	// Starting or Restarting queue
    call QueueRestart()
    if QueueGetNextCommand() then
      set queue_running = true
      set no_attack	= false
      call Trace("Queue started" )
    else
      call Trace("Queue is empty" )
    endif

  elseif cmd == 34 then	// Pausing queue
    set queue_running = false

  elseif cmd == 35 then	// Unpausing queue
    set queue_running = true

  elseif cmd == 36 then	// Removing last command
    call QueueRemoveCommand()

  endif
endfunction

function cmd_misc takes integer cmd, integer data returns nothing
  if cmd == 50 then	// Triggering chat
    set chatting = not chatting

  elseif cmd == 51 then	// Triggering debug
    set debugging = not debugging

  elseif cmd == 52 then	// Triggering balancing
    set balancing = not balancing

  elseif cmd == 53 then
    set strat_change_allowed = not strat_change_allowed

  elseif cmd == 60 then // Show strat name
    call DisplayToAllies(GetCurrentStrategyReport())

  elseif cmd == 61 then // Show all strats
    call DisplayStratNames()

  elseif cmd == 70 then // change strategy
    if data < rp_strat_length then
      set strategy = data
      set chosen_strategy = strategy
    else
      call DisplayToAllies("Invalid strategy number")
    endif

  elseif cmd == 71 then // change language
    if false then
    elseif data == 0 then
      set language = "English"
    elseif data == 1 then
      set language = "Deutsch"
    elseif data == 2 then
      set language = "Swedish"
    elseif data == 3 then
      set language = "French"
    elseif data == 4 then
      set language = "Spanish"
    elseif data == 5 then
      set language = "Romanian"
    elseif data == 6 then
      set language = "Russian"
    elseif data == 7 then
      set language = "Portuguese"
    elseif data == 8 then
      set language = "Norwegian"
    elseif data == 9 then
      set language = "Chinese"
    endif
    call InitChatArrays()

  endif
endfunction

function cmd_loop takes nothing returns nothing
  local integer cmd = 0
  local integer data = 0

  call StaggerSleep(0,3)
  call Trace("Starting Commander Thread Loop" )
  
  loop
    loop
      exitwhen CommandsWaiting()!=0
      exitwhen player_defeated
      call Sleep(command_wait * sleep_multiplier)
    endloop
    exitwhen player_defeated
    set cmd = GetLastCommand()
    set data = GetLastData()
    call PopLastCommand()
    call Trace("Receiving command" )

    if cmd < 10 then
      call cmd_cancel(cmd, data)

    elseif cmd < 20 then
      call cmd_attack(cmd, data)

    elseif cmd < 30 then
      call cmd_build(cmd, data)

    elseif cmd < 40 then
      call cmd_queue(cmd, data)

    else
      call cmd_misc(cmd, data)

    endif

  endloop

endfunction

function InitTownBuilt takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i >= max_towns
    set town_built[i] = false
    set i = i + 1
  endloop
  set town_built[0] = true
  set own_town_loc[0] = Location(GetLocationX(home_location), GetLocationY(home_location))
  set own_town_dist[0] = 0
  set own_town_mine[0] = GetMineNearLoc(home_location, 1500)
endfunction

function GetBuildLock takes nothing returns nothing
    loop
      exitwhen build_lock
      call Trace("Build Lock not received")
      call Sleep(0.5)
    endloop
    set build_lock = false
endfunction

function ReleaseBuildLock takes nothing returns nothing
    set build_lock = true
endfunction

function InitUpkeep takes nothing returns nothing
  set upkeep_allowed[UPKEEP_LOW] = UPKEEP_UNDECIDED
  set upkeep_border[UPKEEP_LOW] = 50
  set upkeep_resistance[UPKEEP_LOW] = 500
  set upkeep_save_time[UPKEEP_LOW] = 12
  set upkeep_mines_needed[UPKEEP_LOW] = 0
  set upkeep_time[UPKEEP_LOW] = -1
  set upkeep_allowed[UPKEEP_HIGH] = UPKEEP_UNDECIDED
  set upkeep_border[UPKEEP_HIGH] = 80
  set upkeep_resistance[UPKEEP_HIGH] = 2000
  set upkeep_save_time[UPKEEP_HIGH] = 40
  set upkeep_mines_needed[UPKEEP_HIGH] = 2
  set upkeep_time[UPKEEP_HIGH] = -1
endfunction

function InitLastUpkeep takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    set last_upkeep_allowed[i] = UPKEEP_UNDECIDED
    set i = i + 1
  endloop
endfunction

function CheckUpkeepAllowed takes integer food returns nothing
  local integer mines = GetMinesOwned()
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    if food > upkeep_border[i] then
      set upkeep_allowed[i] = UPKEEP_ALLOWED
    elseif mines < upkeep_mines_needed[i] then
      set upkeep_allowed[i] = UPKEEP_NOT_ALLOWED
      set last_upkeep_allowed[i] = UPKEEP_NOT_ALLOWED
      set upkeep_time[i] = -1
    else
      set upkeep_allowed[i] = UPKEEP_UNDECIDED
    endif
    set i = i + 1
  endloop
endfunction

function ApplyUpkeepCheck takes integer afford_food, integer food, integer food_cost, integer cost_qty, integer need_qty returns integer
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    if food + food_cost * cost_qty > upkeep_border[i] then
      if upkeep_allowed[i] == UPKEEP_UNDECIDED then
        if total_gold > upkeep_resistance[i] then
          set upkeep_allowed[i] = UPKEEP_ALLOWED
        else
          set upkeep_allowed[i] = UPKEEP_NOT_ALLOWED
        endif
      endif
      if upkeep_allowed[i] == UPKEEP_NOT_ALLOWED then
        if food_cost == 0 then
          set afford_food = need_qty
        else
          set afford_food = Max(upkeep_border[i] - food, 0) / food_cost
        endif
      endif
    endif
    set i = i + 1
  endloop
  return afford_food
endfunction

function ApplyUpkeepSaving takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    if upkeep_allowed[i] == UPKEEP_ALLOWED then
      set upkeep_time[i] = -1
    elseif last_upkeep_allowed[i] == UPKEEP_UNDECIDED and upkeep_allowed[i] == UPKEEP_NOT_ALLOWED then
      if upkeep_time[i] == -1 then
        if total_gold > 0 and total_wood > 0 then
          set upkeep_time[i] = ai_time
        endif
      elseif use_linear_upkeep_saving then
        set total_gold = total_gold - R2I(LinearInterpolation(upkeep_time[i], upkeep_time[i] + upkeep_save_time[i], 0, upkeep_resistance[i], ai_time))
      elseif ai_time >= upkeep_time[i] + upkeep_save_time[i] then
        set total_gold = total_gold - upkeep_resistance[i]
      endif
    endif
    set i = i + 1
  endloop
endfunction

function UpdateLastUpkeep takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    set last_upkeep_allowed[i] = upkeep_allowed[i]
    set i = i + 1
  endloop
endfunction

function ResetUpkeepSaveTime takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= UPKEEP_NUM
    if upkeep_allowed[i] == UPKEEP_UNDECIDED then
      set upkeep_time[i] = -1
    endif
    set i = i + 1
  endloop
endfunction

function InitBuildArrayAM takes nothing returns nothing
    local integer i = 0
    call GetBuildLock()
    set build_length = 0
    loop
      exitwhen i >= building_length
      set income_percentage[building[i]] = 1 / I2R(building_length)
      set i = i + 1
    endloop
    call ReleaseBuildLock()
endfunction

function InitUpgradeTimeArray takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > OBJECT_NUM
    set upgrade_time[i] = -1
    set i = i + 1
  endloop
endfunction

function InitPlayerStrengthCache takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= 12
    set p_str_cache[i] = 0
    set p_str_cache_timeout[i] = 0
    set i = i + 1
  endloop
endfunction

function InitHeroArrays takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > 3
    set hero[i] = 0
    set hero_built[i] = false
    set hero_unit[i] = null
    set i = i + 1
  endloop
  set hero_revive_prio[1] = hero1_revive_prio
  set hero_revive_prio[2] = hero2_revive_prio
  set hero_revive_prio[3] = hero3_revive_prio
endfunction

function InitNeutralSpecial takes nothing returns nothing
  set neutral_zeppelin = ZEPPELIN
  set neutral_shredder = SHREDDER
  set tp_item = TOWN_PORTAL
endfunction

function InitCreepStrengthArray takes nothing returns nothing
endfunction

function InitGlobalSettings takes nothing returns nothing
  set sleep_multiplier = 1
  set slm_start = 4
  set slm_end = 10
  set slm_start_mult = 1
  set slm_end_mult = 2
  set hero_radius = 200
  set use_linear_upkeep_saving = false
  set repair_threshold = 6
  set repair_threshold_threatened = 8
  set max_follow_dist = 1000
  set neutral_hero_time = 26
  set buy_distance = 350
  set buy_timeout_large = 120
  set buy_timeout_small = 3
  set build_array_reset_time = 100
  set rp_strat_normal = 250
  set strategy_tier_bonus = 22
  set attacking_strategy = 4
  set focus_fire_limit = 35
  set focus_fire_ranged_dist = 600
  set focus_fire_melee_dist = 250
  set flee_health_percentage = 0.30
  set flee_minimum_health = 100
  set statue_distance = 300
  set teleport_radius = 800
  set gold_exchange_level = 650
  set wood_exchange_level = 350
  set max_towns = 5
  set add_tag = true
  set add_skill = false
  set fav_hero_add  = 10
  set max_harass_groups = 10
  set attacking_aggression = 2
  set expansion_radius = 1000
  set harass_radius_attack_ranged = 800
  set harass_radius_attack_melee = 400
  set harass_radius_flee_ranged = 1500
  set harass_radius_flee_melee = 800
  set chatting = true
  set full_threat_distance = 1000
  set no_threat_distance = 2000
  set distance_threat_exponent = 0.8
  set distance_threat_mult = 540
  set atl_time_start = 300
  set atl_time_end = 900
  set atl_time_start_val = 10
  set atl_time_end_val = 20
  set atl_enemy_start = 1
  set atl_enemy_end = 4
  set atl_enemy_start_mult = 1
  set atl_enemy_end_mult = 1.5
  set teleport_low_threat = 100
  set teleport_high_threat = 200
  set teleport_low_threat_distance = 4000
  set teleport_high_threat_distance = 2500
  set teleport_army_min_strength = 15
  set teleport_min_threat = 50
  set shredder_peon_count = 9
  set minimum_peon_wood = 2000
  set maximum_peon_wood = 200
  set ver_neutral_heroes_available = true
  set ver_neutral_hero_number = 8
  set ver_only_heroes_buy = false
  set ver_food_limit = 100
  set normal_battle_radius = 1500
  set creep_battle_radius = 750
  set expansion_taken_radius = 1000
  set ver_hero_base_value = 4
  set ver_hero_ultimate_level = 6
  set ver_hero_ultimate_value = 6
  set ver_creeps_attack_buildings_dist = 1500
  set ver_mercs_night_buy = false
  set ver_tower_check_radius = 2000
  set ver_harass_tower_check_radius = 2200
  set ver_strat_change_enemy_strength_min = 25
  set destroy_buildings_on_defeat = true
  set attack_reform_length = 10
  set front_base_distance = 900
  set ver_heroes = true
  set fixedcomputername = false
  set green_creep_camp_strength_bonus = 0
  set orange_creep_camp_strength_bonus = 2
  set red_creep_camp_strength_bonus = 4
  set debugging = true
  set strategy_change_threshold = 1.05
  set disable_surrender = false
  set major_hero_skill_value = 60
  set minor_hero_skill_value = 30
  set rare_hero_skill_value = 10
  set fav_hero_add = 20
  set ver_optimal_gold = 5
  set ver_flee_multiple1 = 1
  set ver_flee_multiple2 = 2
  set ver_flee_multiple3 = 3
  set ver_low_aggression = -15
  set ver_high_aggression = 45
endfunction

function IsGameFFA takes nothing returns boolean
  local boolean array team_exists
  local integer i = 0
  local integer tc = 0
  loop
    exitwhen i >= 12
    set team_exists[i] = false
    set i = i + 1
  endloop
  set i = 0
  loop
    exitwhen i >= 12
    if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then
      set team_exists[GetPlayerTeam(Player(i))] = true
    endif
    set i = i + 1
  endloop
  set i = 0
  loop
    exitwhen i >= 12
    if team_exists[i] then
      set tc = tc + 1
    endif
    set i = i + 1
  endloop
  return tc > 3
endfunction


function InitRaceNames takes nothing returns nothing
  set race_name[1] = "ELF"
  set race_name[2] = "HUMAN"
  set race_name[3] = "ORC"
  set race_name[4] = "UNDEAD"
endfunction

function InitSpecialRaces takes nothing returns nothing
  local integer i = 0
  local string s = null
  loop
    exitwhen i >= 12
    set s = Int2Str(i)
    set player_race[i] = GetStoredInteger(com, "Race", s)
    set player_race_pref[i] = GetStoredInteger(com, "RacePref", s)
    set i = i + 1
  endloop
endfunction

function InitStandardRaces takes nothing returns nothing
  local integer i = 0
  local player p = null
  loop
    exitwhen i >= 12
    set p = Player(i)
    if GetPlayerRace(p) == RACE_NIGHTELF then
      set player_race[i] = SR_ELF
      if IsPlayerRacePrefSet(p, RACE_PREF_NIGHTELF) then
        set player_race_pref[i] = SR_ELF
      else
        set player_race_pref[i] = SR_RANDOM
      endif
    elseif GetPlayerRace(p) == RACE_HUMAN then
      set player_race[i] = SR_HUMAN
      if IsPlayerRacePrefSet(p, RACE_PREF_HUMAN) then
        set player_race_pref[i] = SR_HUMAN
      else
        set player_race_pref[i] = SR_RANDOM
      endif
    elseif GetPlayerRace(p) == RACE_ORC then
      set player_race[i] = SR_ORC
      if IsPlayerRacePrefSet(p, RACE_PREF_ORC) then
        set player_race_pref[i] = SR_ORC
      else
        set player_race_pref[i] = SR_RANDOM
      endif
    else
      set player_race[i] = SR_UNDEAD
      if IsPlayerRacePrefSet(p, RACE_PREF_UNDEAD) then
        set player_race_pref[i] = SR_UNDEAD
      else
        set player_race_pref[i] = SR_RANDOM
      endif
    endif
    set i = i + 1
  endloop
endfunction

function InitRaces takes nothing returns nothing
  if GetStoredBoolean(com, "Races", "Special") then
    call InitSpecialRaces()
  else
    call InitStandardRaces()
  endif
endfunction

function GetMaxFarms takes nothing returns integer
  local integer fm = GetFoodMade(old_id[racial_farm])
  local integer div = ver_food_limit / fm
  if div * fm < ver_food_limit then
    set div = div + 1
  endif
  return div
endfunction

function GetMilitiaHall takes nothing returns unit
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitAbilityLevel(u, race_militia_hall_ability) > 0 then
      call DestroyGroup(g)
      set g = null
      return u
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  return null
endfunction


function InitAMAI takes nothing returns nothing
    set message_add = c2s(GetPlayerColor(ai_player))
    if race_militia_available then
      set militia_hall = GetMilitiaHall()
    endif
    call InitDigits()
    set ai_id = Int2Str(GetAiPlayer())
    call StoreBoolean(com, "IsAMAI", ai_id, true)	
    call InitRaces()
    if IsGameFFA() then
      set game_is_ffa = true
      set attacking_strategy = 5
    endif
    call countAllyEnemy()
    if c_enemy_total == 1 and c_ally_total == 0 then
      set game_is_1on1 = true
    endif
    set sleep_multiplier = sleep_multiplier * LinearInterpolation(I2R(slm_start), I2R(slm_end), slm_start_mult, slm_end_mult, I2R(c_ai_total))
    set difficulty = MeleeDifficulty()
    set income_per_mine = income_per_mine * Max(difficulty - 1, 1)
			call Trace("Init AMAI step 1")
    call InitNeutralSpecial()
    call InitHeroArrays()
    call InitArrays()  // Has been moved to be set before all other code as is only variable declaration
    call InitChatArrays()
    call InitChatEvents()
    call InitTrans()
    call InitTranslations()
    call InitRaceNames()
    call InitCT()
    call InitChatVars()
    call InitCreepStrengthArray()
    call StopGathering()
    call InitBuildArrayAM()
    call InitUpkeep()
    call InitNeutralBuildings()
    //call StartThread(function CheckAllNeutrals)
    call InitHealers()
    call InitUpgradeTimeArray()
    call InitPlayerStrengthCache()
    call SetNearestEnemy()
    call InitTownBuilt()
    set max_farms = GetMaxFarms()
    set mine_loc = GetUnitLoc(own_town_mine[0])
    

    call StartThread(function PathingThread)  


endfunction

function AMAI takes code heroes, code peons, code attacks returns nothing
    local boolean isNewbie = (MeleeDifficulty() == EASY)

    call StoreBoolean(com, "Team"+Int2Str(GetPlayerTeam(ai_player))+"StratUsed", Int2Str(strategy_type[chosen_strategy]), true)
    set last_strategy = strategy

    call SetMeleeAI()

    call SetDefendPlayer(true)
    call SetRandomPaths(true)
    call SetTargetHeroes(not isNewbie)
    call SetPeonsRepair(true)
    call SetHeroesFlee(true)
    call SetHeroesBuyItems(not isNewbie)
    call SetUnitsFlee(false)
    call SetGroupsFlee(false)
    call SetWatchMegaTargets(true)
    call SetIgnoreInjured(race_ignore_injured)
    call SetHeroesTakeItems(true)
    call SetSlowChopping(false)
    call SetCaptainChanges(true)
    call SetSmartArtillery(not isNewbie)

    call CreateCaptains()
call Trace("Setting hero levels")	
    call SetHeroLevels(heroes)
	call Trace("heros set")	
    call Sleep(0.1)
    call StartThread(function TQLoop)
	//call Trace("TQLoop")	
    call StartThread(peons)
	//call Trace("peons")	
    call StartThread(attacks)
	//call Trace("attacks")	
    call StartThread(function cmd_loop)
	//call Trace("cmd_loop")	

endfunction

function InitCampaignDefenders takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > 200
    set campaign_defenders[i] = 0
    set i = i + 1
  endloop
endfunction

function KeyAddTimeModify takes integer k_add returns integer
  local real t = TimerGetElapsed(tq_timer)
  return R2I(LinearInterpolation(k_add_start_time, k_add_end_time, k_add_start_mult, k_add_end_mult, t) * I2R(k_add))
endfunction

function GetKeyBuildingAddExt takes integer kb returns integer
  if TownCountDone(kb) > 1 then
    return kb_add4
  elseif TownCountDone(kb) > 0 then
    return kb_add1
  elseif TownCount(kb) > 0 then
    return kb_add2
  elseif TownCountDone(needed1[kb]) > 0 and TownCountDone(needed2[kb]) > 0 then
    return kb_add3
  else
    return 0
  endif
endfunction

function GetKeyBuildingAdd takes integer sn returns integer
  return KeyAddTimeModify(GetKeyBuildingAddExt(key_building1[sn]) + GetKeyBuildingAddExt(key_building2[sn]))
endfunction

function KeyBuildingAdd takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i>= rp_strat_length
    set rp_strat[i] = rp_strat[i] + GetKeyBuildingAdd(i)
    set i = i + 1
  endloop
endfunction

function GetKeyUpgradeAddExt takes integer kb returns integer
  local integer ul = GetUpgradeLevel(old_id[kb])
  if ul >= 3 then
    return ku_add3
  elseif ul == 2 then
    return ku_add2
  elseif ul == 1 then
    return ku_add1
  else
    return 0
  endif
endfunction

function GetKeyUpgradeAdd takes integer sn returns integer
  return KeyAddTimeModify(GetKeyUpgradeAddExt(key_upgrade1[sn]) + GetKeyUpgradeAddExt(key_upgrade2[sn]))
endfunction

function KeyUpgradeAdd takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i>= rp_strat_length
    set rp_strat[i] = rp_strat[i] + GetKeyUpgradeAdd(i)
    set i = i + 1
  endloop
endfunction

function GetKeyUnitAddExt takes integer kb returns integer
  if kb != 0 then
    return TownCountDone(kb) * GetFoodUsed(old_id[kb])
  else
    return 0
  endif
endfunction

function GetKeyUnitAdd takes integer sn returns integer
  return KeyAddTimeModify(GetKeyUnitAddExt(key_unit[sn]))
endfunction

function KeyUnitAdd takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i>= rp_strat_length
    set rp_strat[i] = rp_strat[i] + GetKeyUnitAdd(i)
    set i = i + 1
  endloop
endfunction

function SmallMapsAdd takes nothing returns nothing
  local integer i = 0
  if GetPlayers() > 3 then
    return
  endif
  loop
    exitwhen i >= rp_strat_length
    if strategy_tier[i] == 1 then
      set rp_strat[i] = rp_strat[i] + small_map_tier1_bonus
    endif
    set i = i + 1
  endloop
endfunction

function sum_rp_strat takes integer num returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i >= num
    set sum = sum + rp_strat[i]
    set i = i + 1
  endloop
  return sum
endfunction

function choose_strategy takes nothing returns integer
  local integer i = 1
  local integer rp_sum = sum_rp_strat(rp_strat_length)
  local integer strategy_roll = GetRandomInt(1, rp_sum)
  if rp_sum <= 0 then
    return 0
  endif
  loop
    exitwhen strategy_roll <= sum_rp_strat(i)
    set i = i + 1
  endloop
  
  return i - 1
endfunction

function mult_rp_strat takes integer m returns nothing
  local integer i = 0
  loop
    exitwhen i >= rp_strat_length
    set rp_strat[i] = rp_strat[i] * m
    set i = i + 1
  endloop
endfunction

function div_rp_strat takes integer d returns nothing
  local integer i = 0
  loop
    exitwhen i >= rp_strat_length
    set rp_strat[i] = rp_strat[i] / d
    set i = i + 1
  endloop
endfunction

function make_rp_strat_positive takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= rp_strat_length
    if rp_strat[i] < 0 then
      set rp_strat[i] = 0
    endif
    set i = i + 1
  endloop
endfunction

function normalize_rp_strat takes nothing returns nothing
  local integer i = 0
  local integer sum = sum_rp_strat(rp_strat_length)
  loop
      exitwhen i >= rp_strat_length
      set rp_strat[i] = (rp_strat[i] * rp_strat_normal) / sum
      set i = i + 1
  endloop
endfunction

function add_tier_bonus takes nothing returns nothing
  local integer i = 0
  loop
      exitwhen i >= rp_strat_length
      if tier == strategy_tier[i] then
          set rp_strat[i] = rp_strat[i] + strategy_tier_bonus
      endif
      set i = i + 1
  endloop
endfunction

function display_rp_strat takes nothing returns nothing
  local integer i = 0
  local integer sum = 0
  if balancing then
    set sum = sum_rp_strat(rp_strat_length)
    loop
      exitwhen i >= rp_strat_length
      call DisplayToAll(GetStrategyName(i)+": "+Int2Str(R2I(I2R(100 * rp_strat[i]) / I2R(sum)))+" %")
      set i = i + 1
    endloop
  endif
endfunction

function init_rp_strat_sort takes nothing returns nothing
  set rp_strat_sort_length = 0
endfunction

function sum_rp_strat_sort takes integer num returns integer
  local integer i = 0
  local integer sum = 0
  loop
    exitwhen i >= num
    set sum = sum + rp_strat[rp_strat_sort[i]]
    set i = i + 1
  endloop
  return sum
endfunction

function display_rp_strat_sort takes nothing returns nothing
  local integer i = 0
  local integer sum = 0
  if balancing then
    set sum = sum_rp_strat_sort(relevant_strat_change_number)
    loop
      exitwhen i >= relevant_strat_change_number
      call DisplayToAll(GetStrategyName(rp_strat_sort[i])+": "+Int2Str(R2I(I2R(100 * rp_strat[rp_strat_sort[i]]) / I2R(sum)))+" %")
      set i = i + 1
    endloop
  endif
endfunction

function sort_rp_strat takes nothing returns nothing
  local integer i = 0
  local integer j = 0
  loop
    exitwhen i >= rp_strat_length
    set j = rp_strat_sort_length - 1
    loop
      exitwhen j < 0
      exitwhen rp_strat[rp_strat_sort[j]] > rp_strat[i]
      set rp_strat_sort[j + 1] = rp_strat_sort[j]
      set j = j - 1
    endloop
    set rp_strat_sort[j + 1] = i
    set rp_strat_sort_length = rp_strat_sort_length + 1
    set i = i + 1
  endloop
endfunction

function nullify_bad_strats takes nothing returns nothing
  local integer i = 0
  loop
    if rp_strat[i] < (rp_strat[strategy] - (strat_persistence + (FoodUsed() * strat_food_persistence))) * strategy_change_threshold then
      set rp_strat[i] = 0
    endif
    set i = i + 1
    exitwhen i >= rp_strat_length
  endloop
endfunction

function finish_strategy_change takes nothing returns nothing
  local integer strategy_roll = 0
  local integer sum = 0
  local integer i = 0

  call KeyBuildingAdd()
  call KeyUpgradeAdd()
  call KeyUnitAdd()
  call add_tier_bonus()
  set rp_strat[strategy] = rp_strat[strategy] + strat_persistence + strat_food_persistence * FoodUsed() // Add the bonuses to persistance
  call nullify_bad_strats()

  set rp_strat[strategy] = R2I(I2R(rp_strat[strategy]) * Pow(c_enemy_total,0.75))
  call make_rp_strat_positive()
  call init_rp_strat_sort()
  call sort_rp_strat()
  set sum = sum_rp_strat_sort(relevant_strat_change_number)
  if sum < 1 then
    return
  endif
  set strategy_roll = GetRandomInt(1,sum)
  set sum = 0
  loop
    set sum = sum + rp_strat[rp_strat_sort[i]]
    if strategy_roll <= sum then
	  //if rp_strat[rp_strat_sort[i]] / Max(rp_strat[strategy], 1) > strategy_change_threshold then
		set strategy = rp_strat_sort[i]
		set chosen_strategy = strategy
		call SetChatVar("Strategy", GetCurrentStrategyName())
	  //endif
      return
    endif
    set i = i + 1
  endloop
endfunction

function removeNonBeginningStrats takes nothing returns nothing
  local integer i = 0
  if nearest_enemy_range < 5000 or not ((game_is_ffa and c_enemy_total > 3) or (c_ally_total > 2 and c_enemy_total > 3)) then
    loop
      exitwhen i >= rp_strat_length
      if not beginning_strat[i] and (debug_strategy != i) then
        set rp_strat[i] = 0
      endif
      set i = i + 1
    endloop
  endif
endfunction

function AddStrategyHeroRP takes integer h, integer to_add returns nothing
  local integer i = 0
  loop
    exitwhen i >= hero_number
    if all_heroes[i] == h then
      set hero_rp[i] = hero_rp[i] + to_add
    endif
    set i = i + 1
  endloop
endfunction

function ApplyStrategyRaceAggression takes nothing returns nothing
  local integer i = 0
  local integer l = tiernum * RACE_NUMBER
  loop
    exitwhen i >= l
    set race_aggression[i] = b_race_aggression[i] + strategy_race_aggression[strategy*l + i]
    set i = i + 1
  endloop
endfunction

function make_hero_rp_positive takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= hero_number
    if hero_rp[i] < 0 then
      set hero_rp[i] = 0
    endif
    set i = i + 1
  endloop
endfunction

function sum_hero_rp takes nothing returns integer
  local integer i = first_choosable_hero
  local integer sum = 0
  loop
    exitwhen i >=hero_number
    set sum = sum + hero_rp[i]
    set i = i + 1
  endloop
  return sum
endfunction

function ChooseHero takes nothing returns integer
  local integer i = first_choosable_hero
  local integer sum = 0
  local integer rp_sum = sum_hero_rp()
  local integer hero_roll = GetRandomInt(1,rp_sum)
  if rp_sum <= 0 then
    return 0
  endif
  loop
    set sum = sum + hero_rp[i]
    if hero_roll <= sum then
      return i
    endif
    set i = i + 1
  endloop
  return 0
endfunction

function remove_hero takes integer h returns nothing
  local integer i = h
  set hero_number = hero_number - 1
  loop
    exitwhen i  >= hero_number
    set hero_rp[i] = hero_rp[i + 1]
    set all_heroes[i] = all_heroes[i + 1]
    set i = i + 1
  endloop
endfunction

function GetExistingHero takes nothing returns integer
  local group g = CreateGroup()
  local unit u = null
  local integer oid = 0
  local integer i = 0
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectUnittype(g, UNIT_TYPE_HERO, true)
  set u = FirstOfGroup(g)
  call DestroyGroup(g)
  set g = null
  if u == null then
    call DisplayToAll("Hero not found")
    return 0
  endif
  set oid = GetUnitTypeId(u)
  loop
    exitwhen i >= hero_number
    if old_id[all_heroes[i]] == oid then
      set chosen = i
      return all_heroes[i]
    endif
    set i = i + 1
  endloop
  call DisplayToAll("Unknown hero")
  return 0
endfunction

function ChooseFirstHero takes nothing returns integer
  //if ver_neutral_heroes_available and neutral_available[NEUTRAL_TAVERN] and neutral_guarded[NEUTRAL_TAVERN] then
    //call remove_hero(7)
	//set first_choosable_hero = ver_neutral_hero_number
  //endif
  if IsMapFlagSet(MAP_RANDOM_HERO) then
    set hero[1] = GetExistingHero()
  else
    call make_hero_rp_positive()
    set chosen = ChooseHero()
    set hero[1] = all_heroes[chosen]
  endif
  return chosen
endfunction

function ChooseSecondHero takes nothing returns nothing
  call make_hero_rp_positive()
  call remove_hero(chosen)
  set chosen = ChooseHero()
  set hero[2] = all_heroes[chosen]
endfunction

function ChooseRestHeroes takes nothing returns nothing
  call make_hero_rp_positive()
  call remove_hero(chosen)
  set hero[3] = all_heroes[ChooseHero()]
endfunction

function GetMinesHarvested takes nothing returns integer
  local integer twm = TownWithMine()
  local integer i = twm
  local integer sum = 0
  if twm < 0 then
    return 0
  endif
  loop
    exitwhen i > twm + 3
    if TownHasMine(i) and TownCountEx(racial_expansion,true,i) > 0 then
      set sum = sum + 1
    endif
    set i = i + 1
  endloop
  return sum
endfunction

function GetGoldIncome takes nothing returns real
  local integer inc = GetMinesHarvested()*income_per_mine
  if inc > GetGoldOwned() then
    set inc = GetGoldOwned()
  endif
  return I2R(inc + GetGold())/300
endfunction

function GetIncomePercentage takes integer qty returns real
  if qty == 0 then
    return 0.0
  endif
  return 1 - 1/I2R(qty)
endfunction

function GetFactoryQty takes integer qty, integer build_time, integer gold_cost, real in_percentage returns integer
  local real gip = GetIncomePercentage(qty) * gold_income * in_percentage
  local real gic = I2R(Max(gold_cost,1))/I2R(Max(build_time, 1))
  return Max(Min(R2I(gip/gic), difficulty),1)
endfunction

function IsOneOnlyBuilding takes integer unitid returns boolean
  if false then
  endif
  return false
endfunction

function Get_f_qty takes integer qty, integer unitid, integer town  returns integer
  if buy_type[unitid] != BT_UNIT or unitid == racial_peon or IsOneOnlyBuilding(needed1[unitid]) then
    return 1
  endif
  return GetFactoryQty(qty - TownCountTown(unitid, town), GetUnitBuildTime(old_id[unitid]), GetUnitGoldCost2(unitid), income_percentage[needed1[unitid]])
endfunction

function AddBlock takes integer req_qty, integer req_type, boolean only_done, integer allow_qty, integer allow_type, integer expire_time returns nothing
  set bl_req_qty[bl_length] = req_qty
  set bl_req_type[bl_length] = req_type
  set bl_only_done[bl_length] = only_done
  set bl_allow_qty[bl_length] = allow_qty
  set bl_allow_type[bl_length] = allow_type
  set bl_expire_time[bl_length] = expire_time
  set bl_length = bl_length + 1
endfunction

function InitBlockList takes nothing returns nothing
  set bl_length = 0
endfunction

function BlockListCheck takes integer qty, integer t returns integer
  local integer i = 0
  local integer max_qty = qty
  loop
    exitwhen i >= bl_length
    if ai_time < bl_expire_time[i] and bl_allow_type[i] == t then
      if TownCountEx(bl_req_type[i], bl_only_done[i], -1) < bl_req_qty[i] then
        set max_qty = Min(max_qty, bl_allow_qty[i])
      endif
    endif
    set i = i + 1
  endloop
  return max_qty
endfunction

function AddRBlock takes integer req_gold, integer req_wood, integer req_food, integer allow_qty, integer allow_type, integer expire_time returns nothing
  set rbl_req_gold[rbl_length] = req_gold
  set rbl_req_wood[rbl_length] = req_wood
  set rbl_req_food[rbl_length] = req_food
  set rbl_allow_qty[rbl_length] = allow_qty
  set rbl_allow_type[rbl_length] = allow_type
  set rbl_expire_time[rbl_length] = expire_time
  set rbl_length = rbl_length + 1
endfunction

function InitRBlockList takes nothing returns nothing
  set rbl_length = 0
endfunction

function RBlockListCheck takes integer qty, integer t returns integer
  local integer i = 0
  local integer max_qty = qty
  loop
    exitwhen i >= rbl_length
    if ai_time < rbl_expire_time[i] and rbl_allow_type[i] == t then
      if total_gold < rbl_req_gold[i] or total_wood < rbl_req_wood[i] or FoodUsed() < rbl_req_food[i] then
        set max_qty = Min(max_qty, rbl_allow_qty[i])
        set blocked_gold = Max(blocked_gold, rbl_req_gold[i])
        set blocked_wood = Max(blocked_wood, rbl_req_wood[i])
		set blocked_food = Max(blocked_food, rbl_req_food[i])
      endif
    endif
    set i = i + 1
  endloop
  return max_qty
endfunction

function SetBuildAllAM takes integer t, integer mqty, integer unitid, integer town, integer bloc, integer prio returns nothing
    local integer i = 0
    local integer j = 0
    local integer qty = BlockListCheck(mqty, unitid)
    
    if unitid == 0 then
      return
    endif
    
    if t == BUILD_UPGRADE then
      if GetUpgradeLevel(old_id[unitid]) >= qty then
        return
      endif
    elseif t == BUILD_ITEM then
      if GetItemNumber(unitid) >= qty then
        return
      endif
    elseif TownCountTown(unitid, town) >= qty or (buy_type[unitid] > BT_RACIAL_ITEM and not neutral_available[GetNeutralNumber(unitid)]) then
      return
    endif
    call GetBuildLock()
    set j = build_length - 1
    loop
      exitwhen i >= build_length
      exitwhen build_prio[i] < prio
      if build_item[i] == unitid and build_qty[i] >= qty and build_town[i] == town then
        call ReleaseBuildLock()
        return
      endif
      set i = i + 1
    endloop
    loop
      exitwhen j < i
      set build_qty[j+1] = build_qty[j]
      set build_type[j+1] = build_type[j]
      set build_item[j+1] = build_item[j]
      set build_town[j+1] = build_town[j]
      set build_loc[j+1] = build_loc[j]
      set build_prio[j+1] = build_prio[j]
      set j = j - 1
    endloop
    set build_qty[i] = qty
    set build_type[i] = t
    set build_item[i] = unitid
    set build_town[i] = town
    set build_loc[i] = bloc
    set build_prio[i] = prio
    set build_length = build_length + 1
    call ReleaseBuildLock()

	call Sleep(0.05)
    call SetBuildAllAM(t, qty - 1, unitid, town, bloc, prio + prio_q_inc )

    if buy_type[unitid] == BT_ML_UPGRADE then
      if qty == 1 then
        if needed1[unitid] != 0 then
          call SetBuildAllAM(BUILD_UNIT, Get_f_qty(qty, unitid, town), needed1[unitid], -1, BLOC_STD, prio + prio_n_inc)
        endif
      elseif qty == 2 then
        call SetBuildAllAM(BUILD_UPGRADE, 1, unitid, town, BLOC_STD, prio + prio_n_inc)
        if needed2[unitid] != 0 then
          call SetBuildAllAM(BUILD_UNIT, 1, needed2[unitid], -1, BLOC_STD, prio + prio_n_inc)
        endif
      else
        call SetBuildAllAM(BUILD_UPGRADE, 2, unitid, town, BLOC_STD, prio + prio_n_inc)
        if needed3[unitid] != 0 then
          call SetBuildAllAM(BUILD_UNIT, 1, needed3[unitid], -1, BLOC_STD, prio + prio_n_inc)
        endif
      endif
    elseif buy_type[unitid] == BT_HERO or buy_type[unitid] == BT_NEUTRAL_HERO then
      if unitid == hero[1] or unitid == hero[2] or unitid == hero[3] then
        if needed1[unitid] != 0 then
          call SetBuildAllAM(BUILD_UNIT, 1, needed1[unitid], -1, BLOC_STD, prio + prio_n_inc)
        endif
      endif
      if (unitid == hero[2] and not hero_built[2]) or (unitid == hero[3] and not hero_built[3]) then
        if needed2[unitid] != 0 then
          call SetBuildAllAM(BUILD_UNIT, 1, needed2[unitid], -1, BLOC_STD, prio + prio_n_inc)
        endif
      endif
      if unitid == hero[3] and not hero_built[3] then
        if needed3[unitid] != 0 then
          call SetBuildAllAM(BUILD_UNIT, 1, needed3[unitid], -1, BLOC_STD, prio + prio_n_inc)
        endif
      endif
    else
      if needed1[unitid] != 0 then
        if needed3[unitid] == UPGRADED then
          call SetBuildAllAM(BUILD_UNIT, qty + TownCountExForUpgrade(needed1[unitid],unitid,false,town), needed1[unitid], town, bloc, prio + prio_n_inc)
        else
          call SetBuildAllAM(BUILD_UNIT, Get_f_qty(qty, unitid, town), needed1[unitid], -1, BLOC_STD, prio + prio_n_inc)
        endif
      endif
      if needed2[unitid] != 0 then
        call SetBuildAllAM(BUILD_UNIT, 1, needed2[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
      if needed3[unitid] != 0 and needed3[unitid] != UPGRADED then
        call SetBuildAllAM(BUILD_UNIT, 1, needed3[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    endif
    if unitid == UPG_MARK_CLAW then
      call SetBuildAllAM(BUILD_UPGRADE, 2, UPG_DRUID_CLAW, -1, BLOC_STD, prio + prio_n_inc)
    endif
    if unitid == UPG_MARK_TALON then
      call SetBuildAllAM(BUILD_UPGRADE, 2, UPG_DRUID_TALON, -1, BLOC_STD, prio + prio_n_inc)
    endif
    if unitid == BLK_SPHINX then
      call SetBuildAllAM(BUILD_UPGRADE, 1, UPG_BLK_SPHINX, -1, BLOC_STD, prio + prio_n_inc)
    endif
    if unitid == KNIGHT then
      call SetBuildAllAM(BUILD_UNIT, 1, LUMBER_MILL, -1, BLOC_STD, prio + prio_n_inc)
    endif
    if unitid == UPG_BREEDING then
      call SetBuildAllAM(BUILD_UNIT, 1, LUMBER_MILL, -1, BLOC_STD, prio + prio_n_inc)
    endif
    if unitid == HIPPO_RIDER then
      call SetBuildAllAM(BUILD_UPGRADE, 1, UPG_HIPPO_TAME, -1, BLOC_STD, prio + prio_n_inc)
    endif
    if unitid == ROCKET_TANK then
      call SetBuildAllAM(BUILD_UPGRADE, 1, UPG_TANK, -1, BLOC_STD, prio + prio_n_inc)
    endif

endfunction

function RefreshNeeded takes integer t, integer qty, integer unitid, integer town, integer bloc, integer prio returns nothing
    if buy_type[unitid] == BT_ML_UPGRADE then
      if qty == 1 then
        if needed1[unitid] != 0 then
          call SetBuildAllAM(BUILD_UNIT, Get_f_qty(qty, unitid, town), needed1[unitid], -1, BLOC_STD, prio + prio_n_inc)
        endif
      elseif qty == 2 then
        call SetBuildAllAM(BUILD_UPGRADE, 1, unitid, town, BLOC_STD, prio + prio_n_inc)
        if needed2[unitid] != 0 then
          call SetBuildAllAM(BUILD_UNIT, 1, needed2[unitid], -1, BLOC_STD, prio + prio_n_inc)
        endif
      else
        call SetBuildAllAM(BUILD_UPGRADE, 2, unitid, BLOC_STD, town, prio + prio_n_inc)
        if needed3[unitid] != 0 then
          call SetBuildAllAM(BUILD_UNIT, 1, needed3[unitid], -1, BLOC_STD, prio + prio_n_inc)
        endif
      endif
    elseif buy_type[unitid] == BT_HERO or buy_type[unitid] == BT_NEUTRAL_HERO then
      if unitid == hero[1] or unitid == hero[2] or unitid == hero[3] then
        if needed1[unitid] != 0 then
          call SetBuildAllAM(BUILD_UNIT, 1, needed1[unitid], -1, BLOC_STD, prio + prio_n_inc)
        endif
      endif
      if (unitid == hero[2] and not hero_built[2]) or (unitid == hero[3] and not hero_built[3]) then
        if needed2[unitid] != 0 then
          call SetBuildAllAM(BUILD_UNIT, 1, needed2[unitid], -1, BLOC_STD, prio + prio_n_inc)
        endif
      endif
      if unitid == hero[3] and not hero_built[3] then
        if needed3[unitid] != 0 then
          call SetBuildAllAM(BUILD_UNIT, 1, needed3[unitid], -1, BLOC_STD, prio + prio_n_inc)
        endif
      endif    
    else
      if needed1[unitid] != 0 then
        if needed3[unitid] == UPGRADED then
          call SetBuildAllAM(BUILD_UNIT, qty + TownCountExForUpgrade(needed1[unitid],unitid,false,town), needed1[unitid], town, bloc, prio + prio_n_inc)
        else
          call SetBuildAllAM(BUILD_UNIT, Get_f_qty(qty, unitid, town), needed1[unitid], -1, BLOC_STD, prio + prio_n_inc)
        endif
      endif
      if needed2[unitid] != 0 then
        call SetBuildAllAM(BUILD_UNIT, 1, needed2[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
      if needed3[unitid] != 0 and needed3[unitid] != UPGRADED then
        call SetBuildAllAM(BUILD_UNIT, 1, needed3[unitid], -1, BLOC_STD, prio + prio_n_inc)
      endif
    endif
    if unitid == UPG_MARK_CLAW then
      call SetBuildAllAM(BUILD_UPGRADE, 2, UPG_DRUID_CLAW, -1, BLOC_STD, prio + prio_n_inc)
    endif
    if unitid == UPG_MARK_TALON then
      call SetBuildAllAM(BUILD_UPGRADE, 2, UPG_DRUID_TALON, -1, BLOC_STD, prio + prio_n_inc)
    endif
    if unitid == BLK_SPHINX then
      call SetBuildAllAM(BUILD_UPGRADE, 1, UPG_BLK_SPHINX, -1, BLOC_STD, prio + prio_n_inc)
    endif
    if unitid == KNIGHT then
      call SetBuildAllAM(BUILD_UNIT, 1, LUMBER_MILL, -1, BLOC_STD, prio + prio_n_inc)
    endif
    if unitid == UPG_BREEDING then
      call SetBuildAllAM(BUILD_UNIT, 1, LUMBER_MILL, -1, BLOC_STD, prio + prio_n_inc)
    endif
    if unitid == HIPPO_RIDER then
      call SetBuildAllAM(BUILD_UPGRADE, 1, UPG_HIPPO_TAME, -1, BLOC_STD, prio + prio_n_inc)
    endif
    if unitid == ROCKET_TANK then
      call SetBuildAllAM(BUILD_UPGRADE, 1, UPG_TANK, -1, BLOC_STD, prio + prio_n_inc)
    endif
endfunction

function CanBuildUnit takes integer unitid returns boolean
  local boolean b = (needed1[unitid] == 0 or TownCountDone(needed1[unitid]) > 0) and (needed2[unitid] == 0 or TownCountDone(needed2[unitid]) > 0) and (needed3[unitid] == 0 or needed3[unitid] == UPGRADED or TownCountDone(needed3[unitid]) > 0)
  set b = b and (unitid != KNIGHT or TownCountDone(LUMBER_MILL) > 0)
  set b = b and (unitid != UPG_BREEDING or TownCountDone(LUMBER_MILL) > 0)
  set b = b and (unitid != UPG_MARK_CLAW or GetUpgradeLevel(old_id[UPG_DRUID_CLAW]) >= 2)
  set b = b and (unitid != UPG_MARK_TALON or GetUpgradeLevel(old_id[UPG_DRUID_TALON]) >= 2)
  set b = b and (unitid != BLK_SPHINX or GetUpgradeLevel(old_id[UPG_BLK_SPHINX]) >= 1)
  set b = b and (unitid != HIPPO_RIDER or GetUpgradeLevel(old_id[UPG_HIPPO_TAME]) >= 1)
  set b = b and (unitid != ROCKET_TANK or GetUpgradeLevel(old_id[UPG_TANK]) >= 1)
  return b
endfunction

function BuildUnit takes integer qty, integer unitid, integer prio returns nothing
    call SetBuildAllAM(BUILD_UNIT,qty,unitid,-1, BLOC_STD, prio)
endfunction

function SetBuildUnitIfAvailable takes integer qty, integer unitid, integer prio returns nothing
  if CanBuildUnit(unitid) then
    call BuildUnit(qty, unitid, prio)
  endif
endfunction

function SetBuildUnitExAM takes integer easy, integer med, integer hard, integer unitid, integer prio returns nothing
    if difficulty == EASY then
        call SetBuildAllAM(BUILD_UNIT,easy,unitid,-1, BLOC_STD, prio)
    elseif difficulty == NORMAL then
        call SetBuildAllAM(BUILD_UNIT,med,unitid,-1, BLOC_STD, prio)
    else
        call SetBuildAllAM(BUILD_UNIT,hard,unitid,-1, BLOC_STD, prio)
    endif
endfunction

function SecondaryTownAM takes integer town, integer qty, integer unitid, integer prio returns nothing
    call SetBuildAllAM(BUILD_UNIT,qty,unitid,town, BLOC_STD, prio)
endfunction

function BuildUpgr takes integer qty, integer unitid, integer prio returns nothing
    call SetBuildAllAM(BUILD_UPGRADE,qty,unitid,-1, BLOC_STD, prio)
endfunction


function BuildAdvUpgr takes integer qty, integer unitid, integer starttier, integer unitcount, integer maxunits, integer tierprio, integer prio returns nothing
	if tier >= starttier then
	if unitcount > 0 then
	    if qty >= tier-starttier+1 then
			call BuildUpgr(tier-starttier + 1, unitid, R2I(LinearInterpolation(0, maxunits, 1, prio + ((tier-starttier)* tierprio) , unitcount)))
		else
			// If tier greater than the start tier and qty is less than the difference between the two
			call BuildUpgr(qty, unitid, R2I(LinearInterpolation(0, maxunits, 1, prio + ((tier-starttier)* tierprio), unitcount)))
		endif
	endif
	endif
endfunction

function BuildAdvUpgr2 takes integer qty, integer upgid, integer starttier, integer unitcount, real unitper, integer max, integer prio returns nothing
	if tier >= starttier then
	if unitcount > 0 then
		if GetRandomInt(1, 100) <= Min(R2I(unitcount/unitper), max) then
	    if qty >= tier-starttier+1 then
			call BuildUpgr(tier-starttier + 1, upgid, prio)
		else
			// If tier greater than the start tier and qty is less than the difference between the two
			call BuildUpgr(qty, upgid, prio)
		endif
		endif
	endif
	endif
endfunction
function SetBuildUpgrExAM takes integer easy, integer med, integer hard, integer unitid, integer prio returns nothing
    if difficulty == EASY then
        call SetBuildAllAM(BUILD_UPGRADE,easy,unitid,-1, BLOC_STD, prio)
    elseif difficulty == NORMAL then
        call SetBuildAllAM(BUILD_UPGRADE,med,unitid,-1, BLOC_STD, prio)
    else
        call SetBuildAllAM(BUILD_UPGRADE,hard,unitid,-1, BLOC_STD, prio)
    endif
endfunction

function BuildExpa takes integer qty, integer unitid, integer prio returns nothing
    call SetBuildAllAM(BUILD_EXPAND,qty,unitid,-1, BLOC_STD, prio)
endfunction

function BuildItem takes integer qty, integer unitid, integer prio returns nothing
    call SetBuildAllAM(BUILD_ITEM,qty,unitid,-1, BLOC_STD, prio)
endfunction

function BuildFront takes integer qty, integer unitid, integer prio returns nothing
  call SetBuildAllAM(BUILD_UNIT, qty, unitid, -1, BLOC_FRONT, prio)
endfunction

function BuildAtMine takes integer qty, integer unitid, integer prio returns nothing
  call SetBuildAllAM(BUILD_UNIT, qty, unitid, -1, BLOC_MINE, prio)
endfunction

function SetBuildReact takes integer food, integer min1, integer unit1, integer min2, integer unit2, real enemy_strength, real strength1, real strength2, integer prio returns nothing
  local integer num1 = R2I(LinearInterpolation(strength1, strength2, I2R(food), 0, enemy_strength))/GetFoodUsed(old_id[unit1])
  local integer num2 = (food - num1 * GetFoodUsed(old_id[unit1]))/GetFoodUsed(old_id[unit2])
  local integer prio1 = 0
  local integer prio2 = 0
  local integer food1 = food/GetFoodUsed(old_id[unit1]) 
  local integer food2 = food/GetFoodUsed(old_id[unit2]) 
  
  if food1 > food2 then
	set prio1 = prio+(food1-1)*2 - (min1+num1-1)*2		// So builds starting at the max priority possible
	set prio2 = prio+(food1-1)*2 - (min2+num2-1)*2 		// i.e build 6 footmen instead of 12 but will build those 6 starting at same proirity of 12
  else													// This is so it builds less than the max it still builds at same priority.
	set prio1 = prio+(food2-1)*2 - (min1+num1-1)*2 - 4   // I assuming the second unit id is less common so make sure it has smaller prioity so that first unit gets its requirements first
	set prio2 = prio+(food2-1)*2 - (min2+num2-1)*2 - 4
  endif
  
 // if min1+num1 > min2 + num2 then
  if min1 + num1 > 0 then
	call BuildUnit(min1 + num1, unit1, prio1)
  endif
  if min2 + num2 > 0 then
	call BuildUnit(min2 + num2, unit2, prio2)
  endif
endfunction

function GetTier takes nothing returns integer
  local integer i = tiernum
  loop
    exitwhen i <= 1
    exitwhen TownCountDone(racial_hall[i]) >= 1
    set i = i - 1
  endloop
  return i
endfunction

function DetermineCounterForce takes nothing returns integer
   local integer strength = 0
   local integer total_strength = 0
   local integer array tstrength
   local integer i
   local integer j
   local integer random
   local integer maxstr
   local integer array temps
   local real ally_null = 0    // Blank point
   
   set i = 0
   set j = 0
   set maxstr = 0
	set tstrength[i] = R2I(RMax(enemy_air - ally_piercing - ally_null,0)*100)
	set strength = strength + tstrength[i]
	set i=i+1
	set tstrength[i] = R2I(RMax(enemy_casters - ally_null - ally_null,0)*100)
	set strength = strength + tstrength[i]
	set i=i+1
	set tstrength[i] = R2I(RMax(enemy_towers - ally_siege - ally_null,0)*100)
	set strength = strength + tstrength[i]
	set i=i+1
	set tstrength[i] = R2I(RMax(enemy_piercing - ally_mediumarmor - ally_null,0)*100)
	set strength = strength + tstrength[i]
	set i=i+1
	set tstrength[i] = R2I(RMax(enemy_normal - ally_normal - ally_null,0)*100)
	set strength = strength + tstrength[i]
	set i=i+1
	set tstrength[i] = R2I(RMax(enemy_siege - ally_mediumarmor - ally_null,0)*100)
	set strength = strength + tstrength[i]
	set i=i+1
	set tstrength[i] = R2I(RMax(enemy_magic - ally_mediumarmor - ally_null,0)*100)
	set strength = strength + tstrength[i]
	set i=i+1
	set tstrength[i] = R2I(RMax(enemy_unarmored - ally_piercing - ally_siege,0)*100)
	set strength = strength + tstrength[i]
	set i=i+1
	set tstrength[i] = R2I(RMax(enemy_lightarmor - ally_piercing - ally_magic,0)*100)
	set strength = strength + tstrength[i]
	set i=i+1
	set tstrength[i] = R2I(RMax(enemy_mediumarmor - ally_normal - ally_null,0)*100)
	set strength = strength + tstrength[i]
	set i=i+1
	set tstrength[i] = R2I(RMax(enemy_heavyarmor - ally_magic - ally_null,0)*100)
	set strength = strength + tstrength[i]
	set i=i+1
	//
	//
	set tstrength[4] = tstrength[4] + 3	// Favour to normal enemies
	set strength = strength + 3
	// Normalise strength
	//loop
	//	exitwhen j >= i
	//	set tstrength[j] = R2I((tstrength[j]*100)/strength)
	//	set total_strength = total_strength + tstrength[j]
	//	set j = j + 1
	//endloop
	loop
		exitwhen j >= i
		if tstrength[j] > maxstr then
			set maxstr = j
		endif
		set j = j + 1
	endloop
	if tstrength[maxstr] > 0 then
		set tstrength[maxstr] = tstrength[maxstr] + R2I(strat_persistence/200) // Bonus to top counter
		set strength = strength + R2I(strat_persistence/200)
	endif
	set j = 0
	// Remove bad strats to not affect calculations with really low amounts of strength
	loop
		exitwhen j >= i
		if tstrength[j] < 3 then
			set tstrength[j] = 0
		endif
		set total_strength = total_strength + tstrength[j]
		set j = j+1
	endloop
	set j = 0
	set random =GetRandomInt(1, total_strength)
	set strength = 0
	loop
		set strength = strength + tstrength[j]
		exitwhen random <= strength or j >= i
		set j = j + 1	// Will be the the chosen strength to build units against
	endloop
	if j >= i then // Default to normal if nothing has strength
		set j = 4
	endif
    return j
endfunction

function ResetDynamicSystem takes nothing returns nothing
	set totalanti_air = 0
	set totalchance_air = 0
	set totalanti_casters = 0
	set totalchance_casters = 0
	set totalanti_towers = 0
	set totalchance_towers = 0
	set totalanti_piercing = 0
	set totalchance_piercing = 0
	set totalanti_normal = 0
	set totalchance_normal = 0
	set totalanti_siege = 0
	set totalchance_siege = 0
	set totalanti_magic = 0
	set totalchance_magic = 0
	set totalanti_unarmored = 0
	set totalchance_unarmored = 0
	set totalanti_lightarmor = 0
	set totalchance_lightarmor = 0
	set totalanti_mediumarmor = 0
	set totalchance_mediumarmor = 0
	set totalanti_heavyarmor = 0
	set totalchance_heavyarmor = 0
endfunction

function AddUnitToAntiair takes integer u, integer percent returns nothing
	set dyanti_air[totalanti_air]= u
	set dychance_air[totalanti_air]= percent
	set totalanti_air = totalanti_air + 1
	set totalchance_air = totalchance_air + percent
endfunction
function AddUnitToAnticasters takes integer u, integer percent returns nothing
	set dyanti_casters[totalanti_casters]= u
	set dychance_casters[totalanti_casters]= percent
	set totalanti_casters = totalanti_casters + 1
	set totalchance_casters = totalchance_casters + percent
endfunction
function AddUnitToAntitowers takes integer u, integer percent returns nothing
	set dyanti_towers[totalanti_towers]= u
	set dychance_towers[totalanti_towers]= percent
	set totalanti_towers = totalanti_towers + 1
	set totalchance_towers = totalchance_towers + percent
endfunction
function AddUnitToAntipiercing takes integer u, integer percent returns nothing
	set dyanti_piercing[totalanti_piercing]= u
	set dychance_piercing[totalanti_piercing]= percent
	set totalanti_piercing = totalanti_piercing + 1
	set totalchance_piercing = totalchance_piercing + percent
endfunction
function AddUnitToAntinormal takes integer u, integer percent returns nothing
	set dyanti_normal[totalanti_normal]= u
	set dychance_normal[totalanti_normal]= percent
	set totalanti_normal = totalanti_normal + 1
	set totalchance_normal = totalchance_normal + percent
endfunction
function AddUnitToAntisiege takes integer u, integer percent returns nothing
	set dyanti_siege[totalanti_siege]= u
	set dychance_siege[totalanti_siege]= percent
	set totalanti_siege = totalanti_siege + 1
	set totalchance_siege = totalchance_siege + percent
endfunction
function AddUnitToAntimagic takes integer u, integer percent returns nothing
	set dyanti_magic[totalanti_magic]= u
	set dychance_magic[totalanti_magic]= percent
	set totalanti_magic = totalanti_magic + 1
	set totalchance_magic = totalchance_magic + percent
endfunction
function AddUnitToAntiunarmored takes integer u, integer percent returns nothing
	set dyanti_unarmored[totalanti_unarmored]= u
	set dychance_unarmored[totalanti_unarmored]= percent
	set totalanti_unarmored = totalanti_unarmored + 1
	set totalchance_unarmored = totalchance_unarmored + percent
endfunction
function AddUnitToAntilightarmor takes integer u, integer percent returns nothing
	set dyanti_lightarmor[totalanti_lightarmor]= u
	set dychance_lightarmor[totalanti_lightarmor]= percent
	set totalanti_lightarmor = totalanti_lightarmor + 1
	set totalchance_lightarmor = totalchance_lightarmor + percent
endfunction
function AddUnitToAntimediumarmor takes integer u, integer percent returns nothing
	set dyanti_mediumarmor[totalanti_mediumarmor]= u
	set dychance_mediumarmor[totalanti_mediumarmor]= percent
	set totalanti_mediumarmor = totalanti_mediumarmor + 1
	set totalchance_mediumarmor = totalchance_mediumarmor + percent
endfunction
function AddUnitToAntiheavyarmor takes integer u, integer percent returns nothing
	set dyanti_heavyarmor[totalanti_heavyarmor]= u
	set dychance_heavyarmor[totalanti_heavyarmor]= percent
	set totalanti_heavyarmor = totalanti_heavyarmor + 1
	set totalchance_heavyarmor = totalchance_heavyarmor + percent
endfunction

function BuildAntiairStrength takes integer number, integer prio returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer num
	local integer chance = 0
		
	if totalchance_air > 0 then
		set choice = GetRandomInt(0,totalchance_air) // Build this unit
		loop
			set chance = chance + dychance_air[i]
			exitwhen choice <= chance or i >= totalanti_air
			set i = i + 1
		endloop
		if i >= totalanti_air then
			set u = dyanti_air[i-1]
		else
			set u = dyanti_air[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_air then
		//set food1 = food/GetFoodUsed(old_id[units[choice]])
		if IsUnitIdType(old_id[u], UNIT_TYPE_STRUCTURE) == false and not (buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM) then 
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 and GetUnitCount(old_id[u]) < num then
				call BuildUnit(Min(num, GetUnitCountDone(old_id[u]) + 10), u, prio)  
			endif
		elseif buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM then // A neutral mercenary
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 then
				call BuildUnit(GetUnitCountDone(old_id[u] + 1), u, prio)
			endif
		else // structure
			call BuildUnit(1, u, prio*2) 
		endif

		endif
	endif
	
endfunction
function BuildAnticastersStrength takes integer number, integer prio returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer num
	local integer chance = 0
		
	if totalchance_casters > 0 then
		set choice = GetRandomInt(0,totalchance_casters) // Build this unit
		loop
			set chance = chance + dychance_casters[i]
			exitwhen choice <= chance or i >= totalanti_casters
			set i = i + 1
		endloop
		if i >= totalanti_casters then
			set u = dyanti_casters[i-1]
		else
			set u = dyanti_casters[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_casters then
		//set food1 = food/GetFoodUsed(old_id[units[choice]])
		if IsUnitIdType(old_id[u], UNIT_TYPE_STRUCTURE) == false and not (buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM) then 
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 and GetUnitCount(old_id[u]) < num then
				call BuildUnit(Min(num, GetUnitCountDone(old_id[u]) + 10), u, prio)  
			endif
		elseif buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM then // A neutral mercenary
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 then
				call BuildUnit(GetUnitCountDone(old_id[u] + 1), u, prio)
			endif
		else // structure
			call BuildUnit(1, u, prio*2) 
		endif

		endif
	endif
	
endfunction
function BuildAntitowersStrength takes integer number, integer prio returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer num
	local integer chance = 0
		
	if totalchance_towers > 0 then
		set choice = GetRandomInt(0,totalchance_towers) // Build this unit
		loop
			set chance = chance + dychance_towers[i]
			exitwhen choice <= chance or i >= totalanti_towers
			set i = i + 1
		endloop
		if i >= totalanti_towers then
			set u = dyanti_towers[i-1]
		else
			set u = dyanti_towers[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_towers then
		//set food1 = food/GetFoodUsed(old_id[units[choice]])
		if IsUnitIdType(old_id[u], UNIT_TYPE_STRUCTURE) == false and not (buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM) then 
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 and GetUnitCount(old_id[u]) < num then
				call BuildUnit(Min(num, GetUnitCountDone(old_id[u]) + 10), u, prio)  
			endif
		elseif buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM then // A neutral mercenary
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 then
				call BuildUnit(GetUnitCountDone(old_id[u] + 1), u, prio)
			endif
		else // structure
			call BuildUnit(1, u, prio*2) 
		endif

		endif
	endif
	
endfunction
function BuildAntipiercingStrength takes integer number, integer prio returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer num
	local integer chance = 0
		
	if totalchance_piercing > 0 then
		set choice = GetRandomInt(0,totalchance_piercing) // Build this unit
		loop
			set chance = chance + dychance_piercing[i]
			exitwhen choice <= chance or i >= totalanti_piercing
			set i = i + 1
		endloop
		if i >= totalanti_piercing then
			set u = dyanti_piercing[i-1]
		else
			set u = dyanti_piercing[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_piercing then
		//set food1 = food/GetFoodUsed(old_id[units[choice]])
		if IsUnitIdType(old_id[u], UNIT_TYPE_STRUCTURE) == false and not (buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM) then 
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 and GetUnitCount(old_id[u]) < num then
				call BuildUnit(Min(num, GetUnitCountDone(old_id[u]) + 10), u, prio)  
			endif
		elseif buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM then // A neutral mercenary
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 then
				call BuildUnit(GetUnitCountDone(old_id[u] + 1), u, prio)
			endif
		else // structure
			call BuildUnit(1, u, prio*2) 
		endif

		endif
	endif
	
endfunction
function BuildAntinormalStrength takes integer number, integer prio returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer num
	local integer chance = 0
		
	if totalchance_normal > 0 then
		set choice = GetRandomInt(0,totalchance_normal) // Build this unit
		loop
			set chance = chance + dychance_normal[i]
			exitwhen choice <= chance or i >= totalanti_normal
			set i = i + 1
		endloop
		if i >= totalanti_normal then
			set u = dyanti_normal[i-1]
		else
			set u = dyanti_normal[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_normal then
		//set food1 = food/GetFoodUsed(old_id[units[choice]])
		if IsUnitIdType(old_id[u], UNIT_TYPE_STRUCTURE) == false and not (buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM) then 
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 and GetUnitCount(old_id[u]) < num then
				call BuildUnit(Min(num, GetUnitCountDone(old_id[u]) + 10), u, prio)  
			endif
		elseif buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM then // A neutral mercenary
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 then
				call BuildUnit(GetUnitCountDone(old_id[u] + 1), u, prio)
			endif
		else // structure
			call BuildUnit(1, u, prio*2) 
		endif

		endif
	endif
	
endfunction
function BuildAntisiegeStrength takes integer number, integer prio returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer num
	local integer chance = 0
		
	if totalchance_siege > 0 then
		set choice = GetRandomInt(0,totalchance_siege) // Build this unit
		loop
			set chance = chance + dychance_siege[i]
			exitwhen choice <= chance or i >= totalanti_siege
			set i = i + 1
		endloop
		if i >= totalanti_siege then
			set u = dyanti_siege[i-1]
		else
			set u = dyanti_siege[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_siege then
		//set food1 = food/GetFoodUsed(old_id[units[choice]])
		if IsUnitIdType(old_id[u], UNIT_TYPE_STRUCTURE) == false and not (buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM) then 
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 and GetUnitCount(old_id[u]) < num then
				call BuildUnit(Min(num, GetUnitCountDone(old_id[u]) + 10), u, prio)  
			endif
		elseif buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM then // A neutral mercenary
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 then
				call BuildUnit(GetUnitCountDone(old_id[u] + 1), u, prio)
			endif
		else // structure
			call BuildUnit(1, u, prio*2) 
		endif

		endif
	endif
	
endfunction
function BuildAntimagicStrength takes integer number, integer prio returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer num
	local integer chance = 0
		
	if totalchance_magic > 0 then
		set choice = GetRandomInt(0,totalchance_magic) // Build this unit
		loop
			set chance = chance + dychance_magic[i]
			exitwhen choice <= chance or i >= totalanti_magic
			set i = i + 1
		endloop
		if i >= totalanti_magic then
			set u = dyanti_magic[i-1]
		else
			set u = dyanti_magic[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_magic then
		//set food1 = food/GetFoodUsed(old_id[units[choice]])
		if IsUnitIdType(old_id[u], UNIT_TYPE_STRUCTURE) == false and not (buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM) then 
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 and GetUnitCount(old_id[u]) < num then
				call BuildUnit(Min(num, GetUnitCountDone(old_id[u]) + 10), u, prio)  
			endif
		elseif buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM then // A neutral mercenary
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 then
				call BuildUnit(GetUnitCountDone(old_id[u] + 1), u, prio)
			endif
		else // structure
			call BuildUnit(1, u, prio*2) 
		endif

		endif
	endif
	
endfunction
function BuildAntiunarmoredStrength takes integer number, integer prio returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer num
	local integer chance = 0
		
	if totalchance_unarmored > 0 then
		set choice = GetRandomInt(0,totalchance_unarmored) // Build this unit
		loop
			set chance = chance + dychance_unarmored[i]
			exitwhen choice <= chance or i >= totalanti_unarmored
			set i = i + 1
		endloop
		if i >= totalanti_unarmored then
			set u = dyanti_unarmored[i-1]
		else
			set u = dyanti_unarmored[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_unarmored then
		//set food1 = food/GetFoodUsed(old_id[units[choice]])
		if IsUnitIdType(old_id[u], UNIT_TYPE_STRUCTURE) == false and not (buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM) then 
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 and GetUnitCount(old_id[u]) < num then
				call BuildUnit(Min(num, GetUnitCountDone(old_id[u]) + 10), u, prio)  
			endif
		elseif buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM then // A neutral mercenary
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 then
				call BuildUnit(GetUnitCountDone(old_id[u] + 1), u, prio)
			endif
		else // structure
			call BuildUnit(1, u, prio*2) 
		endif

		endif
	endif
	
endfunction
function BuildAntilightarmorStrength takes integer number, integer prio returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer num
	local integer chance = 0
		
	if totalchance_lightarmor > 0 then
		set choice = GetRandomInt(0,totalchance_lightarmor) // Build this unit
		loop
			set chance = chance + dychance_lightarmor[i]
			exitwhen choice <= chance or i >= totalanti_lightarmor
			set i = i + 1
		endloop
		if i >= totalanti_lightarmor then
			set u = dyanti_lightarmor[i-1]
		else
			set u = dyanti_lightarmor[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_lightarmor then
		//set food1 = food/GetFoodUsed(old_id[units[choice]])
		if IsUnitIdType(old_id[u], UNIT_TYPE_STRUCTURE) == false and not (buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM) then 
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 and GetUnitCount(old_id[u]) < num then
				call BuildUnit(Min(num, GetUnitCountDone(old_id[u]) + 10), u, prio)  
			endif
		elseif buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM then // A neutral mercenary
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 then
				call BuildUnit(GetUnitCountDone(old_id[u] + 1), u, prio)
			endif
		else // structure
			call BuildUnit(1, u, prio*2) 
		endif

		endif
	endif
	
endfunction
function BuildAntimediumarmorStrength takes integer number, integer prio returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer num
	local integer chance = 0
		
	if totalchance_mediumarmor > 0 then
		set choice = GetRandomInt(0,totalchance_mediumarmor) // Build this unit
		loop
			set chance = chance + dychance_mediumarmor[i]
			exitwhen choice <= chance or i >= totalanti_mediumarmor
			set i = i + 1
		endloop
		if i >= totalanti_mediumarmor then
			set u = dyanti_mediumarmor[i-1]
		else
			set u = dyanti_mediumarmor[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_mediumarmor then
		//set food1 = food/GetFoodUsed(old_id[units[choice]])
		if IsUnitIdType(old_id[u], UNIT_TYPE_STRUCTURE) == false and not (buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM) then 
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 and GetUnitCount(old_id[u]) < num then
				call BuildUnit(Min(num, GetUnitCountDone(old_id[u]) + 10), u, prio)  
			endif
		elseif buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM then // A neutral mercenary
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 then
				call BuildUnit(GetUnitCountDone(old_id[u] + 1), u, prio)
			endif
		else // structure
			call BuildUnit(1, u, prio*2) 
		endif

		endif
	endif
	
endfunction
function BuildAntiheavyarmorStrength takes integer number, integer prio returns nothing
	local integer u = 0
	local integer i = 0
	local integer choice
	local integer num
	local integer chance = 0
		
	if totalchance_heavyarmor > 0 then
		set choice = GetRandomInt(0,totalchance_heavyarmor) // Build this unit
		loop
			set chance = chance + dychance_heavyarmor[i]
			exitwhen choice <= chance or i >= totalanti_heavyarmor
			set i = i + 1
		endloop
		if i >= totalanti_heavyarmor then
			set u = dyanti_heavyarmor[i-1]
		else
			set u = dyanti_heavyarmor[i]
		endif
		//if GetFoodUsed(old_id[u]) == 0 then
		//	call Trace("Divide By Zero:" + Int2Str(u) + ":" + Int2Str(old_id[u]))
		//endif
		if u > 0 and i <= totalanti_heavyarmor then
		//set food1 = food/GetFoodUsed(old_id[units[choice]])
		if IsUnitIdType(old_id[u], UNIT_TYPE_STRUCTURE) == false and not (buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM) then 
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 and GetUnitCount(old_id[u]) < num then
				call BuildUnit(Min(num, GetUnitCountDone(old_id[u]) + 10), u, prio)  
			endif
		elseif buy_type[u] > BT_RACIAL_ITEM and buy_type[u] < BT_MERCHANT_ITEM then // A neutral mercenary
			set num = R2I((number - FoodUsed())/GetFoodUsed(old_id[u]))
			if num > 0 then
				call BuildUnit(GetUnitCountDone(old_id[u] + 1), u, prio)
			endif
		else // structure
			call BuildUnit(1, u, prio*2) 
		endif

		endif
	endif
	
endfunction

function DynamicBuildSequence takes integer count, integer prio returns nothing
	local integer h 

	set h = DetermineCounterForce()
	
	if h == 0 then	// air
		//call BuildpiercingStrength(count,prio)
		call Trace("I'm building anti air units")
		call BuildAntiairStrength(count,prio)
	elseif h==1 then	// casters
		call Trace("I'm building anti caster units")
		//call BuildcastersStrength(count,prio)
		call BuildAnticastersStrength(count,prio)
	elseif h==2 then // tower
		call Trace("I'm building anti tower units")
		// Seige
		//call BuildsiegeStrength(count,prio)
		call BuildAntitowersStrength(count,prio)
	elseif h==3 then // piercing
			call Trace("I'm building anti piercing units")
		// Medium
		//call BuildmediumarmorStrength(count,prio)
		call BuildAntipiercingStrength(count,prio)
	elseif h==4 then // normal
			call Trace("I'm building anti normal units")
		// Normal
		//call BuildnormalStrength(count,prio)
		call BuildAntinormalStrength(count,prio)
	elseif h==5 then // siege
			call Trace("I'm building anti siege units")
		// Medium Armor
		//call BuildmediumarmorStrength(count,prio)
		call BuildAntisiegeStrength(count,prio)
	elseif h==6 then// magic
			call Trace("I'm building anti magic units")
		// Medium Armor
		//call BuildmediumarmorStrength(count,prio)
		call BuildAntimagicStrength(count,prio)
	elseif h==7 then// unarmored
			call Trace("I'm building anti unarmored units")
		//if GetRandomReal(0, 100) < 50 then
			// Seige
		//	call BuildsiegeStrength(count,prio)
		//else
			// Pierce
		//	call BuildpiercingStrength(count,prio)
		//endif
		call BuildAntiunarmoredStrength(count,prio)
	elseif h==8 then// lightarmor
			call Trace("I'm building anti light armor units")
		//if GetRandomReal(0, 125) < 25 then
			// Magic
		//	call BuildmagicStrength(count,prio)
		//else
			// Pierce
		//	call BuildpiercingStrength(count,prio)
		//endif
		call BuildAntilightarmorStrength(count,prio)
	elseif h==9 then// mediumarmor
			call Trace("I'm building anti medium units")
		// Normal
		//call BuildnormalStrength(count,prio)
		call BuildAntimediumarmorStrength(count,prio)
	elseif h==10 then
			call Trace("I'm building anti heavy units")
		// Magic
		//call BuildmagicStrength(count,prio)
		call BuildAntiheavyarmorStrength(count,prio)
	endif
endfunction

function InitHarass takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > max_harass_groups
    set harass_size[i] = 0
    set harass_time[i] = -1000000
    set i = i + 1
  endloop
  set distraction_group = 0
endfunction

function AddHarass takes integer groupnum, integer qty, integer unitid returns nothing
  set harass_qty[harass_size[groupnum]*max_harass_groups + groupnum] = qty
  set harass_units[harass_size[groupnum]*max_harass_groups + groupnum] = unitid
  set harass_size[groupnum] = harass_size[groupnum] + 1
endfunction

function AddHarassUnittype takes integer groupnum, integer harassnum, group harasser, string key returns group
  local group g = CreateGroup()
  local unit u = null
  local real player_sum = 0
  
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectByUnitStandard(g, true)
  set g = SelectByUnitFree(g, true)
  set g = SelectByFullHealth(g, true)
  set g = SelectNumberOfId(g, harass_qty[harassnum*max_harass_groups + groupnum], old_id[harass_units[harassnum*max_harass_groups + groupnum]])
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    call GroupAddUnit(unit_harassing, u)
    call RemoveGuardPosition(u)
    call GroupAddUnit(harasser,u)
	set player_sum = player_sum + GetUnitStrength(u)	
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  call StoreReal(additional_info, key, "Start_Strength", player_sum)
  return harasser
endfunction

function StartHarass takes integer groupnum, integer harass_target, boolean avoid_towers, real strength_limit, real flee_percent, integer flee_number, real lx, real ly returns nothing
  local integer i = 0
  local group harasser = CreateGroup()
  local string key = Int2Str(H2I(harasser))
  loop
    exitwhen i >= harass_size[groupnum]
    set harasser = AddHarassUnittype(groupnum, i, harasser, key)
    set i = i + 1
  endloop
  set harass_time[groupnum] = ai_time
  call StoreBoolean(additional_info, key, "Avoid_Towers", avoid_towers)
  //if avoid_towers and GetLocationTowerStrength(GetUnitX(target), GetUnitY(target), ver_tower_check_radius) > 0
  call StoreReal(additional_info, key, "Strength_Limit", strength_limit)
  call StoreBoolean(additional_info, key, "State_Attacking", true)
  call StoreReal(additional_info, key, "Flee_Percent", flee_percent)
  call StoreInteger(additional_info, key, "Flee_Number", flee_number)
  call StoreInteger(additional_info, key, "Invisible_Count", 0)
  call StoreReal(additional_info, key, "LocationX", lx)
  call StoreReal(additional_info, key, "LocationY", ly)
  call TQAddGroupJob(0, HARASS, harass_target, null, harasser)
endfunction

function GetHarassGroupStrength takes integer groupnum returns real
  local integer i = 0
  local real sum = 0
  local integer id = 0
  loop
    exitwhen i >= harass_size[groupnum]
    set id = harass_units[i*max_harass_groups + groupnum]
    set sum = sum + Min(harass_qty[i*max_harass_groups + groupnum], TownCountDone(id)) * GetFoodUsed(old_id[id]) * GetPlayerHandicap(ai_player)
    set i = i + 1
  endloop
  return sum
endfunction

function Harass takes integer groupnum, integer harass_target, boolean avoid_towers, real strength_limit, real flee_percent, integer flee_number, boolean cond, integer min_time, integer time returns nothing
  if cond and ai_time - harass_time[groupnum] >= time and ai_time >= min_time then
    call StartHarass(groupnum, harass_target, avoid_towers, strength_limit, flee_percent, flee_number, 0, 0)
  endif
endfunction


function StartUpgradeAM takes integer level, integer upgid returns integer
    local integer gold_cost = 0
    local integer wood_cost = 0
    local integer upg_level = GetUpgradeLevel(old_id[upgid])

    if upg_level >= level or ai_time < upgrade_time[upgid] then
      return BUILT_ALL
    endif
    
    if town_threatened then
      return BUILT_SOME
    endif

    set gold_cost = GetUpgradeGoldCost(old_id[upgid])
    set wood_cost = GetUpgradeWoodCost(old_id[upgid])

    set build_free[needed1[upgid]] = build_free[needed1[upgid]] - 1
    if build_free[needed1[upgid]] >= 0 then
      set total_gold = total_gold - gold_cost
      set total_wood = total_wood - wood_cost
      if total_gold < 0 then
        set total_gold = 0
      endif
      if total_wood < 0 then
        set total_wood = 0
      endif
    endif

    if total_gold <= 0 and total_wood <= 0 and (not (total_gold > 0 and wood_cost == 0)) and not (gold_cost == 0 and wood_cost == 0) then
      return NOT_ENOUGH_RES
    endif

    if (total_gold > 0 or gold_cost == 0) and (total_wood > 0 or wood_cost == 0) then
      if SetUpgrade(old_id[upgid]) then
        set upgrade_time[upgid] = ai_time + 10
        return BUILT_ALL
      else
        return CANNOT_BUILD
      endif
    endif
    return BUILT_SOME
endfunction




function GuardSecondaryAM takes integer townid, integer qty, integer unitid, integer prio returns nothing
    if TownHasHall(townid) and TownHasMine(townid) then
        call SecondaryTownAM( townid, qty, unitid, prio )
    endif
endfunction

function DefendTownsEx takes boolean only_done, integer qty, integer unitid, integer prio returns nothing
  local integer twm = Max(TownWithMine(),1)
  local integer i = twm
  loop
    exitwhen i > twm + 2
    if TownHasMine(i) and TownCountEx(racial_expansion,only_done,i) > 0 then
      call SecondaryTownAM(i, qty, unitid, prio)
    endif
    set i = i + 1
  endloop
endfunction

function DefendTowns takes integer qty, integer unitid, integer prio returns nothing
  call DefendTownsEx(false, qty, unitid, prio)
endfunction

function DefendTownsDone takes integer qty, integer unitid, integer prio returns nothing
  call DefendTownsEx(true, qty, unitid, prio)
endfunction

function DefendTownsCond takes integer qty, integer unitid, integer min_dist, integer max_dist, integer min_gold, integer prio returns nothing
  local integer twm = Max(TownWithMine(),1)
  local integer i = twm
  loop
    exitwhen i > twm + 2
    if TownHasMine(i) and town_built[i] and own_town_dist[i] >= min_dist and own_town_dist[i] <= max_dist and GetResourceAmount(own_town_mine[i]) >= min_gold then
      call SecondaryTownAM(i, qty, unitid, prio)
    endif
    set i = i + 1
  endloop
endfunction

function BasicExpansionAM takes boolean build_it, integer unitid, integer prio returns nothing
    if build_it and HallsCompleted(unitid) then
        call BuildExpa( TownCount(unitid)+1, unitid, prio )
    endif
endfunction

function UpgradeAllAM takes integer baseid, integer newid, integer prio returns nothing
    call BuildUnit( TownCountDone(baseid), newid, prio )
endfunction


function FoodPoolAM takes integer food, boolean weak, integer id1, integer use1, boolean strong, integer id2, integer use2, integer prio returns nothing
    if strong then
        call BuildUnit( (food - use1 * TownCount(id1)) / use2, id2, prio )
    elseif weak then
        call BuildUnit( (food - use2 * TownCount(id2)) / use1, id1, prio )
    endif
endfunction


function MeleeTownHallAM takes integer townid, integer unitid, integer prio returns nothing
    if TownHasMine(townid) and not TownHasHall(townid) then
        call SecondaryTownAM ( townid, 1, unitid, prio )
    endif
endfunction

function AddRefresh takes integer t, integer qty, integer unitid, integer town, integer bloc, integer prio returns nothing
    set t_build_qty[t_build_length] = qty
    set t_build_type[t_build_length] = t
    set t_build_item[t_build_length] = unitid
    set t_build_town[t_build_length] = town
    set t_build_loc[t_build_length] = bloc
    set t_build_prio[t_build_length] = prio
    set t_build_length = t_build_length + 1
endfunction

function RefreshAllNeeded takes nothing returns nothing
    local integer index = 0
    loop
      exitwhen index >= t_build_length
      call RefreshNeeded(t_build_type[index], t_build_qty[index], t_build_item[index], t_build_town[index], t_build_loc[index], t_build_prio[index])
      set index = index + 1
    endloop
endfunction

function GetNeutralHero takes integer unitid returns integer
    local unit tavern = nearest_neutral[NEUTRAL_TAVERN]
	local integer i = 0

	call Trace("I Want a Tavern Hero")

  if not neutral_available[NEUTRAL_TAVERN] then
    call Trace("No Tavern Available")
    return BUILT_ALL
  endif

  if tavern == null or neutral_guarded[NEUTRAL_TAVERN] then
    // Returns null if it cannot path to a tavern succesfully
    // Should switch to using transportation to get to it
    // Not Yet Implemented - will instead just build standard heroes
	call Trace("Tavern not usable: Getting standard hero")
	set recalculate_heros = true
	//set first_choosable_hero = ver_neutral_hero_number
	//loop
	//	exitwhen i > hero_number
	//	set all_heroes[i] = all_heroes_copy[i]
	//	set i = i + 1
	//endloop	
	//if hero[1] == unitid then
	//	set picked_hero = ChooseFirstHero()
	//elseif hero[2] == unitid then
	//	set hero[1] = GetExistingHero()
	//	call ChooseSecondHero()
	//else
	//	call ChooseRestHeroes()
	//endif
	//if tavern == null then
	//	call DisplayToAll("No Tavern Reachable")
	//else
	//	call DisplayToAll("Tavern is guarded")
	//endif
	
	// call set_skills()       NOT YET IMPLEMENTED - if tavern is not passable it just chooses a normal hero, unfortunately it at moment has no skills
	return CANNOT_BUILD
  endif



  if (unitid == hero[1] and hero_built[1]) or (unitid == hero[2] and hero_built[2]) or (unitid == hero[3] and hero_built[3]) then
    call Trace("Try To Resurrect Tavern Hero")
	if SetProduce(1,old_id[unitid],-1) then
      return BUILT_ALL
    else
      return CANNOT_BUILD
    endif
  endif

 //   if neutral_sent[NEUTRAL_TAVERN] == null then
 //   	set neutral_sent[NEUTRAL_TAVERN] = GetUnitToBuy(tavern)
 //   	if neutral_sent[NEUTRAL_TAVERN]  == null then

  if TownCountDone(needed1[unitid]) < 1 or (unitid == hero[2] and TownCountDone(needed2[unitid]) < 1) or (unitid == hero[3] and TownCountDone(needed3[unitid]) < 1) then
    call Trace("Requirements failed to get hero")
	return CANNOT_BUILD
  endif


  if not neutral_ordered[NEUTRAL_TAVERN] then
  	call Trace("Prepare to Do Tavern Job")
    set neutral_ordered[NEUTRAL_TAVERN] = true
    set neutral_wanted[NEUTRAL_TAVERN] = 1
    call TQAddJob(0, BUY_NEUTRAL_HERO, unitid)
  endif
  return BUILT_SOME
endfunction

function CheckNotBuiltFrom takes integer unitid returns boolean
  if unitid == BLK_SPHINX then
    return false
  endif
  return true
endfunction

function GetBuildLocation takes integer bloc returns location
  if bloc == BLOC_MINE then
    return mine_loc
  endif
  return front_loc[GetRandomInt(0, front_loc_num - 1)]
endfunction

function UpgradeBuilding takes integer qty, integer unitid, integer town, integer bloc returns integer
  local unit u = null
  local group g = CreateGroup()
  local integer current_town = town
  local integer num = 0
  if town == -1 then
    set current_town = 0
  endif
  if bloc != BLOC_STD then
    call GroupEnumUnitsInRangeOfLoc(g, GetBuildLocation(bloc), 800, null)
    set g = SelectByPlayer(g, ai_player, true)
    set g = SelectByAlive(g, true)
    loop
      set u = FirstOfGroup(g)
      exitwhen u == null
      if GetUnitTypeId(u) == old_id[needed1[unitid]] then
        if IssueImmediateOrderById(u, old_id[unitid]) then
          set num = num + 1
          if num >= qty then
            call DestroyGroup(g)
            set g = null
            return BUILT_ALL
          endif
        endif
      endif
      call GroupRemoveUnit(g,u)
    endloop  
  endif
  call GroupClear(g) 
  call GroupEnumUnitsInRangeOfLoc(g, own_town_loc[current_town], 2000, null)
  set g = SelectByPlayer(g, ai_player, true)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == old_id[needed1[unitid]] then
      if IssueImmediateOrderById(u, old_id[unitid]) then
        set num = num + 1
        if num >= qty then
          call DestroyGroup(g)
          set g = null
          return BUILT_ALL
        endif
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  if town != -1 then
    if num == 0 then
      return CANNOT_BUILD
    else
      return BUILT_SOME
    endif
  endif
  call GroupClear(g)   
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectByAlive(g, true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == old_id[needed1[unitid]] then
      if IssueImmediateOrderById(u, old_id[unitid]) then
        set num = num + 1
        if num >= qty then
          call DestroyGroup(g)
          set g = null
          return BUILT_ALL
        endif
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  if num == 0 then
    return CANNOT_BUILD
  else
    return BUILT_SOME
  endif
endfunction

function BuildAtSpecialLoc takes integer unitid, integer town, integer bloc returns integer
  local unit u = CreateUnitAtLoc(Player(PLAYER_NEUTRAL_PASSIVE), old_id[unitid], GetBuildLocation(bloc), 270.0)
  local location l = GetUnitLoc(u)
  local unit peon = GetExpansionPeon()
  
  if peon == null then
	set peon = GetExpansionPeon2()	// In case we can't get the expansion peon
  endif
  call RemoveUnit(u)
  set u = null
  if l == null then
  	//call Trace("BuildatspecialLoc: No location found")
    //call RemoveLocation(l)
	//set l = null
	return CANNOT_BUILD
  elseif peon == null then
	call Trace("BuildatspecialLoc: No peon available")
	call RemoveLocation(l)
	set l = null
	return CANNOT_BUILD	
  elseif not IssuePointOrderByIdLoc(peon, old_id[unitid], l) then
	//call Trace("Building at special point")
  //else
   // call Trace("BuildatspecialLoc: Not able to build here")
   	call RemoveLocation(l)
	set l = null
	return CANNOT_BUILD	
  endif
	call RemoveLocation(l)
	set l = null
	return BUILT_SOME	  
endfunction

function StartUnitAM takes integer ask_qty, integer unitid, integer town, integer bloc, integer prio, integer max_order returns integer
    local integer have_qty = 0
    local integer need_qty = 0
    local integer afford_gold = 0
    local integer afford_wood = 0
    local integer afford_food = 0
    local integer afford_qty = 0
    local integer gold_cost = 0
    local integer wood_cost = 0
    local integer food_cost = 0
    local integer cost_qty = 0
    local integer n1 = needed1[unitid]
    local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
    local integer nn = GetNeutralNumber(unitid)

    if town != -1 and (not town_built[town] or (unitid != racial_expansion and TownCountTown(racial_expansion, town) <= 0)) then
        return BUILT_ALL
    endif

    if buy_type[unitid] > BT_RACIAL_ITEM and (ai_time < available_time[unitid] or (neutral_guarded[nn] and ((daytime >= 5 and daytime < 18) or not neutral_night_buy[nn] or (buy_type[unitid] != BT_NEUTRAL_HERO and not ver_mercs_night_buy)))) then
      return BUILT_SOME
    endif
    
    if needed3[unitid] == UPGRADED and town != -1 and ai_time < available_time[unitid] then
      return BUILT_SOME
    endif

    //------------------------------------------------------------------------
    // if we have all we're asking for then make nothing
    //
        set have_qty = Max(TownCountTown(unitid,town),max_order)

    if have_qty >= ask_qty then
        return BUILT_ALL
    endif
    set need_qty = ask_qty - have_qty

    //------------------------------------------------------------------------
    // limit the qty we're requesting to the amount of resources available
    //
    set gold_cost = GetUnitGoldCost2(unitid)
    set wood_cost = GetUnitWoodCost2(unitid)
    set food_cost = GetFoodUsed(old_id[unitid])

    if gold_cost == 0 then
        set afford_gold = need_qty
    else
        set afford_gold = total_gold / gold_cost
    endif
    if afford_gold < need_qty then
        set afford_qty = afford_gold
    else
        set afford_qty = need_qty
    endif

    if wood_cost == 0 then
        set afford_wood = need_qty
    else
        set afford_wood = total_wood / wood_cost
    endif
    if afford_wood < afford_qty then
        set afford_qty = afford_wood
    endif

    if food_cost == 0 then
        set afford_food = need_qty
    else
        set afford_food = total_food / food_cost
    endif
    if afford_food < afford_qty then
        set afford_qty = afford_food
    endif

    //------------------------------------------------------------------------
    // whether we make right now what we're requesting or not, assume we will
    // and deduct the cost of the units from our fake gold total right away
    //
    if (buy_type[unitid] == BT_UNIT or buy_type[unitid] == BT_HERO) and CheckNotBuiltFrom(unitid) then
      set cost_qty = build_free[n1]
      if cost_qty > need_qty then
        set cost_qty = need_qty
      endif
      if cost_qty < 0 then
        set cost_qty = 0
      endif
      set build_free[n1] = build_free[n1] - need_qty
      if unitid != racial_peon then
        set gold_sum[n1] = gold_sum[n1] + need_qty * gold_cost
        set build_time_sum[n1] = build_time_sum[n1] + need_qty * GetUnitBuildTime(old_id[unitid])
        set build_num[n1] = build_num[n1] + need_qty
        set prio_sum[n1] = prio_sum[n1] + need_qty * prio
      endif
    else
      set cost_qty = need_qty
    endif

    set cost_qty = Min(cost_qty, afford_food)

	call Sleep(0.05)
    set afford_food = ApplyUpkeepCheck(afford_food, ver_food_limit - total_food, food_cost, cost_qty, need_qty)
    
    set cost_qty = Min(cost_qty, afford_food)
    set afford_qty = Min(afford_qty, cost_qty)
    
    set total_gold = total_gold - gold_cost * cost_qty
    set total_wood = total_wood - wood_cost * cost_qty
    set total_food = total_food - food_cost * cost_qty

    if total_gold < 0 then
        set total_gold = 0
    endif
    if total_wood < 0 then
        set total_wood = 0
    endif
    if total_food < 0 then
        set total_food = 0
    endif

    // if we're waiting on gold and wood; pause build orders
    if total_gold <= 0 and total_wood <= 0 and (not (total_gold > 0 and wood_cost == 0)) and not (gold_cost == 0 and wood_cost == 0) then
        return NOT_ENOUGH_RES
    elseif afford_qty < 1 then
        return BUILT_SOME
    endif

    //------------------------------------------------------------------------
    // give the AI a chance to make the units (it may not be able to right now
    // but that doesn't stop us from trying other units after this as long
    // as we have enough money to make this AND the needed, unbuilt ones)
    //

    if needed3[unitid] == UPGRADED then
      if (needed1[unitid] != 0 and GetUnitCountEx(needed1[unitid],true,town) < 1) or (needed2[unitid] != 0 and TownCountDone(needed2[unitid]) < 1) then
        return CANNOT_BUILD
      endif
    endif

    if unitid == HEAD_HUNTER and GetUpgradeLevel(oUPG_ORC_BERSERKER) >= 1 then
      if SetProduce(afford_qty,oBERSERKER,town) then
        if (afford_qty == need_qty) and (need_qty == cost_qty) then
          return BUILT_ALL
        else
          return BUILT_SOME
        endif
      else
        return CANNOT_BUILD
      endif
    endif

    if unitid == BLK_SPHINX then
      if GetUpgradeLevel(oUPG_BLK_SPHINX) >= 1 then
        if ConvertUnits(afford_qty + have_qty, oOBSIDIAN_STATUE) then
          if (afford_qty == need_qty) and (need_qty == cost_qty) then
            return BUILT_ALL
          else
            return BUILT_SOME
          endif
        else
          return CANNOT_BUILD
        endif
      else
        return CANNOT_BUILD
      endif
    endif

    if buy_type[unitid] == BT_NEUTRAL_HERO then
      return GetNeutralHero(unitid)
    endif

    if buy_type[unitid] > BT_RACIAL_ITEM and buy_type[unitid] <= BT_MERCHANT_ITEM then
      if not (neutral_ordered[nn] or attack_running) and nearest_neutral[nn] != null then
        set neutral_ordered[nn] = true
        set neutral_wanted[nn] = afford_qty + have_qty
        call TQAddJob(0, BUY_NEUTRAL, unitid)
      endif
      return BUILT_SOME
    endif

    if needed3[unitid] == UPGRADED and buy_type[unitid] == BT_BUILDING then
      return UpgradeBuilding(afford_qty, unitid, town, bloc)
    endif
	
	if unitid == racial_lumber and TownCountDone(racial_lumber) < 1 then
		return BuildLumberMillAtBase()
	endif
	
    if bloc != BLOC_STD then
      if not CanBuildUnit(unitid) then
        return CANNOT_BUILD
      endif
      if bloc == BLOC_FRONT and not front_locs_computed then
        return BUILT_SOME
      endif
      if BuildAtSpecialLoc(unitid, town, bloc) != CANNOT_BUILD then   // This only occurs if no peon could be obtained
		return BUILT_SOME
	  endif
    endif

    if SetProduce(afford_qty,old_id[unitid],town) then
      if town != -1 and unitid == racial_expansion then
        set town_built[town] = false
      endif
      if needed3[unitid] == UPGRADED then
        set available_time[unitid] = ai_time + GetUnitBuildTime(old_id[unitid]) / 5 + 1
      endif
      if (afford_qty == need_qty) and (need_qty == cost_qty) then
        return BUILT_ALL
      else
        return BUILT_SOME
      endif
    else
      return CANNOT_BUILD
    endif
endfunction

function ConstructExpansion takes unit peon, integer unitid returns boolean
  local unit u = null
  if ai_time > exp_loc_cache_timeout then
    if exp_loc_cache != null then
		call RemoveLocation(exp_loc_cache)
		set exp_loc_cache = null
    endif
	set u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE), unitid, GetUnitX(current_expansion), GetUnitY(current_expansion), 270.0)
    if DistanceBetweenUnits(u, current_expansion) > race_max_expa_mine_distance then
      call RemoveUnit(u)
      set u = null
      return false
    endif
    set exp_loc_cache = GetUnitLoc(u)
    set exp_loc_cache_timeout = ai_time + 4
  //  call SetUnitExploded(u, true)
  //  call KillUnit(u)
    call RemoveUnit(u)
    set u = null
  endif
  return IssuePointOrderByIdLoc(peon, unitid, exp_loc_cache)
endfunction

function IsWaterExpansion takes unit u returns boolean
  local integer i = 0
  loop
    exitwhen i == water_expansion_list_length
    if water_expansion_list[i] == u then
      return true
    endif
    set i = i + 1
  endloop
  return false
endfunction

function BuildMovePeonZeppelin takes unit peon, unit target returns boolean
  if build_zeppelin == null or not UnitAlive(build_zeppelin) then
    set build_zeppelin = GetUnusedZeppelinNearUnit(peon)
	// Disabled just in case
	set build_zeppelin = null
    if build_zeppelin == null then
      call Trace("No Zeppelin found for transporting peon")
      return false
    endif
    call GroupAddUnit(unit_zepplin_move, build_zeppelin)
  endif
  if IsUnitInTransport(peon, build_zeppelin) then
    if DistanceBetweenUnits(build_zeppelin, target) > 300 then
      call IssuePointOrder(build_zeppelin, "move", GetUnitX(target), GetUnitY(target))
    else
      call IssueTargetOrder(build_zeppelin, "unload", peon)
    endif
  else
    if DistanceBetweenUnits(peon, target) < 400 then
      call GroupRemoveUnit(unit_zepplin_move, build_zeppelin)
      set build_zeppelin = null
      return true
    else
      call IssueTargetOrder(peon, "smart", build_zeppelin)
    endif
  endif
  return false
endfunction

function StartExpansionAM takes integer qty, integer hall returns integer
  local integer count = TownCount(hall)
  local integer countdone = TownCountDone(hall)
  local unit    peon = null
  local integer gold_cost = 0
  local integer wood_cost = 0

  if countdone >= qty then
    return BUILT_ALL
  endif
  if (count > countdone) or town_threatened then
    return BUILT_SOME
  endif
  

  if CheckExpansionTaken(current_expansion) then
    set current_expansion = null
  endif
  
 // call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Expansion Taken Checked")

  if current_expansion == null then
    call ChooseExpansion()
    if current_expansion == null then
     call Trace("AMAIStartexpa: Expansion Not Found")
      return BUILT_ALL
    endif
  endif

 // call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Expansion choosen")

  if GetExpFoe() != null then
      set take_exp = true
  else
	  set take_exp = false
  endif

  set gold_cost = GetUnitGoldCost2(hall)
  set wood_cost = GetUnitWoodCost2(hall)

  set total_gold = total_gold - gold_cost
  set total_wood = total_wood - wood_cost

  if total_gold < 0 then
    set total_gold = 0
  endif
  if total_wood < 0 then
    set total_wood = 0
  endif

  if total_gold <= 0 and total_wood <= 0 then
    return NOT_ENOUGH_RES
  endif

  if take_exp or total_gold <= 0 or total_wood <= 0 then
    return BUILT_SOME
  endif

 // call DisplayTextToPlayer(GetLocalPlayer(), 0, 0, "Expansion rescources sorted")

    set peon = GetExpansionPeon()
	if peon == null then
		set peon = GetExpansionPeon2()
	endif


  if peon != null then
    if IsWaterExpansion(current_expansion) then
      if not BuildMovePeonZeppelin(peon, current_expansion) then
	    call Trace("AMAIStartexpa: Is a water expansion")
        return BUILT_SOME
      endif
    endif
	set exp_time_count = ai_time	// This sets time to next expansion to current time so it waits enough time before starting another expansion 
    if race_uses_mine_expansion then
      call IssueTargetOrderById(peon, old_id[hall], current_expansion)
    else
      call ConstructExpansion(peon,old_id[hall])
    endif
  endif


  return BUILT_SOME
endfunction

function BuyItem takes integer qty, integer id returns boolean
  if attack_running then
    return true
  endif
  if shop_ordered then
      //call Trace("Already ordered to get an item")
	return true
  endif
  set shop_wanted = qty
  if buy_type[id] == BT_RACIAL_ITEM then
    set shop_unit = GetOneOfId(ai_player, old_id[racial_shop])
    set shop_distance_limit = raceshop_distance_limit
  else
    set shop_unit = nearest_neutral[NEUTRAL_MERCHANT]
    set shop_distance_limit = merchant_distance_limit
  endif
  if shop_unit != null then
	set shop_ordered = true
	call TQAddJob(0, BUY_ITEM, id)
  endif
  return true
endfunction

function StartEmergencyItem takes integer ask_qty, integer itemid returns integer
  local integer gold_cost = gold_price[itemid]
  local integer wood_cost = wood_price[itemid]
  local integer have_qty = GetItemNumber(itemid)
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  local integer gold = GetGold()
  local integer wood = GetWood()

  if have_qty >= ask_qty or (buy_type[itemid] == BT_MERCHANT_ITEM and not neutral_available[NEUTRAL_MERCHANT]) then
    return BUILT_ALL
  endif

  if nearest_neutral[NEUTRAL_MERCHANT] == null and buy_type[itemid] == BT_MERCHANT_ITEM then
      call Trace("No merchant available to buy emergency item")
     // Cannot path so will require transporter
     // NYI
     return BUILT_ALL
  endif

  if available_time[itemid] > ai_time or (buy_type[itemid] == BT_MERCHANT_ITEM and neutral_guarded[NEUTRAL_MERCHANT] and ((daytime >= 5 and daytime < 18) or not neutral_night_buy[NEUTRAL_MERCHANT])) then
    return BUILT_SOME
  endif

  if (needed1[itemid] != 0 and TownCountDone(needed1[itemid]) < 1) or (needed2[itemid] != 0 and TownCountDone(needed2[itemid]) < 1) or (needed3[itemid] != 0 and TownCountDone(needed3[itemid]) < 1) then
    call Trace("Emergency item not enough requirements to buy item")
	return CANNOT_BUILD
  endif  
  
  set gold = gold - gold_cost
  set wood = wood - wood_cost

  if gold < 0 then
    set gold = 0
  endif
  if wood < 0 then
    set wood = 0
  endif

  if gold <= 0 and wood <= 0 and (not (gold > 0 and wood_cost == 0)) and not (gold_cost == 0 and wood_cost == 0) then
  call Trace("Need more rescources to buy emergency item")
    return NOT_ENOUGH_RES
  endif

  if (gold > 0 or gold_cost == 0) and (wood > 0 or wood_cost == 0) then
    if BuyItem(have_qty + 1, itemid) then
	  call Trace("Buying emergency item")
      return BUILT_SOME
    else
      return CANNOT_BUILD
    endif
  endif
    return BUILT_SOME
endfunction

function StartItem takes integer ask_qty, integer itemid returns integer
  local integer gold_cost = gold_price[itemid]
  local integer wood_cost = wood_price[itemid]
  local integer have_qty = GetItemNumber(itemid)
  local real daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)


  if have_qty >= ask_qty or (buy_type[itemid] == BT_MERCHANT_ITEM and not neutral_available[NEUTRAL_MERCHANT]) then
    return BUILT_ALL
  endif

  if nearest_neutral[NEUTRAL_MERCHANT] == null and buy_type[itemid] == BT_MERCHANT_ITEM then
     // Cannot path so will require transporter
     // NYI
     return BUILT_ALL
  endif

  if available_time[itemid] > ai_time or GetSlotsFree() <= 0 or (buy_type[itemid] == BT_MERCHANT_ITEM and neutral_guarded[NEUTRAL_MERCHANT] and ((daytime >= 5 and daytime < 18) or not neutral_night_buy[NEUTRAL_MERCHANT])) then
		return BUILT_SOME
  endif

  if (needed1[itemid] != 0 and TownCountDone(needed1[itemid]) < 1) or (needed2[itemid] != 0 and TownCountDone(needed2[itemid]) < 1) or (needed3[itemid] != 0 and TownCountDone(needed3[itemid]) < 1) then
    return CANNOT_BUILD
  endif

  set total_gold = total_gold - gold_cost
  set total_wood = total_wood - wood_cost

  if total_gold < 0 then
    set total_gold = 0
  endif
  if total_wood < 0 then
    set total_wood = 0
  endif

  if total_gold <= 0 and total_wood <= 0 and (not (total_gold > 0 and wood_cost == 0)) and not (gold_cost == 0 and wood_cost == 0) then
    return NOT_ENOUGH_RES
  endif

  if (total_gold > 0 or gold_cost == 0) and (total_wood > 0 or wood_cost == 0) then
    if BuyItem(have_qty + 1, itemid) then
      return BUILT_SOME
    else
      return CANNOT_BUILD
    endif
  endif
  return BUILT_SOME
endfunction

function BuildFarms takes integer qty returns nothing
  if TownCount(racial_farm) < race_farms_at_mine then
    call BuildAtMine(Min(TownCountDone(racial_farm) + qty, max_farms), racial_farm, farm_prio)
  elseif race_build_farms_front and front_locs_computed and TownCountDone(racial_farm) <= race_farms_front_limit + 1 and TownCountDone(racial_farm) >= 1 then
    call BuildFront(Min(TownCountDone(racial_farm) + qty, max_farms), racial_farm, farm_prio)
  else
    call BuildUnit(Min(TownCountDone(racial_farm) + qty, max_farms), racial_farm, farm_prio)
  endif
endfunction

function FarmBuilder takes nothing returns nothing
  if FoodCap() >= ver_food_limit then
    return
  endif
  if FoodSpace() <= farm_food2 then
    call BuildFarms(2)
  elseif FoodSpace() <= farm_food then
    call BuildFarms(1)
  endif
endfunction

function ShredderBuilder takes nothing returns nothing
  local real g = GetGold()
  local real w = Max(GetWood(),1)
  local real gdivw = g / w
  if neutral_available[NEUTRAL_OBSERVATORY] and gdivw > 4 and g - w > 500 and w < 550 and ai_time - available_time[neutral_shredder] >= -1 then
    call BuildUnit(1, neutral_shredder, peon_prio)
  endif
endfunction

function BuildPeons takes integer number returns nothing
  call BuildUnit(number, racial_peon, peon_prio)
endfunction

function BuildGhouls takes integer number returns nothing
  call BuildUnit(number, racial_ghoul, peon_prio-30)
endfunction

function PeonBuilder takes nothing returns nothing
  local integer mo = GetMinesHarvested()
  local integer sc = TownCount(neutral_shredder)
  local real w = GetWood()
  if race_uses_shredder then
    call ShredderBuilder()
  else
    set sc = 0
  endif
   
  //if w <= maximum_peon_wood then 
  /// call BuildPeons( peon_1_mine_number * mo + Max(max_lumber_peons - shredder_peon_count*sc, 1 )  )  // number of peons per mine + wood peons
  //elseif w >= minimum_peon_wood then
  // call BuildPeons( peon_1_mine_number * mo + Max(min_lumber_peons - shredder_peon_count*sc, 1 )  )
 // else
 //  call BuildPeons( peon_1_mine_number * mo + Max(Max(min_lumber_peons, R2I(I2R(max_lumber_peons) / 2)) - shredder_peon_count*sc, 1 )  )
 // endif

  if race_has_ghouls then
	  if mo <= 1 then
		call BuildPeons(min_peon_number_single_mine)
	  elseif mo <= 2 then
		call BuildPeons(min_peon_number_double_mine)
	  else
	  	call BuildPeons(min_peon_number_multi_mine)
	  endif
  else
	  if mo <= 1 then
	   // call BuildPeons(Max(min_peon_number_single_mine, R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_1_mine_number, 5, w)) - shredder_peon_count*sc))
		call BuildPeons(Max(R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_1_mine_number, min_peon_number_single_mine, w) - shredder_peon_count*sc),min_peon_number_single_mine)) // the Max condition prevents having loads of shredders stoping amai getting peons for gold
	  elseif mo <= 2 then
	   // call BuildPeons(Max(min_peon_number_double_mine, R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_2_mines_number, 10, w)) - shredder_peon_count*sc))
		call BuildPeons(Max(R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_2_mines_number, min_peon_number_double_mine, w) - shredder_peon_count*sc),min_peon_number_double_mine))
	  else
	   // call BuildPeons(Max(min_peon_number_multi_mine, R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_mines_number, 10, w)) - shredder_peon_count*sc))
		call BuildPeons(Max(R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, peon_mines_number, min_peon_number_multi_mine, w) - shredder_peon_count*sc),min_peon_number_multi_mine))	
	  endif
  endif
  if race_has_ghouls then
  	  call BuildGhouls(Max(R2I(LinearInterpolation(maximum_peon_wood, minimum_peon_wood, race_max_ghouls, race_min_ghouls, w) - R2I(shredder_peon_count/2)*sc),2)) 
  endif
endfunction

function SetBuildFree takes nothing returns nothing
local integer i = 0
local integer j = 0
loop
  exitwhen i >= building_length
  set j = building[i]
  set build_free[j] = TownCountDone(j)
  set gold_sum[j] = 0
  set build_time_sum[j] = 0
  set build_num[j] = 0
  set prio_sum[j] = 0
  set i = i + 1
endloop
endfunction

function ExpansionBuilder takes nothing returns nothing
local integer mines = GetMinesOwned()
local integer gold_left = GetGoldOwned()
local boolean exp_prepared = false
local boolean rebuild = false

if first_expansion_chosen and (current_expansion == null or CheckExpansionTaken(current_expansion)) then
  call ChooseExpansion()
  if current_expansion == null then
	  call Trace("ExpansionBuilder: No mine available")  
    return
  endif
endif

if mines < 2 and ai_time - exp_time_count > exp_first_time then
  if GetExpFoe() != null then
    set take_exp = true
    //if attacking_expansion then
    //  set exp_prepared = true
	//  call Trace("ExpansionBuilder: Ready to expand to mine 2 - odd")
    //endif
  else
    set take_exp = false
    set exp_prepared = true
	  call Trace("ExpansionBuilder:Ready to expand to mine 2")	
  endif
endif

if mines < 3 and ai_time - exp_time_count > exp_second_time then
    if GetExpFoe() != null then
        set take_exp = true
    else
        set take_exp = false
        set exp_prepared = true
	  call Trace("ExpansionBuilder:Ready to expand to mine 3")		
    endif
endif

if not exp_prepared then
	set rebuild = CheckExpansionRebuild()
	if rebuild then
		set exp_prepared = true
	endif
endif

if mines < 1 or gold_left < 2000 or exp_prepared then
  call Trace("ExpansionBuilder: Putting mine on build list")
  if mines < 1 or gold_left < 2000 then
    call BuildExpa(TownCount(racial_expansion) + 1, racial_expansion, expa_emergency_prio)
  elseif rebuild then
	call BuildExpa(TownCount(racial_expansion) + 1, racial_expansion, expa_rebuild_prio)
  else
    call BuildExpa(TownCount(racial_expansion) + 1, racial_expansion, expa_prio)
  endif
endif

endfunction

function InitHeroInfo takes integer hn returns nothing
  if hero_loc[hn] != null then
	call RemoveLocation(hero_loc[hn])
  endif
  set hero_loc[hn] = GetUnitLoc(hero_unit[hn])
  if hero_enemy_loc[hn] != null then
	call RemoveLocation(hero_enemy_loc[hn])
  endif
  if hero_ally_loc[hn] != null then
	call RemoveLocation(hero_ally_loc[hn])
  endif
  set hero_enemy_loc[hn] = Location(0,0)
  set hero_ally_loc[hn] = Location(0,0)
  set hero_hp[hn] = 1
endfunction

function HeroReviver takes nothing returns nothing
  local integer i = 1
  loop
    exitwhen i > 3
    if GetUnitCountDone(old_id[hero[i]]) > 0 then
        if not hero_built[i] then
          set hero_built[i] = true
          set hero_unit[i] = GetOneOfId(ai_player, old_id[hero[i]])
          call InitHeroInfo(i)
          call TQAddJob(1, MICRO_HERO, i)
        endif
    elseif hero_built[i] then
        call BuildUnit(1, hero[i], hero_revive_prio[i])
    endif
    set i = i + 1
  endloop
endfunction

function CheckUnitNewTown takes unit u, integer num returns boolean
  local integer i = 0
  local location l = GetUnitLoc(u)
  loop
    exitwhen i >= num
    if own_town_loc[i] != null and town_built[i] and DistanceBetweenPoints(l, own_town_loc[i]) < town_radius then
      call RemoveLocation(l)
      set l = null
      return false
    endif
    set i = i + 1
  endloop
  call RemoveLocation(l)
  set l = null
  return true
endfunction

function LocalizeNewTown takes integer num returns nothing
  local group g = CreateGroup()
  local unit u = null
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  set g = SelectById(g, old_id[racial_expansion], true)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    exitwhen CheckUnitNewTown(u, num)
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  if u == null then
    set own_town_loc[num] = null
    set own_town_mine[num] = null
    set own_town_dist[num] = 0
    return
  endif
  set own_town_loc[num] = GetUnitLoc(u)
  set own_town_mine[num] = GetMineNearLoc(own_town_loc[num], 1500)
  set own_town_dist[num] = DistanceBetweenPoints(home_location, own_town_loc[num])
endfunction

function CheckTownBuilt takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= max_towns
    if not town_built[i] then
      if (TownCountEx(racial_expansion, true, i) > 0 and not (TownCountEx(racial_expansion, true, 50) > 0)) then
        set town_built[i] = true
        call LocalizeNewTown(i)
      endif
    endif
    set i = i + 1
  endloop
endfunction

function TimeKeeper takes nothing returns nothing
  local real new_time_of_day = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
  if new_time_of_day < time_of_day then
  //  call Chat(C_NewYear)
  endif
  set time_of_day = new_time_of_day
  set ai_time = R2I(TimerGetElapsed(tq_timer)/5)
  if ai_time >= taunt_start_time then
    call Chat(C_Taunt)
  endif
endfunction

function FactoryNumberUpdate takes nothing returns nothing
  local integer g_sum = 0
  local integer i = 0
  local integer j = 0
  set gold_income = GetGoldIncome() * gold_unit_percentage
  loop
    exitwhen i >= building_length
    set g_sum = g_sum + gold_sum[building[i]]
    set i = i + 1
  endloop
  if g_sum == 0 then
    return
  endif
  set i = 0
  loop
    exitwhen i >= building_length
    set j = building[i]
    set income_percentage[j] = I2R(gold_sum[j]) / I2R(g_sum)
    if build_num[j] > 0 then
      call BuildUnit(GetFactoryQty(build_num[j], build_time_sum[j] / build_num[j], gold_sum[j] / build_num[j], income_percentage[j]), j, prio_sum[j] / build_num[j])
    endif
    set i = i + 1
  endloop
endfunction

function OneBuildLoopAM takes nothing returns nothing
    local integer index = 0
    local integer index_free = 0
    local integer qty = 0
    local integer id = 0
    local integer tp = 0
    local integer ret = 0
    local integer town = 0
    local integer array max_order
    local integer mo = 0
    
    call InitLastUpkeep()

    call TimeKeeper()
    call CheckTownBuilt()
    call SetBuildFree()
    call FarmBuilder()
    call PeonBuilder()
    if not campaign_ai then
      call ExpansionBuilder()
      call HeroReviver()
    endif

    set total_gold   = GetGold() - gold_buffer
    set total_wood   = GetWood() - wood_buffer
    set total_food   = ver_food_limit - FoodUsed()

    call CheckUpkeepAllowed(ver_food_limit - total_food)

    set blocked_gold = 0
    set blocked_wood = 0
	set blocked_food = 0
    set t_build_length = 0

    call GetBuildLock()
    loop
        exitwhen index >= build_length

        set id   = build_item[index]
        set qty  = RBlockListCheck(build_qty[index], id)
        set tp   = build_type[index]
        set town = Max(build_town[index],0)
        set mo = max_order[id + town*OBJECT_NUM]
        
        
        if build_qty[index] > mo then
          
          if tp == BUILD_UNIT then
              set ret = StartUnitAM(qty,id,build_town[index], build_loc[index], build_prio[index], mo)
          elseif tp == BUILD_UPGRADE then
              set ret = StartUpgradeAM(qty,id)
          elseif tp == BUILD_EXPAND then
              set ret = StartExpansionAM(qty,id)
          else
              set ret = StartItem(qty,id)
          endif

          if qty > mo then
            set max_order[id + town*OBJECT_NUM] = qty
          endif

  //        exitwhen ret == NOT_ENOUGH_RES
          if ret == CANNOT_BUILD then
            call AddRefresh(tp, qty, id, build_town[index], build_loc[index], build_prio[index])
          endif
          if ret == CANNOT_BUILD or ret == BUILT_SOME or ret == NOT_ENOUGH_RES or (ret == BUILT_ALL and qty < build_qty[index]) then
            set build_qty[index_free] = build_qty[index]
            set build_type[index_free] = build_type[index]
            set build_item[index_free] = build_item[index]
            set build_loc[index_free] = build_loc[index]
            set build_town[index_free] = build_town[index]
            set build_prio[index_free] = build_prio[index] + prio_t_inc
            set index_free = index_free + 1
          endif
  
          call ApplyUpkeepSaving()
        endif

        set index = index + 1
        set total_gold = total_gold - blocked_gold
        set total_wood = total_wood - blocked_wood
		//set total_food = total_food - blocked_food
        set blocked_gold = 0
        set blocked_wood = 0
		set blocked_food = 0
        call UpdateLastUpkeep()
    endloop
    
    
    loop
          exitwhen index >= build_length
          set build_qty[index_free] = build_qty[index]
          set build_type[index_free] = build_type[index]
          set build_item[index_free] = build_item[index]
          set build_town[index_free] = build_town[index]
          set build_loc[index_free] = build_loc[index]
          set build_prio[index_free] = build_prio[index] + prio_t_inc
          set index_free = index_free + 1
          set index = index + 1
    endloop
    set build_length = index_free
    
    call ResetUpkeepSaveTime()
    call ReleaseBuildLock()
    call RefreshAllNeeded()
    call FactoryNumberUpdate()
    
endfunction


function BuildLoopAM takes nothing returns nothing
  local integer blc = 0
  call OneBuildLoopAM()
  call StaggerSleep(1,5)
  loop
	  //call Trace("Build Loop")
      set blc = blc + 1
      call OneBuildLoopAM()
      exitwhen player_defeated
      if blc > build_array_reset_time then
        call InitBuildArrayAM()
        set blc = 0
      endif
      call Sleep(5 * sleep_multiplier)
  endloop
endfunction

function PlayGameAM takes nothing returns nothing
  call BuildLoopAM()
endfunction

function ConversionsAM takes integer desire, integer unitid returns nothing
  if unitid == HIPPO_RIDER then
      call MergeUnits(desire,oARCHER,oHIPPO,oHIPPO_RIDER)
  endif
endfunction

function SetAssaultGroupAM takes integer qty, integer max, integer unitid returns nothing
  call ConversionsAM(max,unitid)

  set attack_qty[attack_length] = qty
  set attack_max[attack_length] = max
  set attack_units[attack_length] = unitid
  set attack_length = attack_length + 1
endfunction

function SetMeleeGroupAM takes integer unitid returns nothing
  call SetAssaultGroupAM(0,60,unitid)
endfunction

function AttackGroupAddNeutrals takes nothing returns nothing
  local integer i = 0
  loop
    exitwhen i >= merc_number
    call SetMeleeGroupAM(merc_unit[i])
    set i = i + 1
  endloop
  set i = 1
  loop
    exitwhen i > dragon_number
    call SetMeleeGroupAM(dragons[i])
    set i = i + 1
  endloop
endfunction

function FormGroupAM takes integer seconds returns nothing
    local integer index = 0
    local integer count = 0
    local integer unitid = 0
    local integer desire = 0

        call InitAssault()

        loop
            exitwhen index == attack_length

            set unitid = attack_units[index]

            if unitid == HEAD_HUNTER and GetUpgradeLevel(oUPG_ORC_BERSERKER) >= 1 then
              set unitid = BERSERKER
            endif

            set desire = attack_max[index]
            set count  = TownCountDone(unitid)

            if unitid == racial_ghoul then
              set desire = attacking_ghouls
            endif

            call ConversionsAM(desire,unitid)

            if count >= desire then
                call AddAssault(desire,old_id[unitid])    				
            else
				set desire = attack_qty[index]
					
                if count < desire then
                    call AddAssault(desire,old_id[unitid])
                else
                    call AddAssault(count,old_id[unitid])
                endif
            endif

            set index = index + 1
        endloop
        call Sleep(seconds)
endfunction

function DoAttackJobs takes nothing returns nothing
  if major_hero == null or not UnitAlive(major_hero) then
    set major_hero = GetMajorHero()
  endif
  set battle_radius = normal_battle_radius
  set break_attack = false
  //if major_hero != null and UnitAlive(major_hero) then
    if not retreat_controlled then
      call Trace("===Retreat control started===")
      set retreat_controlled = true
      call SetGroupsFlee(false)
      call SetTargetHeroes(false)
      call TQAddJob(2 * sleep_multiplier, RETREAT_CONTROL, 0)
    endif
  //endif
endfunction

function GetDistractionTarget takes unit target returns unit
  local group g = CreateGroup()
  local location unitloc = GetUnitLoc(target)
  local unit farunit = null
  
  call GroupEnumUnitsOfPlayer(g, GetOwningPlayer(target), null)
  set g = SelectUnittype(g, UNIT_TYPE_STRUCTURE, true)
  set g = SelectByLocation(g, unitloc, 3000, false)
  set farunit = GetFarestOfGroup(g, unitloc)
  call RemoveLocation(unitloc)
  set unitloc = null
  call DestroyGroup(g)
  set g = null
  return farunit
endfunction

function DoDistractionAttack takes unit target returns nothing
  local unit d_target = GetDistractionTarget(target)
  if d_target == null then
    return
  endif
  call StartHarass(distraction_group, HARASS_TARGET_LOCATION, false, 15, 0.25, 1, GetUnitX(d_target), GetUnitY(d_target))
  call Sleep(15)
endfunction

function SleepInCombatAM takes nothing returns nothing
    local integer count = 0
    local integer attack_length_counter = 0
	call Trace("SleepInCombat")
    loop
	    exitwhen town_threatened
		exitwhen break_attack
        loop
            exitwhen not CaptainInCombat(true)  // goal is cleared
			exitwhen CaptainIsEmpty()			// duh
            //exitwhen captain_flee and CaptainRetreating()
			//exitwhen isfleeing and CaptainRetreating()
            call Sleep(1 * sleep_multiplier)
            exitwhen town_threat_break and town_threatened
            exitwhen break_attack			
            //set attack_length_counter = attack_length_counter + 1
            //if attack_length_counter > attack_reform_length then
            //  set attack_length_counter = 0
            //  call FormGroupAM(2)
            //endif
        endloop
        //call Sleep(1)
        set count = count + 1
        exitwhen count >= 8
    endloop
	call Trace("exit SleepInCombat")
endfunction

function GetNearAlliedStrength takes unit target returns real
  local integer i = 0
  local real sum = 0
  local location unitloc = GetUnitLoc(target)
  local real dist = DistanceBetweenPoints(unitloc, ally_loc) + 600
  loop
    exitwhen i >= army_num
    if Player(army_owner[i]) != ai_player and IsPlayerAlly(ai_player, Player(army_owner[i])) then
      if DistanceBetweenPoints(unitloc, army_loc[i]) > dist and DistanceBetweenPoints(unitloc, army_future[i]) < 1300 then
        set sum = sum + army_strength[i]
      endif
    endif
    set i = i + 1
  endloop
  call RemoveLocation(unitloc)
  set unitloc = null
  return sum
endfunction

function GetNearerAlliedStrength takes unit target returns real
  local integer i = 0
  local real sum = 0
  local location unitloc = GetUnitLoc(target)
  local real dist = DistanceBetweenPoints(unitloc, ally_loc) + 600
  loop
    exitwhen i >= army_num
    if Player(army_owner[i]) != ai_player and IsPlayerAlly(ai_player, Player(army_owner[i])) then
      if DistanceBetweenPoints(unitloc, army_loc[i]) <= dist and DistanceBetweenPoints(unitloc, army_future[i]) < 1600 then
        set sum = sum + army_strength[i]
      endif
    endif
    set i = i + 1
  endloop
  call RemoveLocation(unitloc)
  set unitloc = null
  return sum
endfunction

function CheckAttackWait takes unit target returns boolean
  local real target_strength = GetLocationStrength(GetUnitX(target), GetUnitY(target), battle_radius)
  local real strength = GetOwnStrength()
  local real nearer_strength = GetNearerAlliedStrength(target)
  if strength + nearer_strength > target_strength * 1.1 then
    return false
  endif
  return GetNearAlliedStrength(target) > 10.0
endfunction

function CommonSleepUntilTargetDeadAM takes unit target, boolean iscreeping, boolean reform returns nothing
  local real dist = 0
  local integer attack_length_counter = 0
  local integer combat_length_counter = 0
  local group g = null
  local location unitloc = null
  
  if race_has_ghouls and race_ghouls_attack then
	set attack_length_counter = 5000  // Force army to regroup to try and get ghouls to go along
  endif
  
    loop
        exitwhen town_threat_break and town_threatened and town_threat[most_threatened_town] >= teleport_low_threat
        exitwhen break_attack
        //exitwhen captain_flee and CaptainRetreating()
		exitwhen isfleeing and CaptainRetreating()
		exitwhen CaptainIsEmpty()
        //exitwhen not UnitAlive(target) and CaptainIsHome()  // A fail safe mechanism if getlocationnoncreepstrength malfunctions: not needed as issue now fixed
		
		if not UnitAlive(target) or (UnitInvis(target) and not IsUnitDetected(target, ai_player)) then
			set g = CreateGroup()
			call GroupEnumUnitsInRange(g,GetUnitX(target), GetUnitY(target),battle_radius,null)
			set g = SelectByAlive(g,true)
			set g = SelectByEnemy(g,ai_player, true)
			if not UnitAlive(target) then
				set g = SelectByVisible(g,ai_player,true)	// to find enemies that ai has noticed
			elseif iscreeping then
				set g = SelectByPlayer(g,GetOwningPlayer(target), true)	// if creeping and unit invisible see if any other creeps targetable
			endif
			set target = FirstOfGroup(g)
			call DestroyGroup(g)
			set g = null
			exitwhen target == null
		//elseif iscreeping then
		//	exitwhen not UnitAlive(target)
		//	exitwhen UnitInvis(target) and not IsUnitDetected(target,ai_player)
		endif
		
		//if not iscreeping then
		//	exitwhen GetLocationNonCreepStrength(unitx, unity, battle_radius) <= 0 and not UnitAlive(target) and GetLocationEnemyStructures(unitx, unity, battle_radius) <= 0 // enemies are dead and target dead
		//else
			//call Trace("Units, Creeps: " + Int2Str(GetLocationNonCreepStrength(unitx, unity, battle_radius)) + "," + Int2Str(GetLocationCreepStrength(unitx, unity, 500)))
		//	exitwhen GetLocationNonCreepStrength(unitx, unity, battle_radius) <= 0 and not UnitAlive(target) and GetLocationCreepStrength(unitx, unity, 500) <= 0			
		//endif
		
		set unitloc = GetUnitLoc(target)
		set dist = DistanceBetweenPoints(ally_loc, unitloc)
        if c_ally_total > 0 and dist > 1300 and dist < 2500 then
          if CheckAttackWait(target) then
            call AttackMoveXY(R2I(GetLocationX(ally_loc)), R2I(GetLocationY(ally_loc)))
          else
            call AttackMoveKill(target)
          endif
        else
          call AttackMoveKill(target)
        endif
		call RemoveLocation(unitloc)
		set unitloc = null

        call Sleep(2 * sleep_multiplier)
		call CreateDebugTag("Reform until target dead", 10, target, 3.00, 1.50)
		//set attack_length_counter = attack_length_counter + 1
        //if reform and attack_length_counter > attack_reform_length then
		//  if CaptainInCombat(true) then
		//	set attack_length_counter = attack_length_counter - 2		  
		//  else
		//	set attack_length_counter = 0
		//	call FormGroupAM(2)
		//  endif
        //endif
		if reform and CaptainInCombat(true) then
			set combat_length_counter = combat_length_counter + 1
		elseif reform then
			set attack_length_counter = attack_length_counter + 1
			set combat_length_counter = 0
		endif
		
		if reform and CaptainInCombat(true) and combat_length_counter > attack_reform_length * 3 then
			set combat_length_counter = 0
			call FormGroupAM(2)
		elseif reform and not CaptainInCombat(true) and attack_length_counter > attack_reform_length then
			set attack_length_counter = 0
			set combat_length_counter = 0
			call FormGroupAM(2)	
		endif
    endloop
endfunction

function ReformUntilTargetDeadAM takes unit target, boolean iscreeping returns nothing
	call CommonSleepUntilTargetDeadAM(target,iscreeping,true)
endfunction

function SleepUntilTargetDeadAM takes unit target, boolean iscreeping returns nothing
	call CreateDebugTag("Sleep until target dead", 10, target, 3.00, 1.50)
	call CommonSleepUntilTargetDeadAM(target,iscreeping,false)
endfunction

function SleepUntilAtGoalAM takes nothing returns nothing
    local integer lcount = 0
    loop
        exitwhen town_threatened and town_threat[most_threatened_town] >= teleport_low_threat
        set lcount = lcount + 1
	      call Sleep(sleep_multiplier)
          exitwhen break_attack
	      exitwhen CaptainRetreating() and isfleeing
		  if lcount >= 6 then
          exitwhen CaptainAtGoal()        // reached goal
          exitwhen CaptainIsHome()        // failed to path and returned home
	      endif
        exitwhen CaptainIsEmpty()       // all units died
		//call Trace("Sleeping until target reached")		
        call Sleep(2 * sleep_multiplier)
    endloop
endfunction

function AttackMoveKillAAM takes unit target returns nothing
    if target == null or not UnitAlive(target) then
        call Trace("Bad target passed to AttackMoveKillAAM")
        call Sleep(3 * sleep_multiplier)
        return
    endif
    set attack_running = true
    call DoAttackJobs()
    if distraction_group != 0 and GetOwningPlayer(target) != Player(PLAYER_NEUTRAL_AGGRESSIVE) and GetRandomInt(1,10) < 5 then
      if GetHarassGroupStrength(distraction_group) < GetOwnStrength() / 3 then
        call DoDistractionAttack(target)
      endif
    endif
    call AttackMoveKill(target)
    call ReformUntilTargetDeadAM(target, false)
    call Chat(C_Done)
    call SleepInCombatAM()
	call Trace("===Attack Fully Finished===")
    set attack_running = false
    call Sleep(2.5)
endfunction

function AttackMoveKillCreep takes unit target returns nothing
    if target == null or not UnitAlive(target) then
        call Trace("Bad target passed to AttackMoveKillCreep")
        call Sleep(3 * sleep_multiplier)
        return
    endif
    set attack_running = true
	set break_attack = false	
	if not retreat_controlled then
      call Trace("===Retreat control started===")
      set retreat_controlled = true
      call SetGroupsFlee(false)
      call SetTargetHeroes(false)
      call TQAddJob(2 * sleep_multiplier, RETREAT_CONTROL, 0)
    endif
    call AttackMoveKill(target)
    call ReformUntilTargetDeadAM(target, true)
    call Chat(C_Done)
    call SleepInCombatAM()
	call Trace("===Attack Fully Finished===")
    set attack_running = false
endfunction

function AttackMoveKillXYAAM takes integer x, integer y returns nothing
    set attack_running = true
    call DoAttackJobs()
	
    if zep_next_wave then
        call LoadZepWave(x,y)
        set zep_next_wave = false
    endif	
	
    call AttackMoveXY(x,y)
    call SleepUntilAtGoalAM()
    call SleepInCombatAM()
    set attack_running = false
endfunction

function AttackMoveTowerRush takes nothing returns nothing
	local integer attack_length_counter = 0
	set attack_running = true	
	loop
		exitwhen not towerrush
		exitwhen town_threatened and town_threat[most_threatened_town] >= teleport_low_threat
		exitwhen break_attack
		//exitwhen CaptainIsEmpty()       // all units died
		if first_tower_point_x == 0 and first_tower_point_y == 0 then
		    call CreateDebugTag("Reform protect peon", 10, builder[1], 2.00, 1.50)
			call SetAllianceTarget(builder[1])		
  			call AttackMoveKill(builder[1])
		else
			//call SetCaptainHome(BOTH_CAPTAINS,R2I(((enemy_point_x - first_tower_point_x)/ 4) + first_tower_point_x),R2I(((enemy_point_y - first_tower_point_y)/ 4) + first_tower_point_y))
			if towers_built < 3 then
				call AttackMoveXY(R2I(((enemy_point_x - first_tower_point_x)/ 4) + first_tower_point_x), R2I(((enemy_point_y - first_tower_point_y)/ 4) + first_tower_point_y))
			elseif towers_built < 6 then
				call AttackMoveXY(R2I(((enemy_point_x - first_tower_point_x)/ 2) + first_tower_point_x), R2I(((enemy_point_y - first_tower_point_y)/ 4) + first_tower_point_y))			
			elseif towers_built <= 9 then
				call AttackMoveXY(R2I(enemy_point_x), R2I(enemy_point_y))
			endif
		endif
		call Sleep(2*sleep_multiplier)
		set attack_length_counter = attack_length_counter + 1
        if attack_length_counter > attack_reform_length then
			set attack_length_counter = 0
			call FormGroupAM(2)
        endif		
	endloop
	call SleepInCombatAM()
	set attack_running = false
endfunction

function GetIntervalCreep takes integer lower, integer upper, integer str, integer anti_air_strength, boolean allow_air, integer sd returns unit
    local unit creep = null
    local integer creep_strength = 0
    local integer middle = (lower + upper) / 2

    if sd < 0 then
      return null
    endif
    set creep = GetCreepCamp(1, middle, allow_air)
    if creep == null then
        return GetIntervalCreep(middle, upper, str, anti_air_strength, allow_air, sd - 1)
    else
      set creep_strength = GetCreepCampStrength(creep) + 1
      if balancing then
        //call Trace("Creep strength: " + Int2Str(creep_strength))
        call PingMinimap(GetUnitX(creep), GetUnitY(creep), 1)
      endif
      if creep_strength < str then
        if air_strength <= anti_air_strength then
          return creep
        else
          return GetIntervalCreep(lower, upper, str, anti_air_strength, false, sd)
        endif
      else
        return GetIntervalCreep(lower, middle, str, anti_air_strength, allow_air, sd - 1)
      endif
    endif
endfunction

function GetFittingCreep takes integer str returns unit
    local integer anti_air_strength = R2I(GetPlayerAntiAirStrength(ai_player))
    local unit creep = null
    local integer creep_strength = 0
    local boolean allow_air = false      //anti_air_strength > 25
    local integer lvl = str
    
    set air_strength = GetLocationCreepAirStrength(GetUnitX(creep), GetUnitY(creep), creep_camp_radius)
	set allow_air = air_strength <= anti_air_strength
    set creep = GetCreepCamp(1, lvl, allow_air)
    if creep == null then 
		return null
	endif

	//call Trace("Our strength: " + Int2Str(str))
	
    set creep_strength = GetCreepCampStrength(creep)
    if creep_strength < str and air_strength <= anti_air_strength then
    	//call Trace("Creep match")
		call Trace("Creeping strength: " + Int2Str(creep_strength))		
      set air_strength = creep_strength
	return creep
    else
      //call Trace("No Creep ")
      return GetIntervalCreep(1,100,str, anti_air_strength, allow_air, camp_scan_depth)
    endif

	return creep



endfunction

function CreepAttack takes integer str returns nothing
    local unit target = GetFittingCreep(str)



    if target == null then
        call Trace("No creep target found")
      call Sleep(20)
      return
    endif
    call Chat(C_Creep)
    if air_strength > 15 then
      call SetAllianceTarget(target)
    endif
	
    call FormGroupAM(3)
	call AttackMoveKillCreep(target)

endfunction

function QueueAttackMoveXY takes integer x, integer y returns nothing
  set attack_running = true
  call DoAttackJobs()
  loop
    call Sleep(sleep_multiplier)
    call AttackMoveXY(x,y)
    exitwhen break_attack
    exitwhen CaptainRetreating()
    exitwhen CaptainAtGoal()
    call Sleep(sleep_multiplier)
  endloop
  call SleepInCombatAM()
  if CaptainAtGoal() then
    call QueueGetNextCommand()
  endif
  set attack_running = false
endfunction

function GetRangePenalty takes unit target returns integer
  if major_hero == null then
	return 0
  elseif UnitAlive(target) == false then
	return 0
  else
	return R2I(DistanceBetweenUnits(major_hero, target)/1400)
  endif
endfunction

function GetWeakestEnemy takes nothing returns player
    local integer i = 0
    local integer pmin = 0
    local integer minstr = 1000
    local integer cstr = 0
    loop
      exitwhen i == 12
      if IsPlayerEnemy(Player(i),ai_player) and not IsPlayerObserver(Player(i)) then
        set cstr = GetUnexactPlayerStrength(Player(i))
        if cstr < minstr and GetBuilding(Player(i)) != null then
          set pmin = i
          set minstr = cstr
        endif
      endif
    set i = i + 1
    endloop
    return Player(pmin)
endfunction

function GetStrongestEnemy takes nothing returns player
    local integer i = 0
    local integer pmax = 0
    local integer maxstr = 0
    local integer cstr = 0
    loop
      exitwhen i == 12
      if IsPlayerEnemy(Player(i),ai_player) and not IsPlayerObserver(Player(i)) then
        set cstr = GetUnexactPlayerStrength(Player(i))
        if cstr > maxstr then
          set pmax = i
          set maxstr = cstr
        endif
      endif
    set i = i + 1
    endloop
    return Player(pmax)
endfunction

function GetWeakAndNearEnemy takes nothing returns player
    local integer i = 0
    local integer pmin = -1
    local integer minstr = 10000
    local integer cstr = 0
    local unit cbuilding = null
    loop
      exitwhen i == 12
      if IsPlayerEnemy(Player(i),ai_player) and not IsPlayerObserver(Player(i)) then
        set cbuilding = GetBuilding(Player(i))
        if cbuilding != null and UnitAlive(cbuilding) then
          set cstr = GetUnexactPlayerStrength(Player(i)) + GetRangePenalty(cbuilding)
          if cstr < minstr then
            set pmin = i
            set minstr = cstr
          endif
        endif
      endif
      set i = i + 1
    endloop
    if pmin == -1 then
      call Trace("Debug: GetWeakAndNearEnemy failed!")
      set pmin = 0
    endif
    return Player(pmin)
endfunction

function GetNearestEnemy takes nothing returns player
local integer i = 0
local real dist = 0
local real mindistance = 1000000
local player nearplayer = null

loop
    exitwhen i >= 12
    if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING and IsPlayerEnemy(Player(i), ai_player) then
	    set dist = DistanceBetweenPoints_kd(home_location, GetPlayerStartLocationLoc(Player(i)))
		if dist < mindistance then
			set mindistance = dist
			set nearplayer = Player(i)
		endif
    endif
    set i = i + 1
endloop
return nearplayer
endfunction

function GetSecondNearestEnemy takes nothing returns player
    local integer i = 0
    local integer pmin = -1
    local integer spmin = -1
    local integer minstr = 10000
    local integer sminstr = 10000
    local integer cstr = 0
    local unit cbuilding = null
    loop
      exitwhen i == 12
      if IsPlayerEnemy(Player(i),ai_player) and not IsPlayerObserver(Player(i)) then
        set cbuilding = GetBuilding(Player(i))
        if cbuilding != null and UnitAlive(cbuilding) then
          set cstr = GetRangePenalty(cbuilding)
          if cstr < minstr then
            set spmin = pmin
            set pmin = i
            set sminstr = minstr
            set minstr = cstr
          elseif cstr < sminstr then
            set spmin = i
            set sminstr = cstr
          endif
        endif
      endif
      set i = i + 1
    endloop
    if spmin == -1 then
      call Trace("Debug: GetSecondNearestEnemy failed!")
      set spmin = 0
    endif
    return Player(spmin)
endfunction

function GetFFAEnemy takes nothing returns player
  if GetRandomInt(1, 3) == 1 then
    return GetSecondNearestEnemy()
  else
    return GetNearestEnemy()
  endif
endfunction

function GetTowerFactor takes unit target returns integer
  local integer tstrength = GetLocationTowerStrength(GetUnitX(target), GetUnitY(target), ver_tower_check_radius)
  if h_siege then
    return tstrength
  else
    return 4*tstrength
  endif
endfunction

function GetRace takes player p returns integer
  return player_race[GetPlayerId(p)]
endfunction

function GetRaceAggression takes unit target returns integer
  return race_aggression[(GetRace(GetOwningPlayer(target))-1) * tiernum + tier - 1]
endfunction

function GetTargetStrength takes unit target returns integer
  local integer str = GetUnexactPlayerStrength(GetOwningPlayer(target))
  if str < 100 then
    set str = Min(str + GetRangePenalty(target), 100)
  endif
  return str
endfunction

function GetEnemyAllyStrength takes player tp returns integer
  local integer i = 0
  local integer ally_sum = 0
  local integer enemy_sum = 0
  loop
    exitwhen i >= 12
    if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING and Player(i) != ai_player and Player(i) != tp then
      if IsPlayerAlly(Player(i), ai_player) then
        set ally_sum = ally_sum + R2I(GetPlayerStrength(Player(i)))
      elseif IsPlayerAlly(Player(i), tp) then
        set enemy_sum = enemy_sum + GetUnexactPlayerStrength(Player(i))
      endif
    endif
    set i = i + 1
  endloop
  return (enemy_sum - ally_sum)/2
endfunction

function IsTargetGood takes unit target, integer attacker_bonus returns boolean
  set added_target_aggression = attacker_bonus
  set added_racial_aggression = GetRaceAggression(target)
  if target != null then
	return GetTargetStrength(target) + GetEnemyAllyStrength(GetOwningPlayer(target)) + GetTowerFactor(target) <= own_strength + attacking_aggression + added_aggression + added_racial_aggression + attacker_bonus
  else
	return false
  endif
endfunction

function ChooseEnemyExpansionTarget takes nothing returns unit
    local unit target = null
    set target = GetEnemyExpansion()
    if target != null then
      if IsTargetGood(target, expansion_target_bonus) then
	  	call Trace("Hardcoded enemy expansion target chosen")
        return target
      else
        return null
      endif
    else
      return null
    endif
endfunction

function ChooseEnemyBaseTarget takes nothing returns unit
    local integer c = 0
    local unit target = null
    call StartGetEnemyBase()
    loop
      exitwhen not WaitGetEnemyBase()
      if c > 4 then
        return null
      endif
      call Sleep(1)
      set c = c + 1
    endloop
    set target = GetEnemyBase()
    if target != null then
      if IsTargetGood(target, comp_chosen_target_bonus) then
	    call Trace("Hardcoded Enemy Base Target chosen")
        return target
      else
        return null
      endif
    else
      return null
    endif
endfunction

function ChooseAnyEnemyTarget takes nothing returns unit
    local unit target = null
    local player target_enemy = null
	local group g = CreateGroup()
	local location enemy_base = null
	
    if attacking_strategy == 1 or attacking_strategy == 3 then
      set target_enemy = GetWeakestEnemy()
	  //call Trace("Chooing Weakest Enemy")
    elseif attacking_strategy == 2 then
      set target_enemy = GetStrongestEnemy()
	  //call Trace("Choosing Strongest Enemy")
    elseif attacking_strategy == 5 then
      set target_enemy = GetFFAEnemy()
	  //call Trace("Choosing FFA Enemy")	  
    else
      set target_enemy = GetWeakAndNearEnemy()
	  //call Trace("Choosing weakest closest Enemy")
    endif
	call GroupEnumUnitsOfPlayer(g, target_enemy, null)
	set enemy_base = GetPlayerStartLocationLoc(target_enemy)
	set g = SelectUnittype(g, UNIT_TYPE_TOWNHALL, true)
	set g = SelectByLocation(g, enemy_base, 1000, false)
	set g = SelectByAlive(g, true)
	set target = FirstOfGroup(g)
	if target == null then
		set target = GetBuilding(target_enemy)
	endif
	call DestroyGroup(g)
	set g = null
	call RemoveLocation(enemy_base)
	set enemy_base = null
	set target_enemy = null
    if attacking_strategy == 3 then
      set alli_target = GetBuilding(GetStrongestEnemy())
      return target
    elseif IsTargetGood(target, 0) then
	  call Trace("Enemy Advanced Target Chosen")
      set alli_target = target
      return target
    else
      return null
    endif
endfunction

function ChooseAttackTarget takes nothing returns unit
    local unit target = null
	//call DisplayToAll("Choosing attack target")
    if GetRandomReal(0.0,1.0) <= comp_chosen_target_rate then
       set target = null
	else
		set target = ChooseEnemyExpansionTarget()
		if target == null then
			//call DisplayToAll("Attack enemy Base")
			set target = ChooseEnemyBaseTarget()
		endif
		set alli_target = target	
    endif	

    if target == null then
      set target = ChooseAnyEnemyTarget()
    endif
    return target
endfunction

function SetChatVarsAttack takes unit u returns nothing
  local player p = GetOwningPlayer(u)
  call SetChatVar("TargetRace", race_name[player_race[GetPlayerId(p)]])
  call SetChatVar("TargetColor", ColorText(p))
  call SetChatVarR("TargetStrength", GetPlayerStrength(p))
endfunction

function Militia_Expansion takes integer m returns nothing
     local group g = CreateGroup()
	 local group tempg = CreateGroup()
     local unit u = null
     local real x = 0
     local real y = 0
     local unit efoe = GetExpFoe()
     local integer t = 0

	 set break_attack = false  // to persuade attack system to hopefully not exit early and do the reforming behaviour
     set militia_check_enabled = false
     //call BuildExpa( TownCount(racial_expansion)+1, racial_expansion, farm_prio + 50 )
     call DisplayToAlliesChat(militia_expansion_chat)
     call GroupEnumUnitsOfPlayer(g, ai_player, null)
     set g = SelectNumberOfId(g, 100, old_id[racial_peon] )
	 set g = SelectByAlive(g, true)
	 set tempg = g
     set g = GetNearestSubGroupOfGroup(tempg, home_location, m)
	 call DestroyGroup(tempg)
	 set tempg = null
     set expansion_peon = FirstOfGroup(g)
     call AddAbilityToGroup(CopyGroup(g), race_militia_ability)
     call GroupImmediateOrder(g, "militia" )
     call RemoveInjuries()
     call FormGroupAM(4)
     loop
       exitwhen AreUnitsOfType(g, race_militia_id)
       exitwhen t > 4
       call Sleep(2)
       set t = t + 1
     endloop
	 //call AddAssault(m, old_id[racial_militia])   // Lil problem with adding assaults. For some reasons
     //call AttackMoveKill(efoe)
     set x = GetUnitX(current_expansion)
     set y = GetUnitY(current_expansion)
     call GroupPointOrder(g, "attack", x, y )
     set town_threat_break = false
     //set captain_flee = false
	 //call SetCaptainHome(ATTACK_CAPTAIN, GetUnitX(efoe), GetUnitY(efoe)) //
     //call AttackMoveKillCreep(efoe)
	set attack_running = true
	//if not retreat_controlled then
    //  call Trace("===Retreat control started===")
    //  set retreat_controlled = true
    //  call SetGroupsFlee(false)
    //  call SetTargetHeroes(false)
    //  call TQAddJob(2 * sleep_multiplier, RETREAT_CONTROL, 0)
    //endif
    call AttackMoveKill(efoe)
    call SleepUntilTargetDeadAM(efoe, true)
    call Chat(C_Done)
    call SleepInCombatAM()
	call Trace("===Attack Fully Finished===")
	set x = GetLocationX(home_location)
    set y = GetLocationY(home_location)
	call GroupPointOrder(g, "move", x, y )
    call GroupImmediateOrder(g, "militiaoff" )	
    set attack_running = false
	 //call SetCaptainHome(ATTACK_CAPTAIN, GetLocationX(home_location), GetLocationY(home_location))
     set militia_check_enabled = true
     set town_threat_break = true
     //set captain_flee = true
     //set militia = false
     set take_exp = false
endfunction

function SleepUntilTownDefended takes integer ai_strength returns nothing
	local integer defense_length_counter = 0

	set own_strength = ai_strength
	call Trace("==Sleep Defend Town==" )
	loop
		exitwhen not town_threatened
		exitwhen player_defeated
		if LinearInterpolation(ver_low_aggression,ver_high_aggression,ver_flee_multiple1,ver_flee_multiple2,attacking_aggression)*own_strength > army_strength[town_threat_army[most_threatened_town]] then
			if town_threat[most_threatened_town] >= teleport_low_threat then
				if not teleporting then
					call AttackMoveXY(R2I(GetLocationX(town_loc[most_threatened_town])), R2I(GetLocationY(town_loc[most_threatened_town])))
				endif
			endif
			call SetCaptainHome(DEFENSE_CAPTAIN, GetLocationX(town_loc[most_threatened_town]), GetLocationY(town_loc[most_threatened_town]))		
		else
			//call Trace("Town threatened - retreat" )
			//if town_threat[most_threatened_town] >= teleport_low_threat then
				if not teleporting then
					call AttackMoveXY(R2I(GetLocationX(home_location)), R2I(GetLocationY(home_location)))
				endif
				set defense_length_counter = defense_length_counter + 1
				if defense_length_counter > attack_reform_length then
					set defense_length_counter = 0
					call FormGroupAM(2)
				endif
			//endif
			call SetCaptainHome(DEFENSE_CAPTAIN, GetLocationX(home_location), GetLocationY(home_location))
		    //call ClearCaptainTargets() 
	        //call CaptainGoHome()		
		endif
		call Sleep(2*sleep_multiplier)
		set own_strength = GetOwnStrength()
	endloop
	call Trace("==exit Sleep Defend Town==")
	call SetCaptainHome(DEFENSE_CAPTAIN, GetLocationX(home_location), GetLocationY(home_location))	
endfunction

function SetLeadAlly takes nothing returns nothing
	local integer i = 0
	local boolean checkdone = false
	loop
	   exitwhen i > 11 or checkdone
	   if GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(Player(i)) == MAP_CONTROL_COMPUTER and Player(i) != ai_player and IsPlayerAlly(ai_player, Player(i)) then
		  set leadally = false
		  set checkdone = true
		  set i = i + 1
	   elseif Player(i) == ai_player then
		  set leadally = true
		  set checkdone = true
		  set i = i + 1
	   else
	   	   set i = i + 1
	   endif
	endloop
endfunction
function SingleMeleeAttackAM takes boolean needs_exp, boolean has_siege, integer ai_strength returns nothing
    local unit hall = null
    local unit mega = null
    local unit creep = null
    local unit common = null



	if town_threatened then
		set break_attack = false
		set isfleeing = false
		call FormGroupAM(1)
		call SleepUntilTownDefended(ai_strength)
		call SleepInCombatAM()
    endif

    call Trace("===Single Melee Attack===" )
	call Trace("AI strength: " + Int2Str(ai_strength))	
	
    set h_siege = has_siege
    set own_strength = ai_strength

    call set_aggression()


    // Commander Control Attacks
    //
    if no_attack then
      call Trace("No Attack is on" )
      call Sleep(4 * sleep_multiplier)
      call ClearCaptainTargets()
      return
    endif

    if queue_running then

      if queue_attack_p then
        call Trace("Attacking point "+Int2Str(queue_t_x)+","+Int2Str(queue_t_y) )
        call FormGroupAM(3)
        call QueueAttackMoveXY(queue_t_x, queue_t_y)
        call Trace("Point reached or aborted" )
        return

      elseif queue_attack_u then
        if queue_t_u == null then
          call Trace("No unit targeted, queue stopped" )
          set queue_running = false
        elseif not UnitAlive(queue_t_u) then
          call Trace("Unit is dead, next command" )
          call QueueGetNextCommand()
        else
          call Trace("Attacking unit" )
          call FormGroupAM(3)
          call AttackMoveKillAAM(queue_t_u)
          call Trace("Attack complete" )
          return
        endif
      endif

    endif

    if attack_player then
      call Trace("Attacking player" )
      set hall = GetBuilding(Player(attack_target_p))
      if hall == null then
        call Trace("No target found" )
        set attack_player = false
        return
      endif
      call FormGroupAM(3)
      call AttackMoveKillAAM(hall)
      call Trace("Attack complete" )
      return
    endif

    if attack_point then
      call Trace("Attacking point "+Int2Str(attack_target_x)+","+Int2Str(attack_target_y) )
      call FormGroupAM(3)
      call AttackMoveKillXYAAM(attack_target_x, attack_target_y)
      call Trace("Attack complete" )
      return
    endif

    if attack_unit then
      if target_unit == null then
        call Trace("No unit targeted" )
        set attack_unit = false
      elseif not UnitAlive(target_unit) then
        call Trace("Unit is dead" )
        set attack_unit = false
      else
        call Trace("Attacking unit" )
        call FormGroupAM(3)
        call AttackMoveKillAAM(target_unit)
        call Trace("Attack complete" )
        return
      endif
    endif

	if not creeping_only then	// Do the normal attack sequence
	
   // militia expansion
   //
	if militia_expanding then 
		call Trace("A Militia Expansion")
		call Militia_Expansion(6)
    	set militia_expanding = false
		return
	endif

   // tower rush attack
   //
	if towerrush then
	        call Trace("A Tower Rush Attack")
            call FormGroupAM(3)
			call AttackMoveTowerRush()
			return
	endif

    // ancient expansion attack
    //
       if ancient_expanding then
		if ancient_exp_state == 2 or ancient_exp_state == 3 then
            call Trace("An Ancient Expansion Attack")
            //call FormGroupAM(3)
			//call AddAssault(1, old_id[racial_hall[1]])
			call SetCaptainHome(BOTH_CAPTAINS,GetUnitX(ancient_exp_unit),GetUnitY(ancient_exp_unit))
			//call AttackMoveKillXYAAM(R2I(GetUnitX(ancient_exp_unit)), R2I(GetUnitY(ancient_exp_unit)))
            return
            elseif ancient_exp_state == 4 then
				set ancient_attack_running = true
                call Trace("An Ancient Expansion - Final stage")
                call FormGroupAM(3)
				//call AddAssault(1, old_id[racial_hall[1]])
				call SetCaptainHome(BOTH_CAPTAINS,GetUnitX(ancient_exp_unit),GetUnitY(ancient_exp_unit))
				//if DistanceBetweenUnits(ancient_exp_unit, GetExpFoe()) <= 500 then
					call AttackMoveKillCreep(GetExpFoe())
				//else
				//	call AttackMoveKillXYAAM(R2I(GetUnitX(ancient_exp_unit)), R2I(GetUnitY(ancient_exp_unit)))
				//endif
				set ancient_attack_running = false
                return
            endif
       endif
	   
	   
    // defend expansion from other expansion
    //

    if double_expansion_target != null and IsTargetGood(double_expansion_target, 10) then
      call Trace("Double Expansion Attack")
	  call SetAllianceTarget(double_expansion_target)
	  call FormGroupAM(3)
      call AttackMoveKillAAM(double_expansion_target)
      if not UnitAlive(double_expansion_target) then
        set double_expansion_target = null
      endif
      return
    endif
    
    if not (no_creep_attack or ai_no_creep) then

      // take expansions as needed
      //
      if needs_exp then
        if first_expansion_chosen and (current_expansion == null or CheckExpansionTaken(current_expansion)) then
          call ChooseExpansion()
          if current_expansion == null then
            return
          endif
        endif
        set creep = GetExpFoe()
        if creep != null and UnitAlive(creep) then
          call Trace("Creep the Expansion")
          set attacking_expansion = true
          set battle_radius = creep_battle_radius
			call SetAllianceTarget(creep)
		  call Chat(C_Expansion)
          call FormGroupAM(3)
          call AttackMoveKillCreep(creep)
	        if GetExpFoe() == null then
            set take_exp = false
	        endif
			call Sleep(10)
	        set attacking_expansion = false
          return
        endif
      endif

    endif

    // coordinate with allies
    //
	if c_ally_total > 0 then
	call SetLeadAlly()
    if MeleeDifficulty() != MELEE_NEWBIE then
      set common = GetAllianceTarget()
      if common != null then
	    call Trace("Attack Alliance Target")
        call Chat(C_Ally)
        call FormGroupAM(3)
        call AttackMoveKillAAM(common)
        call Trace("Attack complete")
        call SetAllianceTarget(null)
        return
      endif
    endif
	endif

    if not no_player_attack then

      // all-out attack if the player is weak
      //
	if MeleeDifficulty() != MELEE_NEWBIE then
      set mega = GetMegaTarget()
      if mega != null and UnitAlive(mega) then
        call Trace("Mega Attack Target")
			call SetAllianceTarget(mega)		
        call SetChatVarsAttack(mega)
        call Chat(C_Mega)
        call Chat(C_Megatarget)
        call FormGroupAM(3)
        call AttackMoveKillAAM(mega)
        return
      endif
	endif
	  
      if GetHeroXP(hero_unit[1]) < GetRandomInt(50,150) or GetHeroXP(hero_unit[1]) > GetRandomInt(300,850) or GetHeroXP(hero_unit[2]) > 450 or FoodUsed() > GetRandomInt(40,60) then
  
        set hall = ChooseAttackTarget()
        if hall != null and UnitAlive(hall) then
          call SetChatVarsAttack(hall)
          call Chat(C_Attack)
            call SetAllianceTarget(alli_target)
            //set alli_target = null
          call FormGroupAM(3)
          call AttackMoveKillAAM(hall)
          return
        endif

      endif
    endif

	endif // if not creep only
	
    if no_creep_attack or ai_no_creep then
      call Trace("no creeping" )
      call Sleep(4 * sleep_multiplier)
      return
    endif

    // nothing better to do, so kill a creep camp
    //
    set battle_radius = creep_battle_radius
    call Trace("Just gonna be creeping")
    call CreepAttack(own_strength)

endfunction


function SkillArraysAM takes nothing returns integer
    local integer level = GetHeroLevelAI()
    local integer hn = GetHeroNumber(GetHeroId())

    if level > max_hero_level then
        set max_hero_level = level
    endif

    return skills[(hn - 1) * HERO_LEVEL_NUMBER + level]
endfunction

function StoreSkills takes integer ta returns nothing
  local integer i = 1
  loop
    exitwhen i > HERO_LEVEL_NUMBER
    set skills[(ta - 1) * HERO_LEVEL_NUMBER + i] = tempskills[i]
    set i = i + 1
  endloop
endfunction

function LoadSkillsExt takes integer sa returns nothing
  local integer i = 1
  loop
    exitwhen i > HERO_LEVEL_NUMBER
    set tempskills[i] = allskills[sa + i]
    set i = i + 1
  endloop
endfunction

function LoadSkills takes integer sa, integer hn, integer ta returns nothing
  local integer perc = GetRandomInt(0,major_hero_skill_value+minor_hero_skill_value+rare_hero_skill_value)
  local integer sk = 0	// is which of the 3 skill lines is chosen
  
	if perc <= rare_hero_skill_value then
		set sk = HERO_SKILL_RARE
	elseif perc <= minor_hero_skill_value+rare_hero_skill_value then
		set sk = HERO_SKILL_MINOR
	endif
  set hero_skills[sa] = sk // set global variable so we can use the fact of knowning what skill was chosen in AMAI
  call LoadSkillsExt((sa-1)*3*HERO_LEVEL_NUMBER + sk*HERO_LEVEL_NUMBER + (hn-1)*9*HERO_LEVEL_NUMBER)
  call StoreSkills(ta)
endfunction

function HeroHealingBugFix takes nothing returns nothing
  local integer i = 1
    loop
      exitwhen i > 3
      if GetUnitState(hero_unit[i], UNIT_STATE_LIFE) == GetUnitState(hero_unit[i], UNIT_STATE_MAX_LIFE) and IsUnitInGroup(hero_unit[i], unit_healing) then
		call Trace("HERO HEALING BUG FIX WAS RUN")
		call RecycleGuardPosition(hero_unit[i])
		call GroupRemoveUnit(unit_healing, hero_unit[i])
      endif
      set i = i + 1
    endloop
endfunction

function AwaitMeleeHeroesAM takes nothing returns boolean
  local integer i = 1
  local boolean hero_available = false
  
  loop
    //call HeroHealingBugFix()
    loop
      exitwhen i > 3
      if GetUnitCountDone(old_id[hero[i]]) > 0 then
		if not IsUnitInGroup(hero_unit[i], unit_healing) then
			return false
		endif
		set hero_available = true
      endif
      set i = i + 1
    endloop
    set i = 1
    exitwhen player_defeated or hero_available
    call Sleep(2 * sleep_multiplier)
	call Trace("AwaitMeleeHeroesAM: No Heroes Ready")
  endloop
  
  return true
endfunction

function GetArmyHealthState takes nothing returns real
  local group g = CreateGroup()
  local unit u = null
  local real health_sum = 0.0
  local integer count = 0
  local real uhs = 0.0
  local integer hid = 0
  
  call GroupClear(healer_group)
  call GroupClear(urgent_healing_group)
  call GroupClear(medium_healing_group)
  call GroupClear(small_healing_group)
  set urgent_healing_count = 0
  set medium_healing_count = 0
  set small_healing_count = 0
  set ward_cast = false
  call GroupEnumUnitsOfPlayer(g, ai_player, null)
  loop
    set u = FirstOfGroup(g)
    exitwhen u == null
    if GetUnitTypeId(u) == 'ohwd' then
      set ward_cast = true
    endif
    if UnitAlive(u) and not (IsUnitHidden(u) or IsUnitType(u, UNIT_TYPE_PEON) or IsUnitType(u, UNIT_TYPE_STRUCTURE) or IsUnitType(u, UNIT_TYPE_SUMMONED) or IsUnitType(u, UNIT_TYPE_MECHANICAL) or IsUnitIllusion(u)) then
      set uhs = GetUnitState(u, UNIT_STATE_LIFE) / GetUnitState(u, UNIT_STATE_MAX_LIFE)
      set health_sum = health_sum + uhs
      set count = count + 1
      set hid = GetHealerId(GetUnitTypeId(u))
      if hid != -1 and GetUnitState(u, UNIT_STATE_MANA) >= (healer_mana_cost[hid] * 2) / 3 and ((healer_upg_id[hid] == 0) or (GetUpgradeLevel(healer_upg_id[hid]) >= healer_upg_level[hid])) then
        call GroupAddUnit(healer_group, u)
      endif
      if uhs < 0.5 then
        call GroupAddUnit(urgent_healing_group, u)
        set urgent_healing_count = urgent_healing_count + 1
      elseif uhs < 0.75 then
        call GroupAddUnit(medium_healing_group, u)
        set medium_healing_count = medium_healing_count + 1
      elseif uhs < 1 then
        call GroupAddUnit(small_healing_group, u)
        set small_healing_count = small_healing_count + 1
      endif
    endif
    call GroupRemoveUnit(g,u)
  endloop
  call DestroyGroup(g)
  set g = null
  set fountain_available = race_use_fountain and neutral_available[NEUTRAL_HEALING_FOUNTAIN] and nearest_neutral[NEUTRAL_HEALING_FOUNTAIN] != null and (not neutral_guarded[NEUTRAL_HEALING_FOUNTAIN] or (neutral_night_buy[NEUTRAL_HEALING_FOUNTAIN] and GetFloatGameState(GAME_STATE_TIME_OF_DAY) >= 18))
  if count == 0 then
    return 1
  endif
  return health_sum / count
endfunction


function ApplyMassHealingItem takes unit u, item mh_i returns nothing
  local unit hu = null
  local real time = 0
  
  set hu = FirstOfGroup(urgent_healing_group)
  if hu == null then
	set hu = FirstOfGroup(medium_healing_group)
	if hu == null then
		set hu = FirstOfGroup(small_healing_group)
	endif
  endif
  
  call RemoveGuardPosition(u)
  call GroupPointOrder(urgent_healing_group, "move", GetUnitX(u), GetUnitY(u))
  call GroupPointOrder(medium_healing_group, "move", GetUnitX(u), GetUnitY(u))
  call GroupPointOrder(small_healing_group, "move", GetUnitX(u), GetUnitY(u))
  call IssuePointOrder(u, "move", GetUnitX(hu), GetUnitY(hu))
  set time = RMax((GetTimeToReachUnit(u, hu) + GetTimeToReachUnit(hu, u))/2,2)    // Average of times. Not accurate as is longer than it should be to definatly make sure units surround the hero
  call Sleep(time)
  call UnitUseItem(u, mh_i)
  call RecycleGuardPosition(u)  
endfunction

function ApplyHealingItem takes unit u, item heal_item returns nothing

	local unit target = null
	local group urgent = null
	local group medium = null

	set urgent = CopyGroup(urgent_healing_group)
	set medium = CopyGroup(medium_healing_group)	
	call RemoveGuardPosition(u)
	call GroupPointOrder(urgent_healing_group, "move", GetUnitX(u), GetUnitY(u))
	call GroupPointOrder(medium_healing_group, "move", GetUnitX(u), GetUnitY(u))
	call GroupPointOrder(small_healing_group, "move", GetUnitX(u), GetUnitY(u))
	call Sleep(5 * sleep_multiplier)
	loop
		exitwhen not UnitHasItem(u, heal_item)
		set target = FirstOfGroup(urgent)
		if target != null then
			call UnitUseItemTarget(u, heal_item, target)
			call GroupRemoveUnit(urgent, target)
		else
			set target = FirstOfGroup(medium)
			if target != null then
				call UnitUseItemTarget(u, heal_item, target)
				call GroupRemoveUnit(medium, target)
			endif
		endif
		exitwhen target == null
		call Sleep(2 * sleep_multiplier)
	endloop
	call RecycleGuardPosition(u)
	call DestroyGroup(urgent)
	call DestroyGroup(medium)
	set urgent = null
	set medium = null
	set target = null
endfunction

function ApplyGlobalItem takes unit u, item heal_item returns nothing
  call UnitUseItem(u, heal_item)
endfunction
function HealArmy takes nothing returns nothing
  local real hs = 0.0
  local unit u = null
  local integer mh_item = 0
  local item mh_i = null
  local boolean mass_healed = false
  loop
    //if not (town_threatened or CaptainRetreating()) then
      set hs = GetArmyHealthState()
      set mass_healed = false
	  exitwhen (urgent_healing_count <= 3 and hs > 0.75) // and not shop_ordered	
      exitwhen player_defeated or town_threatened	  
	  call Trace("function HealArmy: Army is badly damaged and needs healing")	  
      if urgent_healing_count + medium_healing_count > 3 then
        set mh_item = GetMassHealingItem()
        if mh_item > 0 then
          set mass_healed = true
          set mh_i = GetItemOfType(mh_item)
          if mh_i != null then
            set u = GetItemHero(mh_i)
            if u != null then
              call ApplyMassHealingItem(u, mh_i)
            endif
			if hs <= 0.75 then
				call Sleep(10 * sleep_multiplier)
			endif
          else
            call StartEmergencyItem(1, mh_item)
			if hs <= 0.75 then
				call Sleep(8 * sleep_multiplier)
			endif
          endif
        else  
		  // -----------Merchant Mass Healing Items -----------
		  set mh_item = GetMerchantMassHealingItem()
		  if mh_item > 0 then
			set mass_healed = true
			set mh_i = GetItemOfType(mh_item)
			if mh_i != null then
				set u = GetItemHero(mh_i)
				if u != null then
					call ApplyMassHealingItem(u, mh_i)
				endif
			else
				set mh_item = GetGlobalHealingItem()
				if mh_item > 0 then
					set mh_i = GetItemOfType(mh_item)
					if mh_i != null then
						set u = GetItemHero(mh_i)
						if u != null then
							call ApplyGlobalItem(u, mh_i)
						endif
						if hs <= 0.75 then
							call Sleep(25 * sleep_multiplier)
						endif
					else
						call StartEmergencyItem(1, mh_item)
						if hs <= 0.75 then
							call Sleep(8*sleep_multiplier)
						endif
					endif
				else  
					// ----------- Single Healing Item -----------
						set mh_item = GetHealingItem()
						if mh_item > 0 then
							//set mass_healed = true
							set mh_i = GetItemOfType(mh_item)
							if mh_i != null then	
								set u = GetItemHero(mh_i)	
								if u != null then
									call ApplyHealingItem(u, mh_i)
								endif
								if hs <= 0.75 then
									call Sleep(10 * sleep_multiplier)	
								endif
							else
								call StartEmergencyItem(1, mh_item)
								if hs <= 0.75 then
									call Sleep(8 * sleep_multiplier)
								endif
							endif
						endif	
				endif
			endif
		  endif
		endif
      endif

    call Sleep(2 * sleep_multiplier)
	exitwhen hs > 0.75	// Still a large proportion of army is strong so exit loop
  endloop
endfunction

function universal_attack_sequence takes nothing returns nothing
    local boolean needs_exp = false
    local boolean has_siege = false
    local integer ai_strength = GetOwnStrength()
    local integer ai_antiair_strength = air_strength
    local integer exp_strength = GetExpansionStrength()

    if hero_unit[1] == null and ver_heroes then
      call Sleep(sleep_multiplier)
      return
    endif	
    
    if major_hero == null or not UnitAlive(major_hero) or not IsStandardUnit(major_hero) or (IsUnitType(major_hero, UNIT_TYPE_HERO) == false and ver_heroes) then
      set major_hero = GetMajorHero()
    endif

    set needs_exp        = take_exp and (ai_strength > exp_strength)
    set has_siege = ai_strength > 60
    set has_siege        = has_siege or TownCountDone(MORTAR) > 0
    set has_siege        = has_siege or TownCountDone(STEAM_TANK) > 0
    set has_siege        = has_siege or TownCountDone(ROCKET_TANK) > 0
    set has_siege        = has_siege or TownCountDone(CATAPULT) > 0
    set has_siege        = has_siege or TownCountDone(MEAT_WAGON) > 0
    set has_siege        = has_siege or TownCountDone(BALLISTA) > 0
    set has_siege        = has_siege or TownCountDone(CHIMAERA) > 0
    set has_siege        = has_siege or TownCountDone(NAGA_TURTLE) > 0

	call SingleMeleeAttackAM(needs_exp,has_siege,ai_strength)
	set added_target_aggression = 0
	set added_racial_aggression = 0
	
    //call TeleportCaptain(GetLocationX(home_location), GetLocationY(home_location))
    
    loop
      exitwhen not teleporting
      //call Trace("UNIVERSAL ATTACK: Units are teleporting")
      call Sleep(1)
    endloop
    
    if town_threatened then
		set break_attack = false
		set isfleeing = false
		call FormGroupAM(1)
		call SleepUntilTownDefended(GetOwnStrength())
		call SleepInCombatAM()
    elseif not towerrush and not ancient_expanding and not militia_expanding then
		call SetCaptainHome(DEFENSE_CAPTAIN, GetLocationX(home_location), GetLocationY(home_location))
	endif
    
    if go_home then
      call Trace("UNIVERSAL ATTACK: Going home" )
	  call ClearCaptainTargets() 
      call CaptainGoHome()
    endif
    set break_attack = false
    set go_home = false
	if not town_threatened then
		call ClearCaptainTargets()   // Causes the pause in movement to allow units to catch up
		                             // disabled when town threatened as we want units to get back fast
	endif
endfunction

function universal_peon_assignment takes nothing returns nothing
    local integer T = TownWithMine()
    local integer g = GetGold()
    local integer w = GetWood()
    local integer pwh = 0
    local integer swh = 0
    local real gdivw = I2R(g)/I2R(Max(w,1))
    local integer i = T + 1

    if T < 0 then
      set T = 0
    endif

    if g - w > 300 then
      set pwh = 2
    elseif g - w > 500 and w < 100 then
      set pwh = 5
    elseif g - w > 900 and w < 200 then
      set pwh = 8
    else
      set pwh = 2
    endif

    if w < 200 then
      set swh = 6 - pwh
    elseif gdivw < 0.5 then
      set swh = 0
    elseif gdivw < 0.8 then
      set swh = Max(1 - pwh,0)
    elseif gdivw < 1.1 then
      set swh = Max(2 - pwh,0)
    elseif gdivw < 1.4 then
      set swh = Max(3 - pwh,0)
    elseif gdivw < 1.7 then
      set swh = Max(4 - pwh,0)
    elseif gdivw < 2.0 then
      set swh = Max(5 - pwh,0)
    else
      set swh = Max(6 - pwh,0)
    endif

    set swh = Max(swh - 4 * TownCountDone(neutral_shredder),0)

    call ClearHarvestAI()
    call HarvestGold(T,ver_optimal_gold)
    call HarvestWood(0,pwh)
    call HarvestWood(0,swh)

    loop
	  //set i = i + 1
      exitwhen i > T + 3
      if T != i and TownHasMine(i) and TownCountEx(racial_expansion,true,i) > 0 then
        if gdivw < 3.0 or g < 300 then
          call HarvestGold(i,ver_optimal_gold)
        else
          call HarvestGold(i,ver_optimal_gold - 2)
        endif
      endif
	  set i = i + 1
    endloop

    call HarvestWood(0,20)
endfunction

function SetAIResources takes integer g, integer w returns nothing
  call SetPlayerGold(ai_player, g)
  call SetPlayerWood(ai_player, w)
endfunction

function IncreaseAIResources takes integer g, integer w returns nothing
  call IncreasePlayerGold(ai_player, g)
  call IncreasePlayerWood(ai_player, w)
endfunction

function AddWaveResources takes nothing returns nothing
  local integer g = 0
  local integer w = 0
  local integer i = 0
  local integer unitid = 0
  local integer desire = 0

  loop
    exitwhen i >= attack_length
    set unitid = attack_units[i]
    set desire = attack_qty[i]
    set g = g + desire * GetUnitGoldCost2(unitid)
    set w = w + desire * GetUnitWoodCost2(unitid)
    set i = i + 1
  endloop

  call IncreaseAIResources(g,w)
  
endfunction

function BuildAndAttack takes player p, integer prio returns nothing
    local integer index = 0
    local integer unitid = 0
    local integer desire = 0
    local boolean group_ready = true
    
    call AddWaveResources()

    loop
      set index = 0
      set group_ready = true
      loop
        exitwhen index >= attack_length
        set unitid = attack_units[index]
        set desire = attack_qty[index] + campaign_defenders[unitid]
        if TownCountDone(unitid)<desire then
          set group_ready = false
          call BuildUnit(desire , unitid, prio)
        endif
        set index = index + 1
      endloop
      exitwhen group_ready
      call Sleep(5 * sleep_multiplier)
    endloop

    call FormGroupAM(5)
    call SuicidePlayer(p, true)
    loop
      exitwhen CaptainIsEmpty()
      call Sleep(5 * sleep_multiplier)
    endloop
    
endfunction

function BuildDefendersAM takes integer prio returns nothing
    local integer index = 0
    local integer unitid = 0
    local integer qty = 0
    loop
        exitwhen index >= defense_length

        set unitid = defense_units[index]
        set qty = defense_qty[index]

        call BuildUnit(qty, unitid, prio)
        call ConversionsAM(qty,unitid)
        call AddDefenders(qty,old_id[unitid])
        set campaign_defenders[unitid] = qty

        set index = index + 1
    endloop
endfunction





function InitAI takes nothing returns nothing
    set ai_player = Player(GetAiPlayer())
    set sleep_seconds = 0
	call InitAiUnits()
    call InitArrays()
    call StopGathering()
endfunction

function StandardAI takes code heroes, code peons, code attacks returns nothing

    local boolean isNewbie = (MeleeDifficulty() == MELEE_NEWBIE)

    call InitAI()

    call SetMeleeAI()

    call SetDefendPlayer(true)
    call SetGroupsFlee(not isNewbie)
    call SetHeroesBuyItems(not isNewbie)
    call SetHeroesFlee(true)
    call SetHeroesTakeItems(true)
    call SetIgnoreInjured(true)
    call SetPeonsRepair(true)
    call SetSmartArtillery(not isNewbie)
    call SetTargetHeroes(not isNewbie)
    call SetUnitsFlee(not isNewbie)
    call SetWatchMegaTargets(true)

    call CreateCaptains()

    call SetHeroLevels(heroes)

    call Sleep(0.1)
    call StartThread(peons)
    call StartThread(attacks)
endfunction


function SetZepNextWave takes nothing returns nothing
    set zep_next_wave = true
endfunction

function SuicideSleep takes integer seconds returns nothing
    set sleep_seconds = sleep_seconds - seconds
    loop
        exitwhen seconds <= 0
        exitwhen allow_signal_abort and CommandsWaiting() != 0

        if seconds >= 5 then
            call Sleep(5)
            set seconds = seconds - 5
        else
            call Sleep(seconds)
            set seconds = 0
        endif
    endloop
endfunction

function WaitForSignal takes nothing returns integer
    local integer cmd
    local boolean display = false //xxx
    loop
        exitwhen CommandsWaiting() != 0

        //xxx
        call Trace("waiting for a signal to begin AI script...\n")
        set display = true
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        //xxx

    endloop

    //xxx
    if display then
        call Trace("signal received, beginning AI script\n")
    endif
    //xxx

    set cmd = GetLastCommand()
    call PopLastCommand()
    return cmd
endfunction

function SetWoodPeons takes integer count returns nothing
    set campaign_wood_peons = count
endfunction

function SetGoldPeons takes integer count returns nothing
    set campaign_gold_peons = count
endfunction

function SetHarvestLumber takes boolean harvest returns nothing
    if harvest then
        set campaign_wood_peons = 3
    else
        set campaign_wood_peons = 0
    endif
endfunction

function SetFormGroupTimeouts takes boolean state returns nothing
    set form_group_timeouts = state
endfunction

function DoCampaignFarms takes boolean state returns nothing
    set do_campaign_farms = state
endfunction

function GetMinorCreep takes nothing returns unit
    return GetCreepCamp(0,9,false)
endfunction

function GetMajorCreep takes nothing returns unit
    return GetCreepCamp(10,100,allow_air_creeps)
endfunction

function InitBuildArray takes nothing returns nothing
    set build_length = 0
endfunction

function InitMeleeGroup takes nothing returns nothing
    call InitAssaultGroup()
    call RemoveInjuries()
    call RemoveSiege()
endfunction

function PrepFullSuicide takes nothing returns nothing
    call InitAssaultGroup()
    call InitDefenseGroup()
    set campaign_gold_peons = 0
    set campaign_wood_peons = 0
endfunction

function SetReplacements takes integer easy, integer med, integer hard returns nothing
    if difficulty == EASY then
        call SetReplacementCount(easy)
    elseif difficulty == NORMAL then
        call SetReplacementCount(med)
    else
        call SetReplacementCount(hard)
    endif
endfunction

function StartTownBuilder takes code func returns nothing
    call StartThread(func)
endfunction

function SetBuildAll takes integer t, integer qty, integer unitid, integer town returns nothing
    if qty > 0 then
        set build_qty[build_length] = qty
        set build_type[build_length] = t
        set build_item[build_length] = unitid
        set build_town[build_length] = town
        set build_length = build_length + 1
    endif
endfunction

function SetBuildUnit takes integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_UNIT,qty,unitid,-1)
endfunction

function SetBuildNext takes integer qty, integer unitid returns nothing
    local integer has = GetUnitCount(unitid)
    if has >= qty then
        return
    endif
    call SetBuildAll(BUILD_UNIT,GetUnitCountDone(unitid)+1,unitid,-1)
endfunction

function SetBuildUnitEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call SetBuildAll(BUILD_UNIT,easy,unitid,-1)
    elseif difficulty == NORMAL then
        call SetBuildAll(BUILD_UNIT,med,unitid,-1)
    else
        call SetBuildAll(BUILD_UNIT,hard,unitid,-1)
    endif
endfunction

function SecondaryTown takes integer town, integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_UNIT,qty,unitid,town)
endfunction

function SecTown takes integer town, integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_UNIT,qty,unitid,town)
endfunction

function SetBuildUpgr takes integer qty, integer unitid returns nothing
    if MeleeDifficulty() != MELEE_NEWBIE or qty == 1 then
        call SetBuildAll(BUILD_UPGRADE,qty,unitid,-1)
    endif
endfunction

function SetBuildUpgrEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call SetBuildAll(BUILD_UPGRADE,easy,unitid,-1)
    elseif difficulty == NORMAL then
        call SetBuildAll(BUILD_UPGRADE,med,unitid,-1)
    else
        call SetBuildAll(BUILD_UPGRADE,hard,unitid,-1)
    endif
endfunction

function SetBuildExpa takes integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_EXPAND,qty,unitid,-1)
endfunction

function StartUpgrade takes integer level, integer upgid returns boolean
    local integer gold_cost
    local integer wood_cost

    if GetUpgradeLevel(upgid) >= level then
        return true
    endif

    set gold_cost = GetUpgradeGoldCost(upgid)
    if total_gold < gold_cost then
        return false
    endif

    set wood_cost = GetUpgradeWoodCost(upgid)
    if total_wood < wood_cost then
        return false
    endif

    return SetUpgrade(upgid)
endfunction

function BuildFactory takes integer unitid returns nothing
    if GetGold() > 1000 and GetWood() > 500 then
        call SetBuildUnit( 2, unitid )
    else
        call SetBuildUnit( 1, unitid )
    endif
endfunction

function GuardSecondary takes integer townid, integer qty, integer unitid returns nothing
    if TownHasHall(townid) and TownHasMine(townid) then
        call SecondaryTown( townid, qty, unitid )
    endif
endfunction

function BasicExpansion takes boolean build_it, integer unitid returns nothing
    if build_it and HallsCompleted(unitid) then
        call SetBuildExpa( TownCount(unitid)+1, unitid )
    endif
endfunction

function UpgradeAll takes integer baseid, integer newid returns nothing
    call SetBuildUnit( TownCountDone(baseid), newid )
endfunction

function FoodPool takes integer food, boolean weak, integer id1, integer use1, boolean strong, integer id2, integer use2 returns nothing
    if strong then
        call SetBuildUnit( (food - use1 * TownCount(id1)) / use2, id2 )
    elseif weak then
        call SetBuildUnit( (food - use2 * TownCount(id2)) / use1, id1 )
    endif
endfunction

function MeleeTownHall takes integer townid, integer unitid returns nothing
    if TownHasMine(townid) and not TownHasHall(townid) then
        call SecondaryTown ( townid, 1, unitid )
    endif
endfunction

function WaitForUnits takes integer unitid, integer qty returns nothing
    loop
        exitwhen TownCountDone(unitid) == qty
        call Sleep(2)
    endloop
endfunction

function StartUnit takes integer ask_qty, integer unitid, integer town returns boolean
    local integer have_qty
    local integer need_qty
    local integer afford_gold
    local integer afford_wood
    local integer afford_qty
    local integer gold_cost
    local integer wood_cost
	
    //------------------------------------------------------------------------
    // if we have all we're asking for then make nothing
    //
    if town == -1 then
        set have_qty = TownCount(unitid)
    else
        set have_qty = TownCountTown(unitid,town)
    endif

    if have_qty >= ask_qty then
        return true
    endif
    set need_qty = ask_qty - have_qty

    //------------------------------------------------------------------------
    // limit the qty we're requesting to the amount of resources available
    //
    set gold_cost = GetUnitGoldCost(unitid)
    set wood_cost = GetUnitWoodCost(unitid)
	
    if gold_cost == 0 then
        set afford_gold = need_qty
    else
        set afford_gold = total_gold / gold_cost
    endif
    if afford_gold < need_qty then
        set afford_qty = afford_gold
    else
        set afford_qty = need_qty
    endif

    if wood_cost == 0 then
        set afford_wood = need_qty
    else
        set afford_wood = total_wood / wood_cost
    endif
    if afford_wood < afford_qty then
        set afford_qty = afford_wood
    endif

    // if we're waiting on gold/wood; pause build orders
    if afford_qty < 1 then
        return false
    endif

    //------------------------------------------------------------------------
    // whether we make right now what we're requesting or not, assume we will
    // and deduct the cost of the units from our fake gold total right away
    //
    set total_gold = total_gold - gold_cost * need_qty
    set total_wood = total_wood - wood_cost * need_qty

    if total_gold < 0 then
        set total_gold = 0
    endif
    if total_wood < 0 then
        set total_wood = 0
    endif

    //------------------------------------------------------------------------
    // give the AI a chance to make the units (it may not be able to right now
    // but that doesn't stop us from trying other units after this as long
    // as we have enough money to make this AND the needed, unbuilt ones)
    //
    return SetProduce(afford_qty,unitid,town)
endfunction

function WaitForTown takes integer towns, integer townid returns nothing
    local integer i = 0
    loop
        call Sleep(10)
        exitwhen TownCount(townid) >= towns
        set i = i + 1
        exitwhen i == 12
    endloop
endfunction

function StartExpansion takes integer qty, integer hall returns boolean
    local integer count
    local integer town
    local unit    peon
    local integer gold_cost

    set count = TownCount(hall)
    if count >= qty then
        return true
    endif

    set town = GetNextExpansion()
    if town == -1 then
        return true
    endif

    set take_exp = true

    set gold_cost = GetUnitGoldCost(hall)
    if gold_cost > total_gold then
        return false
    endif
    set total_gold = total_gold - gold_cost

    if GetExpansionFoe() != null then
        return true
    endif

    set peon = GetExpansionPeon()
    if peon != null then
        return SetExpansion(peon,hall)
    endif

    return true
endfunction

function OneBuildLoop takes nothing returns nothing
    local integer index = 0
    local integer qty
    local integer id
    local integer tp

    set total_gold = GetGold() - gold_buffer
    set total_wood = GetWood()

    loop
        exitwhen index == build_length

        set qty = build_qty [index]
        set id  = build_item[index]
        set tp  = build_type[index]

        //--------------------------------------------------------------------
        if tp == BUILD_UNIT then
            if not StartUnit(qty,id,build_town[index]) then
                return
            endif

        //--------------------------------------------------------------------
        elseif tp == BUILD_UPGRADE then
            call StartUpgrade(qty,id)

        //--------------------------------------------------------------------
        else // tp == BUILD_EXPAND
            if not StartExpansion(qty,id) then
                return
            endif
        endif

        set index = index + 1
    endloop
endfunction

function BuildLoop takes nothing returns nothing
    call OneBuildLoop()
    call StaggerSleep(1,2)
    loop
        call OneBuildLoop()
        call Sleep(2)
    endloop
endfunction

function StartBuildLoop takes nothing returns nothing
    call StartThread(function BuildLoop)
endfunction

function SetInitialWave takes integer seconds returns nothing
    set sleep_seconds = seconds
endfunction

function AddSleepSeconds takes integer seconds returns nothing
    set sleep_seconds = sleep_seconds + seconds
endfunction

function SleepForever takes nothing returns nothing
    call Trace("going to sleep forever\n") //xxx
    loop
        call Sleep(100)
    endloop
endfunction

function PlayGame takes nothing returns nothing
    call StartBuildLoop()
    call SleepForever()
endfunction

function ConvertNeeds takes integer unitid returns nothing
    if GetUnitCount(unitid) < 1 then
        call StartUnit(1,unitid,-1)
    endif
endfunction

function Conversions takes integer desire, integer unitid returns nothing

    if GetUnitCount(unitid) >= desire then
        return
    endif

  	if unitid == HIPPO_RIDER then
            call ConvertNeeds(ARCHER)
		call ConvertNeeds(HIPPO)
      	call MergeUnits(desire,ARCHER,HIPPO,HIPPO_RIDER)
      endif

    	if unitid == BLK_SPHINX then
		call ConvertNeeds(OBSIDIAN_STATUE)
        	call ConvertUnits(desire, OBSIDIAN_STATUE)
      endif

endfunction

function SetAssaultGroup takes integer qty, integer max, integer unitid returns nothing
    call Conversions(max,unitid)

    if qty <= 0 and TownCountDone(unitid) == 0 then
        return
    endif
    set harass_qty[harass_length] = qty
    set harass_max[harass_length] = max
    set harass_units[harass_length] = unitid
    set harass_length = harass_length + 1
endfunction

function Interleave3 takes integer e1, integer m1, integer h1, integer u1, integer e2, integer m2, integer h2, integer u2, integer e3, integer m3, integer h3, integer u3 returns nothing
    local integer i1 = 1
    local integer i2 = 1
    local integer i3 = 1
    local integer q1
    local integer q2
    local integer q3

    if difficulty == EASY then
        set q1 = e1
        set q2 = e2
        set q3 = e3
    elseif difficulty == NORMAL then
        set q1 = m1
        set q2 = m2
        set q3 = m3
    else // difficulty == HARD
        set q1 = h1
        set q2 = h2
        set q3 = h3
    endif

    loop
        exitwhen q1<=0 and q2<=0 and q3<=0

        if q1 > 0 then
            call SetAssaultGroup(i1,i1,u1)
            set q1 = q1 - 1
            set i1 = i1 + 1
        endif

        if q2 > 0 then
            call SetAssaultGroup(i2,i2,u2)
            set q2 = q2 - 1
            set i2 = i2 + 1
        endif

        if q3 > 0 then
            call SetAssaultGroup(i3,i3,u3)
            set q3 = q3 - 1
            set i3 = i3 + 1
        endif
    endloop
endfunction

function SetMeleeGroup takes integer unitid returns nothing
    if unitid == hero_id then
        call SetAssaultGroup(1,9,unitid)
    else
        call SetAssaultGroup((TownCountDone(unitid)*3)/4,20,unitid)
    endif
endfunction

function CampaignDefender takes integer level, integer qty, integer unitid returns nothing
    if qty > 0 and difficulty >= level then
        set defense_qty[defense_length] = qty
        set defense_units[defense_length] = unitid
        set defense_length = defense_length + 1
        call Conversions(qty,unitid)
        call SetBuildUnit(qty,unitid)
    endif
endfunction

function CampaignDefenderEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call CampaignDefender(EASY,easy,unitid)
    elseif difficulty == NORMAL then
        call CampaignDefender(NORMAL,med,unitid)
    else
        call CampaignDefender(HARD,hard,unitid)
    endif
endfunction

function CampaignAttacker takes integer level, integer qty, integer unitid returns nothing
    if qty > 0 and difficulty >= level then 
        call SetAssaultGroup(qty,qty,unitid)
    endif
endfunction

function CampaignAttackerEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call CampaignAttacker(EASY,easy,unitid)
    elseif difficulty == NORMAL then
        call CampaignAttacker(NORMAL,med,unitid)
    else
        call CampaignAttacker(HARD,hard,unitid)
    endif
endfunction

function FormGroup takes integer seconds, boolean testReady returns nothing
    local integer index
    local integer count
    local integer unitid
    local integer desire
    local integer readyPercent

    // normally test for CaptainReadiness() of 50%
    if testReady == true then
        set readyPercent = 50
        call Trace("forming group, requiring healthy guys\n") //xxx
    else
        set readyPercent = 0
        call Trace("forming group, unit health not important\n") //xxx
    endif

    call Trace("trying to gather forces\n") //xxx

    loop
        call SuicideSleep(seconds)
        call InitAssault()

        set index = 0
        loop
            exitwhen index == harass_length

            set unitid = harass_units[index]
            set desire = harass_max[index]
            set count  = TownCountDone(unitid)

            call Conversions(desire,unitid)

            if count >= desire then
                call AddAssault(desire,unitid)
            else
                set desire = harass_qty[index]

                if count < desire then
                    call AddAssault(desire,unitid)
                else
                    call AddAssault(count,unitid)
                endif
            endif

            set index = index + 1
        endloop

        //xxx
        if form_group_timeouts and (sleep_seconds < -60) then
            call Trace("exit form group -- timeout\n")
        elseif CaptainInCombat(true) then
            call Trace("exit form group -- can't form while already in combat\n")
        elseif CaptainIsFull() and CaptainReadiness() >= readyPercent then
            call Trace("exit form group -- ready\n")
        endif
        //xxx

        // time out and send group anyway if time has already expired
        exitwhen form_group_timeouts and (sleep_seconds < -60)
        exitwhen CaptainInCombat(true)
        exitwhen CaptainIsFull() and CaptainReadiness() >= readyPercent
    endloop
endfunction

function WavePrepare takes integer unitid returns integer
    return GetUnitBuildTime(unitid)
endfunction

function PrepTime takes nothing returns integer
    local integer unitid
    local integer missing
    local integer prep
    local integer count
    local integer largest = 30
    local integer index = 0

    loop
        exitwhen index == harass_length

        set unitid  = harass_units[index]
        set missing = harass_qty[index] + IgnoredUnits(old_id[unitid]) - TownCount(unitid)
        set prep    = WavePrepare(unitid) * missing

        if prep > largest then
            set largest = prep
        endif

        set index = index + 1
    endloop
    call TraceI("next wave will require around %d seconds to build and gather\n",largest) //xxx

    return largest
endfunction

function PrepSuicideOnPlayer takes integer seconds returns boolean
    local integer wave_prep   = PrepTime()
    local integer save_length

    set save_length = harass_length
    set harass_length = 0

    call AddSleepSeconds(seconds)
    if sleep_seconds-wave_prep > 0 then
        call TraceI("going to sleep for %d seconds before gathering next attack wave\n",sleep_seconds-wave_prep) //xxx
        call SuicideSleep(sleep_seconds-wave_prep)
    endif

    call Trace("preparing suicide attack wave\n") //xxx

    set harass_length = save_length
    if harass_length < 1 then
        call Trace("ERROR - no units specificed, exiting early\n") //xxx
        return false
    endif

    return true
endfunction

function SleepUntilAtGoal takes nothing returns nothing
    loop
        exitwhen CaptainRetreating()
        exitwhen CaptainAtGoal()        // reached goal
        exitwhen CaptainIsHome()        // failed to path and returned home
        exitwhen CaptainIsEmpty()       // all units died
        call SuicideSleep(3)
    endloop
endfunction

function SleepInCombat takes nothing returns nothing
    local integer count = 0
    debug call Trace("SleepInCombat\n")
    loop
        loop
            exitwhen not CaptainInCombat(true)  // goal is cleared
            exitwhen CaptainIsEmpty()           // duh
            call SuicideSleep(1)
        endloop

        set count = count + 1
        exitwhen count >= 8

        //xxx this is what it should have been; do this for next patch?
        //call SuicideSleep(1)
    endloop
    debug call Trace("exit SleepInCombat\n")
endfunction

function AttackMoveXYA takes integer x, integer y returns nothing

    if zep_next_wave then
        call LoadZepWave(x,y)
        set zep_next_wave = false
    endif

    call AttackMoveXY(x,y)
    call SleepUntilAtGoal()
    call SleepInCombat()
endfunction

function SuicideOnPlayerWave takes nothing returns nothing
    call Trace("waiting for attack wave to enter combat\n") //xxx
    loop
        //xxx
        if allow_signal_abort and CommandsWaiting() != 0 then
            call Trace("ABORT -- attack wave override\n")
        endif

        if CaptainInCombat(true) then
            call Trace("done - captain has entered combat\n")
        endif

        if CaptainIsEmpty() then
            call Trace("done - all units are dead\n")
        endif

        if sleep_seconds < -300 then
            call Trace("done - timeout, took too long to reach engage the enemy\n")
        endif
        //xxx

        exitwhen allow_signal_abort and CommandsWaiting() != 0

        exitwhen CaptainInCombat(true)
        exitwhen CaptainIsEmpty()
        call SuicideSleep(10)
        exitwhen sleep_seconds < -300
    endloop

    call Trace("waiting for attack wave to die\n") //xxx
    loop
        //xxx
        if allow_signal_abort and CommandsWaiting() != 0 then
            call Trace("ABORT - attack wave override\n")
        endif

        if CaptainIsEmpty() then
            call Trace("done - all units are dead\n")
        endif

        if sleep_seconds < -300 then
            call Trace("done - timeout, took too long to reach engage the enemy\n")
        endif
        //xxx

        exitwhen allow_signal_abort and CommandsWaiting() != 0

        exitwhen CaptainIsEmpty()
        call SuicideSleep(10)
        exitwhen sleep_seconds < -300
    endloop
endfunction

function CommonSuicideOnPlayer takes boolean standard, boolean bldgs, integer seconds, player p, integer x, integer y returns nothing
    local integer save_peons

    if not PrepSuicideOnPlayer(seconds) then
        return
    endif

    set save_peons = campaign_wood_peons
    set campaign_wood_peons = 0

    loop
        //xxx
        if allow_signal_abort and CommandsWaiting() != 0 then
            call Trace("ABORT -- attack wave override\n")
        endif
        //xxx

        exitwhen allow_signal_abort and CommandsWaiting() != 0

        loop
            exitwhen allow_signal_abort and CommandsWaiting() != 0

            call FormGroup(5,true)
            exitwhen sleep_seconds <= 0
            call TraceI("waiting %d seconds before suicide\n",sleep_seconds) //xxx
        endloop

        if standard then
            if bldgs then
                exitwhen SuicidePlayer(p,sleep_seconds >= -60)
            else
                exitwhen SuicidePlayerUnits(p,sleep_seconds >= -60)
            endif
        else
            call AttackMoveXYA(x,y)
        endif

        call TraceI("waiting %d seconds before timeout\n",60+sleep_seconds) //xxx
        call SuicideSleep(5)
    endloop

    set campaign_wood_peons = save_peons
    set harass_length = 0

    call SuicideOnPlayerWave()
endfunction

function SuicideOnPlayer takes integer seconds, player p returns nothing
    call CommonSuicideOnPlayer(true,true,seconds,p,0,0)
endfunction

function SuicideOnUnits takes integer seconds, player p returns nothing
    call CommonSuicideOnPlayer(true,false,seconds,p,0,0)
endfunction

function SuicideOnPoint takes integer seconds, player p, integer x, integer y returns nothing
    call CommonSuicideOnPlayer(false,false,seconds,p,x,y)
endfunction

function SuicideUntilSignal takes integer seconds, player p returns nothing
    local integer save
    local integer wave_prep = PrepTime()

    loop
        call AddSleepSeconds(seconds)
        if sleep_seconds-wave_prep > 0 then
            call SuicideSleep(sleep_seconds-wave_prep)
        endif

        set save = campaign_wood_peons
        set campaign_wood_peons = 0
        loop
            loop
                call FormGroup(5, true)
                exitwhen sleep_seconds <= 0
                exitwhen CommandsWaiting() != 0
            endloop
            exitwhen SuicidePlayer(p,sleep_seconds >= -60)
            exitwhen CommandsWaiting() != 0
            call SuicideSleep(3)
        endloop
        set campaign_wood_peons = save

        loop
            exitwhen CaptainIsEmpty()
            exitwhen CommandsWaiting() != 0
            call SuicideSleep(5)
        endloop
        exitwhen CommandsWaiting() != 0
    endloop
endfunction

function SuicideOnce takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call SuicideUnit(easy,unitid)
    elseif difficulty == NORMAL then
        call SuicideUnit(med,unitid)
    else
        call SuicideUnit(hard,unitid)
    endif
endfunction

function SuicideUnitA takes integer unitid returns nothing
    if unitid != 0 then
        call SuicideUnit(1,unitid)
    endif
    call Sleep(0.1)
endfunction

function SuicideUnitB takes integer unitid, integer playerid returns nothing
    if unitid != 0 then
        call SuicideUnitEx(1,unitid,playerid)
    endif
    call Sleep(0.1)
endfunction

function SuicideUnits takes integer u1, integer u2, integer u3, integer u4, integer u5, integer u6, integer u7, integer u8, integer u9, integer uA returns nothing
    call Trace("MASS SUICIDE - this script is now technically done\n") //xxx

    call PrepFullSuicide()
    loop
        call SuicideUnitA(u1)
        call SuicideUnitA(u2)
        call SuicideUnitA(u3)
        call SuicideUnitA(u4)
        call SuicideUnitA(u5)
        call SuicideUnitA(u6)
        call SuicideUnitA(u7)
        call SuicideUnitA(u8)
        call SuicideUnitA(u9)
        call SuicideUnitA(uA)
    endloop
endfunction

function SuicideUnitsEx takes integer playerid, integer u1, integer u2, integer u3, integer u4, integer u5, integer u6, integer u7, integer u8, integer u9, integer uA returns nothing
    call Trace("MASS SUICIDE - this script is now technically done\n") //xxx

    call PrepFullSuicide()
    loop
        call SuicideUnitB(u1,playerid)
        call SuicideUnitB(u2,playerid)
        call SuicideUnitB(u3,playerid)
        call SuicideUnitB(u4,playerid)
        call SuicideUnitB(u5,playerid)
        call SuicideUnitB(u6,playerid)
        call SuicideUnitB(u7,playerid)
        call SuicideUnitB(u8,playerid)
        call SuicideUnitB(u9,playerid)
        call SuicideUnitB(uA,playerid)
    endloop
endfunction

function SuicideOnPlayerEx takes integer easy, integer med, integer hard, player p returns nothing
    if difficulty == EASY then
        call SuicideOnPlayer(easy,p)
    elseif difficulty == NORMAL then
        call SuicideOnPlayer(med,p)
    else
        call SuicideOnPlayer(hard,p)
    endif
endfunction

function SuicideOnUnitsEx takes integer easy, integer med, integer hard, player p returns nothing
    if difficulty == EASY then
        call SuicideOnUnits(easy,p)
    elseif difficulty == NORMAL then
        call SuicideOnUnits(med,p)
    else
        call SuicideOnUnits(hard,p)
    endif
endfunction

function SuicideOnPointEx takes integer easy, integer med, integer hard, player p, integer x, integer y returns nothing
    if difficulty == EASY then
        call SuicideOnPoint(easy,p,x,y)
    elseif difficulty == NORMAL then
        call SuicideOnPoint(med,p,x,y)
    else
        call SuicideOnPoint(hard,p,x,y)
    endif
endfunction

function ForeverSuicideOnPlayer takes integer seconds, player p returns nothing
    local integer length = harass_length
    loop
        exitwhen allow_signal_abort and CommandsWaiting() != 0
        call SuicideOnPlayer(seconds,p)
        set harass_length = length
    endloop
endfunction

function CommonSleepUntilTargetDead takes unit target, boolean reform returns nothing
    loop
        exitwhen CaptainRetreating()
        exitwhen CaptainReadinessHP() <= 40

        exitwhen not UnitAlive(target)
        exitwhen UnitInvis(target) and not IsUnitDetected(target,ai_player)

        if not TownThreatened() then
            call AttackMoveKill(target)
        endif

        call SuicideSleep(3)

        if reform and sleep_seconds < -40 then
            if CaptainInCombat(true) then
                set sleep_seconds = sleep_seconds + 5
            else
                set sleep_seconds = 0
                call FormGroup(1,false)
            endif
        endif
    endloop
endfunction

function SleepUntilTargetDead takes unit target returns nothing
    call CommonSleepUntilTargetDead(target,false)
endfunction

function ReformUntilTargetDead takes unit target returns nothing
    debug call Trace("ReformUntilTargetDead\n")
    call CommonSleepUntilTargetDead(target,true)
endfunction

function AttackMoveKillA takes unit target returns nothing
    if target == null then
        call SuicideSleep(3)
        return
    endif

    debug call Trace("AttackMoveKillA\n")
    call AttackMoveKill(target)
    call ReformUntilTargetDead(target)
    call SleepInCombat()
endfunction

function MinorCreepAttack takes nothing returns nothing
    local unit target = GetMinorCreep()
    call SetAllianceTarget(target)
    call FormGroup(3, true)
    call AttackMoveKillA(target)
endfunction

function MajorCreepAttack takes nothing returns nothing
    local unit target = GetMajorCreep()
    call SetAllianceTarget(target)
    call FormGroup(3,true)
    call AttackMoveKillA(target)
endfunction

function CreepAttackEx takes nothing returns nothing
    local unit target = GetCreepCamp(min_creeps,max_creeps,allow_air_creeps)
    call SetAllianceTarget(target)
    call FormGroup(3,true)
    call AttackMoveKillA(target)
endfunction

function AnyPlayerAttack takes nothing returns nothing
    local unit hall

    set hall = GetEnemyExpansion()
    if hall == null then
        call StartGetEnemyBase()
        loop
            exitwhen not WaitGetEnemyBase()
            call SuicideSleep(1)
        endloop
        set hall = GetEnemyBase()
    endif

    call SetAllianceTarget(hall)
    call FormGroup(3,true)
    call AttackMoveKillA(hall)
endfunction

function ExpansionAttack takes nothing returns nothing
    local unit creep = GetExpansionFoe()
    local integer x

    call FormGroup(3, true)
    if creep == null then
        set x = GetExpansionX()
        if x != -1 then
            call AttackMoveXYA(x,GetExpansionY())
        endif
    else
        call AttackMoveKillA(creep)
    endif
endfunction

function AddSiege takes nothing returns nothing

    call SetAssaultGroup( 0, 9, MORTAR )
    call SetAssaultGroup( 0, 9, STEAM_TANK )
    call SetAssaultGroup( 0, 9, ROCKET_TANK )
    call SetAssaultGroup( 0, 9, CATAPULT )
    call SetAssaultGroup( 0, 9, MEAT_WAGON )
    call SetAssaultGroup( 0, 9, BALLISTA )
    call SetAssaultGroup( 0, 9, CHIMAERA )
    call SetAssaultGroup( 0, 9, NAGA_TURTLE )

endfunction

function GetAllyCount takes player whichPlayer returns integer
    local integer    playerIndex = 0
    local integer    count = 0
    local player     indexPlayer

    loop
        set indexPlayer = Player(playerIndex)

        if whichPlayer != indexPlayer then
            if GetPlayerAlliance(whichPlayer,indexPlayer,ALLIANCE_PASSIVE) then
                if GetPlayerAlliance(indexPlayer,whichPlayer,ALLIANCE_PASSIVE) then
                    if GetPlayerStructureCount(indexPlayer,true) > 0 then
                        set count = count + 1
                    endif
                endif
            endif
        endif
         
        set playerIndex = playerIndex + 1
        exitwhen playerIndex == 12
    endloop

    return count
endfunction

function SingleMeleeAttack takes boolean needs_exp, boolean has_siege, boolean major_ok, boolean air_units returns nothing
    local boolean   can_siege
    local real      daytime 
    local unit      hall
    local unit      mega
    local unit      creep
    local unit      common
    local integer   minexp
    local boolean   allies

    call Trace("===SingleMeleeAttack===\n") //xxx

    if TownThreatened() then
        call Trace("sleep 2, town threatened\n") //xxx
        call Sleep(2)
        return
    endif

    // purchase zeppelins
    //
    if get_zeppelin and GetGold() > 300 and GetWood() > 100 then
        call Trace("purchase zep\n") //xxx
        call PurchaseZeppelin()
        set get_zeppelin = false
        set ready_for_zeppelin = false
        return
    endif
    set ready_for_zeppelin = true

    // coordinate with allies
    //
    set allies = GetAllyCount(ai_player) > 0
    if allies and MeleeDifficulty() != MELEE_NEWBIE then
        set common = GetAllianceTarget()
        if common != null then
            call Trace("join ally force\n") //xxx
            if GetMegaTarget() != null then
                call AddSiege()
            endif
            call FormGroup(3,true)
            call AttackMoveKillA(common)
            call SetAllianceTarget(null)
            return
        endif
    endif

    // take expansions as needed
    //
    if needs_exp then
        call Trace("needs exp\n") //xxx
        set creep = GetExpansionFoe()
        if creep != null then
            call Trace("attack exp\n") //xxx
            call SetAllianceTarget(creep)
            call FormGroup(3,true)
            call AttackMoveKillA(creep)
            call Sleep(20)
            set take_exp = false
            return
        endif
    endif

    // all-out attack if the player is weak
    //
    if MeleeDifficulty() != MELEE_NEWBIE then
        set mega = GetMegaTarget()
        if mega != null then
            call Trace("MEGA TARGET!!!\n") //xxx
            call AddSiege()
            call FormGroup(3,true)
            call AttackMoveKillA(mega)
            return
        endif
    endif

    // deny player an expansion
    //
    set hall = GetEnemyExpansion()
    set daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
    set can_siege = has_siege and (air_units or (daytime>=4 and daytime<=12))

    if hall!=null and (can_siege or not IsTowered(hall)) then

        call Trace("test player town attack\n") //xxx

        if MeleeDifficulty() == MELEE_NEWBIE then
            set minexp = 3
        elseif allies and MeleeDifficulty() == MELEE_NORMAL then
            set minexp = 1
        else
            set minexp = 0 // HARD, INSANE, and NORMAL with no allies
        endif

        if exp_seen >= minexp then
            call Trace("do player town attack\n") //xxx
            set exp_seen = 0
            call AddSiege()
            call SetAllianceTarget(hall)
            call FormGroup(3,true)
            call AttackMoveKillA(hall)
            return
        endif

        set exp_seen = exp_seen + 1
    endif

    // attack player's main base when siege is available
    //
    if can_siege then
        call Trace("attack player's town\n") //xxx
        call AddSiege()
        call AnyPlayerAttack()
        return
    endif

    // extended, more specific method of determining creep levels
    //
    if min_creeps != -1 then
        call TraceI("custom creep attack %d\n",max_creeps) //xxx
        call CreepAttackEx()
        return
    endif

    // nothing better to do, so kill a creep camp
    //
    if major_ok then
        call Trace("major creep attack\n") //xxx
        call MajorCreepAttack()
        return
    endif

    call Trace("minor creep attack\n") //xxx
    call MinorCreepAttack()
endfunction

function GetZeppelin takes nothing returns nothing
    if ready_for_zeppelin then
        set get_zeppelin = true
    endif
endfunction

function BuildAttackers takes nothing returns nothing
    local integer index = 0
    local integer unitid
    local integer desire
    local integer count

    loop
        exitwhen index == harass_length

        set unitid = harass_units[index]
        set desire = harass_qty[index] + IgnoredUnits(unitid)
        set count  = TownCount(unitid)

        if count != desire then
            if not StartUnit(desire,unitid,-1) then
                return
            endif
        endif

        set index = index + 1
    endloop
endfunction

function BuildDefenders takes nothing returns nothing
    local integer index = 0
    local integer unitid
    local integer qty
    loop
        exitwhen index == defense_length

        set unitid = defense_units[index]
        set qty = defense_qty[index]

        call Conversions(qty,unitid)
        call AddDefenders(qty,unitid)

        set index = index + 1
    endloop
endfunction

function CampaignBasicsA takes nothing returns nothing
    local integer food_each = GetFoodMade(racial_farm)
    local integer on_wood

    call ClearHarvestAI()

    if CaptainInCombat(false) then
        set on_wood = 0
    else
        set on_wood = campaign_wood_peons
    endif

    call HarvestGold(0,campaign_gold_peons)
    call HarvestWood(0,on_wood)

    if harvest_town1 then
        call HarvestGold(1,campaign_gold_peons)
        call HarvestWood(1,on_wood)
    endif

    if harvest_town2 then
        call HarvestGold(2,campaign_gold_peons)
        call HarvestWood(2,on_wood)
    endif

    if harvest_town3 then
        call HarvestGold(3,campaign_gold_peons)
        call HarvestWood(3,on_wood)
    endif

    if do_campaign_farms and FoodUsed()+food_each-1 > food_each*(TownCount(racial_farm)+1) then
        call StartUnit(TownCount(racial_farm)+1,racial_farm,-1)
    endif

    if build_campaign_attackers then
        call BuildAttackers()
    endif

    if not CaptainInCombat(false) then
        call BuildDefenders()
    endif

    call FillGuardPosts()
    call ReturnGuardPosts()
endfunction

function CampaignBasics takes nothing returns nothing
    call Sleep(1)
    call CampaignBasicsA()
    call StaggerSleep(1,5)
    loop
        call CampaignBasicsA()
        call Sleep(campaign_basics_speed)
    endloop
endfunction

function CampaignAI takes integer farms, code heroes returns nothing
    if GetGameDifficulty() == MAP_DIFFICULTY_EASY then
        set difficulty = EASY

        call SetTargetHeroes(false)
        call SetUnitsFlee(false)

    elseif GetGameDifficulty() == MAP_DIFFICULTY_NORMAL then
        set difficulty = NORMAL

        call SetTargetHeroes(false)
        call SetUnitsFlee(false)

    elseif GetGameDifficulty() == MAP_DIFFICULTY_HARD then
        set difficulty = HARD

        call SetPeonsRepair(true)
    else
        set difficulty = INSANE
    endif

    call InitAI()
    call InitBuildArray()
    call InitAssaultGroup()
    call CreateCaptains()

    call SetNewHeroes(false)
    if heroes != null then
        call SetHeroLevels(heroes)
    endif

    call SetHeroesFlee(false)
    call SetGroupsFlee(false)
    call SetSlowChopping(true)
    call GroupTimedLife(false)
    call SetCampaignAI()
    call Sleep(0.1)

    set racial_farm = farms
    call StartThread(function CampaignBasics)
    call StartBuildLoop()
endfunction

function UnsummonAll takes nothing returns nothing
    local unit bldg
    loop
        set bldg = GetBuilding(ai_player)
        exitwhen bldg==null
        call Unsummon(bldg)
        call Sleep(2)
    endloop
endfunction

function SkillArrays takes nothing returns integer
    local integer level = GetHeroLevelAI()

    if level > max_hero_level then
        set max_hero_level = level
    endif

    if GetHeroId() == hero_id then
        return skills1[level]
    elseif GetHeroId() == hero_id2 then
        return skills2[level]
    else
        return skills3[level]
    endif
endfunction

function SetSkillArray takes integer index, integer id returns nothing
    local integer i = 1

    if index == 1 then
        if hero_id != id then
            return
        endif
        loop
            set skills1[i] = skill[i]
            exitwhen i == 10
            set i = i + 1
        endloop
    elseif index == 2 then
        if hero_id2 != id then
            return
        endif
        loop
            set skills2[i] = skill[i]
            exitwhen i == 10
            set i = i + 1
        endloop
    else
        if hero_id3 != id then
            return
        endif
        loop
            set skills3[i] = skill[i]
            exitwhen i == 10
            set i = i + 1
        endloop
    endif
endfunction

function AwaitMeleeHeroes takes nothing returns nothing
    if GetUnitCountDone(hero_id2) > 0 then
        set two_heroes = true
    endif
    loop
        exitwhen GetUnitCountDone(hero_id)>0 and (take_exp or (not two_heroes or GetUnitCountDone(hero_id2)>0))
        call Sleep(1)
    endloop
endfunction

function PickMeleeHero takes race raceid returns integer
    local integer first
    local integer second
    local integer third
    local integer last
    local integer array heroes
    local integer i

    call InitGlobalSettings()
	call InitAiUnits()	// This function makes all unit ids go back to there originals
	
   set i = ver_neutral_hero_number
    //------------------------------------------------------------------------
    if raceid == RACE_HUMAN then
    //------------------------------------------------------------------------

        set heroes[1] = NAGA_SORCERESS
        set heroes[2] = BEAST_MASTER
        set heroes[3] = DARK_RANGER 
        set heroes[4] = NEUTRAL_PIT_LORD 
        set heroes[5] = BREW_MASTER 
        set heroes[6] = GOBLIN_TINKER
        set heroes[7] = FIRELORD
        set heroes[8] = ALCHEMIST
        set heroes[9] = ARCHMAGE
        set heroes[10] = MTN_KING
        set heroes[11] = PALADIN
        set heroes[12] = BLOOD_MAGE

    //------------------------------------------------------------------------
    elseif raceid == RACE_ORC then
    //------------------------------------------------------------------------
        set heroes[1] = NAGA_SORCERESS
        set heroes[2] = BEAST_MASTER
        set heroes[3] = DARK_RANGER 
        set heroes[4] = NEUTRAL_PIT_LORD 
        set heroes[5] = BREW_MASTER 
        set heroes[6] = GOBLIN_TINKER
        set heroes[7] = FIRELORD
        set heroes[8] = ALCHEMIST
        set heroes[9] = BLADE_MASTER
        set heroes[10] = FAR_SEER
        set heroes[11] = TAUREN_CHIEF
        set heroes[12] = SHADOW_HUNTER

    //------------------------------------------------------------------------
    elseif raceid == RACE_NIGHTELF then
    //------------------------------------------------------------------------
        set heroes[1] = NAGA_SORCERESS
        set heroes[2] = BEAST_MASTER
        set heroes[3] = DARK_RANGER
        set heroes[4] = NEUTRAL_PIT_LORD
        set heroes[5] = BREW_MASTER
        set heroes[6] = GOBLIN_TINKER
        set heroes[7] = FIRELORD
        set heroes[8] = ALCHEMIST
        set heroes[9] = DEMON_HUNTER
        set heroes[10] = KEEPER
        set heroes[11] = MOON_PRIESTESS
        set heroes[12] = WARDEN

    //------------------------------------------------------------------------
    elseif raceid == RACE_UNDEAD then
    //------------------------------------------------------------------------
        set heroes[1] = NAGA_SORCERESS
        set heroes[2] = BEAST_MASTER
        set heroes[3] = DARK_RANGER
        set heroes[4] = NEUTRAL_PIT_LORD
        set heroes[5] = BREW_MASTER
        set heroes[6] = GOBLIN_TINKER
        set heroes[7] = FIRELORD
        set heroes[8] = ALCHEMIST
        set heroes[9] = DEATH_KNIGHT
        set heroes[10] = DREAD_LORD
        set heroes[11] = LICH
        set heroes[12] = CRYPT_LORD

    else
        set hero_id = 0
    endif

    //if VersionCompatible(VERSION_FROZEN_THRONE) then
        set last = race_hero_number + i
    //else
    //    set last = race_hero_number
    //endif

    set first  = GetRandomInt(i+1,last)
    set second = GetRandomInt(i+1,last-1)
	if VersionCompatible(VERSION_FROZEN_THRONE) then
		set third  = GetRandomInt(i+1,last-2)
	else
		set third = 1
    endif
    set hero_id        = heroes[first]
    set heroes[first]  = heroes[last]
    set hero_id2       = heroes[second]
    set heroes[second] = heroes[last-1]
    set hero_id3       = heroes[third]

    return hero_id
endfunction

function main takes nothing returns nothing

endfunction

library themain
   //! inject main
   //some function calls may go here

   // this places vjass initializations there, notice structs are first initialized then library initializers
   // are called
   //! dovjassinit
   //! endinject
endlibrary
